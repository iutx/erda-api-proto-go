// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: podscaler.proto

package pb

import (
	context "context"
	http1 "net/http"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// PodScalerServiceHandler is the server API for PodScalerService service.
type PodScalerServiceHandler interface {
	// POST /api/runtimes/autoscaler/hpa
	CreateRuntimeHPARules(context.Context, *HPARuleCreateRequest) (*CommonResponse, error)
	// GET /api/runtimes/autoscaler/hpa
	ListRuntimeHPARules(context.Context, *ListRequest) (*ErdaRuntimeHPARules, error)
	// PUT /api/runtimes/autoscaler/hpa
	UpdateRuntimeHPARules(context.Context, *ErdaRuntimeHPARules) (*CommonResponse, error)
	// DELETE /api/runtimes/autoscaler/hpa
	DeleteHPARulesByIds(context.Context, *DeleteRuntimePARulesRequest) (*CommonResponse, error)
	// POST /api/runtimes/autoscaler/hpa-rules-action
	ApplyOrCancelHPARulesByIds(context.Context, *ApplyOrCancelPARulesRequest) (*CommonResponse, error)
	// GET /api/runtimes/baseinfo/{runtimeId}
	GetRuntimeBaseInfo(context.Context, *ListRequest) (*RuntimeServiceBaseInfos, error)
	// GET /api/runtimes/autoscaler/hpa-event
	ListRuntimeHPAEvents(context.Context, *ListRequest) (*ErdaRuntimeHPAEvents, error)
	// POST /api/runtimes/autoscaler/vpa
	CreateRuntimeVPARules(context.Context, *VPARuleCreateRequest) (*CommonResponse, error)
	// GET /api/runtimes/autoscaler/vpa
	ListRuntimeVPARules(context.Context, *ListRequest) (*ErdaRuntimeVPARules, error)
	// PUT /api/runtimes/autoscaler/vpa
	UpdateRuntimeVPARules(context.Context, *ErdaRuntimeVPARules) (*CommonResponse, error)
	// DELETE /api/runtimes/autoscaler/vpa
	DeleteVPARulesByIds(context.Context, *DeleteRuntimePARulesRequest) (*CommonResponse, error)
	// POST /api/runtimes/autoscaler/vpa-rules-action
	ApplyOrCancelVPARulesByIds(context.Context, *ApplyOrCancelPARulesRequest) (*CommonResponse, error)
	// GET /api/runtimes/autoscaler/vpa-recommendations
	ListRuntimeVPARecommendations(context.Context, *ListRequest) (*ErdaRuntimeVPARecommendations, error)
	// PUT /api/runtimes/actions/update-pre-overlay
	HPScaleManual(context.Context, *ManualHPRequest) (*HPManualResponse, error)
}

// RegisterPodScalerServiceHandler register PodScalerServiceHandler to http.Router.
func RegisterPodScalerServiceHandler(r http.Router, srv PodScalerServiceHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_CreateRuntimeHPARules := func(method, path string, fn func(context.Context, *HPARuleCreateRequest) (*CommonResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*HPARuleCreateRequest))
		}
		var CreateRuntimeHPARules_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateRuntimeHPARules_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "CreateRuntimeHPARules", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateRuntimeHPARules_info)
				}
				r = r.WithContext(ctx)
				var in HPARuleCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListRuntimeHPARules := func(method, path string, fn func(context.Context, *ListRequest) (*ErdaRuntimeHPARules, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListRequest))
		}
		var ListRuntimeHPARules_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListRuntimeHPARules_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "ListRuntimeHPARules", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListRuntimeHPARules_info)
				}
				r = r.WithContext(ctx)
				var in ListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeId = vals[0]
				}
				if vals := params["services"]; len(vals) > 0 {
					in.Services = vals[0]
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateRuntimeHPARules := func(method, path string, fn func(context.Context, *ErdaRuntimeHPARules) (*CommonResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ErdaRuntimeHPARules))
		}
		var UpdateRuntimeHPARules_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateRuntimeHPARules_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "UpdateRuntimeHPARules", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateRuntimeHPARules_info)
				}
				r = r.WithContext(ctx)
				var in ErdaRuntimeHPARules
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteHPARulesByIds := func(method, path string, fn func(context.Context, *DeleteRuntimePARulesRequest) (*CommonResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteRuntimePARulesRequest))
		}
		var DeleteHPARulesByIds_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteHPARulesByIds_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "DeleteHPARulesByIds", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteHPARulesByIds_info)
				}
				r = r.WithContext(ctx)
				var in DeleteRuntimePARulesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ApplyOrCancelHPARulesByIds := func(method, path string, fn func(context.Context, *ApplyOrCancelPARulesRequest) (*CommonResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplyOrCancelPARulesRequest))
		}
		var ApplyOrCancelHPARulesByIds_info transport.ServiceInfo
		if h.Interceptor != nil {
			ApplyOrCancelHPARulesByIds_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "ApplyOrCancelHPARulesByIds", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ApplyOrCancelHPARulesByIds_info)
				}
				r = r.WithContext(ctx)
				var in ApplyOrCancelPARulesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetRuntimeBaseInfo := func(method, path string, fn func(context.Context, *ListRequest) (*RuntimeServiceBaseInfos, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListRequest))
		}
		var GetRuntimeBaseInfo_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetRuntimeBaseInfo_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "GetRuntimeBaseInfo", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetRuntimeBaseInfo_info)
				}
				r = r.WithContext(ctx)
				var in ListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeId":
							in.RuntimeId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListRuntimeHPAEvents := func(method, path string, fn func(context.Context, *ListRequest) (*ErdaRuntimeHPAEvents, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListRequest))
		}
		var ListRuntimeHPAEvents_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListRuntimeHPAEvents_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "ListRuntimeHPAEvents", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListRuntimeHPAEvents_info)
				}
				r = r.WithContext(ctx)
				var in ListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeId = vals[0]
				}
				if vals := params["services"]; len(vals) > 0 {
					in.Services = vals[0]
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateRuntimeVPARules := func(method, path string, fn func(context.Context, *VPARuleCreateRequest) (*CommonResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*VPARuleCreateRequest))
		}
		var CreateRuntimeVPARules_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateRuntimeVPARules_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "CreateRuntimeVPARules", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateRuntimeVPARules_info)
				}
				r = r.WithContext(ctx)
				var in VPARuleCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListRuntimeVPARules := func(method, path string, fn func(context.Context, *ListRequest) (*ErdaRuntimeVPARules, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListRequest))
		}
		var ListRuntimeVPARules_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListRuntimeVPARules_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "ListRuntimeVPARules", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListRuntimeVPARules_info)
				}
				r = r.WithContext(ctx)
				var in ListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeId = vals[0]
				}
				if vals := params["services"]; len(vals) > 0 {
					in.Services = vals[0]
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateRuntimeVPARules := func(method, path string, fn func(context.Context, *ErdaRuntimeVPARules) (*CommonResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ErdaRuntimeVPARules))
		}
		var UpdateRuntimeVPARules_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateRuntimeVPARules_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "UpdateRuntimeVPARules", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateRuntimeVPARules_info)
				}
				r = r.WithContext(ctx)
				var in ErdaRuntimeVPARules
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteVPARulesByIds := func(method, path string, fn func(context.Context, *DeleteRuntimePARulesRequest) (*CommonResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteRuntimePARulesRequest))
		}
		var DeleteVPARulesByIds_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteVPARulesByIds_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "DeleteVPARulesByIds", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteVPARulesByIds_info)
				}
				r = r.WithContext(ctx)
				var in DeleteRuntimePARulesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ApplyOrCancelVPARulesByIds := func(method, path string, fn func(context.Context, *ApplyOrCancelPARulesRequest) (*CommonResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplyOrCancelPARulesRequest))
		}
		var ApplyOrCancelVPARulesByIds_info transport.ServiceInfo
		if h.Interceptor != nil {
			ApplyOrCancelVPARulesByIds_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "ApplyOrCancelVPARulesByIds", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ApplyOrCancelVPARulesByIds_info)
				}
				r = r.WithContext(ctx)
				var in ApplyOrCancelPARulesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListRuntimeVPARecommendations := func(method, path string, fn func(context.Context, *ListRequest) (*ErdaRuntimeVPARecommendations, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListRequest))
		}
		var ListRuntimeVPARecommendations_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListRuntimeVPARecommendations_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "ListRuntimeVPARecommendations", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListRuntimeVPARecommendations_info)
				}
				r = r.WithContext(ctx)
				var in ListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeId = vals[0]
				}
				if vals := params["services"]; len(vals) > 0 {
					in.Services = vals[0]
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_HPScaleManual := func(method, path string, fn func(context.Context, *ManualHPRequest) (*HPManualResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ManualHPRequest))
		}
		var HPScaleManual_info transport.ServiceInfo
		if h.Interceptor != nil {
			HPScaleManual_info = transport.NewServiceInfo("erda.orchestrator.podscaler.PodScalerService", "HPScaleManual", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, HPScaleManual_info)
				}
				r = r.WithContext(ctx)
				var in ManualHPRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateRuntimeHPARules("POST", "/api/runtimes/autoscaler/hpa", srv.CreateRuntimeHPARules)
	add_ListRuntimeHPARules("GET", "/api/runtimes/autoscaler/hpa", srv.ListRuntimeHPARules)
	add_UpdateRuntimeHPARules("PUT", "/api/runtimes/autoscaler/hpa", srv.UpdateRuntimeHPARules)
	add_DeleteHPARulesByIds("DELETE", "/api/runtimes/autoscaler/hpa", srv.DeleteHPARulesByIds)
	add_ApplyOrCancelHPARulesByIds("POST", "/api/runtimes/autoscaler/hpa-rules-action", srv.ApplyOrCancelHPARulesByIds)
	add_GetRuntimeBaseInfo("GET", "/api/runtimes/baseinfo/{runtimeId}", srv.GetRuntimeBaseInfo)
	add_ListRuntimeHPAEvents("GET", "/api/runtimes/autoscaler/hpa-event", srv.ListRuntimeHPAEvents)
	add_CreateRuntimeVPARules("POST", "/api/runtimes/autoscaler/vpa", srv.CreateRuntimeVPARules)
	add_ListRuntimeVPARules("GET", "/api/runtimes/autoscaler/vpa", srv.ListRuntimeVPARules)
	add_UpdateRuntimeVPARules("PUT", "/api/runtimes/autoscaler/vpa", srv.UpdateRuntimeVPARules)
	add_DeleteVPARulesByIds("DELETE", "/api/runtimes/autoscaler/vpa", srv.DeleteVPARulesByIds)
	add_ApplyOrCancelVPARulesByIds("POST", "/api/runtimes/autoscaler/vpa-rules-action", srv.ApplyOrCancelVPARulesByIds)
	add_ListRuntimeVPARecommendations("GET", "/api/runtimes/autoscaler/vpa-recommendations", srv.ListRuntimeVPARecommendations)
	add_HPScaleManual("PUT", "/api/runtimes/actions/update-pre-overlay", srv.HPScaleManual)
}
