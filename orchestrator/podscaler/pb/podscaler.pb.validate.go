// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: podscaler.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RuntimeServiceBaseInfos with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeServiceBaseInfos) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeServiceBaseInfos with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeServiceBaseInfosMultiError, or nil if none found.
func (m *RuntimeServiceBaseInfos) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeServiceBaseInfos) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeID

	for idx, item := range m.GetServiceBaseInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeServiceBaseInfosValidationError{
						field:  fmt.Sprintf("ServiceBaseInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeServiceBaseInfosValidationError{
						field:  fmt.Sprintf("ServiceBaseInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeServiceBaseInfosValidationError{
					field:  fmt.Sprintf("ServiceBaseInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RuntimeServiceBaseInfosMultiError(errors)
	}

	return nil
}

// RuntimeServiceBaseInfosMultiError is an error wrapping multiple validation
// errors returned by RuntimeServiceBaseInfos.ValidateAll() if the designated
// constraints aren't met.
type RuntimeServiceBaseInfosMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeServiceBaseInfosMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeServiceBaseInfosMultiError) AllErrors() []error { return m }

// RuntimeServiceBaseInfosValidationError is the validation error returned by
// RuntimeServiceBaseInfos.Validate if the designated constraints aren't met.
type RuntimeServiceBaseInfosValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeServiceBaseInfosValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeServiceBaseInfosValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeServiceBaseInfosValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeServiceBaseInfosValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeServiceBaseInfosValidationError) ErrorName() string {
	return "RuntimeServiceBaseInfosValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeServiceBaseInfosValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeServiceBaseInfos.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeServiceBaseInfosValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeServiceBaseInfosValidationError{}

// Validate checks the field values on ServiceBaseInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceBaseInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceBaseInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceBaseInfoMultiError, or nil if none found.
func (m *ServiceBaseInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceBaseInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	if all {
		switch v := interface{}(m.GetDeployments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceBaseInfoValidationError{
					field:  "Deployments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceBaseInfoValidationError{
					field:  "Deployments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceBaseInfoValidationError{
				field:  "Deployments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceBaseInfoValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceBaseInfoValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceBaseInfoValidationError{
				field:  "Resources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceBaseInfoMultiError(errors)
	}

	return nil
}

// ServiceBaseInfoMultiError is an error wrapping multiple validation errors
// returned by ServiceBaseInfo.ValidateAll() if the designated constraints
// aren't met.
type ServiceBaseInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceBaseInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceBaseInfoMultiError) AllErrors() []error { return m }

// ServiceBaseInfoValidationError is the validation error returned by
// ServiceBaseInfo.Validate if the designated constraints aren't met.
type ServiceBaseInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceBaseInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceBaseInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceBaseInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceBaseInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceBaseInfoValidationError) ErrorName() string { return "ServiceBaseInfoValidationError" }

// Error satisfies the builtin error interface
func (e ServiceBaseInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceBaseInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceBaseInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceBaseInfoValidationError{}

// Validate checks the field values on HPARuleCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HPARuleCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HPARuleCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HPARuleCreateRequestMultiError, or nil if none found.
func (m *HPARuleCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HPARuleCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeID

	for idx, item := range m.GetServices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HPARuleCreateRequestValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HPARuleCreateRequestValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HPARuleCreateRequestValidationError{
					field:  fmt.Sprintf("Services[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HPARuleCreateRequestMultiError(errors)
	}

	return nil
}

// HPARuleCreateRequestMultiError is an error wrapping multiple validation
// errors returned by HPARuleCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type HPARuleCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HPARuleCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HPARuleCreateRequestMultiError) AllErrors() []error { return m }

// HPARuleCreateRequestValidationError is the validation error returned by
// HPARuleCreateRequest.Validate if the designated constraints aren't met.
type HPARuleCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HPARuleCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HPARuleCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HPARuleCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HPARuleCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HPARuleCreateRequestValidationError) ErrorName() string {
	return "HPARuleCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HPARuleCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHPARuleCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HPARuleCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HPARuleCreateRequestValidationError{}

// Validate checks the field values on ListRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListRequestMultiError, or
// nil if none found.
func (m *ListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeId

	// no validation rules for Services

	if len(errors) > 0 {
		return ListRequestMultiError(errors)
	}

	return nil
}

// ListRequestMultiError is an error wrapping multiple validation errors
// returned by ListRequest.ValidateAll() if the designated constraints aren't met.
type ListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRequestMultiError) AllErrors() []error { return m }

// ListRequestValidationError is the validation error returned by
// ListRequest.Validate if the designated constraints aren't met.
type ListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRequestValidationError) ErrorName() string { return "ListRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRequestValidationError{}

// Validate checks the field values on DeleteRuntimePARulesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRuntimePARulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRuntimePARulesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRuntimePARulesRequestMultiError, or nil if none found.
func (m *DeleteRuntimePARulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRuntimePARulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return DeleteRuntimePARulesRequestMultiError(errors)
	}

	return nil
}

// DeleteRuntimePARulesRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteRuntimePARulesRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteRuntimePARulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRuntimePARulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRuntimePARulesRequestMultiError) AllErrors() []error { return m }

// DeleteRuntimePARulesRequestValidationError is the validation error returned
// by DeleteRuntimePARulesRequest.Validate if the designated constraints
// aren't met.
type DeleteRuntimePARulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRuntimePARulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRuntimePARulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRuntimePARulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRuntimePARulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRuntimePARulesRequestValidationError) ErrorName() string {
	return "DeleteRuntimePARulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRuntimePARulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRuntimePARulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRuntimePARulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRuntimePARulesRequestValidationError{}

// Validate checks the field values on ApplyOrCancelPARulesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyOrCancelPARulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyOrCancelPARulesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyOrCancelPARulesRequestMultiError, or nil if none found.
func (m *ApplyOrCancelPARulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyOrCancelPARulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeID

	for idx, item := range m.GetRuleAction() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyOrCancelPARulesRequestValidationError{
						field:  fmt.Sprintf("RuleAction[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyOrCancelPARulesRequestValidationError{
						field:  fmt.Sprintf("RuleAction[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyOrCancelPARulesRequestValidationError{
					field:  fmt.Sprintf("RuleAction[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApplyOrCancelPARulesRequestMultiError(errors)
	}

	return nil
}

// ApplyOrCancelPARulesRequestMultiError is an error wrapping multiple
// validation errors returned by ApplyOrCancelPARulesRequest.ValidateAll() if
// the designated constraints aren't met.
type ApplyOrCancelPARulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyOrCancelPARulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyOrCancelPARulesRequestMultiError) AllErrors() []error { return m }

// ApplyOrCancelPARulesRequestValidationError is the validation error returned
// by ApplyOrCancelPARulesRequest.Validate if the designated constraints
// aren't met.
type ApplyOrCancelPARulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyOrCancelPARulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyOrCancelPARulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyOrCancelPARulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyOrCancelPARulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyOrCancelPARulesRequestValidationError) ErrorName() string {
	return "ApplyOrCancelPARulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyOrCancelPARulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyOrCancelPARulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyOrCancelPARulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyOrCancelPARulesRequestValidationError{}

// Validate checks the field values on RuleAction with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuleAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuleAction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuleActionMultiError, or
// nil if none found.
func (m *RuleAction) ValidateAll() error {
	return m.validate(true)
}

func (m *RuleAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuleId

	// no validation rules for Action

	if len(errors) > 0 {
		return RuleActionMultiError(errors)
	}

	return nil
}

// RuleActionMultiError is an error wrapping multiple validation errors
// returned by RuleAction.ValidateAll() if the designated constraints aren't met.
type RuleActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuleActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuleActionMultiError) AllErrors() []error { return m }

// RuleActionValidationError is the validation error returned by
// RuleAction.Validate if the designated constraints aren't met.
type RuleActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuleActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuleActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuleActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuleActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuleActionValidationError) ErrorName() string { return "RuleActionValidationError" }

// Error satisfies the builtin error interface
func (e RuleActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuleAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuleActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuleActionValidationError{}

// Validate checks the field values on CommonResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommonResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommonResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommonResponseMultiError,
// or nil if none found.
func (m *CommonResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CommonResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CommonResponseMultiError(errors)
	}

	return nil
}

// CommonResponseMultiError is an error wrapping multiple validation errors
// returned by CommonResponse.ValidateAll() if the designated constraints
// aren't met.
type CommonResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommonResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommonResponseMultiError) AllErrors() []error { return m }

// CommonResponseValidationError is the validation error returned by
// CommonResponse.Validate if the designated constraints aren't met.
type CommonResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommonResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommonResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommonResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommonResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommonResponseValidationError) ErrorName() string { return "CommonResponseValidationError" }

// Error satisfies the builtin error interface
func (e CommonResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommonResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommonResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommonResponseValidationError{}

// Validate checks the field values on ErrorResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ErrorResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ErrorResponseMultiError, or
// nil if none found.
func (m *ErrorResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetCtx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErrorResponseValidationError{
					field:  "Ctx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErrorResponseValidationError{
					field:  "Ctx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCtx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErrorResponseValidationError{
				field:  "Ctx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ErrorResponseMultiError(errors)
	}

	return nil
}

// ErrorResponseMultiError is an error wrapping multiple validation errors
// returned by ErrorResponse.ValidateAll() if the designated constraints
// aren't met.
type ErrorResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorResponseMultiError) AllErrors() []error { return m }

// ErrorResponseValidationError is the validation error returned by
// ErrorResponse.Validate if the designated constraints aren't met.
type ErrorResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorResponseValidationError) ErrorName() string { return "ErrorResponseValidationError" }

// Error satisfies the builtin error interface
func (e ErrorResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorResponseValidationError{}

// Validate checks the field values on ScaleTargetRef with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScaleTargetRef) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScaleTargetRef with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScaleTargetRefMultiError,
// or nil if none found.
func (m *ScaleTargetRef) ValidateAll() error {
	return m.validate(true)
}

func (m *ScaleTargetRef) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiVersion

	// no validation rules for Kind

	// no validation rules for Name

	// no validation rules for EnvSourceContainerName

	if len(errors) > 0 {
		return ScaleTargetRefMultiError(errors)
	}

	return nil
}

// ScaleTargetRefMultiError is an error wrapping multiple validation errors
// returned by ScaleTargetRef.ValidateAll() if the designated constraints
// aren't met.
type ScaleTargetRefMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScaleTargetRefMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScaleTargetRefMultiError) AllErrors() []error { return m }

// ScaleTargetRefValidationError is the validation error returned by
// ScaleTargetRef.Validate if the designated constraints aren't met.
type ScaleTargetRefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScaleTargetRefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScaleTargetRefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScaleTargetRefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScaleTargetRefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScaleTargetRefValidationError) ErrorName() string { return "ScaleTargetRefValidationError" }

// Error satisfies the builtin error interface
func (e ScaleTargetRefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScaleTargetRef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScaleTargetRefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScaleTargetRefValidationError{}

// Validate checks the field values on HPAAdvanced with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HPAAdvanced) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HPAAdvanced with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HPAAdvancedMultiError, or
// nil if none found.
func (m *HPAAdvanced) ValidateAll() error {
	return m.validate(true)
}

func (m *HPAAdvanced) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RestoreToOriginalReplicaCount

	if all {
		switch v := interface{}(m.GetHorizontalPodAutoscalerConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HPAAdvancedValidationError{
					field:  "HorizontalPodAutoscalerConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HPAAdvancedValidationError{
					field:  "HorizontalPodAutoscalerConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHorizontalPodAutoscalerConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HPAAdvancedValidationError{
				field:  "HorizontalPodAutoscalerConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HPAAdvancedMultiError(errors)
	}

	return nil
}

// HPAAdvancedMultiError is an error wrapping multiple validation errors
// returned by HPAAdvanced.ValidateAll() if the designated constraints aren't met.
type HPAAdvancedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HPAAdvancedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HPAAdvancedMultiError) AllErrors() []error { return m }

// HPAAdvancedValidationError is the validation error returned by
// HPAAdvanced.Validate if the designated constraints aren't met.
type HPAAdvancedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HPAAdvancedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HPAAdvancedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HPAAdvancedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HPAAdvancedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HPAAdvancedValidationError) ErrorName() string { return "HPAAdvancedValidationError" }

// Error satisfies the builtin error interface
func (e HPAAdvancedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHPAAdvanced.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HPAAdvancedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HPAAdvancedValidationError{}

// Validate checks the field values on HorizontalPodAutoscalerConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HorizontalPodAutoscalerConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HorizontalPodAutoscalerConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// HorizontalPodAutoscalerConfigMultiError, or nil if none found.
func (m *HorizontalPodAutoscalerConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *HorizontalPodAutoscalerConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBehavior()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HorizontalPodAutoscalerConfigValidationError{
					field:  "Behavior",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HorizontalPodAutoscalerConfigValidationError{
					field:  "Behavior",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBehavior()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HorizontalPodAutoscalerConfigValidationError{
				field:  "Behavior",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HorizontalPodAutoscalerConfigMultiError(errors)
	}

	return nil
}

// HorizontalPodAutoscalerConfigMultiError is an error wrapping multiple
// validation errors returned by HorizontalPodAutoscalerConfig.ValidateAll()
// if the designated constraints aren't met.
type HorizontalPodAutoscalerConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HorizontalPodAutoscalerConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HorizontalPodAutoscalerConfigMultiError) AllErrors() []error { return m }

// HorizontalPodAutoscalerConfigValidationError is the validation error
// returned by HorizontalPodAutoscalerConfig.Validate if the designated
// constraints aren't met.
type HorizontalPodAutoscalerConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HorizontalPodAutoscalerConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HorizontalPodAutoscalerConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HorizontalPodAutoscalerConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HorizontalPodAutoscalerConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HorizontalPodAutoscalerConfigValidationError) ErrorName() string {
	return "HorizontalPodAutoscalerConfigValidationError"
}

// Error satisfies the builtin error interface
func (e HorizontalPodAutoscalerConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHorizontalPodAutoscalerConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HorizontalPodAutoscalerConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HorizontalPodAutoscalerConfigValidationError{}

// Validate checks the field values on HorizontalPodAutoscalerBehavior with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HorizontalPodAutoscalerBehavior) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HorizontalPodAutoscalerBehavior with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// HorizontalPodAutoscalerBehaviorMultiError, or nil if none found.
func (m *HorizontalPodAutoscalerBehavior) ValidateAll() error {
	return m.validate(true)
}

func (m *HorizontalPodAutoscalerBehavior) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetScaleUp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HorizontalPodAutoscalerBehaviorValidationError{
					field:  "ScaleUp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HorizontalPodAutoscalerBehaviorValidationError{
					field:  "ScaleUp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleUp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HorizontalPodAutoscalerBehaviorValidationError{
				field:  "ScaleUp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaleDown()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HorizontalPodAutoscalerBehaviorValidationError{
					field:  "ScaleDown",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HorizontalPodAutoscalerBehaviorValidationError{
					field:  "ScaleDown",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleDown()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HorizontalPodAutoscalerBehaviorValidationError{
				field:  "ScaleDown",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HorizontalPodAutoscalerBehaviorMultiError(errors)
	}

	return nil
}

// HorizontalPodAutoscalerBehaviorMultiError is an error wrapping multiple
// validation errors returned by HorizontalPodAutoscalerBehavior.ValidateAll()
// if the designated constraints aren't met.
type HorizontalPodAutoscalerBehaviorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HorizontalPodAutoscalerBehaviorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HorizontalPodAutoscalerBehaviorMultiError) AllErrors() []error { return m }

// HorizontalPodAutoscalerBehaviorValidationError is the validation error
// returned by HorizontalPodAutoscalerBehavior.Validate if the designated
// constraints aren't met.
type HorizontalPodAutoscalerBehaviorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HorizontalPodAutoscalerBehaviorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HorizontalPodAutoscalerBehaviorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HorizontalPodAutoscalerBehaviorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HorizontalPodAutoscalerBehaviorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HorizontalPodAutoscalerBehaviorValidationError) ErrorName() string {
	return "HorizontalPodAutoscalerBehaviorValidationError"
}

// Error satisfies the builtin error interface
func (e HorizontalPodAutoscalerBehaviorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHorizontalPodAutoscalerBehavior.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HorizontalPodAutoscalerBehaviorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HorizontalPodAutoscalerBehaviorValidationError{}

// Validate checks the field values on HPAScalingRules with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HPAScalingRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HPAScalingRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HPAScalingRulesMultiError, or nil if none found.
func (m *HPAScalingRules) ValidateAll() error {
	return m.validate(true)
}

func (m *HPAScalingRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StabilizationWindowSeconds

	// no validation rules for SelectPolicy

	for idx, item := range m.GetPolicies() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HPAScalingRulesValidationError{
						field:  fmt.Sprintf("Policies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HPAScalingRulesValidationError{
						field:  fmt.Sprintf("Policies[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HPAScalingRulesValidationError{
					field:  fmt.Sprintf("Policies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HPAScalingRulesMultiError(errors)
	}

	return nil
}

// HPAScalingRulesMultiError is an error wrapping multiple validation errors
// returned by HPAScalingRules.ValidateAll() if the designated constraints
// aren't met.
type HPAScalingRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HPAScalingRulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HPAScalingRulesMultiError) AllErrors() []error { return m }

// HPAScalingRulesValidationError is the validation error returned by
// HPAScalingRules.Validate if the designated constraints aren't met.
type HPAScalingRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HPAScalingRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HPAScalingRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HPAScalingRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HPAScalingRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HPAScalingRulesValidationError) ErrorName() string { return "HPAScalingRulesValidationError" }

// Error satisfies the builtin error interface
func (e HPAScalingRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHPAScalingRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HPAScalingRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HPAScalingRulesValidationError{}

// Validate checks the field values on HPAScalingPolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HPAScalingPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HPAScalingPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HPAScalingPolicyMultiError, or nil if none found.
func (m *HPAScalingPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *HPAScalingPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Value

	// no validation rules for PeriodSeconds

	if len(errors) > 0 {
		return HPAScalingPolicyMultiError(errors)
	}

	return nil
}

// HPAScalingPolicyMultiError is an error wrapping multiple validation errors
// returned by HPAScalingPolicy.ValidateAll() if the designated constraints
// aren't met.
type HPAScalingPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HPAScalingPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HPAScalingPolicyMultiError) AllErrors() []error { return m }

// HPAScalingPolicyValidationError is the validation error returned by
// HPAScalingPolicy.Validate if the designated constraints aren't met.
type HPAScalingPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HPAScalingPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HPAScalingPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HPAScalingPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HPAScalingPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HPAScalingPolicyValidationError) ErrorName() string { return "HPAScalingPolicyValidationError" }

// Error satisfies the builtin error interface
func (e HPAScalingPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHPAScalingPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HPAScalingPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HPAScalingPolicyValidationError{}

// Validate checks the field values on FallBack with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FallBack) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FallBack with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FallBackMultiError, or nil
// if none found.
func (m *FallBack) ValidateAll() error {
	return m.validate(true)
}

func (m *FallBack) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FailureThreshold

	// no validation rules for Replicas

	if len(errors) > 0 {
		return FallBackMultiError(errors)
	}

	return nil
}

// FallBackMultiError is an error wrapping multiple validation errors returned
// by FallBack.ValidateAll() if the designated constraints aren't met.
type FallBackMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FallBackMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FallBackMultiError) AllErrors() []error { return m }

// FallBackValidationError is the validation error returned by
// FallBack.Validate if the designated constraints aren't met.
type FallBackValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FallBackValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FallBackValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FallBackValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FallBackValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FallBackValidationError) ErrorName() string { return "FallBackValidationError" }

// Error satisfies the builtin error interface
func (e FallBackValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFallBack.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FallBackValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FallBackValidationError{}

// Validate checks the field values on ScaledObjectAuthRef with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ScaledObjectAuthRef) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScaledObjectAuthRef with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScaledObjectAuthRefMultiError, or nil if none found.
func (m *ScaledObjectAuthRef) ValidateAll() error {
	return m.validate(true)
}

func (m *ScaledObjectAuthRef) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Kind

	if len(errors) > 0 {
		return ScaledObjectAuthRefMultiError(errors)
	}

	return nil
}

// ScaledObjectAuthRefMultiError is an error wrapping multiple validation
// errors returned by ScaledObjectAuthRef.ValidateAll() if the designated
// constraints aren't met.
type ScaledObjectAuthRefMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScaledObjectAuthRefMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScaledObjectAuthRefMultiError) AllErrors() []error { return m }

// ScaledObjectAuthRefValidationError is the validation error returned by
// ScaledObjectAuthRef.Validate if the designated constraints aren't met.
type ScaledObjectAuthRefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScaledObjectAuthRefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScaledObjectAuthRefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScaledObjectAuthRefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScaledObjectAuthRefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScaledObjectAuthRefValidationError) ErrorName() string {
	return "ScaledObjectAuthRefValidationError"
}

// Error satisfies the builtin error interface
func (e ScaledObjectAuthRefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScaledObjectAuthRef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScaledObjectAuthRefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScaledObjectAuthRefValidationError{}

// Validate checks the field values on ScaleTriggers with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScaleTriggers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScaleTriggers with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScaleTriggersMultiError, or
// nil if none found.
func (m *ScaleTriggers) ValidateAll() error {
	return m.validate(true)
}

func (m *ScaleTriggers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetAuthenticationRef()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaleTriggersValidationError{
					field:  "AuthenticationRef",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaleTriggersValidationError{
					field:  "AuthenticationRef",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthenticationRef()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaleTriggersValidationError{
				field:  "AuthenticationRef",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MetricType

	if len(errors) > 0 {
		return ScaleTriggersMultiError(errors)
	}

	return nil
}

// ScaleTriggersMultiError is an error wrapping multiple validation errors
// returned by ScaleTriggers.ValidateAll() if the designated constraints
// aren't met.
type ScaleTriggersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScaleTriggersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScaleTriggersMultiError) AllErrors() []error { return m }

// ScaleTriggersValidationError is the validation error returned by
// ScaleTriggers.Validate if the designated constraints aren't met.
type ScaleTriggersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScaleTriggersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScaleTriggersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScaleTriggersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScaleTriggersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScaleTriggersValidationError) ErrorName() string { return "ScaleTriggersValidationError" }

// Error satisfies the builtin error interface
func (e ScaleTriggersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScaleTriggers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScaleTriggersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScaleTriggersValidationError{}

// Validate checks the field values on ScaledConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScaledConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScaledConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScaledConfigMultiError, or
// nil if none found.
func (m *ScaledConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ScaledConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuleName

	// no validation rules for RuleID

	// no validation rules for RuntimeID

	// no validation rules for ApplicationID

	// no validation rules for OrgID

	// no validation rules for ServiceName

	// no validation rules for RuleNameSpace

	if all {
		switch v := interface{}(m.GetScaleTargetRef()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaledConfigValidationError{
					field:  "ScaleTargetRef",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaledConfigValidationError{
					field:  "ScaleTargetRef",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleTargetRef()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaledConfigValidationError{
				field:  "ScaleTargetRef",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PollingInterval

	// no validation rules for CooldownPeriod

	// no validation rules for MinReplicaCount

	// no validation rules for MaxReplicaCount

	if all {
		switch v := interface{}(m.GetAdvanced()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaledConfigValidationError{
					field:  "Advanced",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaledConfigValidationError{
					field:  "Advanced",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdvanced()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaledConfigValidationError{
				field:  "Advanced",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTriggers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ScaledConfigValidationError{
						field:  fmt.Sprintf("Triggers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ScaledConfigValidationError{
						field:  fmt.Sprintf("Triggers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ScaledConfigValidationError{
					field:  fmt.Sprintf("Triggers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFallback()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ScaledConfigValidationError{
					field:  "Fallback",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ScaledConfigValidationError{
					field:  "Fallback",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFallback()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ScaledConfigValidationError{
				field:  "Fallback",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ScaledConfigMultiError(errors)
	}

	return nil
}

// ScaledConfigMultiError is an error wrapping multiple validation errors
// returned by ScaledConfig.ValidateAll() if the designated constraints aren't met.
type ScaledConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScaledConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScaledConfigMultiError) AllErrors() []error { return m }

// ScaledConfigValidationError is the validation error returned by
// ScaledConfig.Validate if the designated constraints aren't met.
type ScaledConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScaledConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScaledConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScaledConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScaledConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScaledConfigValidationError) ErrorName() string { return "ScaledConfigValidationError" }

// Error satisfies the builtin error interface
func (e ScaledConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScaledConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScaledConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScaledConfigValidationError{}

// Validate checks the field values on RuntimeServiceHPAConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeServiceHPAConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeServiceHPAConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeServiceHPAConfigMultiError, or nil if none found.
func (m *RuntimeServiceHPAConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeServiceHPAConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Type

	// no validation rules for ServiceName

	// no validation rules for RuleName

	if all {
		switch v := interface{}(m.GetDeployments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeServiceHPAConfigValidationError{
					field:  "Deployments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeServiceHPAConfigValidationError{
					field:  "Deployments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeServiceHPAConfigValidationError{
				field:  "Deployments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeServiceHPAConfigValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeServiceHPAConfigValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeServiceHPAConfigValidationError{
				field:  "Resources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaledConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeServiceHPAConfigValidationError{
					field:  "ScaledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeServiceHPAConfigValidationError{
					field:  "ScaledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaledConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeServiceHPAConfigValidationError{
				field:  "ScaledConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RuntimeServiceHPAConfigMultiError(errors)
	}

	return nil
}

// RuntimeServiceHPAConfigMultiError is an error wrapping multiple validation
// errors returned by RuntimeServiceHPAConfig.ValidateAll() if the designated
// constraints aren't met.
type RuntimeServiceHPAConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeServiceHPAConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeServiceHPAConfigMultiError) AllErrors() []error { return m }

// RuntimeServiceHPAConfigValidationError is the validation error returned by
// RuntimeServiceHPAConfig.Validate if the designated constraints aren't met.
type RuntimeServiceHPAConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeServiceHPAConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeServiceHPAConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeServiceHPAConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeServiceHPAConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeServiceHPAConfigValidationError) ErrorName() string {
	return "RuntimeServiceHPAConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeServiceHPAConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeServiceHPAConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeServiceHPAConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeServiceHPAConfigValidationError{}

// Validate checks the field values on ErdaRuntimeHPARules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ErdaRuntimeHPARules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErdaRuntimeHPARules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErdaRuntimeHPARulesMultiError, or nil if none found.
func (m *ErdaRuntimeHPARules) ValidateAll() error {
	return m.validate(true)
}

func (m *ErdaRuntimeHPARules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeID

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ErdaRuntimeHPARulesValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ErdaRuntimeHPARulesValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ErdaRuntimeHPARulesValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ErdaRuntimeHPARulesMultiError(errors)
	}

	return nil
}

// ErdaRuntimeHPARulesMultiError is an error wrapping multiple validation
// errors returned by ErdaRuntimeHPARules.ValidateAll() if the designated
// constraints aren't met.
type ErdaRuntimeHPARulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErdaRuntimeHPARulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErdaRuntimeHPARulesMultiError) AllErrors() []error { return m }

// ErdaRuntimeHPARulesValidationError is the validation error returned by
// ErdaRuntimeHPARules.Validate if the designated constraints aren't met.
type ErdaRuntimeHPARulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErdaRuntimeHPARulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErdaRuntimeHPARulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErdaRuntimeHPARulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErdaRuntimeHPARulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErdaRuntimeHPARulesValidationError) ErrorName() string {
	return "ErdaRuntimeHPARulesValidationError"
}

// Error satisfies the builtin error interface
func (e ErdaRuntimeHPARulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErdaRuntimeHPARules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErdaRuntimeHPARulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErdaRuntimeHPARulesValidationError{}

// Validate checks the field values on ErdaRuntimeHPARule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ErdaRuntimeHPARule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErdaRuntimeHPARule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErdaRuntimeHPARuleMultiError, or nil if none found.
func (m *ErdaRuntimeHPARule) ValidateAll() error {
	return m.validate(true)
}

func (m *ErdaRuntimeHPARule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuleID

	if all {
		switch v := interface{}(m.GetCreateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeHPARuleValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeHPARuleValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeHPARuleValidationError{
				field:  "CreateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeHPARuleValidationError{
					field:  "UpdateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeHPARuleValidationError{
					field:  "UpdateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeHPARuleValidationError{
				field:  "UpdateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServiceName

	// no validation rules for RuleName

	if all {
		switch v := interface{}(m.GetUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeHPARuleValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeHPARuleValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeHPARuleValidationError{
				field:  "UserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetScaledConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeHPARuleValidationError{
					field:  "ScaledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeHPARuleValidationError{
					field:  "ScaledConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaledConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeHPARuleValidationError{
				field:  "ScaledConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsApplied

	if len(errors) > 0 {
		return ErdaRuntimeHPARuleMultiError(errors)
	}

	return nil
}

// ErdaRuntimeHPARuleMultiError is an error wrapping multiple validation errors
// returned by ErdaRuntimeHPARule.ValidateAll() if the designated constraints
// aren't met.
type ErdaRuntimeHPARuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErdaRuntimeHPARuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErdaRuntimeHPARuleMultiError) AllErrors() []error { return m }

// ErdaRuntimeHPARuleValidationError is the validation error returned by
// ErdaRuntimeHPARule.Validate if the designated constraints aren't met.
type ErdaRuntimeHPARuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErdaRuntimeHPARuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErdaRuntimeHPARuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErdaRuntimeHPARuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErdaRuntimeHPARuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErdaRuntimeHPARuleValidationError) ErrorName() string {
	return "ErdaRuntimeHPARuleValidationError"
}

// Error satisfies the builtin error interface
func (e ErdaRuntimeHPARuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErdaRuntimeHPARule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErdaRuntimeHPARuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErdaRuntimeHPARuleValidationError{}

// Validate checks the field values on UserInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoMultiError, or nil
// if none found.
func (m *UserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserID

	// no validation rules for UserName

	// no validation rules for UserNickName

	if len(errors) > 0 {
		return UserInfoMultiError(errors)
	}

	return nil
}

// UserInfoMultiError is an error wrapping multiple validation errors returned
// by UserInfo.ValidateAll() if the designated constraints aren't met.
type UserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoMultiError) AllErrors() []error { return m }

// UserInfoValidationError is the validation error returned by
// UserInfo.Validate if the designated constraints aren't met.
type UserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoValidationError) ErrorName() string { return "UserInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoValidationError{}

// Validate checks the field values on RuntimeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuntimeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimeInfoMultiError, or
// nil if none found.
func (m *RuntimeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for OrgName

	// no validation rules for ProjectID

	// no validation rules for ProjectName

	// no validation rules for ApplicationID

	// no validation rules for ApplicationName

	// no validation rules for Workspace

	// no validation rules for RuntimeID

	// no validation rules for RuntimeName

	// no validation rules for ClusterID

	// no validation rules for ClusterName

	// no validation rules for ClusterType

	if len(errors) > 0 {
		return RuntimeInfoMultiError(errors)
	}

	return nil
}

// RuntimeInfoMultiError is an error wrapping multiple validation errors
// returned by RuntimeInfo.ValidateAll() if the designated constraints aren't met.
type RuntimeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeInfoMultiError) AllErrors() []error { return m }

// RuntimeInfoValidationError is the validation error returned by
// RuntimeInfo.Validate if the designated constraints aren't met.
type RuntimeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeInfoValidationError) ErrorName() string { return "RuntimeInfoValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeInfoValidationError{}

// Validate checks the field values on BatchManualHPRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchManualHPRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchManualHPRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchManualHPRequestMultiError, or nil if none found.
func (m *BatchManualHPRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchManualHPRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Action

	for idx, item := range m.GetRuntimeRecords() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchManualHPRequestValidationError{
						field:  fmt.Sprintf("RuntimeRecords[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchManualHPRequestValidationError{
						field:  fmt.Sprintf("RuntimeRecords[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchManualHPRequestValidationError{
					field:  fmt.Sprintf("RuntimeRecords[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchManualHPRequestMultiError(errors)
	}

	return nil
}

// BatchManualHPRequestMultiError is an error wrapping multiple validation
// errors returned by BatchManualHPRequest.ValidateAll() if the designated
// constraints aren't met.
type BatchManualHPRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchManualHPRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchManualHPRequestMultiError) AllErrors() []error { return m }

// BatchManualHPRequestValidationError is the validation error returned by
// BatchManualHPRequest.Validate if the designated constraints aren't met.
type BatchManualHPRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchManualHPRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchManualHPRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchManualHPRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchManualHPRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchManualHPRequestValidationError) ErrorName() string {
	return "BatchManualHPRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchManualHPRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchManualHPRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchManualHPRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchManualHPRequestValidationError{}

// Validate checks the field values on RuntimeScaleRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeScaleRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeScaleRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeScaleRecordMultiError, or nil if none found.
func (m *RuntimeScaleRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeScaleRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApplicationId

	// no validation rules for Workspace

	// no validation rules for Name

	// no validation rules for RuntimeId

	if all {
		switch v := interface{}(m.GetPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeScaleRecordValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeScaleRecordValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeScaleRecordValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ErrorMsg

	if len(errors) > 0 {
		return RuntimeScaleRecordMultiError(errors)
	}

	return nil
}

// RuntimeScaleRecordMultiError is an error wrapping multiple validation errors
// returned by RuntimeScaleRecord.ValidateAll() if the designated constraints
// aren't met.
type RuntimeScaleRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeScaleRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeScaleRecordMultiError) AllErrors() []error { return m }

// RuntimeScaleRecordValidationError is the validation error returned by
// RuntimeScaleRecord.Validate if the designated constraints aren't met.
type RuntimeScaleRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeScaleRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeScaleRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeScaleRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeScaleRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeScaleRecordValidationError) ErrorName() string {
	return "RuntimeScaleRecordValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeScaleRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeScaleRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeScaleRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeScaleRecordValidationError{}

// Validate checks the field values on PreDiceDTO with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PreDiceDTO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreDiceDTO with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PreDiceDTOMultiError, or
// nil if none found.
func (m *PreDiceDTO) ValidateAll() error {
	return m.validate(true)
}

func (m *PreDiceDTO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Envs

	{
		sorted_keys := make([]string, len(m.GetServices()))
		i := 0
		for key := range m.GetServices() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetServices()[key]
			_ = val

			// no validation rules for Services[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PreDiceDTOValidationError{
							field:  fmt.Sprintf("Services[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PreDiceDTOValidationError{
							field:  fmt.Sprintf("Services[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PreDiceDTOValidationError{
						field:  fmt.Sprintf("Services[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return PreDiceDTOMultiError(errors)
	}

	return nil
}

// PreDiceDTOMultiError is an error wrapping multiple validation errors
// returned by PreDiceDTO.ValidateAll() if the designated constraints aren't met.
type PreDiceDTOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreDiceDTOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreDiceDTOMultiError) AllErrors() []error { return m }

// PreDiceDTOValidationError is the validation error returned by
// PreDiceDTO.Validate if the designated constraints aren't met.
type PreDiceDTOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreDiceDTOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreDiceDTOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreDiceDTOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreDiceDTOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreDiceDTOValidationError) ErrorName() string { return "PreDiceDTOValidationError" }

// Error satisfies the builtin error interface
func (e PreDiceDTOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreDiceDTO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreDiceDTOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreDiceDTOValidationError{}

// Validate checks the field values on ManualHPRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ManualHPRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManualHPRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ManualHPRequestMultiError, or nil if none found.
func (m *ManualHPRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ManualHPRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApplicationId

	// no validation rules for Workspace

	// no validation rules for RuntimeName

	// no validation rules for Name

	// no validation rules for Envs

	{
		sorted_keys := make([]string, len(m.GetServices()))
		i := 0
		for key := range m.GetServices() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetServices()[key]
			_ = val

			// no validation rules for Services[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ManualHPRequestValidationError{
							field:  fmt.Sprintf("Services[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ManualHPRequestValidationError{
							field:  fmt.Sprintf("Services[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ManualHPRequestValidationError{
						field:  fmt.Sprintf("Services[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ManualHPRequestMultiError(errors)
	}

	return nil
}

// ManualHPRequestMultiError is an error wrapping multiple validation errors
// returned by ManualHPRequest.ValidateAll() if the designated constraints
// aren't met.
type ManualHPRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManualHPRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManualHPRequestMultiError) AllErrors() []error { return m }

// ManualHPRequestValidationError is the validation error returned by
// ManualHPRequest.Validate if the designated constraints aren't met.
type ManualHPRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManualHPRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManualHPRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManualHPRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManualHPRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManualHPRequestValidationError) ErrorName() string { return "ManualHPRequestValidationError" }

// Error satisfies the builtin error interface
func (e ManualHPRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManualHPRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManualHPRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManualHPRequestValidationError{}

// Validate checks the field values on RuntimeInspectServiceDTO with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeInspectServiceDTO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeInspectServiceDTO with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeInspectServiceDTOMultiError, or nil if none found.
func (m *RuntimeInspectServiceDTO) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeInspectServiceDTO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for AutoscalerEnabled

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetDeployments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeInspectServiceDTOValidationError{
					field:  "Deployments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeInspectServiceDTOValidationError{
					field:  "Deployments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeInspectServiceDTOValidationError{
				field:  "Deployments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeInspectServiceDTOValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeInspectServiceDTOValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeInspectServiceDTOValidationError{
				field:  "Resources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Envs

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeInspectServiceDTOValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeInspectServiceDTOValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeInspectServiceDTOValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RuntimeInspectServiceDTOMultiError(errors)
	}

	return nil
}

// RuntimeInspectServiceDTOMultiError is an error wrapping multiple validation
// errors returned by RuntimeInspectServiceDTO.ValidateAll() if the designated
// constraints aren't met.
type RuntimeInspectServiceDTOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeInspectServiceDTOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeInspectServiceDTOMultiError) AllErrors() []error { return m }

// RuntimeInspectServiceDTOValidationError is the validation error returned by
// RuntimeInspectServiceDTO.Validate if the designated constraints aren't met.
type RuntimeInspectServiceDTOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeInspectServiceDTOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeInspectServiceDTOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeInspectServiceDTOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeInspectServiceDTOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeInspectServiceDTOValidationError) ErrorName() string {
	return "RuntimeInspectServiceDTOValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeInspectServiceDTOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeInspectServiceDTO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeInspectServiceDTOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeInspectServiceDTOValidationError{}

// Validate checks the field values on HPManualResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HPManualResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HPManualResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HPManualResponseMultiError, or nil if none found.
func (m *HPManualResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HPManualResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Envs

	{
		sorted_keys := make([]string, len(m.GetServices()))
		i := 0
		for key := range m.GetServices() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetServices()[key]
			_ = val

			// no validation rules for Services[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, HPManualResponseValidationError{
							field:  fmt.Sprintf("Services[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, HPManualResponseValidationError{
							field:  fmt.Sprintf("Services[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return HPManualResponseValidationError{
						field:  fmt.Sprintf("Services[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return HPManualResponseMultiError(errors)
	}

	return nil
}

// HPManualResponseMultiError is an error wrapping multiple validation errors
// returned by HPManualResponse.ValidateAll() if the designated constraints
// aren't met.
type HPManualResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HPManualResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HPManualResponseMultiError) AllErrors() []error { return m }

// HPManualResponseValidationError is the validation error returned by
// HPManualResponse.Validate if the designated constraints aren't met.
type HPManualResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HPManualResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HPManualResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HPManualResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HPManualResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HPManualResponseValidationError) ErrorName() string { return "HPManualResponseValidationError" }

// Error satisfies the builtin error interface
func (e HPManualResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHPManualResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HPManualResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HPManualResponseValidationError{}

// Validate checks the field values on BatchManualResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchManualResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchManualResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchManualResponseMultiError, or nil if none found.
func (m *BatchManualResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchManualResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for Success

	// no validation rules for Failed

	for idx, item := range m.GetReDeployed() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("ReDeployed[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("ReDeployed[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchManualResponseValidationError{
					field:  fmt.Sprintf("ReDeployed[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUnReDeployed() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("UnReDeployed[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("UnReDeployed[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchManualResponseValidationError{
					field:  fmt.Sprintf("UnReDeployed[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDeleted() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("Deleted[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("Deleted[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchManualResponseValidationError{
					field:  fmt.Sprintf("Deleted[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUnDeleted() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("UnDeleted[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("UnDeleted[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchManualResponseValidationError{
					field:  fmt.Sprintf("UnDeleted[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSuccessedScales() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("SuccessedScales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("SuccessedScales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchManualResponseValidationError{
					field:  fmt.Sprintf("SuccessedScales[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFailedScales() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("FailedScales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchManualResponseValidationError{
						field:  fmt.Sprintf("FailedScales[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchManualResponseValidationError{
					field:  fmt.Sprintf("FailedScales[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchManualResponseMultiError(errors)
	}

	return nil
}

// BatchManualResponseMultiError is an error wrapping multiple validation
// errors returned by BatchManualResponse.ValidateAll() if the designated
// constraints aren't met.
type BatchManualResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchManualResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchManualResponseMultiError) AllErrors() []error { return m }

// BatchManualResponseValidationError is the validation error returned by
// BatchManualResponse.Validate if the designated constraints aren't met.
type BatchManualResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchManualResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchManualResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchManualResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchManualResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchManualResponseValidationError) ErrorName() string {
	return "BatchManualResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatchManualResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchManualResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchManualResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchManualResponseValidationError{}

// Validate checks the field values on RuntimeDeployDTO with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RuntimeDeployDTO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeDeployDTO with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeDeployDTOMultiError, or nil if none found.
func (m *RuntimeDeployDTO) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeDeployDTO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PipelineID

	// no validation rules for Workspace

	// no validation rules for ClusterName

	// no validation rules for ApplicationID

	// no validation rules for ApplicationName

	// no validation rules for ProjectID

	// no validation rules for ProjectName

	// no validation rules for OrgID

	// no validation rules for OrgName

	if len(errors) > 0 {
		return RuntimeDeployDTOMultiError(errors)
	}

	return nil
}

// RuntimeDeployDTOMultiError is an error wrapping multiple validation errors
// returned by RuntimeDeployDTO.ValidateAll() if the designated constraints
// aren't met.
type RuntimeDeployDTOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeDeployDTOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeDeployDTOMultiError) AllErrors() []error { return m }

// RuntimeDeployDTOValidationError is the validation error returned by
// RuntimeDeployDTO.Validate if the designated constraints aren't met.
type RuntimeDeployDTOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeDeployDTOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeDeployDTOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeDeployDTOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeDeployDTOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeDeployDTOValidationError) ErrorName() string { return "RuntimeDeployDTOValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeDeployDTOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeDeployDTO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeDeployDTOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeDeployDTOValidationError{}

// Validate checks the field values on RuntimeDTO with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RuntimeDTO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeDTO with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RuntimeDTOMultiError, or
// nil if none found.
func (m *RuntimeDTO) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeDTO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for GitBranch

	// no validation rules for Workspace

	// no validation rules for ClusterName

	// no validation rules for ClusterId

	// no validation rules for Status

	// no validation rules for ApplicationID

	// no validation rules for ApplicationName

	// no validation rules for ProjectID

	// no validation rules for ProjectName

	// no validation rules for OrgID

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RuntimeDTOValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RuntimeDTOValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RuntimeDTOValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RuntimeDTOMultiError(errors)
	}

	return nil
}

// RuntimeDTOMultiError is an error wrapping multiple validation errors
// returned by RuntimeDTO.ValidateAll() if the designated constraints aren't met.
type RuntimeDTOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeDTOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeDTOMultiError) AllErrors() []error { return m }

// RuntimeDTOValidationError is the validation error returned by
// RuntimeDTO.Validate if the designated constraints aren't met.
type RuntimeDTOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeDTOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeDTOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeDTOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeDTOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeDTOValidationError) ErrorName() string { return "RuntimeDTOValidationError" }

// Error satisfies the builtin error interface
func (e RuntimeDTOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeDTO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeDTOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeDTOValidationError{}

// Validate checks the field values on Resources with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resources with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourcesMultiError, or nil
// if none found.
func (m *Resources) ValidateAll() error {
	return m.validate(true)
}

func (m *Resources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cpu

	// no validation rules for Mem

	// no validation rules for Disk

	if len(errors) > 0 {
		return ResourcesMultiError(errors)
	}

	return nil
}

// ResourcesMultiError is an error wrapping multiple validation errors returned
// by Resources.ValidateAll() if the designated constraints aren't met.
type ResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourcesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourcesMultiError) AllErrors() []error { return m }

// ResourcesValidationError is the validation error returned by
// Resources.Validate if the designated constraints aren't met.
type ResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourcesValidationError) ErrorName() string { return "ResourcesValidationError" }

// Error satisfies the builtin error interface
func (e ResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourcesValidationError{}

// Validate checks the field values on Deployments with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Deployments) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Deployments with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeploymentsMultiError, or
// nil if none found.
func (m *Deployments) ValidateAll() error {
	return m.validate(true)
}

func (m *Deployments) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Replicas

	if len(errors) > 0 {
		return DeploymentsMultiError(errors)
	}

	return nil
}

// DeploymentsMultiError is an error wrapping multiple validation errors
// returned by Deployments.ValidateAll() if the designated constraints aren't met.
type DeploymentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentsMultiError) AllErrors() []error { return m }

// DeploymentsValidationError is the validation error returned by
// Deployments.Validate if the designated constraints aren't met.
type DeploymentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentsValidationError) ErrorName() string { return "DeploymentsValidationError" }

// Error satisfies the builtin error interface
func (e DeploymentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployments.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentsValidationError{}

// Validate checks the field values on ErdaRuntimeHPAEvents with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ErdaRuntimeHPAEvents) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErdaRuntimeHPAEvents with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErdaRuntimeHPAEventsMultiError, or nil if none found.
func (m *ErdaRuntimeHPAEvents) ValidateAll() error {
	return m.validate(true)
}

func (m *ErdaRuntimeHPAEvents) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ErdaRuntimeHPAEventsValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ErdaRuntimeHPAEventsValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ErdaRuntimeHPAEventsValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ErdaRuntimeHPAEventsMultiError(errors)
	}

	return nil
}

// ErdaRuntimeHPAEventsMultiError is an error wrapping multiple validation
// errors returned by ErdaRuntimeHPAEvents.ValidateAll() if the designated
// constraints aren't met.
type ErdaRuntimeHPAEventsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErdaRuntimeHPAEventsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErdaRuntimeHPAEventsMultiError) AllErrors() []error { return m }

// ErdaRuntimeHPAEventsValidationError is the validation error returned by
// ErdaRuntimeHPAEvents.Validate if the designated constraints aren't met.
type ErdaRuntimeHPAEventsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErdaRuntimeHPAEventsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErdaRuntimeHPAEventsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErdaRuntimeHPAEventsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErdaRuntimeHPAEventsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErdaRuntimeHPAEventsValidationError) ErrorName() string {
	return "ErdaRuntimeHPAEventsValidationError"
}

// Error satisfies the builtin error interface
func (e ErdaRuntimeHPAEventsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErdaRuntimeHPAEvents.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErdaRuntimeHPAEventsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErdaRuntimeHPAEventsValidationError{}

// Validate checks the field values on ErdaRuntimeHPAEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ErdaRuntimeHPAEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErdaRuntimeHPAEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErdaRuntimeHPAEventMultiError, or nil if none found.
func (m *ErdaRuntimeHPAEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ErdaRuntimeHPAEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	// no validation rules for RuleId

	if all {
		switch v := interface{}(m.GetEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeHPAEventValidationError{
					field:  "Event",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeHPAEventValidationError{
					field:  "Event",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeHPAEventValidationError{
				field:  "Event",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ErdaRuntimeHPAEventMultiError(errors)
	}

	return nil
}

// ErdaRuntimeHPAEventMultiError is an error wrapping multiple validation
// errors returned by ErdaRuntimeHPAEvent.ValidateAll() if the designated
// constraints aren't met.
type ErdaRuntimeHPAEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErdaRuntimeHPAEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErdaRuntimeHPAEventMultiError) AllErrors() []error { return m }

// ErdaRuntimeHPAEventValidationError is the validation error returned by
// ErdaRuntimeHPAEvent.Validate if the designated constraints aren't met.
type ErdaRuntimeHPAEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErdaRuntimeHPAEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErdaRuntimeHPAEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErdaRuntimeHPAEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErdaRuntimeHPAEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErdaRuntimeHPAEventValidationError) ErrorName() string {
	return "ErdaRuntimeHPAEventValidationError"
}

// Error satisfies the builtin error interface
func (e ErdaRuntimeHPAEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErdaRuntimeHPAEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErdaRuntimeHPAEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErdaRuntimeHPAEventValidationError{}

// Validate checks the field values on HPAEventDetail with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HPAEventDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HPAEventDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HPAEventDetailMultiError,
// or nil if none found.
func (m *HPAEventDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *HPAEventDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HPAEventDetailValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HPAEventDetailValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HPAEventDetailValidationError{
				field:  "CreateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for Reason

	// no validation rules for EventMessage

	if len(errors) > 0 {
		return HPAEventDetailMultiError(errors)
	}

	return nil
}

// HPAEventDetailMultiError is an error wrapping multiple validation errors
// returned by HPAEventDetail.ValidateAll() if the designated constraints
// aren't met.
type HPAEventDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HPAEventDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HPAEventDetailMultiError) AllErrors() []error { return m }

// HPAEventDetailValidationError is the validation error returned by
// HPAEventDetail.Validate if the designated constraints aren't met.
type HPAEventDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HPAEventDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HPAEventDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HPAEventDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HPAEventDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HPAEventDetailValidationError) ErrorName() string { return "HPAEventDetailValidationError" }

// Error satisfies the builtin error interface
func (e HPAEventDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHPAEventDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HPAEventDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HPAEventDetailValidationError{}

// Validate checks the field values on VPARuleCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VPARuleCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VPARuleCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VPARuleCreateRequestMultiError, or nil if none found.
func (m *VPARuleCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VPARuleCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeID

	for idx, item := range m.GetServices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, VPARuleCreateRequestValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, VPARuleCreateRequestValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return VPARuleCreateRequestValidationError{
					field:  fmt.Sprintf("Services[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return VPARuleCreateRequestMultiError(errors)
	}

	return nil
}

// VPARuleCreateRequestMultiError is an error wrapping multiple validation
// errors returned by VPARuleCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type VPARuleCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VPARuleCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VPARuleCreateRequestMultiError) AllErrors() []error { return m }

// VPARuleCreateRequestValidationError is the validation error returned by
// VPARuleCreateRequest.Validate if the designated constraints aren't met.
type VPARuleCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VPARuleCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VPARuleCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VPARuleCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VPARuleCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VPARuleCreateRequestValidationError) ErrorName() string {
	return "VPARuleCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e VPARuleCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVPARuleCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VPARuleCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VPARuleCreateRequestValidationError{}

// Validate checks the field values on RuntimeServiceVPAConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RuntimeServiceVPAConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RuntimeServiceVPAConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RuntimeServiceVPAConfigMultiError, or nil if none found.
func (m *RuntimeServiceVPAConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *RuntimeServiceVPAConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuleID

	// no validation rules for RuleName

	// no validation rules for RuntimeID

	// no validation rules for ApplicationID

	// no validation rules for ProjectID

	// no validation rules for OrgID

	// no validation rules for ServiceName

	if all {
		switch v := interface{}(m.GetScaleTargetRef()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeServiceVPAConfigValidationError{
					field:  "ScaleTargetRef",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeServiceVPAConfigValidationError{
					field:  "ScaleTargetRef",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScaleTargetRef()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeServiceVPAConfigValidationError{
				field:  "ScaleTargetRef",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RuleNameSpace

	// no validation rules for UpdateMode

	if all {
		switch v := interface{}(m.GetDeployments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeServiceVPAConfigValidationError{
					field:  "Deployments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeServiceVPAConfigValidationError{
					field:  "Deployments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeServiceVPAConfigValidationError{
				field:  "Deployments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeServiceVPAConfigValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeServiceVPAConfigValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeServiceVPAConfigValidationError{
				field:  "Resources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaxResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RuntimeServiceVPAConfigValidationError{
					field:  "MaxResources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RuntimeServiceVPAConfigValidationError{
					field:  "MaxResources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RuntimeServiceVPAConfigValidationError{
				field:  "MaxResources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RuntimeServiceVPAConfigMultiError(errors)
	}

	return nil
}

// RuntimeServiceVPAConfigMultiError is an error wrapping multiple validation
// errors returned by RuntimeServiceVPAConfig.ValidateAll() if the designated
// constraints aren't met.
type RuntimeServiceVPAConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RuntimeServiceVPAConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RuntimeServiceVPAConfigMultiError) AllErrors() []error { return m }

// RuntimeServiceVPAConfigValidationError is the validation error returned by
// RuntimeServiceVPAConfig.Validate if the designated constraints aren't met.
type RuntimeServiceVPAConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RuntimeServiceVPAConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RuntimeServiceVPAConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RuntimeServiceVPAConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RuntimeServiceVPAConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RuntimeServiceVPAConfigValidationError) ErrorName() string {
	return "RuntimeServiceVPAConfigValidationError"
}

// Error satisfies the builtin error interface
func (e RuntimeServiceVPAConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRuntimeServiceVPAConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RuntimeServiceVPAConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RuntimeServiceVPAConfigValidationError{}

// Validate checks the field values on ErdaRuntimeVPARules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ErdaRuntimeVPARules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErdaRuntimeVPARules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErdaRuntimeVPARulesMultiError, or nil if none found.
func (m *ErdaRuntimeVPARules) ValidateAll() error {
	return m.validate(true)
}

func (m *ErdaRuntimeVPARules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeID

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ErdaRuntimeVPARulesValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ErdaRuntimeVPARulesValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ErdaRuntimeVPARulesValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ErdaRuntimeVPARulesMultiError(errors)
	}

	return nil
}

// ErdaRuntimeVPARulesMultiError is an error wrapping multiple validation
// errors returned by ErdaRuntimeVPARules.ValidateAll() if the designated
// constraints aren't met.
type ErdaRuntimeVPARulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErdaRuntimeVPARulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErdaRuntimeVPARulesMultiError) AllErrors() []error { return m }

// ErdaRuntimeVPARulesValidationError is the validation error returned by
// ErdaRuntimeVPARules.Validate if the designated constraints aren't met.
type ErdaRuntimeVPARulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErdaRuntimeVPARulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErdaRuntimeVPARulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErdaRuntimeVPARulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErdaRuntimeVPARulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErdaRuntimeVPARulesValidationError) ErrorName() string {
	return "ErdaRuntimeVPARulesValidationError"
}

// Error satisfies the builtin error interface
func (e ErdaRuntimeVPARulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErdaRuntimeVPARules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErdaRuntimeVPARulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErdaRuntimeVPARulesValidationError{}

// Validate checks the field values on ErdaRuntimeVPARule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ErdaRuntimeVPARule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErdaRuntimeVPARule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErdaRuntimeVPARuleMultiError, or nil if none found.
func (m *ErdaRuntimeVPARule) ValidateAll() error {
	return m.validate(true)
}

func (m *ErdaRuntimeVPARule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeVPARuleValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeVPARuleValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeVPARuleValidationError{
				field:  "CreateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeVPARuleValidationError{
					field:  "UpdateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeVPARuleValidationError{
					field:  "UpdateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeVPARuleValidationError{
				field:  "UpdateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServiceName

	if all {
		switch v := interface{}(m.GetUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeVPARuleValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeVPARuleValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeVPARuleValidationError{
				field:  "UserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaRuntimeVPARuleValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaRuntimeVPARuleValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaRuntimeVPARuleValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsApplied

	if len(errors) > 0 {
		return ErdaRuntimeVPARuleMultiError(errors)
	}

	return nil
}

// ErdaRuntimeVPARuleMultiError is an error wrapping multiple validation errors
// returned by ErdaRuntimeVPARule.ValidateAll() if the designated constraints
// aren't met.
type ErdaRuntimeVPARuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErdaRuntimeVPARuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErdaRuntimeVPARuleMultiError) AllErrors() []error { return m }

// ErdaRuntimeVPARuleValidationError is the validation error returned by
// ErdaRuntimeVPARule.Validate if the designated constraints aren't met.
type ErdaRuntimeVPARuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErdaRuntimeVPARuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErdaRuntimeVPARuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErdaRuntimeVPARuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErdaRuntimeVPARuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErdaRuntimeVPARuleValidationError) ErrorName() string {
	return "ErdaRuntimeVPARuleValidationError"
}

// Error satisfies the builtin error interface
func (e ErdaRuntimeVPARuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErdaRuntimeVPARule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErdaRuntimeVPARuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErdaRuntimeVPARuleValidationError{}

// Validate checks the field values on ErdaRuntimeVPARecommendations with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ErdaRuntimeVPARecommendations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErdaRuntimeVPARecommendations with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ErdaRuntimeVPARecommendationsMultiError, or nil if none found.
func (m *ErdaRuntimeVPARecommendations) ValidateAll() error {
	return m.validate(true)
}

func (m *ErdaRuntimeVPARecommendations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RuntimeID

	for idx, item := range m.GetServiceRecommendations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ErdaRuntimeVPARecommendationsValidationError{
						field:  fmt.Sprintf("ServiceRecommendations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ErdaRuntimeVPARecommendationsValidationError{
						field:  fmt.Sprintf("ServiceRecommendations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ErdaRuntimeVPARecommendationsValidationError{
					field:  fmt.Sprintf("ServiceRecommendations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ErdaRuntimeVPARecommendationsMultiError(errors)
	}

	return nil
}

// ErdaRuntimeVPARecommendationsMultiError is an error wrapping multiple
// validation errors returned by ErdaRuntimeVPARecommendations.ValidateAll()
// if the designated constraints aren't met.
type ErdaRuntimeVPARecommendationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErdaRuntimeVPARecommendationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErdaRuntimeVPARecommendationsMultiError) AllErrors() []error { return m }

// ErdaRuntimeVPARecommendationsValidationError is the validation error
// returned by ErdaRuntimeVPARecommendations.Validate if the designated
// constraints aren't met.
type ErdaRuntimeVPARecommendationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErdaRuntimeVPARecommendationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErdaRuntimeVPARecommendationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErdaRuntimeVPARecommendationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErdaRuntimeVPARecommendationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErdaRuntimeVPARecommendationsValidationError) ErrorName() string {
	return "ErdaRuntimeVPARecommendationsValidationError"
}

// Error satisfies the builtin error interface
func (e ErdaRuntimeVPARecommendationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErdaRuntimeVPARecommendations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErdaRuntimeVPARecommendationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErdaRuntimeVPARecommendationsValidationError{}

// Validate checks the field values on ErdaServiceRecommendation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ErdaServiceRecommendation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErdaServiceRecommendation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ErdaServiceRecommendationMultiError, or nil if none found.
func (m *ErdaServiceRecommendation) ValidateAll() error {
	return m.validate(true)
}

func (m *ErdaServiceRecommendation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreateAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaServiceRecommendationValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaServiceRecommendationValidationError{
					field:  "CreateAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaServiceRecommendationValidationError{
				field:  "CreateAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServiceName

	// no validation rules for RuleID

	// no validation rules for RuleName

	if all {
		switch v := interface{}(m.GetContainerRecommendation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErdaServiceRecommendationValidationError{
					field:  "ContainerRecommendation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErdaServiceRecommendationValidationError{
					field:  "ContainerRecommendation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContainerRecommendation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErdaServiceRecommendationValidationError{
				field:  "ContainerRecommendation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ErdaServiceRecommendationMultiError(errors)
	}

	return nil
}

// ErdaServiceRecommendationMultiError is an error wrapping multiple validation
// errors returned by ErdaServiceRecommendation.ValidateAll() if the
// designated constraints aren't met.
type ErdaServiceRecommendationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErdaServiceRecommendationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErdaServiceRecommendationMultiError) AllErrors() []error { return m }

// ErdaServiceRecommendationValidationError is the validation error returned by
// ErdaServiceRecommendation.Validate if the designated constraints aren't met.
type ErdaServiceRecommendationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErdaServiceRecommendationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErdaServiceRecommendationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErdaServiceRecommendationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErdaServiceRecommendationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErdaServiceRecommendationValidationError) ErrorName() string {
	return "ErdaServiceRecommendationValidationError"
}

// Error satisfies the builtin error interface
func (e ErdaServiceRecommendationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErdaServiceRecommendation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErdaServiceRecommendationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErdaServiceRecommendationValidationError{}

// Validate checks the field values on VPAContainerRecommendation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VPAContainerRecommendation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VPAContainerRecommendation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VPAContainerRecommendationMultiError, or nil if none found.
func (m *VPAContainerRecommendation) ValidateAll() error {
	return m.validate(true)
}

func (m *VPAContainerRecommendation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContainerName

	if all {
		switch v := interface{}(m.GetLowerBound()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VPAContainerRecommendationValidationError{
					field:  "LowerBound",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VPAContainerRecommendationValidationError{
					field:  "LowerBound",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLowerBound()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VPAContainerRecommendationValidationError{
				field:  "LowerBound",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpperBound()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VPAContainerRecommendationValidationError{
					field:  "UpperBound",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VPAContainerRecommendationValidationError{
					field:  "UpperBound",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpperBound()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VPAContainerRecommendationValidationError{
				field:  "UpperBound",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VPAContainerRecommendationValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VPAContainerRecommendationValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VPAContainerRecommendationValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUncappedTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VPAContainerRecommendationValidationError{
					field:  "UncappedTarget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VPAContainerRecommendationValidationError{
					field:  "UncappedTarget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUncappedTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VPAContainerRecommendationValidationError{
				field:  "UncappedTarget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VPAContainerRecommendationMultiError(errors)
	}

	return nil
}

// VPAContainerRecommendationMultiError is an error wrapping multiple
// validation errors returned by VPAContainerRecommendation.ValidateAll() if
// the designated constraints aren't met.
type VPAContainerRecommendationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VPAContainerRecommendationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VPAContainerRecommendationMultiError) AllErrors() []error { return m }

// VPAContainerRecommendationValidationError is the validation error returned
// by VPAContainerRecommendation.Validate if the designated constraints aren't met.
type VPAContainerRecommendationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VPAContainerRecommendationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VPAContainerRecommendationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VPAContainerRecommendationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VPAContainerRecommendationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VPAContainerRecommendationValidationError) ErrorName() string {
	return "VPAContainerRecommendationValidationError"
}

// Error satisfies the builtin error interface
func (e VPAContainerRecommendationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVPAContainerRecommendation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VPAContainerRecommendationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VPAContainerRecommendationValidationError{}
