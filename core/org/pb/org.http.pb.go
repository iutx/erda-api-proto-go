// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: org.proto

package pb

import (
	context "context"
	http1 "net/http"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// OrgServiceHandler is the server API for OrgService service.
type OrgServiceHandler interface {
	// POST /core/api/orgs
	CreateOrg(context.Context, *CreateOrgRequest) (*CreateOrgResponse, error)
	// PUT /core/api/orgs/{orgID}
	UpdateOrg(context.Context, *UpdateOrgRequest) (*UpdateOrgResponse, error)
	// GET /core/api/orgs/{idOrName}
	GetOrg(context.Context, *GetOrgRequest) (*GetOrgResponse, error)
	// DELETE /core/api/orgs/{idOrName}
	DeleteOrg(context.Context, *DeleteOrgRequest) (*DeleteOrgResponse, error)
	// GET /core/api/orgs
	ListOrg(context.Context, *ListOrgRequest) (*ListOrgResponse, error)
	// GET /core/api/orgs/actions/list-public
	ListPublicOrg(context.Context, *ListOrgRequest) (*ListOrgResponse, error)
	// GET /core/api/orgs/actions/get-by-domain
	GetOrgByDomain(context.Context, *GetOrgByDomainRequest) (*GetOrgByDomainResponse, error)
	// POST /core/api/orgs/actions/switch
	ChangeCurrentOrg(context.Context, *ChangeCurrentOrgRequest) (*ChangeCurrentOrgResponse, error)
	// POST /core/api/orgs/actions/relate-cluster
	CreateOrgClusterRelation(context.Context, *OrgClusterRelationCreateRequest) (*OrgClusterRelationCreateResponse, error)
	// GET /core/api/orgs/clusters/relations
	ListOrgClusterRelation(context.Context, *ListOrgClusterRelationRequest) (*ListOrgClusterRelationResponse, error)
	// POST /core/api/orgs/{orgID}/actions/set-release-cross-cluster
	SetReleaseCrossCluster(context.Context, *SetReleaseCrossClusterRequest) (*SetReleaseCrossClusterResponse, error)
	// POST /core/api/orgs/actions/gen-verify-code
	GenVerifyCode(context.Context, *GenVerifyCodeRequest) (*GenVerifyCodeResponse, error)
	// POST /core/api/orgs/{orgID}/actions/set-notify-config
	SetNotifyConfig(context.Context, *SetNotifyConfigRequest) (*SetNotifyConfigResponse, error)
	// GET /core/api/orgs/{orgID}/actions/get-notify-config
	GetNotifyConfig(context.Context, *GetNotifyConfigRequest) (*GetNotifyConfigResponse, error)
	// GET /core/api/orgs/clusters/relations/{orgID}
	GetOrgClusterRelationsByOrg(context.Context, *GetOrgClusterRelationsByOrgRequest) (*GetOrgClusterRelationsByOrgResponse, error)
	// PUT /core/api/clusters/actions/dereference
	DereferenceCluster(context.Context, *DereferenceClusterRequest) (*DereferenceClusterResponse, error)
}

// RegisterOrgServiceHandler register OrgServiceHandler to http.Router.
func RegisterOrgServiceHandler(r http.Router, srv OrgServiceHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_CreateOrg := func(method, path string, fn func(context.Context, *CreateOrgRequest) (*CreateOrgResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateOrgRequest))
		}
		var CreateOrg_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateOrg_info = transport.NewServiceInfo("erda.core.org.OrgService", "CreateOrg", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateOrg_info)
				}
				r = r.WithContext(ctx)
				var in CreateOrgRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateOrg := func(method, path string, fn func(context.Context, *UpdateOrgRequest) (*UpdateOrgResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateOrgRequest))
		}
		var UpdateOrg_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateOrg_info = transport.NewServiceInfo("erda.core.org.OrgService", "UpdateOrg", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateOrg_info)
				}
				r = r.WithContext(ctx)
				var in UpdateOrgRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetOrg := func(method, path string, fn func(context.Context, *GetOrgRequest) (*GetOrgResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetOrgRequest))
		}
		var GetOrg_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetOrg_info = transport.NewServiceInfo("erda.core.org.OrgService", "GetOrg", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetOrg_info)
				}
				r = r.WithContext(ctx)
				var in GetOrgRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "idOrName":
							in.IdOrName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteOrg := func(method, path string, fn func(context.Context, *DeleteOrgRequest) (*DeleteOrgResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteOrgRequest))
		}
		var DeleteOrg_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteOrg_info = transport.NewServiceInfo("erda.core.org.OrgService", "DeleteOrg", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteOrg_info)
				}
				r = r.WithContext(ctx)
				var in DeleteOrgRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "idOrName":
							in.IdOrName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListOrg := func(method, path string, fn func(context.Context, *ListOrgRequest) (*ListOrgResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListOrgRequest))
		}
		var ListOrg_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListOrg_info = transport.NewServiceInfo("erda.core.org.OrgService", "ListOrg", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListOrg_info)
				}
				r = r.WithContext(ctx)
				var in ListOrgRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListPublicOrg := func(method, path string, fn func(context.Context, *ListOrgRequest) (*ListOrgResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListOrgRequest))
		}
		var ListPublicOrg_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListPublicOrg_info = transport.NewServiceInfo("erda.core.org.OrgService", "ListPublicOrg", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListPublicOrg_info)
				}
				r = r.WithContext(ctx)
				var in ListOrgRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetOrgByDomain := func(method, path string, fn func(context.Context, *GetOrgByDomainRequest) (*GetOrgByDomainResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetOrgByDomainRequest))
		}
		var GetOrgByDomain_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetOrgByDomain_info = transport.NewServiceInfo("erda.core.org.OrgService", "GetOrgByDomain", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetOrgByDomain_info)
				}
				r = r.WithContext(ctx)
				var in GetOrgByDomainRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ChangeCurrentOrg := func(method, path string, fn func(context.Context, *ChangeCurrentOrgRequest) (*ChangeCurrentOrgResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ChangeCurrentOrgRequest))
		}
		var ChangeCurrentOrg_info transport.ServiceInfo
		if h.Interceptor != nil {
			ChangeCurrentOrg_info = transport.NewServiceInfo("erda.core.org.OrgService", "ChangeCurrentOrg", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ChangeCurrentOrg_info)
				}
				r = r.WithContext(ctx)
				var in ChangeCurrentOrgRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateOrgClusterRelation := func(method, path string, fn func(context.Context, *OrgClusterRelationCreateRequest) (*OrgClusterRelationCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgClusterRelationCreateRequest))
		}
		var CreateOrgClusterRelation_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateOrgClusterRelation_info = transport.NewServiceInfo("erda.core.org.OrgService", "CreateOrgClusterRelation", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateOrgClusterRelation_info)
				}
				r = r.WithContext(ctx)
				var in OrgClusterRelationCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListOrgClusterRelation := func(method, path string, fn func(context.Context, *ListOrgClusterRelationRequest) (*ListOrgClusterRelationResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListOrgClusterRelationRequest))
		}
		var ListOrgClusterRelation_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListOrgClusterRelation_info = transport.NewServiceInfo("erda.core.org.OrgService", "ListOrgClusterRelation", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListOrgClusterRelation_info)
				}
				r = r.WithContext(ctx)
				var in ListOrgClusterRelationRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SetReleaseCrossCluster := func(method, path string, fn func(context.Context, *SetReleaseCrossClusterRequest) (*SetReleaseCrossClusterResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SetReleaseCrossClusterRequest))
		}
		var SetReleaseCrossCluster_info transport.ServiceInfo
		if h.Interceptor != nil {
			SetReleaseCrossCluster_info = transport.NewServiceInfo("erda.core.org.OrgService", "SetReleaseCrossCluster", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SetReleaseCrossCluster_info)
				}
				r = r.WithContext(ctx)
				var in SetReleaseCrossClusterRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GenVerifyCode := func(method, path string, fn func(context.Context, *GenVerifyCodeRequest) (*GenVerifyCodeResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GenVerifyCodeRequest))
		}
		var GenVerifyCode_info transport.ServiceInfo
		if h.Interceptor != nil {
			GenVerifyCode_info = transport.NewServiceInfo("erda.core.org.OrgService", "GenVerifyCode", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GenVerifyCode_info)
				}
				r = r.WithContext(ctx)
				var in GenVerifyCodeRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SetNotifyConfig := func(method, path string, fn func(context.Context, *SetNotifyConfigRequest) (*SetNotifyConfigResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SetNotifyConfigRequest))
		}
		var SetNotifyConfig_info transport.ServiceInfo
		if h.Interceptor != nil {
			SetNotifyConfig_info = transport.NewServiceInfo("erda.core.org.OrgService", "SetNotifyConfig", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SetNotifyConfig_info)
				}
				r = r.WithContext(ctx)
				var in SetNotifyConfigRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetNotifyConfig := func(method, path string, fn func(context.Context, *GetNotifyConfigRequest) (*GetNotifyConfigResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetNotifyConfigRequest))
		}
		var GetNotifyConfig_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetNotifyConfig_info = transport.NewServiceInfo("erda.core.org.OrgService", "GetNotifyConfig", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetNotifyConfig_info)
				}
				r = r.WithContext(ctx)
				var in GetNotifyConfigRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetOrgClusterRelationsByOrg := func(method, path string, fn func(context.Context, *GetOrgClusterRelationsByOrgRequest) (*GetOrgClusterRelationsByOrgResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetOrgClusterRelationsByOrgRequest))
		}
		var GetOrgClusterRelationsByOrg_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetOrgClusterRelationsByOrg_info = transport.NewServiceInfo("erda.core.org.OrgService", "GetOrgClusterRelationsByOrg", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetOrgClusterRelationsByOrg_info)
				}
				r = r.WithContext(ctx)
				var in GetOrgClusterRelationsByOrgRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DereferenceCluster := func(method, path string, fn func(context.Context, *DereferenceClusterRequest) (*DereferenceClusterResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DereferenceClusterRequest))
		}
		var DereferenceCluster_info transport.ServiceInfo
		if h.Interceptor != nil {
			DereferenceCluster_info = transport.NewServiceInfo("erda.core.org.OrgService", "DereferenceCluster", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DereferenceCluster_info)
				}
				r = r.WithContext(ctx)
				var in DereferenceClusterRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateOrg("POST", "/core/api/orgs", srv.CreateOrg)
	add_UpdateOrg("PUT", "/core/api/orgs/{orgID}", srv.UpdateOrg)
	add_GetOrg("GET", "/core/api/orgs/{idOrName}", srv.GetOrg)
	add_DeleteOrg("DELETE", "/core/api/orgs/{idOrName}", srv.DeleteOrg)
	add_ListOrg("GET", "/core/api/orgs", srv.ListOrg)
	add_ListPublicOrg("GET", "/core/api/orgs/actions/list-public", srv.ListPublicOrg)
	add_GetOrgByDomain("GET", "/core/api/orgs/actions/get-by-domain", srv.GetOrgByDomain)
	add_ChangeCurrentOrg("POST", "/core/api/orgs/actions/switch", srv.ChangeCurrentOrg)
	add_CreateOrgClusterRelation("POST", "/core/api/orgs/actions/relate-cluster", srv.CreateOrgClusterRelation)
	add_ListOrgClusterRelation("GET", "/core/api/orgs/clusters/relations", srv.ListOrgClusterRelation)
	add_SetReleaseCrossCluster("POST", "/core/api/orgs/{orgID}/actions/set-release-cross-cluster", srv.SetReleaseCrossCluster)
	add_GenVerifyCode("POST", "/core/api/orgs/actions/gen-verify-code", srv.GenVerifyCode)
	add_SetNotifyConfig("POST", "/core/api/orgs/{orgID}/actions/set-notify-config", srv.SetNotifyConfig)
	add_GetNotifyConfig("GET", "/core/api/orgs/{orgID}/actions/get-notify-config", srv.GetNotifyConfig)
	add_GetOrgClusterRelationsByOrg("GET", "/core/api/orgs/clusters/relations/{orgID}", srv.GetOrgClusterRelationsByOrg)
	add_DereferenceCluster("PUT", "/core/api/clusters/actions/dereference", srv.DereferenceCluster)
}
