// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: diagnotor.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on StartDiagnosisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartDiagnosisRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartDiagnosisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartDiagnosisRequestMultiError, or nil if none found.
func (m *StartDiagnosisRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartDiagnosisRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := StartDiagnosisRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := StartDiagnosisRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPodName()) < 1 {
		err := StartDiagnosisRequestValidationError{
			field:  "PodName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Labels

	if len(errors) > 0 {
		return StartDiagnosisRequestMultiError(errors)
	}

	return nil
}

// StartDiagnosisRequestMultiError is an error wrapping multiple validation
// errors returned by StartDiagnosisRequest.ValidateAll() if the designated
// constraints aren't met.
type StartDiagnosisRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartDiagnosisRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartDiagnosisRequestMultiError) AllErrors() []error { return m }

// StartDiagnosisRequestValidationError is the validation error returned by
// StartDiagnosisRequest.Validate if the designated constraints aren't met.
type StartDiagnosisRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartDiagnosisRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartDiagnosisRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartDiagnosisRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartDiagnosisRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartDiagnosisRequestValidationError) ErrorName() string {
	return "StartDiagnosisRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartDiagnosisRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartDiagnosisRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartDiagnosisRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartDiagnosisRequestValidationError{}

// Validate checks the field values on StartDiagnosisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartDiagnosisResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartDiagnosisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartDiagnosisResponseMultiError, or nil if none found.
func (m *StartDiagnosisResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartDiagnosisResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDiagnosisResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDiagnosisResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDiagnosisResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartDiagnosisResponseMultiError(errors)
	}

	return nil
}

// StartDiagnosisResponseMultiError is an error wrapping multiple validation
// errors returned by StartDiagnosisResponse.ValidateAll() if the designated
// constraints aren't met.
type StartDiagnosisResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartDiagnosisResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartDiagnosisResponseMultiError) AllErrors() []error { return m }

// StartDiagnosisResponseValidationError is the validation error returned by
// StartDiagnosisResponse.Validate if the designated constraints aren't met.
type StartDiagnosisResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartDiagnosisResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartDiagnosisResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartDiagnosisResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartDiagnosisResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartDiagnosisResponseValidationError) ErrorName() string {
	return "StartDiagnosisResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartDiagnosisResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartDiagnosisResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartDiagnosisResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartDiagnosisResponseValidationError{}

// Validate checks the field values on QueryDiagnosisStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryDiagnosisStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryDiagnosisStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryDiagnosisStatusRequestMultiError, or nil if none found.
func (m *QueryDiagnosisStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryDiagnosisStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := QueryDiagnosisStatusRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := QueryDiagnosisStatusRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPodName()) < 1 {
		err := QueryDiagnosisStatusRequestValidationError{
			field:  "PodName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QueryDiagnosisStatusRequestMultiError(errors)
	}

	return nil
}

// QueryDiagnosisStatusRequestMultiError is an error wrapping multiple
// validation errors returned by QueryDiagnosisStatusRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryDiagnosisStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryDiagnosisStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryDiagnosisStatusRequestMultiError) AllErrors() []error { return m }

// QueryDiagnosisStatusRequestValidationError is the validation error returned
// by QueryDiagnosisStatusRequest.Validate if the designated constraints
// aren't met.
type QueryDiagnosisStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryDiagnosisStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryDiagnosisStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryDiagnosisStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryDiagnosisStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryDiagnosisStatusRequestValidationError) ErrorName() string {
	return "QueryDiagnosisStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryDiagnosisStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryDiagnosisStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryDiagnosisStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryDiagnosisStatusRequestValidationError{}

// Validate checks the field values on QueryDiagnosisStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryDiagnosisStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryDiagnosisStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryDiagnosisStatusResponseMultiError, or nil if none found.
func (m *QueryDiagnosisStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryDiagnosisStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryDiagnosisStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryDiagnosisStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryDiagnosisStatusResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryDiagnosisStatusResponseMultiError(errors)
	}

	return nil
}

// QueryDiagnosisStatusResponseMultiError is an error wrapping multiple
// validation errors returned by QueryDiagnosisStatusResponse.ValidateAll() if
// the designated constraints aren't met.
type QueryDiagnosisStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryDiagnosisStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryDiagnosisStatusResponseMultiError) AllErrors() []error { return m }

// QueryDiagnosisStatusResponseValidationError is the validation error returned
// by QueryDiagnosisStatusResponse.Validate if the designated constraints
// aren't met.
type QueryDiagnosisStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryDiagnosisStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryDiagnosisStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryDiagnosisStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryDiagnosisStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryDiagnosisStatusResponseValidationError) ErrorName() string {
	return "QueryDiagnosisStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryDiagnosisStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryDiagnosisStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryDiagnosisStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryDiagnosisStatusResponseValidationError{}

// Validate checks the field values on DiagnosisInstance with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DiagnosisInstance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiagnosisInstance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiagnosisInstanceMultiError, or nil if none found.
func (m *DiagnosisInstance) ValidateAll() error {
	return m.validate(true)
}

func (m *DiagnosisInstance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterName

	// no validation rules for Namespace

	// no validation rules for PodName

	// no validation rules for HostIP

	// no validation rules for PodIP

	// no validation rules for Status

	// no validation rules for Message

	if len(errors) > 0 {
		return DiagnosisInstanceMultiError(errors)
	}

	return nil
}

// DiagnosisInstanceMultiError is an error wrapping multiple validation errors
// returned by DiagnosisInstance.ValidateAll() if the designated constraints
// aren't met.
type DiagnosisInstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiagnosisInstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiagnosisInstanceMultiError) AllErrors() []error { return m }

// DiagnosisInstanceValidationError is the validation error returned by
// DiagnosisInstance.Validate if the designated constraints aren't met.
type DiagnosisInstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiagnosisInstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiagnosisInstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiagnosisInstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiagnosisInstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiagnosisInstanceValidationError) ErrorName() string {
	return "DiagnosisInstanceValidationError"
}

// Error satisfies the builtin error interface
func (e DiagnosisInstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiagnosisInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiagnosisInstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiagnosisInstanceValidationError{}

// Validate checks the field values on StopDiagnosisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopDiagnosisRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopDiagnosisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopDiagnosisRequestMultiError, or nil if none found.
func (m *StopDiagnosisRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StopDiagnosisRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := StopDiagnosisRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := StopDiagnosisRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPodName()) < 1 {
		err := StopDiagnosisRequestValidationError{
			field:  "PodName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StopDiagnosisRequestMultiError(errors)
	}

	return nil
}

// StopDiagnosisRequestMultiError is an error wrapping multiple validation
// errors returned by StopDiagnosisRequest.ValidateAll() if the designated
// constraints aren't met.
type StopDiagnosisRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopDiagnosisRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopDiagnosisRequestMultiError) AllErrors() []error { return m }

// StopDiagnosisRequestValidationError is the validation error returned by
// StopDiagnosisRequest.Validate if the designated constraints aren't met.
type StopDiagnosisRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopDiagnosisRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopDiagnosisRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopDiagnosisRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopDiagnosisRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopDiagnosisRequestValidationError) ErrorName() string {
	return "StopDiagnosisRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StopDiagnosisRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopDiagnosisRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopDiagnosisRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopDiagnosisRequestValidationError{}

// Validate checks the field values on StopDiagnosisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopDiagnosisResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopDiagnosisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopDiagnosisResponseMultiError, or nil if none found.
func (m *StopDiagnosisResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StopDiagnosisResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return StopDiagnosisResponseMultiError(errors)
	}

	return nil
}

// StopDiagnosisResponseMultiError is an error wrapping multiple validation
// errors returned by StopDiagnosisResponse.ValidateAll() if the designated
// constraints aren't met.
type StopDiagnosisResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopDiagnosisResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopDiagnosisResponseMultiError) AllErrors() []error { return m }

// StopDiagnosisResponseValidationError is the validation error returned by
// StopDiagnosisResponse.Validate if the designated constraints aren't met.
type StopDiagnosisResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopDiagnosisResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopDiagnosisResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopDiagnosisResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopDiagnosisResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopDiagnosisResponseValidationError) ErrorName() string {
	return "StopDiagnosisResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StopDiagnosisResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopDiagnosisResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopDiagnosisResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopDiagnosisResponseValidationError{}

// Validate checks the field values on ListProcessesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProcessesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProcessesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProcessesRequestMultiError, or nil if none found.
func (m *ListProcessesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProcessesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := ListProcessesRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := ListProcessesRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPodName()) < 1 {
		err := ListProcessesRequestValidationError{
			field:  "PodName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPodIP()) < 1 {
		err := ListProcessesRequestValidationError{
			field:  "PodIP",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListProcessesRequestMultiError(errors)
	}

	return nil
}

// ListProcessesRequestMultiError is an error wrapping multiple validation
// errors returned by ListProcessesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListProcessesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProcessesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProcessesRequestMultiError) AllErrors() []error { return m }

// ListProcessesRequestValidationError is the validation error returned by
// ListProcessesRequest.Validate if the designated constraints aren't met.
type ListProcessesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProcessesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProcessesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProcessesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProcessesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProcessesRequestValidationError) ErrorName() string {
	return "ListProcessesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProcessesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProcessesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProcessesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProcessesRequestValidationError{}

// Validate checks the field values on ListProcessesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProcessesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProcessesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProcessesResponseMultiError, or nil if none found.
func (m *ListProcessesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProcessesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProcessesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProcessesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProcessesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListProcessesResponseMultiError(errors)
	}

	return nil
}

// ListProcessesResponseMultiError is an error wrapping multiple validation
// errors returned by ListProcessesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListProcessesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProcessesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProcessesResponseMultiError) AllErrors() []error { return m }

// ListProcessesResponseValidationError is the validation error returned by
// ListProcessesResponse.Validate if the designated constraints aren't met.
type ListProcessesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProcessesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProcessesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProcessesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProcessesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProcessesResponseValidationError) ErrorName() string {
	return "ListProcessesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListProcessesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProcessesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProcessesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProcessesResponseValidationError{}

// Validate checks the field values on HostProcessStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HostProcessStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostProcessStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostProcessStatusMultiError, or nil if none found.
func (m *HostProcessStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *HostProcessStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProcesses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostProcessStatusValidationError{
						field:  fmt.Sprintf("Processes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostProcessStatusValidationError{
						field:  fmt.Sprintf("Processes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostProcessStatusValidationError{
					field:  fmt.Sprintf("Processes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TotalMemory

	// no validation rules for MemoryUsed

	// no validation rules for MemoryUsedPercent

	// no validation rules for TotalCpuCores

	// no validation rules for CpuUsedCores

	// no validation rules for CpuUsedPercent

	// no validation rules for Connections

	if len(errors) > 0 {
		return HostProcessStatusMultiError(errors)
	}

	return nil
}

// HostProcessStatusMultiError is an error wrapping multiple validation errors
// returned by HostProcessStatus.ValidateAll() if the designated constraints
// aren't met.
type HostProcessStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostProcessStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostProcessStatusMultiError) AllErrors() []error { return m }

// HostProcessStatusValidationError is the validation error returned by
// HostProcessStatus.Validate if the designated constraints aren't met.
type HostProcessStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostProcessStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostProcessStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostProcessStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostProcessStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostProcessStatusValidationError) ErrorName() string {
	return "HostProcessStatusValidationError"
}

// Error satisfies the builtin error interface
func (e HostProcessStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostProcessStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostProcessStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostProcessStatusValidationError{}

// Validate checks the field values on Process with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Process) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Process with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProcessMultiError, or nil if none found.
func (m *Process) ValidateAll() error {
	return m.validate(true)
}

func (m *Process) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pid

	// no validation rules for Name

	// no validation rules for Cmdline

	// no validation rules for User

	// no validation rules for CreateTime

	// no validation rules for NumThreads

	// no validation rules for NumFDs

	// no validation rules for Connections

	if all {
		switch v := interface{}(m.GetCpu()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "Cpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "Cpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCpu()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessValidationError{
				field:  "Cpu",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMemory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "Memory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "Memory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMemory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessValidationError{
				field:  "Memory",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "Io",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "Io",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessValidationError{
				field:  "Io",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContextSwitches()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "ContextSwitches",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "ContextSwitches",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContextSwitches()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessValidationError{
				field:  "ContextSwitches",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRlimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "Rlimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessValidationError{
					field:  "Rlimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRlimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessValidationError{
				field:  "Rlimit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AppType

	if len(errors) > 0 {
		return ProcessMultiError(errors)
	}

	return nil
}

// ProcessMultiError is an error wrapping multiple validation errors returned
// by Process.ValidateAll() if the designated constraints aren't met.
type ProcessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessMultiError) AllErrors() []error { return m }

// ProcessValidationError is the validation error returned by Process.Validate
// if the designated constraints aren't met.
type ProcessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessValidationError) ErrorName() string { return "ProcessValidationError" }

// Error satisfies the builtin error interface
func (e ProcessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcess.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessValidationError{}

// Validate checks the field values on ProcessRLimit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProcessRLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessRLimit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProcessRLimitMultiError, or
// nil if none found.
func (m *ProcessRLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessRLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCpuTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "CpuTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "CpuTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCpuTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "CpuTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMemoryData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMemoryData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "MemoryData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMemoryStack()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryStack",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryStack",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMemoryStack()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "MemoryStack",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMemoryRss()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryRss",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryRss",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMemoryRss()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "MemoryRss",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMemoryLocked()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryLocked",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryLocked",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMemoryLocked()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "MemoryLocked",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMemoryVms()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryVms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "MemoryVms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMemoryVms()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "MemoryVms",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNumFDs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "NumFDs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "NumFDs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNumFDs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "NumFDs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFileLocks()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "FileLocks",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "FileLocks",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileLocks()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "FileLocks",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSignalsPending()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "SignalsPending",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "SignalsPending",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignalsPending()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "SignalsPending",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNicePriority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "NicePriority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "NicePriority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNicePriority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "NicePriority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRealtimePriority()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "RealtimePriority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessRLimitValidationError{
					field:  "RealtimePriority",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRealtimePriority()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessRLimitValidationError{
				field:  "RealtimePriority",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProcessRLimitMultiError(errors)
	}

	return nil
}

// ProcessRLimitMultiError is an error wrapping multiple validation errors
// returned by ProcessRLimit.ValidateAll() if the designated constraints
// aren't met.
type ProcessRLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessRLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessRLimitMultiError) AllErrors() []error { return m }

// ProcessRLimitValidationError is the validation error returned by
// ProcessRLimit.Validate if the designated constraints aren't met.
type ProcessRLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessRLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessRLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessRLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessRLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessRLimitValidationError) ErrorName() string { return "ProcessRLimitValidationError" }

// Error satisfies the builtin error interface
func (e ProcessRLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessRLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessRLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessRLimitValidationError{}

// Validate checks the field values on ProcessRLimitStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessRLimitStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessRLimitStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessRLimitStatusMultiError, or nil if none found.
func (m *ProcessRLimitStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessRLimitStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Soft

	// no validation rules for Hard

	// no validation rules for Used

	if len(errors) > 0 {
		return ProcessRLimitStatusMultiError(errors)
	}

	return nil
}

// ProcessRLimitStatusMultiError is an error wrapping multiple validation
// errors returned by ProcessRLimitStatus.ValidateAll() if the designated
// constraints aren't met.
type ProcessRLimitStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessRLimitStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessRLimitStatusMultiError) AllErrors() []error { return m }

// ProcessRLimitStatusValidationError is the validation error returned by
// ProcessRLimitStatus.Validate if the designated constraints aren't met.
type ProcessRLimitStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessRLimitStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessRLimitStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessRLimitStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessRLimitStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessRLimitStatusValidationError) ErrorName() string {
	return "ProcessRLimitStatusValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessRLimitStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessRLimitStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessRLimitStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessRLimitStatusValidationError{}

// Validate checks the field values on ProcessMemoryStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessMemoryStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessMemoryStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessMemoryStatusMultiError, or nil if none found.
func (m *ProcessMemoryStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessMemoryStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rss

	// no validation rules for Vms

	// no validation rules for Swap

	// no validation rules for Data

	// no validation rules for Stack

	// no validation rules for Locked

	// no validation rules for UsedPercent

	if len(errors) > 0 {
		return ProcessMemoryStatusMultiError(errors)
	}

	return nil
}

// ProcessMemoryStatusMultiError is an error wrapping multiple validation
// errors returned by ProcessMemoryStatus.ValidateAll() if the designated
// constraints aren't met.
type ProcessMemoryStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessMemoryStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessMemoryStatusMultiError) AllErrors() []error { return m }

// ProcessMemoryStatusValidationError is the validation error returned by
// ProcessMemoryStatus.Validate if the designated constraints aren't met.
type ProcessMemoryStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessMemoryStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessMemoryStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessMemoryStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessMemoryStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessMemoryStatusValidationError) ErrorName() string {
	return "ProcessMemoryStatusValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessMemoryStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessMemoryStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessMemoryStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessMemoryStatusValidationError{}

// Validate checks the field values on ProcessCPUStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProcessCPUStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessCPUStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessCPUStatusMultiError, or nil if none found.
func (m *ProcessCPUStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessCPUStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for User

	// no validation rules for System

	// no validation rules for IoWait

	// no validation rules for UsedCores

	// no validation rules for UsedPercent

	// no validation rules for UsedPercentInHost

	if len(errors) > 0 {
		return ProcessCPUStatusMultiError(errors)
	}

	return nil
}

// ProcessCPUStatusMultiError is an error wrapping multiple validation errors
// returned by ProcessCPUStatus.ValidateAll() if the designated constraints
// aren't met.
type ProcessCPUStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessCPUStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessCPUStatusMultiError) AllErrors() []error { return m }

// ProcessCPUStatusValidationError is the validation error returned by
// ProcessCPUStatus.Validate if the designated constraints aren't met.
type ProcessCPUStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessCPUStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessCPUStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessCPUStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessCPUStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessCPUStatusValidationError) ErrorName() string { return "ProcessCPUStatusValidationError" }

// Error satisfies the builtin error interface
func (e ProcessCPUStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessCPUStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessCPUStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessCPUStatusValidationError{}

// Validate checks the field values on ProcessIOStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProcessIOStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessIOStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessIOStatusMultiError, or nil if none found.
func (m *ProcessIOStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessIOStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReadCount

	// no validation rules for ReadBytes

	// no validation rules for ReadRate

	// no validation rules for WriteCount

	// no validation rules for WriteBytes

	// no validation rules for WriteRate

	if len(errors) > 0 {
		return ProcessIOStatusMultiError(errors)
	}

	return nil
}

// ProcessIOStatusMultiError is an error wrapping multiple validation errors
// returned by ProcessIOStatus.ValidateAll() if the designated constraints
// aren't met.
type ProcessIOStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessIOStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessIOStatusMultiError) AllErrors() []error { return m }

// ProcessIOStatusValidationError is the validation error returned by
// ProcessIOStatus.Validate if the designated constraints aren't met.
type ProcessIOStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessIOStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessIOStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessIOStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessIOStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessIOStatusValidationError) ErrorName() string { return "ProcessIOStatusValidationError" }

// Error satisfies the builtin error interface
func (e ProcessIOStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessIOStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessIOStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessIOStatusValidationError{}

// Validate checks the field values on ProcessContextSwitches with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessContextSwitches) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessContextSwitches with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessContextSwitchesMultiError, or nil if none found.
func (m *ProcessContextSwitches) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessContextSwitches) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Voluntary

	// no validation rules for Involuntary

	if len(errors) > 0 {
		return ProcessContextSwitchesMultiError(errors)
	}

	return nil
}

// ProcessContextSwitchesMultiError is an error wrapping multiple validation
// errors returned by ProcessContextSwitches.ValidateAll() if the designated
// constraints aren't met.
type ProcessContextSwitchesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessContextSwitchesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessContextSwitchesMultiError) AllErrors() []error { return m }

// ProcessContextSwitchesValidationError is the validation error returned by
// ProcessContextSwitches.Validate if the designated constraints aren't met.
type ProcessContextSwitchesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessContextSwitchesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessContextSwitchesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessContextSwitchesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessContextSwitchesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessContextSwitchesValidationError) ErrorName() string {
	return "ProcessContextSwitchesValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessContextSwitchesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessContextSwitches.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessContextSwitchesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessContextSwitchesValidationError{}
