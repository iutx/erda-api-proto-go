// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: meta.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ListMetricNamesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMetricNamesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetricNamesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMetricNamesRequestMultiError, or nil if none found.
func (m *ListMetricNamesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetricNamesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetScope()) < 1 {
		err := ListMetricNamesRequestValidationError{
			field:  "Scope",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := ListMetricNamesRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListMetricNamesRequestMultiError(errors)
	}

	return nil
}

// ListMetricNamesRequestMultiError is an error wrapping multiple validation
// errors returned by ListMetricNamesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListMetricNamesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetricNamesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetricNamesRequestMultiError) AllErrors() []error { return m }

// ListMetricNamesRequestValidationError is the validation error returned by
// ListMetricNamesRequest.Validate if the designated constraints aren't met.
type ListMetricNamesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetricNamesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetricNamesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetricNamesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetricNamesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetricNamesRequestValidationError) ErrorName() string {
	return "ListMetricNamesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMetricNamesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetricNamesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetricNamesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetricNamesRequestValidationError{}

// Validate checks the field values on ListMetricNamesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMetricNamesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetricNamesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMetricNamesResponseMultiError, or nil if none found.
func (m *ListMetricNamesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetricNamesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMetricNamesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMetricNamesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMetricNamesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMetricNamesResponseMultiError(errors)
	}

	return nil
}

// ListMetricNamesResponseMultiError is an error wrapping multiple validation
// errors returned by ListMetricNamesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListMetricNamesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetricNamesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetricNamesResponseMultiError) AllErrors() []error { return m }

// ListMetricNamesResponseValidationError is the validation error returned by
// ListMetricNamesResponse.Validate if the designated constraints aren't met.
type ListMetricNamesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetricNamesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetricNamesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetricNamesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetricNamesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetricNamesResponseValidationError) ErrorName() string {
	return "ListMetricNamesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMetricNamesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetricNamesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetricNamesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetricNamesResponseValidationError{}

// Validate checks the field values on RegisterMetricMetaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterMetricMetaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterMetricMetaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterMetricMetaRequestMultiError, or nil if none found.
func (m *RegisterMetricMetaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterMetricMetaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Scope

	// no validation rules for ScopeID

	// no validation rules for Group

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterMetricMetaRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterMetricMetaRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterMetricMetaRequestValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterMetricMetaRequestMultiError(errors)
	}

	return nil
}

// RegisterMetricMetaRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterMetricMetaRequest.ValidateAll() if the
// designated constraints aren't met.
type RegisterMetricMetaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterMetricMetaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterMetricMetaRequestMultiError) AllErrors() []error { return m }

// RegisterMetricMetaRequestValidationError is the validation error returned by
// RegisterMetricMetaRequest.Validate if the designated constraints aren't met.
type RegisterMetricMetaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterMetricMetaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterMetricMetaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterMetricMetaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterMetricMetaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterMetricMetaRequestValidationError) ErrorName() string {
	return "RegisterMetricMetaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterMetricMetaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterMetricMetaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterMetricMetaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterMetricMetaRequestValidationError{}

// Validate checks the field values on RegisterMetricMetaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterMetricMetaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterMetricMetaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterMetricMetaResponseMultiError, or nil if none found.
func (m *RegisterMetricMetaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterMetricMetaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return RegisterMetricMetaResponseMultiError(errors)
	}

	return nil
}

// RegisterMetricMetaResponseMultiError is an error wrapping multiple
// validation errors returned by RegisterMetricMetaResponse.ValidateAll() if
// the designated constraints aren't met.
type RegisterMetricMetaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterMetricMetaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterMetricMetaResponseMultiError) AllErrors() []error { return m }

// RegisterMetricMetaResponseValidationError is the validation error returned
// by RegisterMetricMetaResponse.Validate if the designated constraints aren't met.
type RegisterMetricMetaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterMetricMetaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterMetricMetaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterMetricMetaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterMetricMetaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterMetricMetaResponseValidationError) ErrorName() string {
	return "RegisterMetricMetaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterMetricMetaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterMetricMetaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterMetricMetaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterMetricMetaResponseValidationError{}

// Validate checks the field values on UnRegisterMetricMetaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnRegisterMetricMetaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnRegisterMetricMetaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnRegisterMetricMetaRequestMultiError, or nil if none found.
func (m *UnRegisterMetricMetaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnRegisterMetricMetaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Scope

	// no validation rules for ScopeID

	// no validation rules for Group

	// no validation rules for MetricName

	if len(errors) > 0 {
		return UnRegisterMetricMetaRequestMultiError(errors)
	}

	return nil
}

// UnRegisterMetricMetaRequestMultiError is an error wrapping multiple
// validation errors returned by UnRegisterMetricMetaRequest.ValidateAll() if
// the designated constraints aren't met.
type UnRegisterMetricMetaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnRegisterMetricMetaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnRegisterMetricMetaRequestMultiError) AllErrors() []error { return m }

// UnRegisterMetricMetaRequestValidationError is the validation error returned
// by UnRegisterMetricMetaRequest.Validate if the designated constraints
// aren't met.
type UnRegisterMetricMetaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnRegisterMetricMetaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnRegisterMetricMetaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnRegisterMetricMetaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnRegisterMetricMetaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnRegisterMetricMetaRequestValidationError) ErrorName() string {
	return "UnRegisterMetricMetaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnRegisterMetricMetaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnRegisterMetricMetaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnRegisterMetricMetaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnRegisterMetricMetaRequestValidationError{}

// Validate checks the field values on UnRegisterMetricMetaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnRegisterMetricMetaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnRegisterMetricMetaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnRegisterMetricMetaResponseMultiError, or nil if none found.
func (m *UnRegisterMetricMetaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnRegisterMetricMetaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return UnRegisterMetricMetaResponseMultiError(errors)
	}

	return nil
}

// UnRegisterMetricMetaResponseMultiError is an error wrapping multiple
// validation errors returned by UnRegisterMetricMetaResponse.ValidateAll() if
// the designated constraints aren't met.
type UnRegisterMetricMetaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnRegisterMetricMetaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnRegisterMetricMetaResponseMultiError) AllErrors() []error { return m }

// UnRegisterMetricMetaResponseValidationError is the validation error returned
// by UnRegisterMetricMetaResponse.Validate if the designated constraints
// aren't met.
type UnRegisterMetricMetaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnRegisterMetricMetaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnRegisterMetricMetaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnRegisterMetricMetaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnRegisterMetricMetaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnRegisterMetricMetaResponseValidationError) ErrorName() string {
	return "UnRegisterMetricMetaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnRegisterMetricMetaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnRegisterMetricMetaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnRegisterMetricMetaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnRegisterMetricMetaResponseValidationError{}

// Validate checks the field values on ListMetricMetaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMetricMetaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetricMetaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMetricMetaRequestMultiError, or nil if none found.
func (m *ListMetricMetaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetricMetaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetScope()) < 1 {
		err := ListMetricMetaRequestValidationError{
			field:  "Scope",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := ListMetricMetaRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListMetricMetaRequestMultiError(errors)
	}

	return nil
}

// ListMetricMetaRequestMultiError is an error wrapping multiple validation
// errors returned by ListMetricMetaRequest.ValidateAll() if the designated
// constraints aren't met.
type ListMetricMetaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetricMetaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetricMetaRequestMultiError) AllErrors() []error { return m }

// ListMetricMetaRequestValidationError is the validation error returned by
// ListMetricMetaRequest.Validate if the designated constraints aren't met.
type ListMetricMetaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetricMetaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetricMetaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetricMetaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetricMetaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetricMetaRequestValidationError) ErrorName() string {
	return "ListMetricMetaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMetricMetaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetricMetaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetricMetaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetricMetaRequestValidationError{}

// Validate checks the field values on ListMetricMetaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMetricMetaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetricMetaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMetricMetaResponseMultiError, or nil if none found.
func (m *ListMetricMetaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetricMetaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMetricMetaResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMetricMetaResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMetricMetaResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMetricMetaResponseMultiError(errors)
	}

	return nil
}

// ListMetricMetaResponseMultiError is an error wrapping multiple validation
// errors returned by ListMetricMetaResponse.ValidateAll() if the designated
// constraints aren't met.
type ListMetricMetaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetricMetaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetricMetaResponseMultiError) AllErrors() []error { return m }

// ListMetricMetaResponseValidationError is the validation error returned by
// ListMetricMetaResponse.Validate if the designated constraints aren't met.
type ListMetricMetaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetricMetaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetricMetaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetricMetaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetricMetaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetricMetaResponseValidationError) ErrorName() string {
	return "ListMetricMetaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMetricMetaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetricMetaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetricMetaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetricMetaResponseValidationError{}

// Validate checks the field values on ListMetricGroupsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMetricGroupsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetricGroupsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMetricGroupsRequestMultiError, or nil if none found.
func (m *ListMetricGroupsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetricGroupsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetScope()) < 1 {
		err := ListMetricGroupsRequestValidationError{
			field:  "Scope",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := ListMetricGroupsRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Mode

	if len(errors) > 0 {
		return ListMetricGroupsRequestMultiError(errors)
	}

	return nil
}

// ListMetricGroupsRequestMultiError is an error wrapping multiple validation
// errors returned by ListMetricGroupsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListMetricGroupsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetricGroupsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetricGroupsRequestMultiError) AllErrors() []error { return m }

// ListMetricGroupsRequestValidationError is the validation error returned by
// ListMetricGroupsRequest.Validate if the designated constraints aren't met.
type ListMetricGroupsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetricGroupsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetricGroupsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetricGroupsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetricGroupsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetricGroupsRequestValidationError) ErrorName() string {
	return "ListMetricGroupsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMetricGroupsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetricGroupsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetricGroupsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetricGroupsRequestValidationError{}

// Validate checks the field values on ListMetricGroupsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMetricGroupsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetricGroupsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMetricGroupsResponseMultiError, or nil if none found.
func (m *ListMetricGroupsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetricGroupsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMetricGroupsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMetricGroupsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMetricGroupsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMetricGroupsResponseMultiError(errors)
	}

	return nil
}

// ListMetricGroupsResponseMultiError is an error wrapping multiple validation
// errors returned by ListMetricGroupsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListMetricGroupsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetricGroupsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetricGroupsResponseMultiError) AllErrors() []error { return m }

// ListMetricGroupsResponseValidationError is the validation error returned by
// ListMetricGroupsResponse.Validate if the designated constraints aren't met.
type ListMetricGroupsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetricGroupsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetricGroupsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetricGroupsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetricGroupsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetricGroupsResponseValidationError) ErrorName() string {
	return "ListMetricGroupsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListMetricGroupsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetricGroupsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetricGroupsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetricGroupsResponseValidationError{}

// Validate checks the field values on GetMetricGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMetricGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMetricGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMetricGroupRequestMultiError, or nil if none found.
func (m *GetMetricGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMetricGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetScope()) < 1 {
		err := GetMetricGroupRequestValidationError{
			field:  "Scope",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := GetMetricGroupRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetMetricGroupRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Mode

	// no validation rules for Version

	// no validation rules for Format

	// no validation rules for AppendTags

	if len(errors) > 0 {
		return GetMetricGroupRequestMultiError(errors)
	}

	return nil
}

// GetMetricGroupRequestMultiError is an error wrapping multiple validation
// errors returned by GetMetricGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type GetMetricGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMetricGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMetricGroupRequestMultiError) AllErrors() []error { return m }

// GetMetricGroupRequestValidationError is the validation error returned by
// GetMetricGroupRequest.Validate if the designated constraints aren't met.
type GetMetricGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMetricGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMetricGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMetricGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMetricGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMetricGroupRequestValidationError) ErrorName() string {
	return "GetMetricGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMetricGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMetricGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMetricGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMetricGroupRequestValidationError{}

// Validate checks the field values on GetMetricGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMetricGroupResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMetricGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMetricGroupResponseMultiError, or nil if none found.
func (m *GetMetricGroupResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMetricGroupResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMetricGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMetricGroupResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMetricGroupResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMetricGroupResponseMultiError(errors)
	}

	return nil
}

// GetMetricGroupResponseMultiError is an error wrapping multiple validation
// errors returned by GetMetricGroupResponse.ValidateAll() if the designated
// constraints aren't met.
type GetMetricGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMetricGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMetricGroupResponseMultiError) AllErrors() []error { return m }

// GetMetricGroupResponseValidationError is the validation error returned by
// GetMetricGroupResponse.Validate if the designated constraints aren't met.
type GetMetricGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMetricGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMetricGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMetricGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMetricGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMetricGroupResponseValidationError) ErrorName() string {
	return "GetMetricGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMetricGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMetricGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMetricGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMetricGroupResponseValidationError{}

// Validate checks the field values on MetricGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetricGroupMultiError, or
// nil if none found.
func (m *MetricGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricGroupValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricGroupValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricGroupValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMetrics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricGroupValidationError{
						field:  fmt.Sprintf("Metrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricGroupValidationError{
						field:  fmt.Sprintf("Metrics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricGroupValidationError{
					field:  fmt.Sprintf("Metrics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricGroupMultiError(errors)
	}

	return nil
}

// MetricGroupMultiError is an error wrapping multiple validation errors
// returned by MetricGroup.ValidateAll() if the designated constraints aren't met.
type MetricGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricGroupMultiError) AllErrors() []error { return m }

// MetricGroupValidationError is the validation error returned by
// MetricGroup.Validate if the designated constraints aren't met.
type MetricGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricGroupValidationError) ErrorName() string { return "MetricGroupValidationError" }

// Error satisfies the builtin error interface
func (e MetricGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricGroupValidationError{}

// Validate checks the field values on GroupMetricMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GroupMetricMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GroupMetricMeta with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GroupMetricMetaMultiError, or nil if none found.
func (m *GroupMetricMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *GroupMetricMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Metric

	// no validation rules for Name

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GroupMetricMetaValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GroupMetricMetaValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GroupMetricMetaValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GroupMetricMetaValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GroupMetricMetaValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GroupMetricMetaValidationError{
					field:  fmt.Sprintf("Fields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GroupMetricMetaValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GroupMetricMetaValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GroupMetricMetaValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GroupMetricMetaMultiError(errors)
	}

	return nil
}

// GroupMetricMetaMultiError is an error wrapping multiple validation errors
// returned by GroupMetricMeta.ValidateAll() if the designated constraints
// aren't met.
type GroupMetricMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupMetricMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupMetricMetaMultiError) AllErrors() []error { return m }

// GroupMetricMetaValidationError is the validation error returned by
// GroupMetricMeta.Validate if the designated constraints aren't met.
type GroupMetricMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupMetricMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupMetricMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupMetricMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupMetricMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupMetricMetaValidationError) ErrorName() string { return "GroupMetricMetaValidationError" }

// Error satisfies the builtin error interface
func (e GroupMetricMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroupMetricMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupMetricMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupMetricMetaValidationError{}

// Validate checks the field values on MetricMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetricMetaMultiError, or
// nil if none found.
func (m *MetricMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricMetaValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricMetaValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricMetaValidationError{
				field:  "Name",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	{
		sorted_keys := make([]string, len(m.GetTags()))
		i := 0
		for key := range m.GetTags() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTags()[key]
			_ = val

			// no validation rules for Tags[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MetricMetaValidationError{
							field:  fmt.Sprintf("Tags[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MetricMetaValidationError{
							field:  fmt.Sprintf("Tags[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MetricMetaValidationError{
						field:  fmt.Sprintf("Tags[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetFields()))
		i := 0
		for key := range m.GetFields() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFields()[key]
			_ = val

			// no validation rules for Fields[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MetricMetaValidationError{
							field:  fmt.Sprintf("Fields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MetricMetaValidationError{
							field:  fmt.Sprintf("Fields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MetricMetaValidationError{
						field:  fmt.Sprintf("Fields[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return MetricMetaMultiError(errors)
	}

	return nil
}

// MetricMetaMultiError is an error wrapping multiple validation errors
// returned by MetricMeta.ValidateAll() if the designated constraints aren't met.
type MetricMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricMetaMultiError) AllErrors() []error { return m }

// MetricMetaValidationError is the validation error returned by
// MetricMeta.Validate if the designated constraints aren't met.
type MetricMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricMetaValidationError) ErrorName() string { return "MetricMetaValidationError" }

// Error satisfies the builtin error interface
func (e MetricMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricMetaValidationError{}

// Validate checks the field values on NameDefine with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NameDefine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NameDefine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NameDefineMultiError, or
// nil if none found.
func (m *NameDefine) ValidateAll() error {
	return m.validate(true)
}

func (m *NameDefine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Name

	if len(errors) > 0 {
		return NameDefineMultiError(errors)
	}

	return nil
}

// NameDefineMultiError is an error wrapping multiple validation errors
// returned by NameDefine.ValidateAll() if the designated constraints aren't met.
type NameDefineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NameDefineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NameDefineMultiError) AllErrors() []error { return m }

// NameDefineValidationError is the validation error returned by
// NameDefine.Validate if the designated constraints aren't met.
type NameDefineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NameDefineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NameDefineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NameDefineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NameDefineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NameDefineValidationError) ErrorName() string { return "NameDefineValidationError" }

// Error satisfies the builtin error interface
func (e NameDefineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNameDefine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NameDefineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NameDefineValidationError{}

// Validate checks the field values on TagDefine with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TagDefine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TagDefine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TagDefineMultiError, or nil
// if none found.
func (m *TagDefine) ValidateAll() error {
	return m.validate(true)
}

func (m *TagDefine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Name

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TagDefineValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TagDefineValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TagDefineValidationError{
					field:  fmt.Sprintf("Values[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TagDefineMultiError(errors)
	}

	return nil
}

// TagDefineMultiError is an error wrapping multiple validation errors returned
// by TagDefine.ValidateAll() if the designated constraints aren't met.
type TagDefineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagDefineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagDefineMultiError) AllErrors() []error { return m }

// TagDefineValidationError is the validation error returned by
// TagDefine.Validate if the designated constraints aren't met.
type TagDefineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagDefineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagDefineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagDefineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagDefineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagDefineValidationError) ErrorName() string { return "TagDefineValidationError" }

// Error satisfies the builtin error interface
func (e TagDefineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTagDefine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagDefineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagDefineValidationError{}

// Validate checks the field values on FieldDefine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FieldDefine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldDefine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FieldDefineMultiError, or
// nil if none found.
func (m *FieldDefine) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldDefine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Unit

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldDefineValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldDefineValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldDefineValidationError{
					field:  fmt.Sprintf("Values[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FieldDefineMultiError(errors)
	}

	return nil
}

// FieldDefineMultiError is an error wrapping multiple validation errors
// returned by FieldDefine.ValidateAll() if the designated constraints aren't met.
type FieldDefineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldDefineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldDefineMultiError) AllErrors() []error { return m }

// FieldDefineValidationError is the validation error returned by
// FieldDefine.Validate if the designated constraints aren't met.
type FieldDefineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldDefineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldDefineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldDefineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldDefineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldDefineValidationError) ErrorName() string { return "FieldDefineValidationError" }

// Error satisfies the builtin error interface
func (e FieldDefineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldDefine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldDefineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldDefineValidationError{}

// Validate checks the field values on ValueDefine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ValueDefine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValueDefine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ValueDefineMultiError, or
// nil if none found.
func (m *ValueDefine) ValidateAll() error {
	return m.validate(true)
}

func (m *ValueDefine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValueDefineValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValueDefineValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValueDefineValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ValueDefineMultiError(errors)
	}

	return nil
}

// ValueDefineMultiError is an error wrapping multiple validation errors
// returned by ValueDefine.ValidateAll() if the designated constraints aren't met.
type ValueDefineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValueDefineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValueDefineMultiError) AllErrors() []error { return m }

// ValueDefineValidationError is the validation error returned by
// ValueDefine.Validate if the designated constraints aren't met.
type ValueDefineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValueDefineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValueDefineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValueDefineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValueDefineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValueDefineValidationError) ErrorName() string { return "ValueDefineValidationError" }

// Error satisfies the builtin error interface
func (e ValueDefineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValueDefine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValueDefineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValueDefineValidationError{}

// Validate checks the field values on Group with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Group) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Group with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GroupMultiError, or nil if none found.
func (m *Group) ValidateAll() error {
	return m.validate(true)
}

func (m *Group) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Order

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GroupValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GroupValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GroupValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GroupMultiError(errors)
	}

	return nil
}

// GroupMultiError is an error wrapping multiple validation errors returned by
// Group.ValidateAll() if the designated constraints aren't met.
type GroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GroupMultiError) AllErrors() []error { return m }

// GroupValidationError is the validation error returned by Group.Validate if
// the designated constraints aren't met.
type GroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GroupValidationError) ErrorName() string { return "GroupValidationError" }

// Error satisfies the builtin error interface
func (e GroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GroupValidationError{}

// Validate checks the field values on MetaMode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetaMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetaMode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetaModeMultiError, or nil
// if none found.
func (m *MetaMode) ValidateAll() error {
	return m.validate(true)
}

func (m *MetaMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetTypes()))
		i := 0
		for key := range m.GetTypes() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTypes()[key]
			_ = val

			// no validation rules for Types[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MetaModeValidationError{
							field:  fmt.Sprintf("Types[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MetaModeValidationError{
							field:  fmt.Sprintf("Types[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MetaModeValidationError{
						field:  fmt.Sprintf("Types[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetaModeValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetaModeValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetaModeValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetaModeMultiError(errors)
	}

	return nil
}

// MetaModeMultiError is an error wrapping multiple validation errors returned
// by MetaMode.ValidateAll() if the designated constraints aren't met.
type MetaModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetaModeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetaModeMultiError) AllErrors() []error { return m }

// MetaModeValidationError is the validation error returned by
// MetaMode.Validate if the designated constraints aren't met.
type MetaModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetaModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetaModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetaModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetaModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetaModeValidationError) ErrorName() string { return "MetaModeValidationError" }

// Error satisfies the builtin error interface
func (e MetaModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetaMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetaModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetaModeValidationError{}

// Validate checks the field values on TypeDefine with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TypeDefine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TypeDefine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TypeDefineMultiError, or
// nil if none found.
func (m *TypeDefine) ValidateAll() error {
	return m.validate(true)
}

func (m *TypeDefine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAggregations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TypeDefineValidationError{
						field:  fmt.Sprintf("Aggregations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TypeDefineValidationError{
						field:  fmt.Sprintf("Aggregations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TypeDefineValidationError{
					field:  fmt.Sprintf("Aggregations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOperations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TypeDefineValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TypeDefineValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TypeDefineValidationError{
					field:  fmt.Sprintf("Operations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TypeDefineValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TypeDefineValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TypeDefineValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TypeDefineMultiError(errors)
	}

	return nil
}

// TypeDefineMultiError is an error wrapping multiple validation errors
// returned by TypeDefine.ValidateAll() if the designated constraints aren't met.
type TypeDefineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TypeDefineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TypeDefineMultiError) AllErrors() []error { return m }

// TypeDefineValidationError is the validation error returned by
// TypeDefine.Validate if the designated constraints aren't met.
type TypeDefineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TypeDefineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TypeDefineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TypeDefineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TypeDefineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TypeDefineValidationError) ErrorName() string { return "TypeDefineValidationError" }

// Error satisfies the builtin error interface
func (e TypeDefineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTypeDefine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TypeDefineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TypeDefineValidationError{}

// Validate checks the field values on Aggregation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Aggregation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Aggregation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AggregationMultiError, or
// nil if none found.
func (m *Aggregation) ValidateAll() error {
	return m.validate(true)
}

func (m *Aggregation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Aggregation

	// no validation rules for Name

	// no validation rules for ResultType

	if len(errors) > 0 {
		return AggregationMultiError(errors)
	}

	return nil
}

// AggregationMultiError is an error wrapping multiple validation errors
// returned by Aggregation.ValidateAll() if the designated constraints aren't met.
type AggregationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AggregationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AggregationMultiError) AllErrors() []error { return m }

// AggregationValidationError is the validation error returned by
// Aggregation.Validate if the designated constraints aren't met.
type AggregationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AggregationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AggregationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AggregationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AggregationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AggregationValidationError) ErrorName() string { return "AggregationValidationError" }

// Error satisfies the builtin error interface
func (e AggregationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAggregation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AggregationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AggregationValidationError{}

// Validate checks the field values on Operation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Operation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Operation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationMultiError, or nil
// if none found.
func (m *Operation) ValidateAll() error {
	return m.validate(true)
}

func (m *Operation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Operation

	// no validation rules for Name

	// no validation rules for Multi

	if len(errors) > 0 {
		return OperationMultiError(errors)
	}

	return nil
}

// OperationMultiError is an error wrapping multiple validation errors returned
// by Operation.ValidateAll() if the designated constraints aren't met.
type OperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationMultiError) AllErrors() []error { return m }

// OperationValidationError is the validation error returned by
// Operation.Validate if the designated constraints aren't met.
type OperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationValidationError) ErrorName() string { return "OperationValidationError" }

// Error satisfies the builtin error interface
func (e OperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationValidationError{}

// Validate checks the field values on TagFilter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TagFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TagFilter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TagFilterMultiError, or nil
// if none found.
func (m *TagFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *TagFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Tag

	// no validation rules for Op

	// no validation rules for Value

	if len(errors) > 0 {
		return TagFilterMultiError(errors)
	}

	return nil
}

// TagFilterMultiError is an error wrapping multiple validation errors returned
// by TagFilter.ValidateAll() if the designated constraints aren't met.
type TagFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagFilterMultiError) AllErrors() []error { return m }

// TagFilterValidationError is the validation error returned by
// TagFilter.Validate if the designated constraints aren't met.
type TagFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagFilterValidationError) ErrorName() string { return "TagFilterValidationError" }

// Error satisfies the builtin error interface
func (e TagFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTagFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagFilterValidationError{}
