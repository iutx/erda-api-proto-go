// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: base.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PipelineDTO with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineDTO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineDTO with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineDTOMultiError, or
// nil if none found.
func (m *PipelineDTO) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineDTO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for Source

	// no validation rules for YmlName

	// no validation rules for Namespace

	// no validation rules for ClusterName

	// no validation rules for Status

	// no validation rules for Type

	// no validation rules for TriggerMode

	// no validation rules for Labels

	// no validation rules for YmlSource

	// no validation rules for YmlContent

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineDTOValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OrgID

	// no validation rules for OrgName

	// no validation rules for ProjectID

	// no validation rules for ProjectName

	// no validation rules for ApplicationID

	// no validation rules for ApplicationName

	// no validation rules for Branch

	// no validation rules for Commit

	if all {
		switch v := interface{}(m.GetCommitDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "CommitDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "CommitDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommitDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineDTOValidationError{
				field:  "CommitDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Progress

	// no validation rules for CostTimeSec

	if all {
		switch v := interface{}(m.GetTimeBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineDTOValidationError{
				field:  "TimeBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineDTOValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineDTOValidationError{
				field:  "TimeCreated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "TimeUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineDTOValidationError{
					field:  "TimeUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineDTOValidationError{
				field:  "TimeUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for YmlNameV1

	if m.CronID != nil {
		// no validation rules for CronID
	}

	if len(errors) > 0 {
		return PipelineDTOMultiError(errors)
	}

	return nil
}

// PipelineDTOMultiError is an error wrapping multiple validation errors
// returned by PipelineDTO.ValidateAll() if the designated constraints aren't met.
type PipelineDTOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineDTOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineDTOMultiError) AllErrors() []error { return m }

// PipelineDTOValidationError is the validation error returned by
// PipelineDTO.Validate if the designated constraints aren't met.
type PipelineDTOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineDTOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineDTOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineDTOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineDTOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineDTOValidationError) ErrorName() string { return "PipelineDTOValidationError" }

// Error satisfies the builtin error interface
func (e PipelineDTOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineDTO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineDTOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineDTOValidationError{}

// Validate checks the field values on PipelineExtra with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineExtra) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineExtra with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineExtraMultiError, or
// nil if none found.
func (m *PipelineExtra) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineExtra) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DiceWorkspace

	if all {
		switch v := interface{}(m.GetSubmitUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "SubmitUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "SubmitUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubmitUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExtraValidationError{
				field:  "SubmitUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRunUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "RunUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "RunUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRunUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExtraValidationError{
				field:  "RunUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCancelUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "CancelUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "CancelUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCancelUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExtraValidationError{
				field:  "CancelUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CronExpr

	if all {
		switch v := interface{}(m.GetCronTriggerTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "CronTriggerTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "CronTriggerTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCronTriggerTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExtraValidationError{
				field:  "CronTriggerTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetShowMessage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "ShowMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "ShowMessage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShowMessage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExtraValidationError{
				field:  "ShowMessage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsAutoRun

	if all {
		switch v := interface{}(m.GetOwnerUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "OwnerUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "OwnerUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOwnerUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExtraValidationError{
				field:  "OwnerUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PipelineYmlNameV1

	if all {
		switch v := interface{}(m.GetBreakpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "Breakpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExtraValidationError{
					field:  "Breakpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBreakpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExtraValidationError{
				field:  "Breakpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineExtraMultiError(errors)
	}

	return nil
}

// PipelineExtraMultiError is an error wrapping multiple validation errors
// returned by PipelineExtra.ValidateAll() if the designated constraints
// aren't met.
type PipelineExtraMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineExtraMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineExtraMultiError) AllErrors() []error { return m }

// PipelineExtraValidationError is the validation error returned by
// PipelineExtra.Validate if the designated constraints aren't met.
type PipelineExtraValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineExtraValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineExtraValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineExtraValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineExtraValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineExtraValidationError) ErrorName() string { return "PipelineExtraValidationError" }

// Error satisfies the builtin error interface
func (e PipelineExtraValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineExtra.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineExtraValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineExtraValidationError{}

// Validate checks the field values on PipelineGC with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineGC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineGC with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineGCMultiError, or
// nil if none found.
func (m *PipelineGC) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineGC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResourceGC()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineGCValidationError{
					field:  "ResourceGC",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineGCValidationError{
					field:  "ResourceGC",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceGC()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineGCValidationError{
				field:  "ResourceGC",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatabaseGC()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineGCValidationError{
					field:  "DatabaseGC",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineGCValidationError{
					field:  "DatabaseGC",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatabaseGC()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineGCValidationError{
				field:  "DatabaseGC",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineGCMultiError(errors)
	}

	return nil
}

// PipelineGCMultiError is an error wrapping multiple validation errors
// returned by PipelineGC.ValidateAll() if the designated constraints aren't met.
type PipelineGCMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineGCMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineGCMultiError) AllErrors() []error { return m }

// PipelineGCValidationError is the validation error returned by
// PipelineGC.Validate if the designated constraints aren't met.
type PipelineGCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineGCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineGCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineGCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineGCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineGCValidationError) ErrorName() string { return "PipelineGCValidationError" }

// Error satisfies the builtin error interface
func (e PipelineGCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineGC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineGCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineGCValidationError{}

// Validate checks the field values on PipelineResourceGC with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineResourceGC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineResourceGC with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineResourceGCMultiError, or nil if none found.
func (m *PipelineResourceGC) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineResourceGC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.SuccessTTLSecond != nil {
		// no validation rules for SuccessTTLSecond
	}

	if m.FailedTTLSecond != nil {
		// no validation rules for FailedTTLSecond
	}

	if len(errors) > 0 {
		return PipelineResourceGCMultiError(errors)
	}

	return nil
}

// PipelineResourceGCMultiError is an error wrapping multiple validation errors
// returned by PipelineResourceGC.ValidateAll() if the designated constraints
// aren't met.
type PipelineResourceGCMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineResourceGCMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineResourceGCMultiError) AllErrors() []error { return m }

// PipelineResourceGCValidationError is the validation error returned by
// PipelineResourceGC.Validate if the designated constraints aren't met.
type PipelineResourceGCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineResourceGCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineResourceGCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineResourceGCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineResourceGCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineResourceGCValidationError) ErrorName() string {
	return "PipelineResourceGCValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineResourceGCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineResourceGC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineResourceGCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineResourceGCValidationError{}

// Validate checks the field values on PipelineDatabaseGC with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineDatabaseGC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineDatabaseGC with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineDatabaseGCMultiError, or nil if none found.
func (m *PipelineDatabaseGC) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineDatabaseGC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAnalyzed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineDatabaseGCValidationError{
					field:  "Analyzed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineDatabaseGCValidationError{
					field:  "Analyzed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnalyzed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineDatabaseGCValidationError{
				field:  "Analyzed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinished()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineDatabaseGCValidationError{
					field:  "Finished",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineDatabaseGCValidationError{
					field:  "Finished",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinished()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineDatabaseGCValidationError{
				field:  "Finished",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineDatabaseGCMultiError(errors)
	}

	return nil
}

// PipelineDatabaseGCMultiError is an error wrapping multiple validation errors
// returned by PipelineDatabaseGC.ValidateAll() if the designated constraints
// aren't met.
type PipelineDatabaseGCMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineDatabaseGCMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineDatabaseGCMultiError) AllErrors() []error { return m }

// PipelineDatabaseGCValidationError is the validation error returned by
// PipelineDatabaseGC.Validate if the designated constraints aren't met.
type PipelineDatabaseGCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineDatabaseGCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineDatabaseGCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineDatabaseGCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineDatabaseGCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineDatabaseGCValidationError) ErrorName() string {
	return "PipelineDatabaseGCValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineDatabaseGCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineDatabaseGC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineDatabaseGCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineDatabaseGCValidationError{}

// Validate checks the field values on PipelineDBGCItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineDBGCItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineDBGCItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineDBGCItemMultiError, or nil if none found.
func (m *PipelineDBGCItem) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineDBGCItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.NeedArchive != nil {
		// no validation rules for NeedArchive
	}

	if m.TTLSecond != nil {
		// no validation rules for TTLSecond
	}

	if len(errors) > 0 {
		return PipelineDBGCItemMultiError(errors)
	}

	return nil
}

// PipelineDBGCItemMultiError is an error wrapping multiple validation errors
// returned by PipelineDBGCItem.ValidateAll() if the designated constraints
// aren't met.
type PipelineDBGCItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineDBGCItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineDBGCItemMultiError) AllErrors() []error { return m }

// PipelineDBGCItemValidationError is the validation error returned by
// PipelineDBGCItem.Validate if the designated constraints aren't met.
type PipelineDBGCItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineDBGCItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineDBGCItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineDBGCItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineDBGCItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineDBGCItemValidationError) ErrorName() string { return "PipelineDBGCItemValidationError" }

// Error satisfies the builtin error interface
func (e PipelineDBGCItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineDBGCItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineDBGCItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineDBGCItemValidationError{}

// Validate checks the field values on PipelineRunParam with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineRunParam) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineRunParam with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineRunParamMultiError, or nil if none found.
func (m *PipelineRunParam) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineRunParam) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineRunParamValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineRunParamValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineRunParamValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineRunParamMultiError(errors)
	}

	return nil
}

// PipelineRunParamMultiError is an error wrapping multiple validation errors
// returned by PipelineRunParam.ValidateAll() if the designated constraints
// aren't met.
type PipelineRunParamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineRunParamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineRunParamMultiError) AllErrors() []error { return m }

// PipelineRunParamValidationError is the validation error returned by
// PipelineRunParam.Validate if the designated constraints aren't met.
type PipelineRunParamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineRunParamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineRunParamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineRunParamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineRunParamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineRunParamValidationError) ErrorName() string { return "PipelineRunParamValidationError" }

// Error satisfies the builtin error interface
func (e PipelineRunParamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineRunParam.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineRunParamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineRunParamValidationError{}

// Validate checks the field values on PipelineRunParamWithValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineRunParamWithValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineRunParamWithValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineRunParamWithValueMultiError, or nil if none found.
func (m *PipelineRunParamWithValue) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineRunParamWithValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineRunParamWithValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineRunParamWithValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineRunParamWithValueValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTrueValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineRunParamWithValueValidationError{
					field:  "TrueValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineRunParamWithValueValidationError{
					field:  "TrueValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrueValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineRunParamWithValueValidationError{
				field:  "TrueValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineRunParamWithValueMultiError(errors)
	}

	return nil
}

// PipelineRunParamWithValueMultiError is an error wrapping multiple validation
// errors returned by PipelineRunParamWithValue.ValidateAll() if the
// designated constraints aren't met.
type PipelineRunParamWithValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineRunParamWithValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineRunParamWithValueMultiError) AllErrors() []error { return m }

// PipelineRunParamWithValueValidationError is the validation error returned by
// PipelineRunParamWithValue.Validate if the designated constraints aren't met.
type PipelineRunParamWithValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineRunParamWithValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineRunParamWithValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineRunParamWithValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineRunParamWithValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineRunParamWithValueValidationError) ErrorName() string {
	return "PipelineRunParamWithValueValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineRunParamWithValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineRunParamWithValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineRunParamWithValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineRunParamWithValueValidationError{}

// Validate checks the field values on PipelineUser with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineUser with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineUserMultiError, or
// nil if none found.
func (m *PipelineUser) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetID()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineUserValidationError{
					field:  "ID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineUserValidationError{
					field:  "ID",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetID()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineUserValidationError{
				field:  "ID",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Avatar

	if len(errors) > 0 {
		return PipelineUserMultiError(errors)
	}

	return nil
}

// PipelineUserMultiError is an error wrapping multiple validation errors
// returned by PipelineUser.ValidateAll() if the designated constraints aren't met.
type PipelineUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineUserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineUserMultiError) AllErrors() []error { return m }

// PipelineUserValidationError is the validation error returned by
// PipelineUser.Validate if the designated constraints aren't met.
type PipelineUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineUserValidationError) ErrorName() string { return "PipelineUserValidationError" }

// Error satisfies the builtin error interface
func (e PipelineUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineUserValidationError{}

// Validate checks the field values on ShowMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ShowMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShowMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ShowMessageMultiError, or
// nil if none found.
func (m *ShowMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *ShowMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	// no validation rules for AbortRun

	if len(errors) > 0 {
		return ShowMessageMultiError(errors)
	}

	return nil
}

// ShowMessageMultiError is an error wrapping multiple validation errors
// returned by ShowMessage.ValidateAll() if the designated constraints aren't met.
type ShowMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShowMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShowMessageMultiError) AllErrors() []error { return m }

// ShowMessageValidationError is the validation error returned by
// ShowMessage.Validate if the designated constraints aren't met.
type ShowMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShowMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShowMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShowMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShowMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShowMessageValidationError) ErrorName() string { return "ShowMessageValidationError" }

// Error satisfies the builtin error interface
func (e ShowMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShowMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShowMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShowMessageValidationError{}

// Validate checks the field values on StorageConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StorageConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorageConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StorageConfigMultiError, or
// nil if none found.
func (m *StorageConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *StorageConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EnableNFS

	// no validation rules for EnableLocal

	if len(errors) > 0 {
		return StorageConfigMultiError(errors)
	}

	return nil
}

// StorageConfigMultiError is an error wrapping multiple validation errors
// returned by StorageConfig.ValidateAll() if the designated constraints
// aren't met.
type StorageConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorageConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorageConfigMultiError) AllErrors() []error { return m }

// StorageConfigValidationError is the validation error returned by
// StorageConfig.Validate if the designated constraints aren't met.
type StorageConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorageConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorageConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorageConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorageConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorageConfigValidationError) ErrorName() string { return "StorageConfigValidationError" }

// Error satisfies the builtin error interface
func (e StorageConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorageConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorageConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorageConfigValidationError{}

// Validate checks the field values on PipelineButton with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineButton) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineButton with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineButtonMultiError,
// or nil if none found.
func (m *PipelineButton) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineButton) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CanManualRun

	// no validation rules for CanCancel

	// no validation rules for CanForceCancel

	// no validation rules for CanRerun

	// no validation rules for CanRerunFailed

	// no validation rules for CanStartCron

	// no validation rules for CanStopCron

	// no validation rules for CanPause

	// no validation rules for CanUnpause

	// no validation rules for CanDelete

	if len(errors) > 0 {
		return PipelineButtonMultiError(errors)
	}

	return nil
}

// PipelineButtonMultiError is an error wrapping multiple validation errors
// returned by PipelineButton.ValidateAll() if the designated constraints
// aren't met.
type PipelineButtonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineButtonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineButtonMultiError) AllErrors() []error { return m }

// PipelineButtonValidationError is the validation error returned by
// PipelineButton.Validate if the designated constraints aren't met.
type PipelineButtonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineButtonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineButtonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineButtonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineButtonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineButtonValidationError) ErrorName() string { return "PipelineButtonValidationError" }

// Error satisfies the builtin error interface
func (e PipelineButtonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineButton.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineButtonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineButtonValidationError{}

// Validate checks the field values on PipelineExecuteRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineExecuteRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineExecuteRecord with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineExecuteRecordMultiError, or nil if none found.
func (m *PipelineExecuteRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineExecuteRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PipelineID

	// no validation rules for Status

	// no validation rules for TriggerMode

	if all {
		switch v := interface{}(m.GetTimeCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExecuteRecordValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExecuteRecordValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExecuteRecordValidationError{
				field:  "TimeCreated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExecuteRecordValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExecuteRecordValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExecuteRecordValidationError{
				field:  "TimeBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineExecuteRecordValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineExecuteRecordValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineExecuteRecordValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineExecuteRecordMultiError(errors)
	}

	return nil
}

// PipelineExecuteRecordMultiError is an error wrapping multiple validation
// errors returned by PipelineExecuteRecord.ValidateAll() if the designated
// constraints aren't met.
type PipelineExecuteRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineExecuteRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineExecuteRecordMultiError) AllErrors() []error { return m }

// PipelineExecuteRecordValidationError is the validation error returned by
// PipelineExecuteRecord.Validate if the designated constraints aren't met.
type PipelineExecuteRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineExecuteRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineExecuteRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineExecuteRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineExecuteRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineExecuteRecordValidationError) ErrorName() string {
	return "PipelineExecuteRecordValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineExecuteRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineExecuteRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineExecuteRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineExecuteRecordValidationError{}

// Validate checks the field values on Breakpoint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Breakpoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Breakpoint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BreakpointMultiError, or
// nil if none found.
func (m *Breakpoint) ValidateAll() error {
	return m.validate(true)
}

func (m *Breakpoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BreakpointValidationError{
					field:  "On",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BreakpointValidationError{
					field:  "On",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BreakpointValidationError{
				field:  "On",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Timeout != nil {

		if all {
			switch v := interface{}(m.GetTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BreakpointValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BreakpointValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BreakpointValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BreakpointMultiError(errors)
	}

	return nil
}

// BreakpointMultiError is an error wrapping multiple validation errors
// returned by Breakpoint.ValidateAll() if the designated constraints aren't met.
type BreakpointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BreakpointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BreakpointMultiError) AllErrors() []error { return m }

// BreakpointValidationError is the validation error returned by
// Breakpoint.Validate if the designated constraints aren't met.
type BreakpointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BreakpointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BreakpointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BreakpointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BreakpointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BreakpointValidationError) ErrorName() string { return "BreakpointValidationError" }

// Error satisfies the builtin error interface
func (e BreakpointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBreakpoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BreakpointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BreakpointValidationError{}

// Validate checks the field values on BreakpointOn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BreakpointOn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BreakpointOn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BreakpointOnMultiError, or
// nil if none found.
func (m *BreakpointOn) ValidateAll() error {
	return m.validate(true)
}

func (m *BreakpointOn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Failure

	if len(errors) > 0 {
		return BreakpointOnMultiError(errors)
	}

	return nil
}

// BreakpointOnMultiError is an error wrapping multiple validation errors
// returned by BreakpointOn.ValidateAll() if the designated constraints aren't met.
type BreakpointOnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BreakpointOnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BreakpointOnMultiError) AllErrors() []error { return m }

// BreakpointOnValidationError is the validation error returned by
// BreakpointOn.Validate if the designated constraints aren't met.
type BreakpointOnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BreakpointOnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BreakpointOnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BreakpointOnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BreakpointOnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BreakpointOnValidationError) ErrorName() string { return "BreakpointOnValidationError" }

// Error satisfies the builtin error interface
func (e BreakpointOnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBreakpointOn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BreakpointOnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BreakpointOnValidationError{}

// Validate checks the field values on PipelineEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineEventMultiError, or
// nil if none found.
func (m *PipelineEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reason

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineEventValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineEventValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineEventValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirstTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineEventValidationError{
					field:  "FirstTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineEventValidationError{
					field:  "FirstTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineEventValidationError{
				field:  "FirstTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineEventValidationError{
					field:  "LastTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineEventValidationError{
					field:  "LastTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineEventValidationError{
				field:  "LastTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Count

	// no validation rules for Type

	if len(errors) > 0 {
		return PipelineEventMultiError(errors)
	}

	return nil
}

// PipelineEventMultiError is an error wrapping multiple validation errors
// returned by PipelineEvent.ValidateAll() if the designated constraints
// aren't met.
type PipelineEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineEventMultiError) AllErrors() []error { return m }

// PipelineEventValidationError is the validation error returned by
// PipelineEvent.Validate if the designated constraints aren't met.
type PipelineEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineEventValidationError) ErrorName() string { return "PipelineEventValidationError" }

// Error satisfies the builtin error interface
func (e PipelineEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineEventValidationError{}

// Validate checks the field values on PipelineEventSource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineEventSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineEventSource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineEventSourceMultiError, or nil if none found.
func (m *PipelineEventSource) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineEventSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Component

	// no validation rules for Host

	if len(errors) > 0 {
		return PipelineEventSourceMultiError(errors)
	}

	return nil
}

// PipelineEventSourceMultiError is an error wrapping multiple validation
// errors returned by PipelineEventSource.ValidateAll() if the designated
// constraints aren't met.
type PipelineEventSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineEventSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineEventSourceMultiError) AllErrors() []error { return m }

// PipelineEventSourceValidationError is the validation error returned by
// PipelineEventSource.Validate if the designated constraints aren't met.
type PipelineEventSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineEventSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineEventSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineEventSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineEventSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineEventSourceValidationError) ErrorName() string {
	return "PipelineEventSourceValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineEventSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineEventSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineEventSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineEventSourceValidationError{}

// Validate checks the field values on ErrorResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ErrorResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ErrorResponseMultiError, or
// nil if none found.
func (m *ErrorResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Msg

	if all {
		switch v := interface{}(m.GetCtx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErrorResponseValidationError{
					field:  "Ctx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErrorResponseValidationError{
					field:  "Ctx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCtx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErrorResponseValidationError{
				field:  "Ctx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ErrorResponseMultiError(errors)
	}

	return nil
}

// ErrorResponseMultiError is an error wrapping multiple validation errors
// returned by ErrorResponse.ValidateAll() if the designated constraints
// aren't met.
type ErrorResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorResponseMultiError) AllErrors() []error { return m }

// ErrorResponseValidationError is the validation error returned by
// ErrorResponse.Validate if the designated constraints aren't met.
type ErrorResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorResponseValidationError) ErrorName() string { return "ErrorResponseValidationError" }

// Error satisfies the builtin error interface
func (e ErrorResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorResponseValidationError{}

// Validate checks the field values on PipelineOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineOutput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineOutputMultiError,
// or nil if none found.
func (m *PipelineOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Desc

	// no validation rules for Ref

	if len(errors) > 0 {
		return PipelineOutputMultiError(errors)
	}

	return nil
}

// PipelineOutputMultiError is an error wrapping multiple validation errors
// returned by PipelineOutput.ValidateAll() if the designated constraints
// aren't met.
type PipelineOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineOutputMultiError) AllErrors() []error { return m }

// PipelineOutputValidationError is the validation error returned by
// PipelineOutput.Validate if the designated constraints aren't met.
type PipelineOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineOutputValidationError) ErrorName() string { return "PipelineOutputValidationError" }

// Error satisfies the builtin error interface
func (e PipelineOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineOutputValidationError{}

// Validate checks the field values on PipelineOutputWithValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineOutputWithValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineOutputWithValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineOutputWithValueMultiError, or nil if none found.
func (m *PipelineOutputWithValue) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineOutputWithValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Desc

	// no validation rules for Ref

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineOutputWithValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineOutputWithValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineOutputWithValueValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineOutputWithValueMultiError(errors)
	}

	return nil
}

// PipelineOutputWithValueMultiError is an error wrapping multiple validation
// errors returned by PipelineOutputWithValue.ValidateAll() if the designated
// constraints aren't met.
type PipelineOutputWithValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineOutputWithValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineOutputWithValueMultiError) AllErrors() []error { return m }

// PipelineOutputWithValueValidationError is the validation error returned by
// PipelineOutputWithValue.Validate if the designated constraints aren't met.
type PipelineOutputWithValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineOutputWithValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineOutputWithValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineOutputWithValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineOutputWithValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineOutputWithValueValidationError) ErrorName() string {
	return "PipelineOutputWithValueValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineOutputWithValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineOutputWithValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineOutputWithValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineOutputWithValueValidationError{}

// Validate checks the field values on PipelineParam with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineParam) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineParam with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineParamMultiError, or
// nil if none found.
func (m *PipelineParam) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineParam) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Required

	if all {
		switch v := interface{}(m.GetDefault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineParamValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineParamValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineParamValidationError{
				field:  "Default",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Desc

	// no validation rules for Type

	if len(errors) > 0 {
		return PipelineParamMultiError(errors)
	}

	return nil
}

// PipelineParamMultiError is an error wrapping multiple validation errors
// returned by PipelineParam.ValidateAll() if the designated constraints
// aren't met.
type PipelineParamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineParamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineParamMultiError) AllErrors() []error { return m }

// PipelineParamValidationError is the validation error returned by
// PipelineParam.Validate if the designated constraints aren't met.
type PipelineParamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineParamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineParamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineParamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineParamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineParamValidationError) ErrorName() string { return "PipelineParamValidationError" }

// Error satisfies the builtin error interface
func (e PipelineParamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineParam.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineParamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineParamValidationError{}

// Validate checks the field values on PipelineParamWithValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineParamWithValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineParamWithValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineParamWithValueMultiError, or nil if none found.
func (m *PipelineParamWithValue) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineParamWithValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Required

	if all {
		switch v := interface{}(m.GetDefault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineParamWithValueValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineParamWithValueValidationError{
					field:  "Default",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineParamWithValueValidationError{
				field:  "Default",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Desc

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineParamWithValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineParamWithValueValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineParamWithValueValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineParamWithValueMultiError(errors)
	}

	return nil
}

// PipelineParamWithValueMultiError is an error wrapping multiple validation
// errors returned by PipelineParamWithValue.ValidateAll() if the designated
// constraints aren't met.
type PipelineParamWithValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineParamWithValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineParamWithValueMultiError) AllErrors() []error { return m }

// PipelineParamWithValueValidationError is the validation error returned by
// PipelineParamWithValue.Validate if the designated constraints aren't met.
type PipelineParamWithValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineParamWithValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineParamWithValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineParamWithValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineParamWithValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineParamWithValueValidationError) ErrorName() string {
	return "PipelineParamWithValueValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineParamWithValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineParamWithValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineParamWithValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineParamWithValueValidationError{}

// Validate checks the field values on PipelineYml with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineYml) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineYml with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineYmlMultiError, or
// nil if none found.
func (m *PipelineYml) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineYml) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	// no validation rules for Envs

	// no validation rules for Cron

	if all {
		switch v := interface{}(m.GetCronCompensator()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineYmlValidationError{
					field:  "CronCompensator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineYmlValidationError{
					field:  "CronCompensator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCronCompensator()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineYmlValidationError{
				field:  "CronCompensator",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStages()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineYmlValidationError{
					field:  "Stages",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineYmlValidationError{
					field:  "Stages",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStages()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineYmlValidationError{
				field:  "Stages",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFlatActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("FlatActions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("FlatActions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineYmlValidationError{
					field:  fmt.Sprintf("FlatActions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParams() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("Params[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("Params[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineYmlValidationError{
					field:  fmt.Sprintf("Params[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineYmlValidationError{
					field:  fmt.Sprintf("Outputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NeedUpgrade

	// no validation rules for YmlContent

	if all {
		switch v := interface{}(m.GetOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineYmlValidationError{
					field:  "On",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineYmlValidationError{
					field:  "On",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineYmlValidationError{
				field:  "On",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLifecycle() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("Lifecycle[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("Lifecycle[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineYmlValidationError{
					field:  fmt.Sprintf("Lifecycle[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTriggers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("Triggers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineYmlValidationError{
						field:  fmt.Sprintf("Triggers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineYmlValidationError{
					field:  fmt.Sprintf("Triggers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PipelineYmlMultiError(errors)
	}

	return nil
}

// PipelineYmlMultiError is an error wrapping multiple validation errors
// returned by PipelineYml.ValidateAll() if the designated constraints aren't met.
type PipelineYmlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineYmlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineYmlMultiError) AllErrors() []error { return m }

// PipelineYmlValidationError is the validation error returned by
// PipelineYml.Validate if the designated constraints aren't met.
type PipelineYmlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineYmlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineYmlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineYmlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineYmlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineYmlValidationError) ErrorName() string { return "PipelineYmlValidationError" }

// Error satisfies the builtin error interface
func (e PipelineYmlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineYml.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineYmlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineYmlValidationError{}

// Validate checks the field values on PipelineTrigger with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineTrigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTrigger with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTriggerMultiError, or nil if none found.
func (m *PipelineTrigger) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTrigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for On

	// no validation rules for Filter

	if len(errors) > 0 {
		return PipelineTriggerMultiError(errors)
	}

	return nil
}

// PipelineTriggerMultiError is an error wrapping multiple validation errors
// returned by PipelineTrigger.ValidateAll() if the designated constraints
// aren't met.
type PipelineTriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTriggerMultiError) AllErrors() []error { return m }

// PipelineTriggerValidationError is the validation error returned by
// PipelineTrigger.Validate if the designated constraints aren't met.
type PipelineTriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTriggerValidationError) ErrorName() string { return "PipelineTriggerValidationError" }

// Error satisfies the builtin error interface
func (e PipelineTriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTriggerValidationError{}

// Validate checks the field values on TriggerConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TriggerConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TriggerConfigMultiError, or
// nil if none found.
func (m *TriggerConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPush()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TriggerConfigValidationError{
					field:  "Push",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TriggerConfigValidationError{
					field:  "Push",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPush()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TriggerConfigValidationError{
				field:  "Push",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMerge()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TriggerConfigValidationError{
					field:  "Merge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TriggerConfigValidationError{
					field:  "Merge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMerge()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TriggerConfigValidationError{
				field:  "Merge",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TriggerConfigMultiError(errors)
	}

	return nil
}

// TriggerConfigMultiError is an error wrapping multiple validation errors
// returned by TriggerConfig.ValidateAll() if the designated constraints
// aren't met.
type TriggerConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerConfigMultiError) AllErrors() []error { return m }

// TriggerConfigValidationError is the validation error returned by
// TriggerConfig.Validate if the designated constraints aren't met.
type TriggerConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerConfigValidationError) ErrorName() string { return "TriggerConfigValidationError" }

// Error satisfies the builtin error interface
func (e TriggerConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerConfigValidationError{}

// Validate checks the field values on PushTrigger with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PushTrigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushTrigger with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PushTriggerMultiError, or
// nil if none found.
func (m *PushTrigger) ValidateAll() error {
	return m.validate(true)
}

func (m *PushTrigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PushTriggerMultiError(errors)
	}

	return nil
}

// PushTriggerMultiError is an error wrapping multiple validation errors
// returned by PushTrigger.ValidateAll() if the designated constraints aren't met.
type PushTriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushTriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushTriggerMultiError) AllErrors() []error { return m }

// PushTriggerValidationError is the validation error returned by
// PushTrigger.Validate if the designated constraints aren't met.
type PushTriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushTriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushTriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushTriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushTriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushTriggerValidationError) ErrorName() string { return "PushTriggerValidationError" }

// Error satisfies the builtin error interface
func (e PushTriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushTriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushTriggerValidationError{}

// Validate checks the field values on MergeTrigger with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MergeTrigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeTrigger with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MergeTriggerMultiError, or
// nil if none found.
func (m *MergeTrigger) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeTrigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MergeTriggerMultiError(errors)
	}

	return nil
}

// MergeTriggerMultiError is an error wrapping multiple validation errors
// returned by MergeTrigger.ValidateAll() if the designated constraints aren't met.
type MergeTriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeTriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeTriggerMultiError) AllErrors() []error { return m }

// MergeTriggerValidationError is the validation error returned by
// MergeTrigger.Validate if the designated constraints aren't met.
type MergeTriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeTriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeTriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeTriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeTriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeTriggerValidationError) ErrorName() string { return "MergeTriggerValidationError" }

// Error satisfies the builtin error interface
func (e MergeTriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeTriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeTriggerValidationError{}

// Validate checks the field values on NetworkHookInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NetworkHookInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NetworkHookInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NetworkHookInfoMultiError, or nil if none found.
func (m *NetworkHookInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *NetworkHookInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hook

	// no validation rules for Client

	{
		sorted_keys := make([]string, len(m.GetLabels()))
		i := 0
		for key := range m.GetLabels() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetLabels()[key]
			_ = val

			// no validation rules for Labels[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, NetworkHookInfoValidationError{
							field:  fmt.Sprintf("Labels[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, NetworkHookInfoValidationError{
							field:  fmt.Sprintf("Labels[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return NetworkHookInfoValidationError{
						field:  fmt.Sprintf("Labels[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return NetworkHookInfoMultiError(errors)
	}

	return nil
}

// NetworkHookInfoMultiError is an error wrapping multiple validation errors
// returned by NetworkHookInfo.ValidateAll() if the designated constraints
// aren't met.
type NetworkHookInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NetworkHookInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NetworkHookInfoMultiError) AllErrors() []error { return m }

// NetworkHookInfoValidationError is the validation error returned by
// NetworkHookInfo.Validate if the designated constraints aren't met.
type NetworkHookInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NetworkHookInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NetworkHookInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NetworkHookInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NetworkHookInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NetworkHookInfoValidationError) ErrorName() string { return "NetworkHookInfoValidationError" }

// Error satisfies the builtin error interface
func (e NetworkHookInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNetworkHookInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NetworkHookInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NetworkHookInfoValidationError{}

// Validate checks the field values on PipelineYmlAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineYmlAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineYmlAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineYmlActionMultiError, or nil if none found.
func (m *PipelineYmlAction) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineYmlAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Alias

	// no validation rules for Type

	// no validation rules for Description

	// no validation rules for Version

	{
		sorted_keys := make([]string, len(m.GetParams()))
		i := 0
		for key := range m.GetParams() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetParams()[key]
			_ = val

			// no validation rules for Params[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, PipelineYmlActionValidationError{
							field:  fmt.Sprintf("Params[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, PipelineYmlActionValidationError{
							field:  fmt.Sprintf("Params[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return PipelineYmlActionValidationError{
						field:  fmt.Sprintf("Params[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Image

	if all {
		switch v := interface{}(m.GetCommands()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "Commands",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "Commands",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommands()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineYmlActionValidationError{
				field:  "Commands",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Timeout

	if all {
		switch v := interface{}(m.GetResources()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "Resources",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResources()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineYmlActionValidationError{
				field:  "Resources",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DisplayName

	// no validation rules for LogoUrl

	for idx, item := range m.GetCaches() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineYmlActionValidationError{
						field:  fmt.Sprintf("Caches[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineYmlActionValidationError{
						field:  fmt.Sprintf("Caches[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineYmlActionValidationError{
					field:  fmt.Sprintf("Caches[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSnippetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "SnippetConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "SnippetConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSnippetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineYmlActionValidationError{
				field:  "SnippetConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for If

	if all {
		switch v := interface{}(m.GetLoop()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "Loop",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "Loop",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoop()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineYmlActionValidationError{
				field:  "Loop",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSnippetStages()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "SnippetStages",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineYmlActionValidationError{
					field:  "SnippetStages",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSnippetStages()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineYmlActionValidationError{
				field:  "SnippetStages",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Shell

	// no validation rules for Disable

	if len(errors) > 0 {
		return PipelineYmlActionMultiError(errors)
	}

	return nil
}

// PipelineYmlActionMultiError is an error wrapping multiple validation errors
// returned by PipelineYmlAction.ValidateAll() if the designated constraints
// aren't met.
type PipelineYmlActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineYmlActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineYmlActionMultiError) AllErrors() []error { return m }

// PipelineYmlActionValidationError is the validation error returned by
// PipelineYmlAction.Validate if the designated constraints aren't met.
type PipelineYmlActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineYmlActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineYmlActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineYmlActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineYmlActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineYmlActionValidationError) ErrorName() string {
	return "PipelineYmlActionValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineYmlActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineYmlAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineYmlActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineYmlActionValidationError{}

// Validate checks the field values on Resources with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resources) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resources with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourcesMultiError, or nil
// if none found.
func (m *Resources) ValidateAll() error {
	return m.validate(true)
}

func (m *Resources) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cpu

	// no validation rules for Mem

	// no validation rules for Disk

	if len(errors) > 0 {
		return ResourcesMultiError(errors)
	}

	return nil
}

// ResourcesMultiError is an error wrapping multiple validation errors returned
// by Resources.ValidateAll() if the designated constraints aren't met.
type ResourcesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourcesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourcesMultiError) AllErrors() []error { return m }

// ResourcesValidationError is the validation error returned by
// Resources.Validate if the designated constraints aren't met.
type ResourcesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourcesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourcesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourcesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourcesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourcesValidationError) ErrorName() string { return "ResourcesValidationError" }

// Error satisfies the builtin error interface
func (e ResourcesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResources.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourcesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourcesValidationError{}

// Validate checks the field values on CronCompensator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CronCompensator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CronCompensator with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CronCompensatorMultiError, or nil if none found.
func (m *CronCompensator) ValidateAll() error {
	return m.validate(true)
}

func (m *CronCompensator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enable

	// no validation rules for LatestFirst

	// no validation rules for StopIfLatterExecuted

	if len(errors) > 0 {
		return CronCompensatorMultiError(errors)
	}

	return nil
}

// CronCompensatorMultiError is an error wrapping multiple validation errors
// returned by CronCompensator.ValidateAll() if the designated constraints
// aren't met.
type CronCompensatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CronCompensatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CronCompensatorMultiError) AllErrors() []error { return m }

// CronCompensatorValidationError is the validation error returned by
// CronCompensator.Validate if the designated constraints aren't met.
type CronCompensatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CronCompensatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CronCompensatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CronCompensatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CronCompensatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CronCompensatorValidationError) ErrorName() string { return "CronCompensatorValidationError" }

// Error satisfies the builtin error interface
func (e CronCompensatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCronCompensator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CronCompensatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CronCompensatorValidationError{}

// Validate checks the field values on ActionCache with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionCache) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionCache with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionCacheMultiError, or
// nil if none found.
func (m *ActionCache) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionCache) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Path

	if len(errors) > 0 {
		return ActionCacheMultiError(errors)
	}

	return nil
}

// ActionCacheMultiError is an error wrapping multiple validation errors
// returned by ActionCache.ValidateAll() if the designated constraints aren't met.
type ActionCacheMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionCacheMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionCacheMultiError) AllErrors() []error { return m }

// ActionCacheValidationError is the validation error returned by
// ActionCache.Validate if the designated constraints aren't met.
type ActionCacheValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionCacheValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionCacheValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionCacheValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionCacheValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionCacheValidationError) ErrorName() string { return "ActionCacheValidationError" }

// Error satisfies the builtin error interface
func (e ActionCacheValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionCache.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionCacheValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionCacheValidationError{}

// Validate checks the field values on TaskLoop with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskLoop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskLoop with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaskLoopMultiError, or nil
// if none found.
func (m *TaskLoop) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskLoop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Break

	if all {
		switch v := interface{}(m.GetStrategy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskLoopValidationError{
					field:  "Strategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskLoopValidationError{
					field:  "Strategy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStrategy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskLoopValidationError{
				field:  "Strategy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaskLoopMultiError(errors)
	}

	return nil
}

// TaskLoopMultiError is an error wrapping multiple validation errors returned
// by TaskLoop.ValidateAll() if the designated constraints aren't met.
type TaskLoopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskLoopMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskLoopMultiError) AllErrors() []error { return m }

// TaskLoopValidationError is the validation error returned by
// TaskLoop.Validate if the designated constraints aren't met.
type TaskLoopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskLoopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskLoopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskLoopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskLoopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskLoopValidationError) ErrorName() string { return "TaskLoopValidationError" }

// Error satisfies the builtin error interface
func (e TaskLoopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskLoop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskLoopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskLoopValidationError{}

// Validate checks the field values on TaskLoopStrategy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TaskLoopStrategy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskLoopStrategy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskLoopStrategyMultiError, or nil if none found.
func (m *TaskLoopStrategy) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskLoopStrategy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxTimes

	// no validation rules for DeclineRatio

	// no validation rules for DeclineLimitSec

	// no validation rules for IntervalSec

	if len(errors) > 0 {
		return TaskLoopStrategyMultiError(errors)
	}

	return nil
}

// TaskLoopStrategyMultiError is an error wrapping multiple validation errors
// returned by TaskLoopStrategy.ValidateAll() if the designated constraints
// aren't met.
type TaskLoopStrategyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskLoopStrategyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskLoopStrategyMultiError) AllErrors() []error { return m }

// TaskLoopStrategyValidationError is the validation error returned by
// TaskLoopStrategy.Validate if the designated constraints aren't met.
type TaskLoopStrategyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskLoopStrategyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskLoopStrategyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskLoopStrategyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskLoopStrategyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskLoopStrategyValidationError) ErrorName() string { return "TaskLoopStrategyValidationError" }

// Error satisfies the builtin error interface
func (e TaskLoopStrategyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskLoopStrategy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskLoopStrategyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskLoopStrategyValidationError{}

// Validate checks the field values on SnippetStages with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SnippetStages) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnippetStages with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SnippetStagesMultiError, or
// nil if none found.
func (m *SnippetStages) ValidateAll() error {
	return m.validate(true)
}

func (m *SnippetStages) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParams() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SnippetStagesValidationError{
						field:  fmt.Sprintf("Params[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SnippetStagesValidationError{
						field:  fmt.Sprintf("Params[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SnippetStagesValidationError{
					field:  fmt.Sprintf("Params[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SnippetStagesValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SnippetStagesValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SnippetStagesValidationError{
					field:  fmt.Sprintf("Outputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetStages()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SnippetStagesValidationError{
					field:  "Stages",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SnippetStagesValidationError{
					field:  "Stages",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStages()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SnippetStagesValidationError{
				field:  "Stages",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SnippetStagesMultiError(errors)
	}

	return nil
}

// SnippetStagesMultiError is an error wrapping multiple validation errors
// returned by SnippetStages.ValidateAll() if the designated constraints
// aren't met.
type SnippetStagesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnippetStagesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnippetStagesMultiError) AllErrors() []error { return m }

// SnippetStagesValidationError is the validation error returned by
// SnippetStages.Validate if the designated constraints aren't met.
type SnippetStagesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnippetStagesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnippetStagesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnippetStagesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnippetStagesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnippetStagesValidationError) ErrorName() string { return "SnippetStagesValidationError" }

// Error satisfies the builtin error interface
func (e SnippetStagesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnippetStages.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnippetStagesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnippetStagesValidationError{}

// Validate checks the field values on PipelineStage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineStage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineStage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineStageMultiError, or
// nil if none found.
func (m *PipelineStage) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineStage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for PipelineID

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for CostTimeSec

	if all {
		switch v := interface{}(m.GetTimeBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineStageValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineStageValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineStageValidationError{
				field:  "TimeBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineStageValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineStageValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineStageValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineStageValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineStageValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineStageValidationError{
				field:  "TimeCreated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineStageValidationError{
					field:  "TimeUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineStageValidationError{
					field:  "TimeUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineStageValidationError{
				field:  "TimeUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineStageMultiError(errors)
	}

	return nil
}

// PipelineStageMultiError is an error wrapping multiple validation errors
// returned by PipelineStage.ValidateAll() if the designated constraints
// aren't met.
type PipelineStageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineStageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineStageMultiError) AllErrors() []error { return m }

// PipelineStageValidationError is the validation error returned by
// PipelineStage.Validate if the designated constraints aren't met.
type PipelineStageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineStageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineStageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineStageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineStageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineStageValidationError) ErrorName() string { return "PipelineStageValidationError" }

// Error satisfies the builtin error interface
func (e PipelineStageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineStage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineStageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineStageValidationError{}

// Validate checks the field values on PipelineStageDetailDTO with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineStageDetailDTO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineStageDetailDTO with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineStageDetailDTOMultiError, or nil if none found.
func (m *PipelineStageDetailDTO) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineStageDetailDTO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for PipelineID

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for CostTimeSec

	if all {
		switch v := interface{}(m.GetTimeBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineStageDetailDTOValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineStageDetailDTOValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineStageDetailDTOValidationError{
				field:  "TimeBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineStageDetailDTOValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineStageDetailDTOValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineStageDetailDTOValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineStageDetailDTOValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineStageDetailDTOValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineStageDetailDTOValidationError{
				field:  "TimeCreated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineStageDetailDTOValidationError{
					field:  "TimeUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineStageDetailDTOValidationError{
					field:  "TimeUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineStageDetailDTOValidationError{
				field:  "TimeUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPipelineTasks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineStageDetailDTOValidationError{
						field:  fmt.Sprintf("PipelineTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineStageDetailDTOValidationError{
						field:  fmt.Sprintf("PipelineTasks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineStageDetailDTOValidationError{
					field:  fmt.Sprintf("PipelineTasks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PipelineStageDetailDTOMultiError(errors)
	}

	return nil
}

// PipelineStageDetailDTOMultiError is an error wrapping multiple validation
// errors returned by PipelineStageDetailDTO.ValidateAll() if the designated
// constraints aren't met.
type PipelineStageDetailDTOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineStageDetailDTOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineStageDetailDTOMultiError) AllErrors() []error { return m }

// PipelineStageDetailDTOValidationError is the validation error returned by
// PipelineStageDetailDTO.Validate if the designated constraints aren't met.
type PipelineStageDetailDTOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineStageDetailDTOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineStageDetailDTOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineStageDetailDTOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineStageDetailDTOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineStageDetailDTOValidationError) ErrorName() string {
	return "PipelineStageDetailDTOValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineStageDetailDTOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineStageDetailDTO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineStageDetailDTOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineStageDetailDTOValidationError{}

// Validate checks the field values on PipelineTaskDTO with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskDTO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskDTO with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskDTOMultiError, or nil if none found.
func (m *PipelineTaskDTO) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskDTO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for PipelineID

	// no validation rules for StageID

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetExtra()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "Extra",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtra()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskDTOValidationError{
				field:  "Extra",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Labels

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskDTOValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsSnippet

	if all {
		switch v := interface{}(m.GetSnippetPipelineDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "SnippetPipelineDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "SnippetPipelineDetail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSnippetPipelineDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskDTOValidationError{
				field:  "SnippetPipelineDetail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CostTimeSec

	// no validation rules for QueueTimeSec

	if all {
		switch v := interface{}(m.GetTimeBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "TimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskDTOValidationError{
				field:  "TimeBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskDTOValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "TimeCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskDTOValidationError{
				field:  "TimeCreated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "TimeUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskDTOValidationError{
					field:  "TimeUpdated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskDTOValidationError{
				field:  "TimeUpdated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OpType

	if m.SnippetPipelineID != nil {
		// no validation rules for SnippetPipelineID
	}

	if len(errors) > 0 {
		return PipelineTaskDTOMultiError(errors)
	}

	return nil
}

// PipelineTaskDTOMultiError is an error wrapping multiple validation errors
// returned by PipelineTaskDTO.ValidateAll() if the designated constraints
// aren't met.
type PipelineTaskDTOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskDTOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskDTOMultiError) AllErrors() []error { return m }

// PipelineTaskDTOValidationError is the validation error returned by
// PipelineTaskDTO.Validate if the designated constraints aren't met.
type PipelineTaskDTOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskDTOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskDTOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskDTOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskDTOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskDTOValidationError) ErrorName() string { return "PipelineTaskDTOValidationError" }

// Error satisfies the builtin error interface
func (e PipelineTaskDTOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskDTO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskDTOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskDTOValidationError{}

// Validate checks the field values on TaskContainer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskContainer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskContainer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaskContainerMultiError, or
// nil if none found.
func (m *TaskContainer) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskContainer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskName

	// no validation rules for ContainerID

	if len(errors) > 0 {
		return TaskContainerMultiError(errors)
	}

	return nil
}

// TaskContainerMultiError is an error wrapping multiple validation errors
// returned by TaskContainer.ValidateAll() if the designated constraints
// aren't met.
type TaskContainerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskContainerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskContainerMultiError) AllErrors() []error { return m }

// TaskContainerValidationError is the validation error returned by
// TaskContainer.Validate if the designated constraints aren't met.
type TaskContainerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskContainerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskContainerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskContainerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskContainerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskContainerValidationError) ErrorName() string { return "TaskContainerValidationError" }

// Error satisfies the builtin error interface
func (e TaskContainerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskContainer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskContainerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskContainerValidationError{}

// Validate checks the field values on TaskParamDetail with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TaskParamDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskParamDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskParamDetailMultiError, or nil if none found.
func (m *TaskParamDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskParamDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Values

	if len(errors) > 0 {
		return TaskParamDetailMultiError(errors)
	}

	return nil
}

// TaskParamDetailMultiError is an error wrapping multiple validation errors
// returned by TaskParamDetail.ValidateAll() if the designated constraints
// aren't met.
type TaskParamDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskParamDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskParamDetailMultiError) AllErrors() []error { return m }

// TaskParamDetailValidationError is the validation error returned by
// TaskParamDetail.Validate if the designated constraints aren't met.
type TaskParamDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskParamDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskParamDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskParamDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskParamDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskParamDetailValidationError) ErrorName() string { return "TaskParamDetailValidationError" }

// Error satisfies the builtin error interface
func (e TaskParamDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskParamDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskParamDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskParamDetailValidationError{}

// Validate checks the field values on PipelineTaskExtra with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskExtra) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskExtra with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskExtraMultiError, or nil if none found.
func (m *PipelineTaskExtra) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskExtra) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UUID

	// no validation rules for AllowFailure

	for idx, item := range m.GetTaskContainers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineTaskExtraValidationError{
						field:  fmt.Sprintf("TaskContainers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineTaskExtraValidationError{
						field:  fmt.Sprintf("TaskContainers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineTaskExtraValidationError{
					field:  fmt.Sprintf("TaskContainers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetParams() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineTaskExtraValidationError{
						field:  fmt.Sprintf("Params[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineTaskExtraValidationError{
						field:  fmt.Sprintf("Params[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineTaskExtraValidationError{
					field:  fmt.Sprintf("Params[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskExtraValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskExtraValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskExtraValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBreakpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskExtraValidationError{
					field:  "Breakpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskExtraValidationError{
					field:  "Breakpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBreakpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskExtraValidationError{
				field:  "Breakpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineTaskExtraMultiError(errors)
	}

	return nil
}

// PipelineTaskExtraMultiError is an error wrapping multiple validation errors
// returned by PipelineTaskExtra.ValidateAll() if the designated constraints
// aren't met.
type PipelineTaskExtraMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskExtraMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskExtraMultiError) AllErrors() []error { return m }

// PipelineTaskExtraValidationError is the validation error returned by
// PipelineTaskExtra.Validate if the designated constraints aren't met.
type PipelineTaskExtraValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskExtraValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskExtraValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskExtraValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskExtraValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskExtraValidationError) ErrorName() string {
	return "PipelineTaskExtraValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskExtraValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskExtra.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskExtraValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskExtraValidationError{}

// Validate checks the field values on ErrorContext with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ErrorContext) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorContext with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ErrorContextMultiError, or
// nil if none found.
func (m *ErrorContext) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorContext) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErrorContextValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErrorContextValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErrorContextValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ErrorContextValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ErrorContextValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ErrorContextValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Count

	if len(errors) > 0 {
		return ErrorContextMultiError(errors)
	}

	return nil
}

// ErrorContextMultiError is an error wrapping multiple validation errors
// returned by ErrorContext.ValidateAll() if the designated constraints aren't met.
type ErrorContextMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorContextMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorContextMultiError) AllErrors() []error { return m }

// ErrorContextValidationError is the validation error returned by
// ErrorContext.Validate if the designated constraints aren't met.
type ErrorContextValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorContextValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorContextValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorContextValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorContextValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorContextValidationError) ErrorName() string { return "ErrorContextValidationError" }

// Error satisfies the builtin error interface
func (e ErrorContextValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorContext.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorContextValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorContextValidationError{}

// Validate checks the field values on PipelineTaskResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskResultMultiError, or nil if none found.
func (m *PipelineTaskResult) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMetadata() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineTaskResultValidationError{
						field:  fmt.Sprintf("Metadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineTaskResultValidationError{
						field:  fmt.Sprintf("Metadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineTaskResultValidationError{
					field:  fmt.Sprintf("Metadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineTaskResultValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineTaskResultValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineTaskResultValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetMachineStat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskResultValidationError{
					field:  "MachineStat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskResultValidationError{
					field:  "MachineStat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMachineStat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskResultValidationError{
				field:  "MachineStat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Inspect

	// no validation rules for Events

	if len(errors) > 0 {
		return PipelineTaskResultMultiError(errors)
	}

	return nil
}

// PipelineTaskResultMultiError is an error wrapping multiple validation errors
// returned by PipelineTaskResult.ValidateAll() if the designated constraints
// aren't met.
type PipelineTaskResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskResultMultiError) AllErrors() []error { return m }

// PipelineTaskResultValidationError is the validation error returned by
// PipelineTaskResult.Validate if the designated constraints aren't met.
type PipelineTaskResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskResultValidationError) ErrorName() string {
	return "PipelineTaskResultValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskResultValidationError{}

// Validate checks the field values on PipelineTaskSnippetDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskSnippetDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskSnippetDetail with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskSnippetDetailMultiError, or nil if none found.
func (m *PipelineTaskSnippetDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskSnippetDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineTaskSnippetDetailValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineTaskSnippetDetailValidationError{
						field:  fmt.Sprintf("Outputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineTaskSnippetDetailValidationError{
					field:  fmt.Sprintf("Outputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DirectSnippetTasksNum

	// no validation rules for RecursiveSnippetTasksNum

	if len(errors) > 0 {
		return PipelineTaskSnippetDetailMultiError(errors)
	}

	return nil
}

// PipelineTaskSnippetDetailMultiError is an error wrapping multiple validation
// errors returned by PipelineTaskSnippetDetail.ValidateAll() if the
// designated constraints aren't met.
type PipelineTaskSnippetDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskSnippetDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskSnippetDetailMultiError) AllErrors() []error { return m }

// PipelineTaskSnippetDetailValidationError is the validation error returned by
// PipelineTaskSnippetDetail.Validate if the designated constraints aren't met.
type PipelineTaskSnippetDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskSnippetDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskSnippetDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskSnippetDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskSnippetDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskSnippetDetailValidationError) ErrorName() string {
	return "PipelineTaskSnippetDetailValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskSnippetDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskSnippetDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskSnippetDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskSnippetDetailValidationError{}

// Validate checks the field values on PipelineTaskMachineStat with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskMachineStat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskMachineStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskMachineStatMultiError, or nil if none found.
func (m *PipelineTaskMachineStat) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskMachineStat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Host",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Host",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskMachineStatValidationError{
				field:  "Host",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Pod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskMachineStatValidationError{
				field:  "Pod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLoad()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Load",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Load",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLoad()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskMachineStatValidationError{
				field:  "Load",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Mem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Mem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskMachineStatValidationError{
				field:  "Mem",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSwap()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Swap",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineTaskMachineStatValidationError{
					field:  "Swap",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSwap()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineTaskMachineStatValidationError{
				field:  "Swap",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineTaskMachineStatMultiError(errors)
	}

	return nil
}

// PipelineTaskMachineStatMultiError is an error wrapping multiple validation
// errors returned by PipelineTaskMachineStat.ValidateAll() if the designated
// constraints aren't met.
type PipelineTaskMachineStatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskMachineStatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskMachineStatMultiError) AllErrors() []error { return m }

// PipelineTaskMachineStatValidationError is the validation error returned by
// PipelineTaskMachineStat.Validate if the designated constraints aren't met.
type PipelineTaskMachineStatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskMachineStatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskMachineStatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskMachineStatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskMachineStatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskMachineStatValidationError) ErrorName() string {
	return "PipelineTaskMachineStatValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskMachineStatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskMachineStat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskMachineStatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskMachineStatValidationError{}

// Validate checks the field values on PipelineTaskMachineHostStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskMachineHostStat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskMachineHostStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskMachineHostStatMultiError, or nil if none found.
func (m *PipelineTaskMachineHostStat) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskMachineHostStat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostIP

	// no validation rules for Hostname

	// no validation rules for UptimeSec

	// no validation rules for BootTimeSec

	// no validation rules for Os

	// no validation rules for Platform

	// no validation rules for PlatformVersion

	// no validation rules for KernelVersion

	// no validation rules for KernelArch

	if len(errors) > 0 {
		return PipelineTaskMachineHostStatMultiError(errors)
	}

	return nil
}

// PipelineTaskMachineHostStatMultiError is an error wrapping multiple
// validation errors returned by PipelineTaskMachineHostStat.ValidateAll() if
// the designated constraints aren't met.
type PipelineTaskMachineHostStatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskMachineHostStatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskMachineHostStatMultiError) AllErrors() []error { return m }

// PipelineTaskMachineHostStatValidationError is the validation error returned
// by PipelineTaskMachineHostStat.Validate if the designated constraints
// aren't met.
type PipelineTaskMachineHostStatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskMachineHostStatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskMachineHostStatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskMachineHostStatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskMachineHostStatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskMachineHostStatValidationError) ErrorName() string {
	return "PipelineTaskMachineHostStatValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskMachineHostStatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskMachineHostStat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskMachineHostStatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskMachineHostStatValidationError{}

// Validate checks the field values on PipelineTaskMachinePodStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskMachinePodStat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskMachinePodStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskMachinePodStatMultiError, or nil if none found.
func (m *PipelineTaskMachinePodStat) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskMachinePodStat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PodIP

	if len(errors) > 0 {
		return PipelineTaskMachinePodStatMultiError(errors)
	}

	return nil
}

// PipelineTaskMachinePodStatMultiError is an error wrapping multiple
// validation errors returned by PipelineTaskMachinePodStat.ValidateAll() if
// the designated constraints aren't met.
type PipelineTaskMachinePodStatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskMachinePodStatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskMachinePodStatMultiError) AllErrors() []error { return m }

// PipelineTaskMachinePodStatValidationError is the validation error returned
// by PipelineTaskMachinePodStat.Validate if the designated constraints aren't met.
type PipelineTaskMachinePodStatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskMachinePodStatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskMachinePodStatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskMachinePodStatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskMachinePodStatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskMachinePodStatValidationError) ErrorName() string {
	return "PipelineTaskMachinePodStatValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskMachinePodStatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskMachinePodStat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskMachinePodStatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskMachinePodStatValidationError{}

// Validate checks the field values on PipelineTaskMachineLoadStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskMachineLoadStat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskMachineLoadStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskMachineLoadStatMultiError, or nil if none found.
func (m *PipelineTaskMachineLoadStat) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskMachineLoadStat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Load1

	// no validation rules for Load5

	// no validation rules for Load15

	if len(errors) > 0 {
		return PipelineTaskMachineLoadStatMultiError(errors)
	}

	return nil
}

// PipelineTaskMachineLoadStatMultiError is an error wrapping multiple
// validation errors returned by PipelineTaskMachineLoadStat.ValidateAll() if
// the designated constraints aren't met.
type PipelineTaskMachineLoadStatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskMachineLoadStatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskMachineLoadStatMultiError) AllErrors() []error { return m }

// PipelineTaskMachineLoadStatValidationError is the validation error returned
// by PipelineTaskMachineLoadStat.Validate if the designated constraints
// aren't met.
type PipelineTaskMachineLoadStatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskMachineLoadStatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskMachineLoadStatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskMachineLoadStatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskMachineLoadStatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskMachineLoadStatValidationError) ErrorName() string {
	return "PipelineTaskMachineLoadStatValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskMachineLoadStatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskMachineLoadStat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskMachineLoadStatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskMachineLoadStatValidationError{}

// Validate checks the field values on PipelineTaskMachineMemStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskMachineMemStat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskMachineMemStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskMachineMemStatMultiError, or nil if none found.
func (m *PipelineTaskMachineMemStat) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskMachineMemStat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for Available

	// no validation rules for Used

	// no validation rules for Free

	// no validation rules for UsedPercent

	// no validation rules for Buffers

	// no validation rules for Cached

	if len(errors) > 0 {
		return PipelineTaskMachineMemStatMultiError(errors)
	}

	return nil
}

// PipelineTaskMachineMemStatMultiError is an error wrapping multiple
// validation errors returned by PipelineTaskMachineMemStat.ValidateAll() if
// the designated constraints aren't met.
type PipelineTaskMachineMemStatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskMachineMemStatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskMachineMemStatMultiError) AllErrors() []error { return m }

// PipelineTaskMachineMemStatValidationError is the validation error returned
// by PipelineTaskMachineMemStat.Validate if the designated constraints aren't met.
type PipelineTaskMachineMemStatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskMachineMemStatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskMachineMemStatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskMachineMemStatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskMachineMemStatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskMachineMemStatValidationError) ErrorName() string {
	return "PipelineTaskMachineMemStatValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskMachineMemStatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskMachineMemStat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskMachineMemStatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskMachineMemStatValidationError{}

// Validate checks the field values on PipelineTaskMachineSwapStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskMachineSwapStat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskMachineSwapStat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskMachineSwapStatMultiError, or nil if none found.
func (m *PipelineTaskMachineSwapStat) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskMachineSwapStat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for Used

	// no validation rules for Free

	// no validation rules for UsedPercent

	if len(errors) > 0 {
		return PipelineTaskMachineSwapStatMultiError(errors)
	}

	return nil
}

// PipelineTaskMachineSwapStatMultiError is an error wrapping multiple
// validation errors returned by PipelineTaskMachineSwapStat.ValidateAll() if
// the designated constraints aren't met.
type PipelineTaskMachineSwapStatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskMachineSwapStatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskMachineSwapStatMultiError) AllErrors() []error { return m }

// PipelineTaskMachineSwapStatValidationError is the validation error returned
// by PipelineTaskMachineSwapStat.Validate if the designated constraints
// aren't met.
type PipelineTaskMachineSwapStatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskMachineSwapStatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskMachineSwapStatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskMachineSwapStatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskMachineSwapStatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskMachineSwapStatValidationError) ErrorName() string {
	return "PipelineTaskMachineSwapStatValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskMachineSwapStatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskMachineSwapStat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskMachineSwapStatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskMachineSwapStatValidationError{}

// Validate checks the field values on PipelineTaskActionDetail with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineTaskActionDetail) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineTaskActionDetail with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineTaskActionDetailMultiError, or nil if none found.
func (m *PipelineTaskActionDetail) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineTaskActionDetail) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LogoUrl

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Type

	if len(errors) > 0 {
		return PipelineTaskActionDetailMultiError(errors)
	}

	return nil
}

// PipelineTaskActionDetailMultiError is an error wrapping multiple validation
// errors returned by PipelineTaskActionDetail.ValidateAll() if the designated
// constraints aren't met.
type PipelineTaskActionDetailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineTaskActionDetailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineTaskActionDetailMultiError) AllErrors() []error { return m }

// PipelineTaskActionDetailValidationError is the validation error returned by
// PipelineTaskActionDetail.Validate if the designated constraints aren't met.
type PipelineTaskActionDetailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineTaskActionDetailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineTaskActionDetailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineTaskActionDetailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineTaskActionDetailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineTaskActionDetailValidationError) ErrorName() string {
	return "PipelineTaskActionDetailValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineTaskActionDetailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineTaskActionDetail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineTaskActionDetailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineTaskActionDetailValidationError{}

// Validate checks the field values on SnippetConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SnippetConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SnippetConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SnippetConfigMultiError, or
// nil if none found.
func (m *SnippetConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *SnippetConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Source

	// no validation rules for Name

	// no validation rules for Labels

	if len(errors) > 0 {
		return SnippetConfigMultiError(errors)
	}

	return nil
}

// SnippetConfigMultiError is an error wrapping multiple validation errors
// returned by SnippetConfig.ValidateAll() if the designated constraints
// aren't met.
type SnippetConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SnippetConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SnippetConfigMultiError) AllErrors() []error { return m }

// SnippetConfigValidationError is the validation error returned by
// SnippetConfig.Validate if the designated constraints aren't met.
type SnippetConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SnippetConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SnippetConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SnippetConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SnippetConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SnippetConfigValidationError) ErrorName() string { return "SnippetConfigValidationError" }

// Error satisfies the builtin error interface
func (e SnippetConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSnippetConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SnippetConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SnippetConfigValidationError{}

// Validate checks the field values on DefinitionPageInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DefinitionPageInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DefinitionPageInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DefinitionPageInfoMultiError, or nil if none found.
func (m *DefinitionPageInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DefinitionPageInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Creator

	// no validation rules for Executor

	// no validation rules for SourceRemote

	// no validation rules for SourceRef

	if len(errors) > 0 {
		return DefinitionPageInfoMultiError(errors)
	}

	return nil
}

// DefinitionPageInfoMultiError is an error wrapping multiple validation errors
// returned by DefinitionPageInfo.ValidateAll() if the designated constraints
// aren't met.
type DefinitionPageInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefinitionPageInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefinitionPageInfoMultiError) AllErrors() []error { return m }

// DefinitionPageInfoValidationError is the validation error returned by
// DefinitionPageInfo.Validate if the designated constraints aren't met.
type DefinitionPageInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefinitionPageInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefinitionPageInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefinitionPageInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefinitionPageInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefinitionPageInfoValidationError) ErrorName() string {
	return "DefinitionPageInfoValidationError"
}

// Error satisfies the builtin error interface
func (e DefinitionPageInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefinitionPageInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefinitionPageInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefinitionPageInfoValidationError{}
