// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: pipeline.proto

package pb

import (
	base64 "encoding/base64"
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	pb1 "github.com/erda-project/erda-proto-go/common/pb"
	pb "github.com/erda-project/erda-proto-go/core/pipeline/base/pb"
	pb2 "github.com/erda-project/erda-proto-go/core/pipeline/pb"
	pb3 "github.com/erda-project/erda-proto-go/core/pipeline/queue/pb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*PipelineDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineDetailRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineDetailDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCreateRequestV2)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineBatchCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineBatchCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelinePagingRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelinePagingResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagePipeline)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineDefinitionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTaskOperateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineOperateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineOperateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRunRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRunResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCancelRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCancelResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRerunRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRerunResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRerunFailedRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRerunFailedResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineStatisticRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineStatisticResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineStatisticResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineSnippetQueryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineSnippetQueryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SnippetDetailQuery)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SnippetQueryDetail)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCallbackRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCallbackResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTaskViewRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTaskViewResponse)(nil)

// PipelineDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			}
		}
	}
	return nil
}

// PipelineDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineDetailRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineDetailRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "simplePipelineBaseResult":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.SimplePipelineBaseResult = val
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			}
		}
	}
	return nil
}

// PipelineDetailDTO implement urlenc.URLValuesUnmarshaler.
func (m *PipelineDetailDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "source":
				m.Source = vals[0]
			case "ymlName":
				m.YmlName = vals[0]
			case "namespace":
				m.Namespace = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "status":
				m.Status = vals[0]
			case "type":
				m.Type = vals[0]
			case "triggerMode":
				m.TriggerMode = vals[0]
			case "cronID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CronID = &val
			case "ymlSource":
				m.YmlSource = vals[0]
			case "ymlContent":
				m.YmlContent = vals[0]
			case "extra":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
			case "extra.diceWorkspace":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.DiceWorkspace = vals[0]
			case "extra.submitUser":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
			case "extra.submitUser.ID":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.name":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Extra.SubmitUser.Name = vals[0]
			case "extra.submitUser.avatar":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Extra.SubmitUser.Avatar = vals[0]
			case "extra.runUser":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
			case "extra.runUser.ID":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.name":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Extra.RunUser.Name = vals[0]
			case "extra.runUser.avatar":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Extra.RunUser.Avatar = vals[0]
			case "extra.cancelUser":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
			case "extra.cancelUser.ID":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.name":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Extra.CancelUser.Name = vals[0]
			case "extra.cancelUser.avatar":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Extra.CancelUser.Avatar = vals[0]
			case "extra.cronExpr":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.CronExpr = vals[0]
			case "extra.cronTriggerTime":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CronTriggerTime == nil {
					m.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
			case "extra.cronTriggerTime.seconds":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CronTriggerTime == nil {
					m.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Extra.CronTriggerTime.Seconds = val
			case "extra.cronTriggerTime.nanos":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CronTriggerTime == nil {
					m.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Extra.CronTriggerTime.Nanos = int32(val)
			case "extra.show_message":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.ShowMessage == nil {
					m.Extra.ShowMessage = &pb.ShowMessage{}
				}
			case "extra.show_message.msg":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.ShowMessage == nil {
					m.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Extra.ShowMessage.Msg = vals[0]
			case "extra.show_message.stacks":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.ShowMessage == nil {
					m.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Extra.ShowMessage.Stacks = vals
			case "extra.show_message.abortRun":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.ShowMessage == nil {
					m.Extra.ShowMessage = &pb.ShowMessage{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Extra.ShowMessage.AbortRun = val
			case "extra.configManageNamespaces":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.ConfigManageNamespaces = vals
			case "extra.isAutoRun":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Extra.IsAutoRun = val
			case "extra.callbackURLs":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.CallbackURLs = vals
			case "extra.ownerUser":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
			case "extra.ownerUser.ID":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.name":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Extra.OwnerUser.Name = vals[0]
			case "extra.ownerUser.avatar":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Extra.OwnerUser.Avatar = vals[0]
			case "extra.pipelineYmlNameV1":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.PipelineYmlNameV1 = vals[0]
			case "extra.breakpoint":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
			case "extra.breakpoint.on":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Extra.Breakpoint.On == nil {
					m.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
			case "extra.breakpoint.on.failure":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Extra.Breakpoint.On == nil {
					m.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Extra.Breakpoint.On.Failure = val
			case "extra.breakpoint.timeout":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "orgName":
				m.OrgName = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "applicationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "applicationName":
				m.ApplicationName = vals[0]
			case "branch":
				m.Branch = vals[0]
			case "commit":
				m.Commit = vals[0]
			case "commitDetail":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
			case "commitDetail.commitID":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				m.CommitDetail.CommitID = vals[0]
			case "commitDetail.repo":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				m.CommitDetail.Repo = vals[0]
			case "commitDetail.repoAbbr":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				m.CommitDetail.RepoAbbr = vals[0]
			case "commitDetail.author":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				m.CommitDetail.Author = vals[0]
			case "commitDetail.email":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				m.CommitDetail.Email = vals[0]
			case "commitDetail.time":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				if m.CommitDetail.Time == nil {
					m.CommitDetail.Time = &timestamppb.Timestamp{}
				}
			case "commitDetail.time.seconds":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				if m.CommitDetail.Time == nil {
					m.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CommitDetail.Time.Seconds = val
			case "commitDetail.time.nanos":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				if m.CommitDetail.Time == nil {
					m.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CommitDetail.Time.Nanos = int32(val)
			case "commitDetail.comment":
				if m.CommitDetail == nil {
					m.CommitDetail = &pb1.CommitDetail{}
				}
				m.CommitDetail.Comment = vals[0]
			case "progress":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Progress = val
			case "costTimeSec":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CostTimeSec = val
			case "timeBegin":
				if m.TimeBegin == nil {
					m.TimeBegin = &timestamppb.Timestamp{}
				}
			case "timeBegin.seconds":
				if m.TimeBegin == nil {
					m.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeBegin.Seconds = val
			case "timeBegin.nanos":
				if m.TimeBegin == nil {
					m.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeBegin.Nanos = int32(val)
			case "timeEnd":
				if m.TimeEnd == nil {
					m.TimeEnd = &timestamppb.Timestamp{}
				}
			case "timeEnd.seconds":
				if m.TimeEnd == nil {
					m.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeEnd.Seconds = val
			case "timeEnd.nanos":
				if m.TimeEnd == nil {
					m.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeEnd.Nanos = int32(val)
			case "timeCreated":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
			case "timeCreated.seconds":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeCreated.Seconds = val
			case "timeCreated.nanos":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeCreated.Nanos = int32(val)
			case "timeUpdated":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "timeUpdated.seconds":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeUpdated.Seconds = val
			case "timeUpdated.nanos":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeUpdated.Nanos = int32(val)
			case "pipelineCron":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
			case "pipelineCron.ID":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.ID = val
			case "pipelineCron.timeCreated":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.TimeCreated == nil {
					m.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
			case "pipelineCron.timeCreated.seconds":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.TimeCreated == nil {
					m.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.TimeCreated.Seconds = val
			case "pipelineCron.timeCreated.nanos":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.TimeCreated == nil {
					m.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PipelineCron.TimeCreated.Nanos = int32(val)
			case "pipelineCron.timeUpdated":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.TimeUpdated == nil {
					m.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "pipelineCron.timeUpdated.seconds":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.TimeUpdated == nil {
					m.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.TimeUpdated.Seconds = val
			case "pipelineCron.timeUpdated.nanos":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.TimeUpdated == nil {
					m.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PipelineCron.TimeUpdated.Nanos = int32(val)
			case "pipelineCron.applicationID":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.ApplicationID = val
			case "pipelineCron.branch":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.Branch = vals[0]
			case "pipelineCron.cronExpr":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.CronExpr = vals[0]
			case "pipelineCron.cronStartTime":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.CronStartTime == nil {
					m.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
			case "pipelineCron.cronStartTime.seconds":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.CronStartTime == nil {
					m.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.CronStartTime.Seconds = val
			case "pipelineCron.cronStartTime.nanos":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.CronStartTime == nil {
					m.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PipelineCron.CronStartTime.Nanos = int32(val)
			case "pipelineCron.pipelineYmlName":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.PipelineYmlName = vals[0]
			case "pipelineCron.basePipelineID":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.BasePipelineID = val
			case "pipelineCron.enable":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Enable == nil {
					m.PipelineCron.Enable = &wrapperspb.BoolValue{}
				}
			case "pipelineCron.enable.value":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Enable == nil {
					m.PipelineCron.Enable = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineCron.Enable.Value = val
			case "pipelineCron.pipelineYml":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.PipelineYml = vals[0]
			case "pipelineCron.configManageNamespaces":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.ConfigManageNamespaces = vals
			case "pipelineCron.userID":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.UserID = vals[0]
			case "pipelineCron.orgID":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.OrgID = val
			case "pipelineCron.pipelineDefinitionID":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.PipelineDefinitionID = vals[0]
			case "pipelineCron.pipelineSource":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.PipelineSource = vals[0]
			case "pipelineCron.extra":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
			case "pipelineCron.extra.pipelineYml":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.PipelineCron.Extra.PipelineYml = vals[0]
			case "pipelineCron.extra.clusterName":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.PipelineCron.Extra.ClusterName = vals[0]
			case "pipelineCron.extra.configManageNamespaces":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.PipelineCron.Extra.ConfigManageNamespaces = vals
			case "pipelineCron.extra.cronStartFrom":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.CronStartFrom == nil {
					m.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
			case "pipelineCron.extra.cronStartFrom.seconds":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.CronStartFrom == nil {
					m.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.Extra.CronStartFrom.Seconds = val
			case "pipelineCron.extra.cronStartFrom.nanos":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.CronStartFrom == nil {
					m.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PipelineCron.Extra.CronStartFrom.Nanos = int32(val)
			case "pipelineCron.extra.version":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.PipelineCron.Extra.Version = vals[0]
			case "pipelineCron.extra.compensator":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.Compensator == nil {
					m.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
			case "pipelineCron.extra.compensator.enable":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.Compensator == nil {
					m.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.PipelineCron.Extra.Compensator.Enable == nil {
					m.PipelineCron.Extra.Compensator.Enable = &wrapperspb.BoolValue{}
				}
			case "pipelineCron.extra.compensator.enable.value":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.Compensator == nil {
					m.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.PipelineCron.Extra.Compensator.Enable == nil {
					m.PipelineCron.Extra.Compensator.Enable = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineCron.Extra.Compensator.Enable.Value = val
			case "pipelineCron.extra.compensator.LatestFirst":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.Compensator == nil {
					m.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.PipelineCron.Extra.Compensator.LatestFirst == nil {
					m.PipelineCron.Extra.Compensator.LatestFirst = &wrapperspb.BoolValue{}
				}
			case "pipelineCron.extra.compensator.LatestFirst.value":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.Compensator == nil {
					m.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.PipelineCron.Extra.Compensator.LatestFirst == nil {
					m.PipelineCron.Extra.Compensator.LatestFirst = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineCron.Extra.Compensator.LatestFirst.Value = val
			case "pipelineCron.extra.compensator.StopIfLatterExecuted":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.Compensator == nil {
					m.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.PipelineCron.Extra.Compensator.StopIfLatterExecuted == nil {
					m.PipelineCron.Extra.Compensator.StopIfLatterExecuted = &wrapperspb.BoolValue{}
				}
			case "pipelineCron.extra.compensator.StopIfLatterExecuted.value":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.Compensator == nil {
					m.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.PipelineCron.Extra.Compensator.StopIfLatterExecuted == nil {
					m.PipelineCron.Extra.Compensator.StopIfLatterExecuted = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineCron.Extra.Compensator.StopIfLatterExecuted.Value = val
			case "pipelineCron.extra.lastCompensateAt":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.LastCompensateAt == nil {
					m.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
			case "pipelineCron.extra.lastCompensateAt.seconds":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.LastCompensateAt == nil {
					m.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineCron.Extra.LastCompensateAt.Seconds = val
			case "pipelineCron.extra.lastCompensateAt.nanos":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.Extra == nil {
					m.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.PipelineCron.Extra.LastCompensateAt == nil {
					m.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PipelineCron.Extra.LastCompensateAt.Nanos = int32(val)
			case "pipelineCron.IsEdge":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.IsEdge == nil {
					m.PipelineCron.IsEdge = &wrapperspb.BoolValue{}
				}
			case "pipelineCron.IsEdge.value":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				if m.PipelineCron.IsEdge == nil {
					m.PipelineCron.IsEdge = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineCron.IsEdge.Value = val
			case "pipelineCron.clusterName":
				if m.PipelineCron == nil {
					m.PipelineCron = &pb2.Cron{}
				}
				m.PipelineCron.ClusterName = vals[0]
			case "pipelineButton":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
			case "pipelineButton.canManualRun":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanManualRun = val
			case "pipelineButton.canCancel":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanCancel = val
			case "pipelineButton.canForceCancel":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanForceCancel = val
			case "pipelineButton.canRerun":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanRerun = val
			case "pipelineButton.canRerunFailed":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanRerunFailed = val
			case "pipelineButton.canStartCron":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanStartCron = val
			case "pipelineButton.canStopCron":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanStopCron = val
			case "pipelineButton.canPause":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanPause = val
			case "pipelineButton.canUnpause":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanUnpause = val
			case "pipelineButton.canDelete":
				if m.PipelineButton == nil {
					m.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PipelineButton.CanDelete = val
			case "needApproval":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NeedApproval = val
			}
		}
	}
	return nil
}

// PipelineDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.source":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Source = vals[0]
			case "data.ymlName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.YmlName = vals[0]
			case "data.namespace":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Namespace = vals[0]
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.ClusterName = vals[0]
			case "data.status":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Status = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Type = vals[0]
			case "data.triggerMode":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.TriggerMode = vals[0]
			case "data.cronID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CronID = &val
			case "data.ymlSource":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.YmlSource = vals[0]
			case "data.ymlContent":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.YmlContent = vals[0]
			case "data.extra":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
			case "data.extra.diceWorkspace":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.DiceWorkspace = vals[0]
			case "data.extra.submitUser":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
			case "data.extra.submitUser.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.name":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Name = vals[0]
			case "data.extra.submitUser.avatar":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Avatar = vals[0]
			case "data.extra.runUser":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
			case "data.extra.runUser.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.name":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Name = vals[0]
			case "data.extra.runUser.avatar":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Avatar = vals[0]
			case "data.extra.cancelUser":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
			case "data.extra.cancelUser.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.name":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Name = vals[0]
			case "data.extra.cancelUser.avatar":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Avatar = vals[0]
			case "data.extra.cronExpr":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CronExpr = vals[0]
			case "data.extra.cronTriggerTime":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
			case "data.extra.cronTriggerTime.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Seconds = val
			case "data.extra.cronTriggerTime.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Nanos = int32(val)
			case "data.extra.show_message":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
			case "data.extra.show_message.msg":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Msg = vals[0]
			case "data.extra.show_message.stacks":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Stacks = vals
			case "data.extra.show_message.abortRun":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.ShowMessage.AbortRun = val
			case "data.extra.configManageNamespaces":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.ConfigManageNamespaces = vals
			case "data.extra.isAutoRun":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.IsAutoRun = val
			case "data.extra.callbackURLs":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CallbackURLs = vals
			case "data.extra.ownerUser":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
			case "data.extra.ownerUser.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.name":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Name = vals[0]
			case "data.extra.ownerUser.avatar":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Avatar = vals[0]
			case "data.extra.pipelineYmlNameV1":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.PipelineYmlNameV1 = vals[0]
			case "data.extra.breakpoint":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
			case "data.extra.breakpoint.on":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
			case "data.extra.breakpoint.on.failure":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.Breakpoint.On.Failure = val
			case "data.extra.breakpoint.timeout":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.orgName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.OrgName = vals[0]
			case "data.projectID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.projectName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.ProjectName = vals[0]
			case "data.applicationID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ApplicationID = val
			case "data.applicationName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.ApplicationName = vals[0]
			case "data.branch":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Branch = vals[0]
			case "data.commit":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Commit = vals[0]
			case "data.commitDetail":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
			case "data.commitDetail.commitID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.CommitID = vals[0]
			case "data.commitDetail.repo":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Repo = vals[0]
			case "data.commitDetail.repoAbbr":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.RepoAbbr = vals[0]
			case "data.commitDetail.author":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Author = vals[0]
			case "data.commitDetail.email":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Email = vals[0]
			case "data.commitDetail.time":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
			case "data.commitDetail.time.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Seconds = val
			case "data.commitDetail.time.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Nanos = int32(val)
			case "data.commitDetail.comment":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Comment = vals[0]
			case "data.progress":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.Progress = val
			case "data.costTimeSec":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CostTimeSec = val
			case "data.timeBegin":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
			case "data.timeBegin.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Seconds = val
			case "data.timeBegin.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Nanos = int32(val)
			case "data.timeEnd":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
			case "data.timeEnd.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Seconds = val
			case "data.timeEnd.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Nanos = int32(val)
			case "data.timeCreated":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
			case "data.timeCreated.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Seconds = val
			case "data.timeCreated.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Nanos = int32(val)
			case "data.timeUpdated":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "data.timeUpdated.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Seconds = val
			case "data.timeUpdated.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Nanos = int32(val)
			case "data.pipelineCron":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
			case "data.pipelineCron.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.ID = val
			case "data.pipelineCron.timeCreated":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeCreated == nil {
					m.Data.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.timeCreated.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeCreated == nil {
					m.Data.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.TimeCreated.Seconds = val
			case "data.pipelineCron.timeCreated.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeCreated == nil {
					m.Data.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.TimeCreated.Nanos = int32(val)
			case "data.pipelineCron.timeUpdated":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeUpdated == nil {
					m.Data.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.timeUpdated.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeUpdated == nil {
					m.Data.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.TimeUpdated.Seconds = val
			case "data.pipelineCron.timeUpdated.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeUpdated == nil {
					m.Data.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.TimeUpdated.Nanos = int32(val)
			case "data.pipelineCron.applicationID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.ApplicationID = val
			case "data.pipelineCron.branch":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.Branch = vals[0]
			case "data.pipelineCron.cronExpr":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.CronExpr = vals[0]
			case "data.pipelineCron.cronStartTime":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.CronStartTime == nil {
					m.Data.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.cronStartTime.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.CronStartTime == nil {
					m.Data.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.CronStartTime.Seconds = val
			case "data.pipelineCron.cronStartTime.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.CronStartTime == nil {
					m.Data.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.CronStartTime.Nanos = int32(val)
			case "data.pipelineCron.pipelineYmlName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.PipelineYmlName = vals[0]
			case "data.pipelineCron.basePipelineID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.BasePipelineID = val
			case "data.pipelineCron.enable":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Enable == nil {
					m.Data.PipelineCron.Enable = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.enable.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Enable == nil {
					m.Data.PipelineCron.Enable = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Enable.Value = val
			case "data.pipelineCron.pipelineYml":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.PipelineYml = vals[0]
			case "data.pipelineCron.configManageNamespaces":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.ConfigManageNamespaces = vals
			case "data.pipelineCron.userID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.UserID = vals[0]
			case "data.pipelineCron.orgID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.OrgID = val
			case "data.pipelineCron.pipelineDefinitionID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.PipelineDefinitionID = vals[0]
			case "data.pipelineCron.pipelineSource":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.PipelineSource = vals[0]
			case "data.pipelineCron.extra":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
			case "data.pipelineCron.extra.pipelineYml":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.Data.PipelineCron.Extra.PipelineYml = vals[0]
			case "data.pipelineCron.extra.clusterName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.Data.PipelineCron.Extra.ClusterName = vals[0]
			case "data.pipelineCron.extra.configManageNamespaces":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.Data.PipelineCron.Extra.ConfigManageNamespaces = vals
			case "data.pipelineCron.extra.cronStartFrom":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.CronStartFrom == nil {
					m.Data.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.extra.cronStartFrom.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.CronStartFrom == nil {
					m.Data.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.CronStartFrom.Seconds = val
			case "data.pipelineCron.extra.cronStartFrom.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.CronStartFrom == nil {
					m.Data.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.CronStartFrom.Nanos = int32(val)
			case "data.pipelineCron.extra.version":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.Data.PipelineCron.Extra.Version = vals[0]
			case "data.pipelineCron.extra.compensator":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
			case "data.pipelineCron.extra.compensator.enable":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.Enable == nil {
					m.Data.PipelineCron.Extra.Compensator.Enable = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.extra.compensator.enable.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.Enable == nil {
					m.Data.PipelineCron.Extra.Compensator.Enable = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.Compensator.Enable.Value = val
			case "data.pipelineCron.extra.compensator.LatestFirst":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.LatestFirst == nil {
					m.Data.PipelineCron.Extra.Compensator.LatestFirst = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.extra.compensator.LatestFirst.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.LatestFirst == nil {
					m.Data.PipelineCron.Extra.Compensator.LatestFirst = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.Compensator.LatestFirst.Value = val
			case "data.pipelineCron.extra.compensator.StopIfLatterExecuted":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted == nil {
					m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.extra.compensator.StopIfLatterExecuted.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted == nil {
					m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted.Value = val
			case "data.pipelineCron.extra.lastCompensateAt":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.LastCompensateAt == nil {
					m.Data.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.extra.lastCompensateAt.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.LastCompensateAt == nil {
					m.Data.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.LastCompensateAt.Seconds = val
			case "data.pipelineCron.extra.lastCompensateAt.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.LastCompensateAt == nil {
					m.Data.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.LastCompensateAt.Nanos = int32(val)
			case "data.pipelineCron.IsEdge":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.IsEdge == nil {
					m.Data.PipelineCron.IsEdge = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.IsEdge.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.IsEdge == nil {
					m.Data.PipelineCron.IsEdge = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.IsEdge.Value = val
			case "data.pipelineCron.clusterName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.ClusterName = vals[0]
			case "data.pipelineButton":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
			case "data.pipelineButton.canManualRun":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanManualRun = val
			case "data.pipelineButton.canCancel":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanCancel = val
			case "data.pipelineButton.canForceCancel":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanForceCancel = val
			case "data.pipelineButton.canRerun":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanRerun = val
			case "data.pipelineButton.canRerunFailed":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanRerunFailed = val
			case "data.pipelineButton.canStartCron":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanStartCron = val
			case "data.pipelineButton.canStopCron":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanStopCron = val
			case "data.pipelineButton.canPause":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanPause = val
			case "data.pipelineButton.canUnpause":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanUnpause = val
			case "data.pipelineButton.canDelete":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanDelete = val
			case "data.needApproval":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.NeedApproval = val
			}
		}
	}
	return nil
}

// PipelineCreateRequestV2 implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCreateRequestV2) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineYml":
				m.PipelineYml = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "namespace":
				m.Namespace = vals[0]
			case "pipelineYmlName":
				m.PipelineYmlName = vals[0]
			case "pipelineSource":
				m.PipelineSource = vals[0]
			case "configManageNamespaces":
				m.ConfigManageNamespaces = vals
			case "autoRun":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AutoRun = val
			case "forceRun":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.ForceRun = val
			case "autoRunAtOnce":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AutoRunAtOnce = val
			case "autoStartCron":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AutoStartCron = val
			case "cronStartFrom":
				if m.CronStartFrom == nil {
					m.CronStartFrom = &timestamppb.Timestamp{}
				}
			case "cronStartFrom.seconds":
				if m.CronStartFrom == nil {
					m.CronStartFrom = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CronStartFrom.Seconds = val
			case "cronStartFrom.nanos":
				if m.CronStartFrom == nil {
					m.CronStartFrom = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CronStartFrom.Nanos = int32(val)
			case "GC":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
			case "GC.resourceGC":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.ResourceGC == nil {
					m.GC.ResourceGC = &pb.PipelineResourceGC{}
				}
			case "GC.resourceGC.successTTLSecond":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.ResourceGC == nil {
					m.GC.ResourceGC = &pb.PipelineResourceGC{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GC.ResourceGC.SuccessTTLSecond = &val
			case "GC.resourceGC.failedTTLSecond":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.ResourceGC == nil {
					m.GC.ResourceGC = &pb.PipelineResourceGC{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GC.ResourceGC.FailedTTLSecond = &val
			case "GC.databaseGC":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.DatabaseGC == nil {
					m.GC.DatabaseGC = &pb.PipelineDatabaseGC{}
				}
			case "GC.databaseGC.analyzed":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.DatabaseGC == nil {
					m.GC.DatabaseGC = &pb.PipelineDatabaseGC{}
				}
				if m.GC.DatabaseGC.Analyzed == nil {
					m.GC.DatabaseGC.Analyzed = &pb.PipelineDBGCItem{}
				}
			case "GC.databaseGC.analyzed.needArchive":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.DatabaseGC == nil {
					m.GC.DatabaseGC = &pb.PipelineDatabaseGC{}
				}
				if m.GC.DatabaseGC.Analyzed == nil {
					m.GC.DatabaseGC.Analyzed = &pb.PipelineDBGCItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.GC.DatabaseGC.Analyzed.NeedArchive = &val
			case "GC.databaseGC.analyzed.TTLSecond":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.DatabaseGC == nil {
					m.GC.DatabaseGC = &pb.PipelineDatabaseGC{}
				}
				if m.GC.DatabaseGC.Analyzed == nil {
					m.GC.DatabaseGC.Analyzed = &pb.PipelineDBGCItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GC.DatabaseGC.Analyzed.TTLSecond = &val
			case "GC.databaseGC.finished":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.DatabaseGC == nil {
					m.GC.DatabaseGC = &pb.PipelineDatabaseGC{}
				}
				if m.GC.DatabaseGC.Finished == nil {
					m.GC.DatabaseGC.Finished = &pb.PipelineDBGCItem{}
				}
			case "GC.databaseGC.finished.needArchive":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.DatabaseGC == nil {
					m.GC.DatabaseGC = &pb.PipelineDatabaseGC{}
				}
				if m.GC.DatabaseGC.Finished == nil {
					m.GC.DatabaseGC.Finished = &pb.PipelineDBGCItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.GC.DatabaseGC.Finished.NeedArchive = &val
			case "GC.databaseGC.finished.TTLSecond":
				if m.GC == nil {
					m.GC = &pb.PipelineGC{}
				}
				if m.GC.DatabaseGC == nil {
					m.GC.DatabaseGC = &pb.PipelineDatabaseGC{}
				}
				if m.GC.DatabaseGC.Finished == nil {
					m.GC.DatabaseGC.Finished = &pb.PipelineDBGCItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GC.DatabaseGC.Finished.TTLSecond = &val
			case "bindQueue":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
			case "bindQueue.ID":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BindQueue.ID = val
			case "bindQueue.name":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				m.BindQueue.Name = vals[0]
			case "bindQueue.pipelineSource":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				m.BindQueue.PipelineSource = vals[0]
			case "bindQueue.clusterName":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				m.BindQueue.ClusterName = vals[0]
			case "bindQueue.scheduleStrategy":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				m.BindQueue.ScheduleStrategy = vals[0]
			case "bindQueue.mode":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				m.BindQueue.Mode = vals[0]
			case "bindQueue.priority":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BindQueue.Priority = val
			case "bindQueue.concurrency":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BindQueue.Concurrency = val
			case "bindQueue.maxCPU":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.BindQueue.MaxCPU = val
			case "bindQueue.maxMemoryMB":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.BindQueue.MaxMemoryMB = val
			case "bindQueue.timeCreated":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.TimeCreated == nil {
					m.BindQueue.TimeCreated = &timestamppb.Timestamp{}
				}
			case "bindQueue.timeCreated.seconds":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.TimeCreated == nil {
					m.BindQueue.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BindQueue.TimeCreated.Seconds = val
			case "bindQueue.timeCreated.nanos":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.TimeCreated == nil {
					m.BindQueue.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.BindQueue.TimeCreated.Nanos = int32(val)
			case "bindQueue.timeUpdated":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.TimeUpdated == nil {
					m.BindQueue.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "bindQueue.timeUpdated.seconds":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.TimeUpdated == nil {
					m.BindQueue.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BindQueue.TimeUpdated.Seconds = val
			case "bindQueue.timeUpdated.nanos":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.TimeUpdated == nil {
					m.BindQueue.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.BindQueue.TimeUpdated.Nanos = int32(val)
			case "bindQueue.usage":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.Usage == nil {
					m.BindQueue.Usage = &pb3.QueueUsage{}
				}
			case "bindQueue.usage.inUseCPU":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.Usage == nil {
					m.BindQueue.Usage = &pb3.QueueUsage{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.BindQueue.Usage.InUseCPU = val
			case "bindQueue.usage.inUseMemoryMB":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.Usage == nil {
					m.BindQueue.Usage = &pb3.QueueUsage{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.BindQueue.Usage.InUseMemoryMB = val
			case "bindQueue.usage.remainingCPU":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.Usage == nil {
					m.BindQueue.Usage = &pb3.QueueUsage{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.BindQueue.Usage.RemainingCPU = val
			case "bindQueue.usage.remainingMemoryMB":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.Usage == nil {
					m.BindQueue.Usage = &pb3.QueueUsage{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.BindQueue.Usage.RemainingMemoryMB = val
			case "bindQueue.usage.processingCount":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.Usage == nil {
					m.BindQueue.Usage = &pb3.QueueUsage{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BindQueue.Usage.ProcessingCount = val
			case "bindQueue.usage.pendingCount":
				if m.BindQueue == nil {
					m.BindQueue = &pb3.Queue{}
				}
				if m.BindQueue.Usage == nil {
					m.BindQueue.Usage = &pb3.QueueUsage{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BindQueue.Usage.PendingCount = val
			case "definitionID":
				m.DefinitionID = vals[0]
			case "ownerUser":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
			case "ownerUser.ID":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.OwnerUser.ID = val
					} else {
						m.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "ownerUser.ID.null_value":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.OwnerUser.ID = val
					} else {
						m.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "ownerUser.ID.number_value":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.OwnerUser.ID = val
					} else {
						m.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "ownerUser.ID.string_value":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.OwnerUser.ID = val
					} else {
						m.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "ownerUser.ID.bool_value":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.OwnerUser.ID = val
					} else {
						m.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "ownerUser.ID.struct_value":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.OwnerUser.ID = val
					} else {
						m.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "ownerUser.ID.list_value":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.OwnerUser.ID = val
					} else {
						m.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "ownerUser.name":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				m.OwnerUser.Name = vals[0]
			case "ownerUser.avatar":
				if m.OwnerUser == nil {
					m.OwnerUser = &pb.PipelineUser{}
				}
				m.OwnerUser.Avatar = vals[0]
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			}
		}
	}
	return nil
}

// PipelineCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branch":
				m.Branch = vals[0]
			case "source":
				m.Source = vals[0]
			case "pipelineYmlSource":
				m.PipelineYmlSource = vals[0]
			case "pipelineYmlName":
				m.PipelineYmlName = vals[0]
			case "pipelineYmlContent":
				m.PipelineYmlContent = vals[0]
			case "autoRun":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AutoRun = val
			case "callbackURLs":
				m.CallbackURLs = vals
			case "userID":
				m.UserID = vals[0]
			case "isCronTriggered":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsCronTriggered = val
			}
		}
	}
	return nil
}

// PipelineCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.source":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Source = vals[0]
			case "data.ymlName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlName = vals[0]
			case "data.namespace":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Namespace = vals[0]
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ClusterName = vals[0]
			case "data.status":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Status = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Type = vals[0]
			case "data.triggerMode":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.TriggerMode = vals[0]
			case "data.cronID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CronID = &val
			case "data.ymlSource":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlSource = vals[0]
			case "data.ymlContent":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlContent = vals[0]
			case "data.extra":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
			case "data.extra.diceWorkspace":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.DiceWorkspace = vals[0]
			case "data.extra.submitUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
			case "data.extra.submitUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Name = vals[0]
			case "data.extra.submitUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Avatar = vals[0]
			case "data.extra.runUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
			case "data.extra.runUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Name = vals[0]
			case "data.extra.runUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Avatar = vals[0]
			case "data.extra.cancelUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
			case "data.extra.cancelUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Name = vals[0]
			case "data.extra.cancelUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Avatar = vals[0]
			case "data.extra.cronExpr":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CronExpr = vals[0]
			case "data.extra.cronTriggerTime":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
			case "data.extra.cronTriggerTime.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Seconds = val
			case "data.extra.cronTriggerTime.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Nanos = int32(val)
			case "data.extra.show_message":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
			case "data.extra.show_message.msg":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Msg = vals[0]
			case "data.extra.show_message.stacks":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Stacks = vals
			case "data.extra.show_message.abortRun":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.ShowMessage.AbortRun = val
			case "data.extra.configManageNamespaces":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.ConfigManageNamespaces = vals
			case "data.extra.isAutoRun":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.IsAutoRun = val
			case "data.extra.callbackURLs":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CallbackURLs = vals
			case "data.extra.ownerUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
			case "data.extra.ownerUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Name = vals[0]
			case "data.extra.ownerUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Avatar = vals[0]
			case "data.extra.pipelineYmlNameV1":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.PipelineYmlNameV1 = vals[0]
			case "data.extra.breakpoint":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
			case "data.extra.breakpoint.on":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
			case "data.extra.breakpoint.on.failure":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.Breakpoint.On.Failure = val
			case "data.extra.breakpoint.timeout":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.orgName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.OrgName = vals[0]
			case "data.projectID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.projectName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ProjectName = vals[0]
			case "data.applicationID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ApplicationID = val
			case "data.applicationName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ApplicationName = vals[0]
			case "data.branch":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Branch = vals[0]
			case "data.commit":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Commit = vals[0]
			case "data.commitDetail":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
			case "data.commitDetail.commitID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.CommitID = vals[0]
			case "data.commitDetail.repo":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Repo = vals[0]
			case "data.commitDetail.repoAbbr":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.RepoAbbr = vals[0]
			case "data.commitDetail.author":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Author = vals[0]
			case "data.commitDetail.email":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Email = vals[0]
			case "data.commitDetail.time":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
			case "data.commitDetail.time.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Seconds = val
			case "data.commitDetail.time.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Nanos = int32(val)
			case "data.commitDetail.comment":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Comment = vals[0]
			case "data.progress":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.Progress = val
			case "data.costTimeSec":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CostTimeSec = val
			case "data.timeBegin":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
			case "data.timeBegin.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Seconds = val
			case "data.timeBegin.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Nanos = int32(val)
			case "data.timeEnd":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
			case "data.timeEnd.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Seconds = val
			case "data.timeEnd.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Nanos = int32(val)
			case "data.timeCreated":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
			case "data.timeCreated.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Seconds = val
			case "data.timeCreated.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Nanos = int32(val)
			case "data.timeUpdated":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "data.timeUpdated.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Seconds = val
			case "data.timeUpdated.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Nanos = int32(val)
			case "data.ymlNameV1":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlNameV1 = vals[0]
			}
		}
	}
	return nil
}

// PipelineBatchCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineBatchCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branch":
				m.Branch = vals[0]
			case "source":
				m.Source = vals[0]
			case "batchPipelineYmlPaths":
				m.BatchPipelineYmlPaths = vals
			case "autoRun":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AutoRun = val
			case "callbackURLs":
				m.CallbackURLs = vals
			case "userID":
				m.UserID = vals[0]
			}
		}
	}
	return nil
}

// PipelineBatchCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineBatchCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelinePagingRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelinePagingRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "branches":
				m.Branches = vals[0]
			case "sources":
				m.Sources = vals[0]
			case "ymlNames":
				m.YmlNames = vals[0]
			case "statuses":
				m.Statuses = vals[0]
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branch":
				m.Branch = vals
			case "source":
				m.Source = vals
			case "allSources":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AllSources = val
			case "ymlName":
				m.YmlName = vals
			case "status":
				m.Status = vals
			case "notStatus":
				m.NotStatus = vals
			case "triggerMode":
				m.TriggerMode = vals
			case "clusterName":
				m.ClusterName = vals
			case "includeSnippet":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IncludeSnippet = val
			case "startTimeBegin":
				if m.StartTimeBegin == nil {
					m.StartTimeBegin = &timestamppb.Timestamp{}
				}
			case "startTimeBegin.seconds":
				if m.StartTimeBegin == nil {
					m.StartTimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTimeBegin.Seconds = val
			case "startTimeBegin.nanos":
				if m.StartTimeBegin == nil {
					m.StartTimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.StartTimeBegin.Nanos = int32(val)
			case "startTimeBeginTimestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTimeBeginTimestamp = val
			case "startedAt":
				m.StartedAt = vals[0]
			case "endTimeBegin":
				if m.EndTimeBegin == nil {
					m.EndTimeBegin = &timestamppb.Timestamp{}
				}
			case "endTimeBegin.seconds":
				if m.EndTimeBegin == nil {
					m.EndTimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTimeBegin.Seconds = val
			case "endTimeBegin.nanos":
				if m.EndTimeBegin == nil {
					m.EndTimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.EndTimeBegin.Nanos = int32(val)
			case "endTimeBeginTimestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTimeBeginTimestamp = val
			case "endedAt":
				m.EndedAt = vals[0]
			case "startTimeCreated":
				if m.StartTimeCreated == nil {
					m.StartTimeCreated = &timestamppb.Timestamp{}
				}
			case "startTimeCreated.seconds":
				if m.StartTimeCreated == nil {
					m.StartTimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTimeCreated.Seconds = val
			case "startTimeCreated.nanos":
				if m.StartTimeCreated == nil {
					m.StartTimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.StartTimeCreated.Nanos = int32(val)
			case "startTimeCreatedTimestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTimeCreatedTimestamp = val
			case "endTimeCreated":
				if m.EndTimeCreated == nil {
					m.EndTimeCreated = &timestamppb.Timestamp{}
				}
			case "endTimeCreated.seconds":
				if m.EndTimeCreated == nil {
					m.EndTimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTimeCreated.Seconds = val
			case "endTimeCreated.nanos":
				if m.EndTimeCreated == nil {
					m.EndTimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.EndTimeCreated.Nanos = int32(val)
			case "endTimeCreatedTimestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTimeCreatedTimestamp = val
			case "mustMatchLabels":
				m.MustMatchLabels = vals[0]
			case "mustMatchLabel":
				m.MustMatchLabel = vals
			case "anyMatchLabels":
				m.AnyMatchLabels = vals[0]
			case "anyMatchLabel":
				m.AnyMatchLabel = vals
			case "pageNum":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNum = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "largePageSize":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.LargePageSize = val
			case "countOnly":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CountOnly = val
			case "selectCols":
				m.SelectCols = vals
			case "ascCols":
				m.AscCols = vals
			case "descCols":
				m.DescCols = vals
			case "startIDGt":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartIDGt = val
			case "endIDLt":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndIDLt = val
			case "pipelineDefinitionRequest":
				if m.PipelineDefinitionRequest == nil {
					m.PipelineDefinitionRequest = &PipelineDefinitionRequest{}
				}
			case "pipelineDefinitionRequest.name":
				if m.PipelineDefinitionRequest == nil {
					m.PipelineDefinitionRequest = &PipelineDefinitionRequest{}
				}
				m.PipelineDefinitionRequest.Name = vals[0]
			case "pipelineDefinitionRequest.creators":
				if m.PipelineDefinitionRequest == nil {
					m.PipelineDefinitionRequest = &PipelineDefinitionRequest{}
				}
				m.PipelineDefinitionRequest.Creators = vals
			case "pipelineDefinitionRequest.sourceRemotes":
				if m.PipelineDefinitionRequest == nil {
					m.PipelineDefinitionRequest = &PipelineDefinitionRequest{}
				}
				m.PipelineDefinitionRequest.SourceRemotes = vals
			case "pipelineDefinitionRequest.location":
				if m.PipelineDefinitionRequest == nil {
					m.PipelineDefinitionRequest = &PipelineDefinitionRequest{}
				}
				m.PipelineDefinitionRequest.Location = vals[0]
			case "pipelineDefinitionRequest.definitionID":
				if m.PipelineDefinitionRequest == nil {
					m.PipelineDefinitionRequest = &PipelineDefinitionRequest{}
				}
				m.PipelineDefinitionRequest.DefinitionID = vals[0]
			case "pipelineDefinition":
				m.PipelineDefinition = vals[0]
			}
		}
	}
	return nil
}

// PipelinePagingResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelinePagingResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PipelineListResponseData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &PipelineListResponseData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "data.currentPageSize":
				if m.Data == nil {
					m.Data = &PipelineListResponseData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CurrentPageSize = val
			}
		}
	}
	return nil
}

// PipelineListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *PipelineListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			case "currentPageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CurrentPageSize = val
			}
		}
	}
	return nil
}

// PagePipeline implement urlenc.URLValuesUnmarshaler.
func (m *PagePipeline) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "cronID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CronID = val
			case "commit":
				m.Commit = vals[0]
			case "source":
				m.Source = vals[0]
			case "ymlName":
				m.YmlName = vals[0]
			case "extra":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
			case "extra.diceWorkspace":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.DiceWorkspace = vals[0]
			case "extra.submitUser":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
			case "extra.submitUser.ID":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.ID.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.SubmitUser.ID = val
					} else {
						m.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.submitUser.name":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Extra.SubmitUser.Name = vals[0]
			case "extra.submitUser.avatar":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.SubmitUser == nil {
					m.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Extra.SubmitUser.Avatar = vals[0]
			case "extra.runUser":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
			case "extra.runUser.ID":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.ID.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.RunUser.ID = val
					} else {
						m.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.runUser.name":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Extra.RunUser.Name = vals[0]
			case "extra.runUser.avatar":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.RunUser == nil {
					m.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Extra.RunUser.Avatar = vals[0]
			case "extra.cancelUser":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
			case "extra.cancelUser.ID":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.ID.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.CancelUser.ID = val
					} else {
						m.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.cancelUser.name":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Extra.CancelUser.Name = vals[0]
			case "extra.cancelUser.avatar":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CancelUser == nil {
					m.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Extra.CancelUser.Avatar = vals[0]
			case "extra.cronExpr":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.CronExpr = vals[0]
			case "extra.cronTriggerTime":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CronTriggerTime == nil {
					m.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
			case "extra.cronTriggerTime.seconds":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CronTriggerTime == nil {
					m.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Extra.CronTriggerTime.Seconds = val
			case "extra.cronTriggerTime.nanos":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.CronTriggerTime == nil {
					m.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Extra.CronTriggerTime.Nanos = int32(val)
			case "extra.show_message":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.ShowMessage == nil {
					m.Extra.ShowMessage = &pb.ShowMessage{}
				}
			case "extra.show_message.msg":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.ShowMessage == nil {
					m.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Extra.ShowMessage.Msg = vals[0]
			case "extra.show_message.stacks":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.ShowMessage == nil {
					m.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Extra.ShowMessage.Stacks = vals
			case "extra.show_message.abortRun":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.ShowMessage == nil {
					m.Extra.ShowMessage = &pb.ShowMessage{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Extra.ShowMessage.AbortRun = val
			case "extra.configManageNamespaces":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.ConfigManageNamespaces = vals
			case "extra.isAutoRun":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Extra.IsAutoRun = val
			case "extra.callbackURLs":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.CallbackURLs = vals
			case "extra.ownerUser":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
			case "extra.ownerUser.ID":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.ID.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.OwnerUser.ID = val
					} else {
						m.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.ownerUser.name":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Extra.OwnerUser.Name = vals[0]
			case "extra.ownerUser.avatar":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.OwnerUser == nil {
					m.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Extra.OwnerUser.Avatar = vals[0]
			case "extra.pipelineYmlNameV1":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				m.Extra.PipelineYmlNameV1 = vals[0]
			case "extra.breakpoint":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
			case "extra.breakpoint.on":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Extra.Breakpoint.On == nil {
					m.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
			case "extra.breakpoint.on.failure":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Extra.Breakpoint.On == nil {
					m.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Extra.Breakpoint.On.Failure = val
			case "extra.breakpoint.timeout":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.null_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.number_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.string_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.bool_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.struct_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "extra.breakpoint.timeout.list_value":
				if m.Extra == nil {
					m.Extra = &pb.PipelineExtra{}
				}
				if m.Extra.Breakpoint == nil {
					m.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Extra.Breakpoint.Timeout = val
					} else {
						m.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "type":
				m.Type = vals[0]
			case "triggerMode":
				m.TriggerMode = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "status":
				m.Status = vals[0]
			case "progress":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Progress = val
			case "isSnippet":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsSnippet = val
			case "parentPipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ParentPipelineID = val
			case "parentTaskID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ParentTaskID = val
			case "costTimeSec":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CostTimeSec = val
			case "timeBegin":
				if m.TimeBegin == nil {
					m.TimeBegin = &timestamppb.Timestamp{}
				}
			case "timeBegin.seconds":
				if m.TimeBegin == nil {
					m.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeBegin.Seconds = val
			case "timeBegin.nanos":
				if m.TimeBegin == nil {
					m.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeBegin.Nanos = int32(val)
			case "timeEnd":
				if m.TimeEnd == nil {
					m.TimeEnd = &timestamppb.Timestamp{}
				}
			case "timeEnd.seconds":
				if m.TimeEnd == nil {
					m.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeEnd.Seconds = val
			case "timeEnd.nanos":
				if m.TimeEnd == nil {
					m.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeEnd.Nanos = int32(val)
			case "timeCreated":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
			case "timeCreated.seconds":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeCreated.Seconds = val
			case "timeCreated.nanos":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeCreated.Nanos = int32(val)
			case "timeUpdated":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "timeUpdated.seconds":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeUpdated.Seconds = val
			case "timeUpdated.nanos":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeUpdated.Nanos = int32(val)
			case "definitionPageInfo":
				if m.DefinitionPageInfo == nil {
					m.DefinitionPageInfo = &pb.DefinitionPageInfo{}
				}
			case "definitionPageInfo.name":
				if m.DefinitionPageInfo == nil {
					m.DefinitionPageInfo = &pb.DefinitionPageInfo{}
				}
				m.DefinitionPageInfo.Name = vals[0]
			case "definitionPageInfo.creator":
				if m.DefinitionPageInfo == nil {
					m.DefinitionPageInfo = &pb.DefinitionPageInfo{}
				}
				m.DefinitionPageInfo.Creator = vals[0]
			case "definitionPageInfo.executor":
				if m.DefinitionPageInfo == nil {
					m.DefinitionPageInfo = &pb.DefinitionPageInfo{}
				}
				m.DefinitionPageInfo.Executor = vals[0]
			case "definitionPageInfo.sourceRemote":
				if m.DefinitionPageInfo == nil {
					m.DefinitionPageInfo = &pb.DefinitionPageInfo{}
				}
				m.DefinitionPageInfo.SourceRemote = vals[0]
			case "definitionPageInfo.sourceRef":
				if m.DefinitionPageInfo == nil {
					m.DefinitionPageInfo = &pb.DefinitionPageInfo{}
				}
				m.DefinitionPageInfo.SourceRef = vals[0]
			}
		}
	}
	return nil
}

// PipelineDefinitionRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineDefinitionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "creators":
				m.Creators = vals
			case "sourceRemotes":
				m.SourceRemotes = vals
			case "location":
				m.Location = vals[0]
			case "definitionID":
				m.DefinitionID = vals[0]
			}
		}
	}
	return nil
}

// PipelineTaskOperateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTaskOperateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "taskID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TaskID = val
			case "taskAlias":
				m.TaskAlias = vals[0]
			case "disable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Disable = &val
			case "pause":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Pause = &val
			}
		}
	}
	return nil
}

// PipelineOperateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineOperateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			}
		}
	}
	return nil
}

// PipelineOperateResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineOperateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineRunRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRunRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			case "forceRun":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.ForceRun = val
			case "configManageNamespaces":
				m.ConfigManageNamespaces = vals
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			}
		}
	}
	return nil
}

// PipelineRunResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRunResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineCancelRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCancelRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			}
		}
	}
	return nil
}

// PipelineCancelResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCancelResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineRerunRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRerunRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			case "autoRunAtOnce":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AutoRunAtOnce = val
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			}
		}
	}
	return nil
}

// PipelineRerunResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRerunResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.source":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Source = vals[0]
			case "data.ymlName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlName = vals[0]
			case "data.namespace":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Namespace = vals[0]
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ClusterName = vals[0]
			case "data.status":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Status = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Type = vals[0]
			case "data.triggerMode":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.TriggerMode = vals[0]
			case "data.cronID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CronID = &val
			case "data.ymlSource":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlSource = vals[0]
			case "data.ymlContent":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlContent = vals[0]
			case "data.extra":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
			case "data.extra.diceWorkspace":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.DiceWorkspace = vals[0]
			case "data.extra.submitUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
			case "data.extra.submitUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Name = vals[0]
			case "data.extra.submitUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Avatar = vals[0]
			case "data.extra.runUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
			case "data.extra.runUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Name = vals[0]
			case "data.extra.runUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Avatar = vals[0]
			case "data.extra.cancelUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
			case "data.extra.cancelUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Name = vals[0]
			case "data.extra.cancelUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Avatar = vals[0]
			case "data.extra.cronExpr":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CronExpr = vals[0]
			case "data.extra.cronTriggerTime":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
			case "data.extra.cronTriggerTime.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Seconds = val
			case "data.extra.cronTriggerTime.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Nanos = int32(val)
			case "data.extra.show_message":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
			case "data.extra.show_message.msg":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Msg = vals[0]
			case "data.extra.show_message.stacks":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Stacks = vals
			case "data.extra.show_message.abortRun":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.ShowMessage.AbortRun = val
			case "data.extra.configManageNamespaces":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.ConfigManageNamespaces = vals
			case "data.extra.isAutoRun":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.IsAutoRun = val
			case "data.extra.callbackURLs":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CallbackURLs = vals
			case "data.extra.ownerUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
			case "data.extra.ownerUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Name = vals[0]
			case "data.extra.ownerUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Avatar = vals[0]
			case "data.extra.pipelineYmlNameV1":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.PipelineYmlNameV1 = vals[0]
			case "data.extra.breakpoint":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
			case "data.extra.breakpoint.on":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
			case "data.extra.breakpoint.on.failure":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.Breakpoint.On.Failure = val
			case "data.extra.breakpoint.timeout":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.orgName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.OrgName = vals[0]
			case "data.projectID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.projectName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ProjectName = vals[0]
			case "data.applicationID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ApplicationID = val
			case "data.applicationName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ApplicationName = vals[0]
			case "data.branch":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Branch = vals[0]
			case "data.commit":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Commit = vals[0]
			case "data.commitDetail":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
			case "data.commitDetail.commitID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.CommitID = vals[0]
			case "data.commitDetail.repo":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Repo = vals[0]
			case "data.commitDetail.repoAbbr":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.RepoAbbr = vals[0]
			case "data.commitDetail.author":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Author = vals[0]
			case "data.commitDetail.email":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Email = vals[0]
			case "data.commitDetail.time":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
			case "data.commitDetail.time.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Seconds = val
			case "data.commitDetail.time.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Nanos = int32(val)
			case "data.commitDetail.comment":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Comment = vals[0]
			case "data.progress":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.Progress = val
			case "data.costTimeSec":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CostTimeSec = val
			case "data.timeBegin":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
			case "data.timeBegin.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Seconds = val
			case "data.timeBegin.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Nanos = int32(val)
			case "data.timeEnd":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
			case "data.timeEnd.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Seconds = val
			case "data.timeEnd.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Nanos = int32(val)
			case "data.timeCreated":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
			case "data.timeCreated.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Seconds = val
			case "data.timeCreated.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Nanos = int32(val)
			case "data.timeUpdated":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "data.timeUpdated.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Seconds = val
			case "data.timeUpdated.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Nanos = int32(val)
			case "data.ymlNameV1":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlNameV1 = vals[0]
			}
		}
	}
	return nil
}

// PipelineRerunFailedRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRerunFailedRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			case "autoRunAtOnce":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AutoRunAtOnce = val
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			}
		}
	}
	return nil
}

// PipelineRerunFailedResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRerunFailedResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.source":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Source = vals[0]
			case "data.ymlName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlName = vals[0]
			case "data.namespace":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Namespace = vals[0]
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ClusterName = vals[0]
			case "data.status":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Status = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Type = vals[0]
			case "data.triggerMode":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.TriggerMode = vals[0]
			case "data.cronID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CronID = &val
			case "data.ymlSource":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlSource = vals[0]
			case "data.ymlContent":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlContent = vals[0]
			case "data.extra":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
			case "data.extra.diceWorkspace":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.DiceWorkspace = vals[0]
			case "data.extra.submitUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
			case "data.extra.submitUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Name = vals[0]
			case "data.extra.submitUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Avatar = vals[0]
			case "data.extra.runUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
			case "data.extra.runUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Name = vals[0]
			case "data.extra.runUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Avatar = vals[0]
			case "data.extra.cancelUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
			case "data.extra.cancelUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Name = vals[0]
			case "data.extra.cancelUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Avatar = vals[0]
			case "data.extra.cronExpr":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CronExpr = vals[0]
			case "data.extra.cronTriggerTime":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
			case "data.extra.cronTriggerTime.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Seconds = val
			case "data.extra.cronTriggerTime.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Nanos = int32(val)
			case "data.extra.show_message":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
			case "data.extra.show_message.msg":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Msg = vals[0]
			case "data.extra.show_message.stacks":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Stacks = vals
			case "data.extra.show_message.abortRun":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.ShowMessage.AbortRun = val
			case "data.extra.configManageNamespaces":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.ConfigManageNamespaces = vals
			case "data.extra.isAutoRun":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.IsAutoRun = val
			case "data.extra.callbackURLs":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CallbackURLs = vals
			case "data.extra.ownerUser":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
			case "data.extra.ownerUser.ID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.name":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Name = vals[0]
			case "data.extra.ownerUser.avatar":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Avatar = vals[0]
			case "data.extra.pipelineYmlNameV1":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.PipelineYmlNameV1 = vals[0]
			case "data.extra.breakpoint":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
			case "data.extra.breakpoint.on":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
			case "data.extra.breakpoint.on.failure":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.Breakpoint.On.Failure = val
			case "data.extra.breakpoint.timeout":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.null_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.number_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.string_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.bool_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.struct_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.list_value":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.orgName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.OrgName = vals[0]
			case "data.projectID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.projectName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ProjectName = vals[0]
			case "data.applicationID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ApplicationID = val
			case "data.applicationName":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.ApplicationName = vals[0]
			case "data.branch":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Branch = vals[0]
			case "data.commit":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.Commit = vals[0]
			case "data.commitDetail":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
			case "data.commitDetail.commitID":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.CommitID = vals[0]
			case "data.commitDetail.repo":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Repo = vals[0]
			case "data.commitDetail.repoAbbr":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.RepoAbbr = vals[0]
			case "data.commitDetail.author":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Author = vals[0]
			case "data.commitDetail.email":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Email = vals[0]
			case "data.commitDetail.time":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
			case "data.commitDetail.time.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Seconds = val
			case "data.commitDetail.time.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Nanos = int32(val)
			case "data.commitDetail.comment":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Comment = vals[0]
			case "data.progress":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.Progress = val
			case "data.costTimeSec":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CostTimeSec = val
			case "data.timeBegin":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
			case "data.timeBegin.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Seconds = val
			case "data.timeBegin.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Nanos = int32(val)
			case "data.timeEnd":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
			case "data.timeEnd.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Seconds = val
			case "data.timeEnd.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Nanos = int32(val)
			case "data.timeCreated":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
			case "data.timeCreated.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Seconds = val
			case "data.timeCreated.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Nanos = int32(val)
			case "data.timeUpdated":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "data.timeUpdated.seconds":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Seconds = val
			case "data.timeUpdated.nanos":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Nanos = int32(val)
			case "data.ymlNameV1":
				if m.Data == nil {
					m.Data = &pb.PipelineDTO{}
				}
				m.Data.YmlNameV1 = vals[0]
			}
		}
	}
	return nil
}

// PipelineStatisticRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineStatisticRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "source":
				m.Source = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			}
		}
	}
	return nil
}

// PipelineStatisticResponseData implement urlenc.URLValuesUnmarshaler.
func (m *PipelineStatisticResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "success":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Success = val
			case "processing":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Processing = val
			case "failed":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Failed = val
			case "completed":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Completed = val
			}
		}
	}
	return nil
}

// PipelineStatisticResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineStatisticResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PipelineStatisticResponseData{}
				}
			case "data.success":
				if m.Data == nil {
					m.Data = &PipelineStatisticResponseData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Success = val
			case "data.processing":
				if m.Data == nil {
					m.Data = &PipelineStatisticResponseData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Processing = val
			case "data.failed":
				if m.Data == nil {
					m.Data = &PipelineStatisticResponseData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Failed = val
			case "data.completed":
				if m.Data == nil {
					m.Data = &PipelineStatisticResponseData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Completed = val
			}
		}
	}
	return nil
}

// PipelineSnippetQueryRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineSnippetQueryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineSnippetQueryResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineSnippetQueryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// SnippetDetailQuery implement urlenc.URLValuesUnmarshaler.
func (m *SnippetDetailQuery) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "source":
				m.Source = vals[0]
			case "name":
				m.Name = vals[0]
			case "alias":
				m.Alias = vals[0]
			}
		}
	}
	return nil
}

// SnippetQueryDetail implement urlenc.URLValuesUnmarshaler.
func (m *SnippetQueryDetail) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "outputs":
				m.Outputs = vals
			}
		}
	}
	return nil
}

// PipelineCallbackRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCallbackRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "data":
				val, err := base64.StdEncoding.DecodeString(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// PipelineCallbackResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCallbackResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineTaskViewRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTaskViewRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			case "ymlNames":
				m.YmlNames = vals[0]
			case "sources":
				m.Sources = vals[0]
			}
		}
	}
	return nil
}

// PipelineTaskViewResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTaskViewResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.source":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Source = vals[0]
			case "data.ymlName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.YmlName = vals[0]
			case "data.namespace":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Namespace = vals[0]
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.ClusterName = vals[0]
			case "data.status":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Status = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Type = vals[0]
			case "data.triggerMode":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.TriggerMode = vals[0]
			case "data.cronID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CronID = &val
			case "data.ymlSource":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.YmlSource = vals[0]
			case "data.ymlContent":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.YmlContent = vals[0]
			case "data.extra":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
			case "data.extra.diceWorkspace":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.DiceWorkspace = vals[0]
			case "data.extra.submitUser":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
			case "data.extra.submitUser.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.ID.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.SubmitUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.SubmitUser.ID = val
					} else {
						m.Data.Extra.SubmitUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.submitUser.name":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Name = vals[0]
			case "data.extra.submitUser.avatar":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.SubmitUser == nil {
					m.Data.Extra.SubmitUser = &pb.PipelineUser{}
				}
				m.Data.Extra.SubmitUser.Avatar = vals[0]
			case "data.extra.runUser":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
			case "data.extra.runUser.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.ID.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.RunUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.RunUser.ID = val
					} else {
						m.Data.Extra.RunUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.runUser.name":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Name = vals[0]
			case "data.extra.runUser.avatar":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.RunUser == nil {
					m.Data.Extra.RunUser = &pb.PipelineUser{}
				}
				m.Data.Extra.RunUser.Avatar = vals[0]
			case "data.extra.cancelUser":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
			case "data.extra.cancelUser.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.ID.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.CancelUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.CancelUser.ID = val
					} else {
						m.Data.Extra.CancelUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.cancelUser.name":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Name = vals[0]
			case "data.extra.cancelUser.avatar":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CancelUser == nil {
					m.Data.Extra.CancelUser = &pb.PipelineUser{}
				}
				m.Data.Extra.CancelUser.Avatar = vals[0]
			case "data.extra.cronExpr":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CronExpr = vals[0]
			case "data.extra.cronTriggerTime":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
			case "data.extra.cronTriggerTime.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Seconds = val
			case "data.extra.cronTriggerTime.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.CronTriggerTime == nil {
					m.Data.Extra.CronTriggerTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Extra.CronTriggerTime.Nanos = int32(val)
			case "data.extra.show_message":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
			case "data.extra.show_message.msg":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Msg = vals[0]
			case "data.extra.show_message.stacks":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				m.Data.Extra.ShowMessage.Stacks = vals
			case "data.extra.show_message.abortRun":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.ShowMessage == nil {
					m.Data.Extra.ShowMessage = &pb.ShowMessage{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.ShowMessage.AbortRun = val
			case "data.extra.configManageNamespaces":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.ConfigManageNamespaces = vals
			case "data.extra.isAutoRun":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.IsAutoRun = val
			case "data.extra.callbackURLs":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.CallbackURLs = vals
			case "data.extra.ownerUser":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
			case "data.extra.ownerUser.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.ID.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.OwnerUser.ID = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.OwnerUser.ID = val
					} else {
						m.Data.Extra.OwnerUser.ID = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.ownerUser.name":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Name = vals[0]
			case "data.extra.ownerUser.avatar":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.OwnerUser == nil {
					m.Data.Extra.OwnerUser = &pb.PipelineUser{}
				}
				m.Data.Extra.OwnerUser.Avatar = vals[0]
			case "data.extra.pipelineYmlNameV1":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				m.Data.Extra.PipelineYmlNameV1 = vals[0]
			case "data.extra.breakpoint":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
			case "data.extra.breakpoint.on":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
			case "data.extra.breakpoint.on.failure":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if m.Data.Extra.Breakpoint.On == nil {
					m.Data.Extra.Breakpoint.On = &pb.BreakpointOn{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Extra.Breakpoint.On.Failure = val
			case "data.extra.breakpoint.timeout":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.null_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.number_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.string_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.bool_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.struct_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.extra.breakpoint.timeout.list_value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.Extra == nil {
					m.Data.Extra = &pb.PipelineExtra{}
				}
				if m.Data.Extra.Breakpoint == nil {
					m.Data.Extra.Breakpoint = &pb.Breakpoint{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Extra.Breakpoint.Timeout = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Extra.Breakpoint.Timeout = val
					} else {
						m.Data.Extra.Breakpoint.Timeout = structpb.NewStringValue(vals[0])
					}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.orgName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.OrgName = vals[0]
			case "data.projectID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.projectName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.ProjectName = vals[0]
			case "data.applicationID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ApplicationID = val
			case "data.applicationName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.ApplicationName = vals[0]
			case "data.branch":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Branch = vals[0]
			case "data.commit":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				m.Data.Commit = vals[0]
			case "data.commitDetail":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
			case "data.commitDetail.commitID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.CommitID = vals[0]
			case "data.commitDetail.repo":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Repo = vals[0]
			case "data.commitDetail.repoAbbr":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.RepoAbbr = vals[0]
			case "data.commitDetail.author":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Author = vals[0]
			case "data.commitDetail.email":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Email = vals[0]
			case "data.commitDetail.time":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
			case "data.commitDetail.time.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Seconds = val
			case "data.commitDetail.time.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				if m.Data.CommitDetail.Time == nil {
					m.Data.CommitDetail.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CommitDetail.Time.Nanos = int32(val)
			case "data.commitDetail.comment":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.CommitDetail == nil {
					m.Data.CommitDetail = &pb1.CommitDetail{}
				}
				m.Data.CommitDetail.Comment = vals[0]
			case "data.progress":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.Progress = val
			case "data.costTimeSec":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CostTimeSec = val
			case "data.timeBegin":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
			case "data.timeBegin.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Seconds = val
			case "data.timeBegin.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeBegin == nil {
					m.Data.TimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeBegin.Nanos = int32(val)
			case "data.timeEnd":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
			case "data.timeEnd.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Seconds = val
			case "data.timeEnd.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeEnd == nil {
					m.Data.TimeEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeEnd.Nanos = int32(val)
			case "data.timeCreated":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
			case "data.timeCreated.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Seconds = val
			case "data.timeCreated.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeCreated == nil {
					m.Data.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeCreated.Nanos = int32(val)
			case "data.timeUpdated":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "data.timeUpdated.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Seconds = val
			case "data.timeUpdated.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.TimeUpdated == nil {
					m.Data.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.TimeUpdated.Nanos = int32(val)
			case "data.pipelineCron":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
			case "data.pipelineCron.ID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.ID = val
			case "data.pipelineCron.timeCreated":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeCreated == nil {
					m.Data.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.timeCreated.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeCreated == nil {
					m.Data.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.TimeCreated.Seconds = val
			case "data.pipelineCron.timeCreated.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeCreated == nil {
					m.Data.PipelineCron.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.TimeCreated.Nanos = int32(val)
			case "data.pipelineCron.timeUpdated":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeUpdated == nil {
					m.Data.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.timeUpdated.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeUpdated == nil {
					m.Data.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.TimeUpdated.Seconds = val
			case "data.pipelineCron.timeUpdated.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.TimeUpdated == nil {
					m.Data.PipelineCron.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.TimeUpdated.Nanos = int32(val)
			case "data.pipelineCron.applicationID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.ApplicationID = val
			case "data.pipelineCron.branch":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.Branch = vals[0]
			case "data.pipelineCron.cronExpr":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.CronExpr = vals[0]
			case "data.pipelineCron.cronStartTime":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.CronStartTime == nil {
					m.Data.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.cronStartTime.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.CronStartTime == nil {
					m.Data.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.CronStartTime.Seconds = val
			case "data.pipelineCron.cronStartTime.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.CronStartTime == nil {
					m.Data.PipelineCron.CronStartTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.CronStartTime.Nanos = int32(val)
			case "data.pipelineCron.pipelineYmlName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.PipelineYmlName = vals[0]
			case "data.pipelineCron.basePipelineID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.BasePipelineID = val
			case "data.pipelineCron.enable":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Enable == nil {
					m.Data.PipelineCron.Enable = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.enable.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Enable == nil {
					m.Data.PipelineCron.Enable = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Enable.Value = val
			case "data.pipelineCron.pipelineYml":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.PipelineYml = vals[0]
			case "data.pipelineCron.configManageNamespaces":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.ConfigManageNamespaces = vals
			case "data.pipelineCron.userID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.UserID = vals[0]
			case "data.pipelineCron.orgID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.OrgID = val
			case "data.pipelineCron.pipelineDefinitionID":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.PipelineDefinitionID = vals[0]
			case "data.pipelineCron.pipelineSource":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.PipelineSource = vals[0]
			case "data.pipelineCron.extra":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
			case "data.pipelineCron.extra.pipelineYml":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.Data.PipelineCron.Extra.PipelineYml = vals[0]
			case "data.pipelineCron.extra.clusterName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.Data.PipelineCron.Extra.ClusterName = vals[0]
			case "data.pipelineCron.extra.configManageNamespaces":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.Data.PipelineCron.Extra.ConfigManageNamespaces = vals
			case "data.pipelineCron.extra.cronStartFrom":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.CronStartFrom == nil {
					m.Data.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.extra.cronStartFrom.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.CronStartFrom == nil {
					m.Data.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.CronStartFrom.Seconds = val
			case "data.pipelineCron.extra.cronStartFrom.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.CronStartFrom == nil {
					m.Data.PipelineCron.Extra.CronStartFrom = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.CronStartFrom.Nanos = int32(val)
			case "data.pipelineCron.extra.version":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				m.Data.PipelineCron.Extra.Version = vals[0]
			case "data.pipelineCron.extra.compensator":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
			case "data.pipelineCron.extra.compensator.enable":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.Enable == nil {
					m.Data.PipelineCron.Extra.Compensator.Enable = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.extra.compensator.enable.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.Enable == nil {
					m.Data.PipelineCron.Extra.Compensator.Enable = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.Compensator.Enable.Value = val
			case "data.pipelineCron.extra.compensator.LatestFirst":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.LatestFirst == nil {
					m.Data.PipelineCron.Extra.Compensator.LatestFirst = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.extra.compensator.LatestFirst.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.LatestFirst == nil {
					m.Data.PipelineCron.Extra.Compensator.LatestFirst = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.Compensator.LatestFirst.Value = val
			case "data.pipelineCron.extra.compensator.StopIfLatterExecuted":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted == nil {
					m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.extra.compensator.StopIfLatterExecuted.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.Compensator == nil {
					m.Data.PipelineCron.Extra.Compensator = &pb2.CronCompensator{}
				}
				if m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted == nil {
					m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.Compensator.StopIfLatterExecuted.Value = val
			case "data.pipelineCron.extra.lastCompensateAt":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.LastCompensateAt == nil {
					m.Data.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
			case "data.pipelineCron.extra.lastCompensateAt.seconds":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.LastCompensateAt == nil {
					m.Data.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.LastCompensateAt.Seconds = val
			case "data.pipelineCron.extra.lastCompensateAt.nanos":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.Extra == nil {
					m.Data.PipelineCron.Extra = &pb2.CronExtra{}
				}
				if m.Data.PipelineCron.Extra.LastCompensateAt == nil {
					m.Data.PipelineCron.Extra.LastCompensateAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PipelineCron.Extra.LastCompensateAt.Nanos = int32(val)
			case "data.pipelineCron.IsEdge":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.IsEdge == nil {
					m.Data.PipelineCron.IsEdge = &wrapperspb.BoolValue{}
				}
			case "data.pipelineCron.IsEdge.value":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				if m.Data.PipelineCron.IsEdge == nil {
					m.Data.PipelineCron.IsEdge = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineCron.IsEdge.Value = val
			case "data.pipelineCron.clusterName":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineCron == nil {
					m.Data.PipelineCron = &pb2.Cron{}
				}
				m.Data.PipelineCron.ClusterName = vals[0]
			case "data.pipelineButton":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
			case "data.pipelineButton.canManualRun":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanManualRun = val
			case "data.pipelineButton.canCancel":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanCancel = val
			case "data.pipelineButton.canForceCancel":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanForceCancel = val
			case "data.pipelineButton.canRerun":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanRerun = val
			case "data.pipelineButton.canRerunFailed":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanRerunFailed = val
			case "data.pipelineButton.canStartCron":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanStartCron = val
			case "data.pipelineButton.canStopCron":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanStopCron = val
			case "data.pipelineButton.canPause":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanPause = val
			case "data.pipelineButton.canUnpause":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanUnpause = val
			case "data.pipelineButton.canDelete":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				if m.Data.PipelineButton == nil {
					m.Data.PipelineButton = &pb.PipelineButton{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PipelineButton.CanDelete = val
			case "data.needApproval":
				if m.Data == nil {
					m.Data = &PipelineDetailDTO{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.NeedApproval = val
			}
		}
	}
	return nil
}
