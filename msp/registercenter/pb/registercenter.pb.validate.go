// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: registercenter.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ListInterfaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInterfaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInterfaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInterfaceRequestMultiError, or nil if none found.
func (m *ListInterfaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInterfaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := ListInterfaceRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := ListInterfaceRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	if utf8.RuneCountInString(m.GetTenantGroup()) < 1 {
		err := ListInterfaceRequestValidationError{
			field:  "TenantGroup",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return ListInterfaceRequestMultiError(errors)
	}

	return nil
}

// ListInterfaceRequestMultiError is an error wrapping multiple validation
// errors returned by ListInterfaceRequest.ValidateAll() if the designated
// constraints aren't met.
type ListInterfaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInterfaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInterfaceRequestMultiError) AllErrors() []error { return m }

// ListInterfaceRequestValidationError is the validation error returned by
// ListInterfaceRequest.Validate if the designated constraints aren't met.
type ListInterfaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInterfaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInterfaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInterfaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInterfaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInterfaceRequestValidationError) ErrorName() string {
	return "ListInterfaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListInterfaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInterfaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInterfaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInterfaceRequestValidationError{}

// Validate checks the field values on ListInterfaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInterfaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInterfaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInterfaceResponseMultiError, or nil if none found.
func (m *ListInterfaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInterfaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListInterfaceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListInterfaceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListInterfaceResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListInterfaceResponseMultiError(errors)
	}

	return nil
}

// ListInterfaceResponseMultiError is an error wrapping multiple validation
// errors returned by ListInterfaceResponse.ValidateAll() if the designated
// constraints aren't met.
type ListInterfaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInterfaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInterfaceResponseMultiError) AllErrors() []error { return m }

// ListInterfaceResponseValidationError is the validation error returned by
// ListInterfaceResponse.Validate if the designated constraints aren't met.
type ListInterfaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInterfaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInterfaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInterfaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInterfaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInterfaceResponseValidationError) ErrorName() string {
	return "ListInterfaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListInterfaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInterfaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInterfaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInterfaceResponseValidationError{}

// Validate checks the field values on GetHTTPServicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetHTTPServicesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHTTPServicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHTTPServicesRequestMultiError, or nil if none found.
func (m *GetHTTPServicesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHTTPServicesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := GetHTTPServicesRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := GetHTTPServicesRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := GetHTTPServicesRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NacosID

	// no validation rules for AppID

	if utf8.RuneCountInString(m.GetTenantGroup()) < 1 {
		err := GetHTTPServicesRequestValidationError{
			field:  "TenantGroup",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetHTTPServicesRequestMultiError(errors)
	}

	return nil
}

// GetHTTPServicesRequestMultiError is an error wrapping multiple validation
// errors returned by GetHTTPServicesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetHTTPServicesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHTTPServicesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHTTPServicesRequestMultiError) AllErrors() []error { return m }

// GetHTTPServicesRequestValidationError is the validation error returned by
// GetHTTPServicesRequest.Validate if the designated constraints aren't met.
type GetHTTPServicesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHTTPServicesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHTTPServicesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHTTPServicesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHTTPServicesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHTTPServicesRequestValidationError) ErrorName() string {
	return "GetHTTPServicesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetHTTPServicesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHTTPServicesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHTTPServicesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHTTPServicesRequestValidationError{}

// Validate checks the field values on GetHTTPServicesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetHTTPServicesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHTTPServicesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHTTPServicesResponseMultiError, or nil if none found.
func (m *GetHTTPServicesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHTTPServicesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetHTTPServicesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetHTTPServicesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetHTTPServicesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetHTTPServicesResponseMultiError(errors)
	}

	return nil
}

// GetHTTPServicesResponseMultiError is an error wrapping multiple validation
// errors returned by GetHTTPServicesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetHTTPServicesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHTTPServicesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHTTPServicesResponseMultiError) AllErrors() []error { return m }

// GetHTTPServicesResponseValidationError is the validation error returned by
// GetHTTPServicesResponse.Validate if the designated constraints aren't met.
type GetHTTPServicesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHTTPServicesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHTTPServicesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHTTPServicesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHTTPServicesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHTTPServicesResponseValidationError) ErrorName() string {
	return "GetHTTPServicesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetHTTPServicesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHTTPServicesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHTTPServicesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHTTPServicesResponseValidationError{}

// Validate checks the field values on EnableHTTPServiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnableHTTPServiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableHTTPServiceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnableHTTPServiceRequestMultiError, or nil if none found.
func (m *EnableHTTPServiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableHTTPServiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := EnableHTTPServiceRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := EnableHTTPServiceRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := EnableHTTPServiceRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for NacosID

	if utf8.RuneCountInString(m.GetTenantGroup()) < 1 {
		err := EnableHTTPServiceRequestValidationError{
			field:  "TenantGroup",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetService() == nil {
		err := EnableHTTPServiceRequestValidationError{
			field:  "Service",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnableHTTPServiceRequestValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnableHTTPServiceRequestValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnableHTTPServiceRequestValidationError{
				field:  "Service",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnableHTTPServiceRequestMultiError(errors)
	}

	return nil
}

// EnableHTTPServiceRequestMultiError is an error wrapping multiple validation
// errors returned by EnableHTTPServiceRequest.ValidateAll() if the designated
// constraints aren't met.
type EnableHTTPServiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableHTTPServiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableHTTPServiceRequestMultiError) AllErrors() []error { return m }

// EnableHTTPServiceRequestValidationError is the validation error returned by
// EnableHTTPServiceRequest.Validate if the designated constraints aren't met.
type EnableHTTPServiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableHTTPServiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableHTTPServiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableHTTPServiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableHTTPServiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableHTTPServiceRequestValidationError) ErrorName() string {
	return "EnableHTTPServiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EnableHTTPServiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableHTTPServiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableHTTPServiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableHTTPServiceRequestValidationError{}

// Validate checks the field values on EnableHTTPServiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnableHTTPServiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableHTTPServiceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnableHTTPServiceResponseMultiError, or nil if none found.
func (m *EnableHTTPServiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableHTTPServiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnableHTTPServiceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnableHTTPServiceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnableHTTPServiceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnableHTTPServiceResponseMultiError(errors)
	}

	return nil
}

// EnableHTTPServiceResponseMultiError is an error wrapping multiple validation
// errors returned by EnableHTTPServiceResponse.ValidateAll() if the
// designated constraints aren't met.
type EnableHTTPServiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableHTTPServiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableHTTPServiceResponseMultiError) AllErrors() []error { return m }

// EnableHTTPServiceResponseValidationError is the validation error returned by
// EnableHTTPServiceResponse.Validate if the designated constraints aren't met.
type EnableHTTPServiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableHTTPServiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableHTTPServiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableHTTPServiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableHTTPServiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableHTTPServiceResponseValidationError) ErrorName() string {
	return "EnableHTTPServiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EnableHTTPServiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableHTTPServiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableHTTPServiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableHTTPServiceResponseValidationError{}

// Validate checks the field values on EnableHTTPService with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnableHTTPService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableHTTPService with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnableHTTPServiceMultiError, or nil if none found.
func (m *EnableHTTPService) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableHTTPService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	// no validation rules for Address

	// no validation rules for Online

	if len(errors) > 0 {
		return EnableHTTPServiceMultiError(errors)
	}

	return nil
}

// EnableHTTPServiceMultiError is an error wrapping multiple validation errors
// returned by EnableHTTPService.ValidateAll() if the designated constraints
// aren't met.
type EnableHTTPServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableHTTPServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableHTTPServiceMultiError) AllErrors() []error { return m }

// EnableHTTPServiceValidationError is the validation error returned by
// EnableHTTPService.Validate if the designated constraints aren't met.
type EnableHTTPServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableHTTPServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableHTTPServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableHTTPServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableHTTPServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableHTTPServiceValidationError) ErrorName() string {
	return "EnableHTTPServiceValidationError"
}

// Error satisfies the builtin error interface
func (e EnableHTTPServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableHTTPService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableHTTPServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableHTTPServiceValidationError{}

// Validate checks the field values on GetRouteRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRouteRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRouteRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRouteRuleRequestMultiError, or nil if none found.
func (m *GetRouteRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRouteRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInterfaceName()) < 1 {
		err := GetRouteRuleRequestValidationError{
			field:  "InterfaceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := GetRouteRuleRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := GetRouteRuleRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return GetRouteRuleRequestMultiError(errors)
	}

	return nil
}

// GetRouteRuleRequestMultiError is an error wrapping multiple validation
// errors returned by GetRouteRuleRequest.ValidateAll() if the designated
// constraints aren't met.
type GetRouteRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRouteRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRouteRuleRequestMultiError) AllErrors() []error { return m }

// GetRouteRuleRequestValidationError is the validation error returned by
// GetRouteRuleRequest.Validate if the designated constraints aren't met.
type GetRouteRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRouteRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRouteRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRouteRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRouteRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRouteRuleRequestValidationError) ErrorName() string {
	return "GetRouteRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRouteRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRouteRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRouteRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRouteRuleRequestValidationError{}

// Validate checks the field values on GetRouteRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRouteRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRouteRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRouteRuleResponseMultiError, or nil if none found.
func (m *GetRouteRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRouteRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRouteRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRouteRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRouteRuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRouteRuleResponseMultiError(errors)
	}

	return nil
}

// GetRouteRuleResponseMultiError is an error wrapping multiple validation
// errors returned by GetRouteRuleResponse.ValidateAll() if the designated
// constraints aren't met.
type GetRouteRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRouteRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRouteRuleResponseMultiError) AllErrors() []error { return m }

// GetRouteRuleResponseValidationError is the validation error returned by
// GetRouteRuleResponse.Validate if the designated constraints aren't met.
type GetRouteRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRouteRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRouteRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRouteRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRouteRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRouteRuleResponseValidationError) ErrorName() string {
	return "GetRouteRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRouteRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRouteRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRouteRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRouteRuleResponseValidationError{}

// Validate checks the field values on CreateRouteRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRouteRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRouteRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRouteRuleRequestMultiError, or nil if none found.
func (m *CreateRouteRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRouteRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInterfaceName()) < 1 {
		err := CreateRouteRuleRequestValidationError{
			field:  "InterfaceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := CreateRouteRuleRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := CreateRouteRuleRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if m.GetRule() == nil {
		err := CreateRouteRuleRequestValidationError{
			field:  "Rule",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRouteRuleRequestValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRouteRuleRequestValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRouteRuleRequestValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRouteRuleRequestMultiError(errors)
	}

	return nil
}

// CreateRouteRuleRequestMultiError is an error wrapping multiple validation
// errors returned by CreateRouteRuleRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateRouteRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRouteRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRouteRuleRequestMultiError) AllErrors() []error { return m }

// CreateRouteRuleRequestValidationError is the validation error returned by
// CreateRouteRuleRequest.Validate if the designated constraints aren't met.
type CreateRouteRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRouteRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRouteRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRouteRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRouteRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRouteRuleRequestValidationError) ErrorName() string {
	return "CreateRouteRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRouteRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRouteRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRouteRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRouteRuleRequestValidationError{}

// Validate checks the field values on CreateRouteRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateRouteRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRouteRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRouteRuleResponseMultiError, or nil if none found.
func (m *CreateRouteRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRouteRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRouteRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRouteRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRouteRuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRouteRuleResponseMultiError(errors)
	}

	return nil
}

// CreateRouteRuleResponseMultiError is an error wrapping multiple validation
// errors returned by CreateRouteRuleResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateRouteRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRouteRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRouteRuleResponseMultiError) AllErrors() []error { return m }

// CreateRouteRuleResponseValidationError is the validation error returned by
// CreateRouteRuleResponse.Validate if the designated constraints aren't met.
type CreateRouteRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRouteRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRouteRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRouteRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRouteRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRouteRuleResponseValidationError) ErrorName() string {
	return "CreateRouteRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRouteRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRouteRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRouteRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRouteRuleResponseValidationError{}

// Validate checks the field values on DeleteRouteRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRouteRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRouteRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRouteRuleRequestMultiError, or nil if none found.
func (m *DeleteRouteRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRouteRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInterfaceName()) < 1 {
		err := DeleteRouteRuleRequestValidationError{
			field:  "InterfaceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := DeleteRouteRuleRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := DeleteRouteRuleRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return DeleteRouteRuleRequestMultiError(errors)
	}

	return nil
}

// DeleteRouteRuleRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteRouteRuleRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteRouteRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRouteRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRouteRuleRequestMultiError) AllErrors() []error { return m }

// DeleteRouteRuleRequestValidationError is the validation error returned by
// DeleteRouteRuleRequest.Validate if the designated constraints aren't met.
type DeleteRouteRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRouteRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRouteRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRouteRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRouteRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRouteRuleRequestValidationError) ErrorName() string {
	return "DeleteRouteRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRouteRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRouteRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRouteRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRouteRuleRequestValidationError{}

// Validate checks the field values on DeleteRouteRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRouteRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRouteRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRouteRuleResponseMultiError, or nil if none found.
func (m *DeleteRouteRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRouteRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRouteRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRouteRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRouteRuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteRouteRuleResponseMultiError(errors)
	}

	return nil
}

// DeleteRouteRuleResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteRouteRuleResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteRouteRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRouteRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRouteRuleResponseMultiError) AllErrors() []error { return m }

// DeleteRouteRuleResponseValidationError is the validation error returned by
// DeleteRouteRuleResponse.Validate if the designated constraints aren't met.
type DeleteRouteRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRouteRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRouteRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRouteRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRouteRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRouteRuleResponseValidationError) ErrorName() string {
	return "DeleteRouteRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRouteRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRouteRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRouteRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRouteRuleResponseValidationError{}

// Validate checks the field values on CetHostRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CetHostRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CetHostRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CetHostRuleRequestMultiError, or nil if none found.
func (m *CetHostRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CetHostRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := CetHostRuleRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := CetHostRuleRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return CetHostRuleRequestMultiError(errors)
	}

	return nil
}

// CetHostRuleRequestMultiError is an error wrapping multiple validation errors
// returned by CetHostRuleRequest.ValidateAll() if the designated constraints
// aren't met.
type CetHostRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CetHostRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CetHostRuleRequestMultiError) AllErrors() []error { return m }

// CetHostRuleRequestValidationError is the validation error returned by
// CetHostRuleRequest.Validate if the designated constraints aren't met.
type CetHostRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CetHostRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CetHostRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CetHostRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CetHostRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CetHostRuleRequestValidationError) ErrorName() string {
	return "CetHostRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CetHostRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCetHostRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CetHostRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CetHostRuleRequestValidationError{}

// Validate checks the field values on CetHostRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CetHostRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CetHostRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CetHostRuleResponseMultiError, or nil if none found.
func (m *CetHostRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CetHostRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CetHostRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CetHostRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CetHostRuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CetHostRuleResponseMultiError(errors)
	}

	return nil
}

// CetHostRuleResponseMultiError is an error wrapping multiple validation
// errors returned by CetHostRuleResponse.ValidateAll() if the designated
// constraints aren't met.
type CetHostRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CetHostRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CetHostRuleResponseMultiError) AllErrors() []error { return m }

// CetHostRuleResponseValidationError is the validation error returned by
// CetHostRuleResponse.Validate if the designated constraints aren't met.
type CetHostRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CetHostRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CetHostRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CetHostRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CetHostRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CetHostRuleResponseValidationError) ErrorName() string {
	return "CetHostRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CetHostRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCetHostRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CetHostRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CetHostRuleResponseValidationError{}

// Validate checks the field values on CreateHostRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateHostRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateHostRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateHostRuleRequestMultiError, or nil if none found.
func (m *CreateHostRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateHostRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := CreateHostRuleRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := CreateHostRuleRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if m.GetRules() == nil {
		err := CreateHostRuleRequestValidationError{
			field:  "Rules",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateHostRuleRequestValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateHostRuleRequestValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateHostRuleRequestValidationError{
				field:  "Rules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateHostRuleRequestMultiError(errors)
	}

	return nil
}

// CreateHostRuleRequestMultiError is an error wrapping multiple validation
// errors returned by CreateHostRuleRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateHostRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateHostRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateHostRuleRequestMultiError) AllErrors() []error { return m }

// CreateHostRuleRequestValidationError is the validation error returned by
// CreateHostRuleRequest.Validate if the designated constraints aren't met.
type CreateHostRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateHostRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateHostRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateHostRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateHostRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateHostRuleRequestValidationError) ErrorName() string {
	return "CreateHostRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateHostRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateHostRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateHostRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateHostRuleRequestValidationError{}

// Validate checks the field values on CreateHostRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateHostRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateHostRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateHostRuleResponseMultiError, or nil if none found.
func (m *CreateHostRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateHostRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateHostRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateHostRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateHostRuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateHostRuleResponseMultiError(errors)
	}

	return nil
}

// CreateHostRuleResponseMultiError is an error wrapping multiple validation
// errors returned by CreateHostRuleResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateHostRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateHostRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateHostRuleResponseMultiError) AllErrors() []error { return m }

// CreateHostRuleResponseValidationError is the validation error returned by
// CreateHostRuleResponse.Validate if the designated constraints aren't met.
type CreateHostRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateHostRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateHostRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateHostRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateHostRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateHostRuleResponseValidationError) ErrorName() string {
	return "CreateHostRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateHostRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateHostRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateHostRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateHostRuleResponseValidationError{}

// Validate checks the field values on DeleteHostRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteHostRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteHostRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteHostRuleRequestMultiError, or nil if none found.
func (m *DeleteHostRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteHostRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := DeleteHostRuleRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := DeleteHostRuleRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return DeleteHostRuleRequestMultiError(errors)
	}

	return nil
}

// DeleteHostRuleRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteHostRuleRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteHostRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteHostRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteHostRuleRequestMultiError) AllErrors() []error { return m }

// DeleteHostRuleRequestValidationError is the validation error returned by
// DeleteHostRuleRequest.Validate if the designated constraints aren't met.
type DeleteHostRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteHostRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteHostRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteHostRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteHostRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteHostRuleRequestValidationError) ErrorName() string {
	return "DeleteHostRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteHostRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteHostRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteHostRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteHostRuleRequestValidationError{}

// Validate checks the field values on DeleteHostRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteHostRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteHostRuleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteHostRuleResponseMultiError, or nil if none found.
func (m *DeleteHostRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteHostRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteHostRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteHostRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteHostRuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteHostRuleResponseMultiError(errors)
	}

	return nil
}

// DeleteHostRuleResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteHostRuleResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteHostRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteHostRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteHostRuleResponseMultiError) AllErrors() []error { return m }

// DeleteHostRuleResponseValidationError is the validation error returned by
// DeleteHostRuleResponse.Validate if the designated constraints aren't met.
type DeleteHostRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteHostRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteHostRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteHostRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteHostRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteHostRuleResponseValidationError) ErrorName() string {
	return "DeleteHostRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteHostRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteHostRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteHostRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteHostRuleResponseValidationError{}

// Validate checks the field values on GetHostRuntimeRuleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetHostRuntimeRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHostRuntimeRuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHostRuntimeRuleRequestMultiError, or nil if none found.
func (m *GetHostRuntimeRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHostRuntimeRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := GetHostRuntimeRuleRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := GetHostRuntimeRuleRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetHost()) < 1 {
		err := GetHostRuntimeRuleRequestValidationError{
			field:  "Host",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return GetHostRuntimeRuleRequestMultiError(errors)
	}

	return nil
}

// GetHostRuntimeRuleRequestMultiError is an error wrapping multiple validation
// errors returned by GetHostRuntimeRuleRequest.ValidateAll() if the
// designated constraints aren't met.
type GetHostRuntimeRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHostRuntimeRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHostRuntimeRuleRequestMultiError) AllErrors() []error { return m }

// GetHostRuntimeRuleRequestValidationError is the validation error returned by
// GetHostRuntimeRuleRequest.Validate if the designated constraints aren't met.
type GetHostRuntimeRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHostRuntimeRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHostRuntimeRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHostRuntimeRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHostRuntimeRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHostRuntimeRuleRequestValidationError) ErrorName() string {
	return "GetHostRuntimeRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetHostRuntimeRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHostRuntimeRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHostRuntimeRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHostRuntimeRuleRequestValidationError{}

// Validate checks the field values on GetHostRuntimeRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetHostRuntimeRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHostRuntimeRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHostRuntimeRuleResponseMultiError, or nil if none found.
func (m *GetHostRuntimeRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHostRuntimeRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetHostRuntimeRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetHostRuntimeRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetHostRuntimeRuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetHostRuntimeRuleResponseMultiError(errors)
	}

	return nil
}

// GetHostRuntimeRuleResponseMultiError is an error wrapping multiple
// validation errors returned by GetHostRuntimeRuleResponse.ValidateAll() if
// the designated constraints aren't met.
type GetHostRuntimeRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHostRuntimeRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHostRuntimeRuleResponseMultiError) AllErrors() []error { return m }

// GetHostRuntimeRuleResponseValidationError is the validation error returned
// by GetHostRuntimeRuleResponse.Validate if the designated constraints aren't met.
type GetHostRuntimeRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHostRuntimeRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHostRuntimeRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHostRuntimeRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHostRuntimeRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHostRuntimeRuleResponseValidationError) ErrorName() string {
	return "GetHostRuntimeRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetHostRuntimeRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHostRuntimeRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHostRuntimeRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHostRuntimeRuleResponseValidationError{}

// Validate checks the field values on CreateHostRuntimeRuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateHostRuntimeRuleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateHostRuntimeRuleRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateHostRuntimeRuleRequestMultiError, or nil if none found.
func (m *CreateHostRuntimeRuleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateHostRuntimeRuleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := CreateHostRuntimeRuleRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := CreateHostRuntimeRuleRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetHost()) < 1 {
		err := CreateHostRuntimeRuleRequestValidationError{
			field:  "Host",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if m.GetRules() == nil {
		err := CreateHostRuntimeRuleRequestValidationError{
			field:  "Rules",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRules()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateHostRuntimeRuleRequestValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateHostRuntimeRuleRequestValidationError{
					field:  "Rules",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRules()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateHostRuntimeRuleRequestValidationError{
				field:  "Rules",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateHostRuntimeRuleRequestMultiError(errors)
	}

	return nil
}

// CreateHostRuntimeRuleRequestMultiError is an error wrapping multiple
// validation errors returned by CreateHostRuntimeRuleRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateHostRuntimeRuleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateHostRuntimeRuleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateHostRuntimeRuleRequestMultiError) AllErrors() []error { return m }

// CreateHostRuntimeRuleRequestValidationError is the validation error returned
// by CreateHostRuntimeRuleRequest.Validate if the designated constraints
// aren't met.
type CreateHostRuntimeRuleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateHostRuntimeRuleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateHostRuntimeRuleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateHostRuntimeRuleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateHostRuntimeRuleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateHostRuntimeRuleRequestValidationError) ErrorName() string {
	return "CreateHostRuntimeRuleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateHostRuntimeRuleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateHostRuntimeRuleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateHostRuntimeRuleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateHostRuntimeRuleRequestValidationError{}

// Validate checks the field values on CreateHostRuntimeRuleResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateHostRuntimeRuleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateHostRuntimeRuleResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateHostRuntimeRuleResponseMultiError, or nil if none found.
func (m *CreateHostRuntimeRuleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateHostRuntimeRuleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateHostRuntimeRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateHostRuntimeRuleResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateHostRuntimeRuleResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateHostRuntimeRuleResponseMultiError(errors)
	}

	return nil
}

// CreateHostRuntimeRuleResponseMultiError is an error wrapping multiple
// validation errors returned by CreateHostRuntimeRuleResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateHostRuntimeRuleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateHostRuntimeRuleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateHostRuntimeRuleResponseMultiError) AllErrors() []error { return m }

// CreateHostRuntimeRuleResponseValidationError is the validation error
// returned by CreateHostRuntimeRuleResponse.Validate if the designated
// constraints aren't met.
type CreateHostRuntimeRuleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateHostRuntimeRuleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateHostRuntimeRuleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateHostRuntimeRuleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateHostRuntimeRuleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateHostRuntimeRuleResponseValidationError) ErrorName() string {
	return "CreateHostRuntimeRuleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateHostRuntimeRuleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateHostRuntimeRuleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateHostRuntimeRuleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateHostRuntimeRuleResponseValidationError{}

// Validate checks the field values on GetAllHostRuntimeRulesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllHostRuntimeRulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllHostRuntimeRulesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetAllHostRuntimeRulesRequestMultiError, or nil if none found.
func (m *GetAllHostRuntimeRulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllHostRuntimeRulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := GetAllHostRuntimeRulesRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := GetAllHostRuntimeRulesRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return GetAllHostRuntimeRulesRequestMultiError(errors)
	}

	return nil
}

// GetAllHostRuntimeRulesRequestMultiError is an error wrapping multiple
// validation errors returned by GetAllHostRuntimeRulesRequest.ValidateAll()
// if the designated constraints aren't met.
type GetAllHostRuntimeRulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllHostRuntimeRulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllHostRuntimeRulesRequestMultiError) AllErrors() []error { return m }

// GetAllHostRuntimeRulesRequestValidationError is the validation error
// returned by GetAllHostRuntimeRulesRequest.Validate if the designated
// constraints aren't met.
type GetAllHostRuntimeRulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllHostRuntimeRulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllHostRuntimeRulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllHostRuntimeRulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllHostRuntimeRulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllHostRuntimeRulesRequestValidationError) ErrorName() string {
	return "GetAllHostRuntimeRulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllHostRuntimeRulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllHostRuntimeRulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllHostRuntimeRulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllHostRuntimeRulesRequestValidationError{}

// Validate checks the field values on GetAllHostRuntimeRulesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllHostRuntimeRulesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllHostRuntimeRulesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetAllHostRuntimeRulesResponseMultiError, or nil if none found.
func (m *GetAllHostRuntimeRulesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllHostRuntimeRulesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAllHostRuntimeRulesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAllHostRuntimeRulesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAllHostRuntimeRulesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAllHostRuntimeRulesResponseMultiError(errors)
	}

	return nil
}

// GetAllHostRuntimeRulesResponseMultiError is an error wrapping multiple
// validation errors returned by GetAllHostRuntimeRulesResponse.ValidateAll()
// if the designated constraints aren't met.
type GetAllHostRuntimeRulesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllHostRuntimeRulesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllHostRuntimeRulesResponseMultiError) AllErrors() []error { return m }

// GetAllHostRuntimeRulesResponseValidationError is the validation error
// returned by GetAllHostRuntimeRulesResponse.Validate if the designated
// constraints aren't met.
type GetAllHostRuntimeRulesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllHostRuntimeRulesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllHostRuntimeRulesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllHostRuntimeRulesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllHostRuntimeRulesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllHostRuntimeRulesResponseValidationError) ErrorName() string {
	return "GetAllHostRuntimeRulesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllHostRuntimeRulesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllHostRuntimeRulesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllHostRuntimeRulesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllHostRuntimeRulesResponseValidationError{}

// Validate checks the field values on GetDubboInterfaceTimeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDubboInterfaceTimeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDubboInterfaceTimeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDubboInterfaceTimeRequestMultiError, or nil if none found.
func (m *GetDubboInterfaceTimeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDubboInterfaceTimeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInterfaceName()) < 1 {
		err := GetDubboInterfaceTimeRequestValidationError{
			field:  "InterfaceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := GetDubboInterfaceTimeRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := GetDubboInterfaceTimeRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	if len(errors) > 0 {
		return GetDubboInterfaceTimeRequestMultiError(errors)
	}

	return nil
}

// GetDubboInterfaceTimeRequestMultiError is an error wrapping multiple
// validation errors returned by GetDubboInterfaceTimeRequest.ValidateAll() if
// the designated constraints aren't met.
type GetDubboInterfaceTimeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDubboInterfaceTimeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDubboInterfaceTimeRequestMultiError) AllErrors() []error { return m }

// GetDubboInterfaceTimeRequestValidationError is the validation error returned
// by GetDubboInterfaceTimeRequest.Validate if the designated constraints
// aren't met.
type GetDubboInterfaceTimeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDubboInterfaceTimeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDubboInterfaceTimeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDubboInterfaceTimeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDubboInterfaceTimeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDubboInterfaceTimeRequestValidationError) ErrorName() string {
	return "GetDubboInterfaceTimeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDubboInterfaceTimeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDubboInterfaceTimeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDubboInterfaceTimeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDubboInterfaceTimeRequestValidationError{}

// Validate checks the field values on GetDubboInterfaceTimeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDubboInterfaceTimeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDubboInterfaceTimeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDubboInterfaceTimeResponseMultiError, or nil if none found.
func (m *GetDubboInterfaceTimeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDubboInterfaceTimeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDubboInterfaceTimeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDubboInterfaceTimeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDubboInterfaceTimeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDubboInterfaceTimeResponseMultiError(errors)
	}

	return nil
}

// GetDubboInterfaceTimeResponseMultiError is an error wrapping multiple
// validation errors returned by GetDubboInterfaceTimeResponse.ValidateAll()
// if the designated constraints aren't met.
type GetDubboInterfaceTimeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDubboInterfaceTimeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDubboInterfaceTimeResponseMultiError) AllErrors() []error { return m }

// GetDubboInterfaceTimeResponseValidationError is the validation error
// returned by GetDubboInterfaceTimeResponse.Validate if the designated
// constraints aren't met.
type GetDubboInterfaceTimeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDubboInterfaceTimeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDubboInterfaceTimeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDubboInterfaceTimeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDubboInterfaceTimeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDubboInterfaceTimeResponseValidationError) ErrorName() string {
	return "GetDubboInterfaceTimeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDubboInterfaceTimeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDubboInterfaceTimeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDubboInterfaceTimeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDubboInterfaceTimeResponseValidationError{}

// Validate checks the field values on DubboInterfaceTime with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DubboInterfaceTime) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DubboInterfaceTime with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DubboInterfaceTimeMultiError, or nil if none found.
func (m *DubboInterfaceTime) ValidateAll() error {
	return m.validate(true)
}

func (m *DubboInterfaceTime) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProviderTime

	// no validation rules for ConsumerTime

	if len(errors) > 0 {
		return DubboInterfaceTimeMultiError(errors)
	}

	return nil
}

// DubboInterfaceTimeMultiError is an error wrapping multiple validation errors
// returned by DubboInterfaceTime.ValidateAll() if the designated constraints
// aren't met.
type DubboInterfaceTimeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DubboInterfaceTimeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DubboInterfaceTimeMultiError) AllErrors() []error { return m }

// DubboInterfaceTimeValidationError is the validation error returned by
// DubboInterfaceTime.Validate if the designated constraints aren't met.
type DubboInterfaceTimeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DubboInterfaceTimeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DubboInterfaceTimeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DubboInterfaceTimeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DubboInterfaceTimeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DubboInterfaceTimeValidationError) ErrorName() string {
	return "DubboInterfaceTimeValidationError"
}

// Error satisfies the builtin error interface
func (e DubboInterfaceTimeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDubboInterfaceTime.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DubboInterfaceTimeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DubboInterfaceTimeValidationError{}

// Validate checks the field values on GetDubboInterfaceQPSRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDubboInterfaceQPSRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDubboInterfaceQPSRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDubboInterfaceQPSRequestMultiError, or nil if none found.
func (m *GetDubboInterfaceQPSRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDubboInterfaceQPSRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInterfaceName()) < 1 {
		err := GetDubboInterfaceQPSRequestValidationError{
			field:  "InterfaceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := GetDubboInterfaceQPSRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := GetDubboInterfaceQPSRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for Point

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	if len(errors) > 0 {
		return GetDubboInterfaceQPSRequestMultiError(errors)
	}

	return nil
}

// GetDubboInterfaceQPSRequestMultiError is an error wrapping multiple
// validation errors returned by GetDubboInterfaceQPSRequest.ValidateAll() if
// the designated constraints aren't met.
type GetDubboInterfaceQPSRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDubboInterfaceQPSRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDubboInterfaceQPSRequestMultiError) AllErrors() []error { return m }

// GetDubboInterfaceQPSRequestValidationError is the validation error returned
// by GetDubboInterfaceQPSRequest.Validate if the designated constraints
// aren't met.
type GetDubboInterfaceQPSRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDubboInterfaceQPSRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDubboInterfaceQPSRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDubboInterfaceQPSRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDubboInterfaceQPSRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDubboInterfaceQPSRequestValidationError) ErrorName() string {
	return "GetDubboInterfaceQPSRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDubboInterfaceQPSRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDubboInterfaceQPSRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDubboInterfaceQPSRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDubboInterfaceQPSRequestValidationError{}

// Validate checks the field values on GetDubboInterfaceQPSResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDubboInterfaceQPSResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDubboInterfaceQPSResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDubboInterfaceQPSResponseMultiError, or nil if none found.
func (m *GetDubboInterfaceQPSResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDubboInterfaceQPSResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDubboInterfaceQPSResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDubboInterfaceQPSResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDubboInterfaceQPSResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDubboInterfaceQPSResponseMultiError(errors)
	}

	return nil
}

// GetDubboInterfaceQPSResponseMultiError is an error wrapping multiple
// validation errors returned by GetDubboInterfaceQPSResponse.ValidateAll() if
// the designated constraints aren't met.
type GetDubboInterfaceQPSResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDubboInterfaceQPSResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDubboInterfaceQPSResponseMultiError) AllErrors() []error { return m }

// GetDubboInterfaceQPSResponseValidationError is the validation error returned
// by GetDubboInterfaceQPSResponse.Validate if the designated constraints
// aren't met.
type GetDubboInterfaceQPSResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDubboInterfaceQPSResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDubboInterfaceQPSResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDubboInterfaceQPSResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDubboInterfaceQPSResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDubboInterfaceQPSResponseValidationError) ErrorName() string {
	return "GetDubboInterfaceQPSResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDubboInterfaceQPSResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDubboInterfaceQPSResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDubboInterfaceQPSResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDubboInterfaceQPSResponseValidationError{}

// Validate checks the field values on GetDubboInterfaceFailedRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDubboInterfaceFailedRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDubboInterfaceFailedRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDubboInterfaceFailedRequestMultiError, or nil if none found.
func (m *GetDubboInterfaceFailedRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDubboInterfaceFailedRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInterfaceName()) < 1 {
		err := GetDubboInterfaceFailedRequestValidationError{
			field:  "InterfaceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := GetDubboInterfaceFailedRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := GetDubboInterfaceFailedRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for Point

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	if len(errors) > 0 {
		return GetDubboInterfaceFailedRequestMultiError(errors)
	}

	return nil
}

// GetDubboInterfaceFailedRequestMultiError is an error wrapping multiple
// validation errors returned by GetDubboInterfaceFailedRequest.ValidateAll()
// if the designated constraints aren't met.
type GetDubboInterfaceFailedRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDubboInterfaceFailedRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDubboInterfaceFailedRequestMultiError) AllErrors() []error { return m }

// GetDubboInterfaceFailedRequestValidationError is the validation error
// returned by GetDubboInterfaceFailedRequest.Validate if the designated
// constraints aren't met.
type GetDubboInterfaceFailedRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDubboInterfaceFailedRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDubboInterfaceFailedRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDubboInterfaceFailedRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDubboInterfaceFailedRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDubboInterfaceFailedRequestValidationError) ErrorName() string {
	return "GetDubboInterfaceFailedRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDubboInterfaceFailedRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDubboInterfaceFailedRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDubboInterfaceFailedRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDubboInterfaceFailedRequestValidationError{}

// Validate checks the field values on GetDubboInterfaceFailedResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDubboInterfaceFailedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDubboInterfaceFailedResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDubboInterfaceFailedResponseMultiError, or nil if none found.
func (m *GetDubboInterfaceFailedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDubboInterfaceFailedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDubboInterfaceFailedResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDubboInterfaceFailedResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDubboInterfaceFailedResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDubboInterfaceFailedResponseMultiError(errors)
	}

	return nil
}

// GetDubboInterfaceFailedResponseMultiError is an error wrapping multiple
// validation errors returned by GetDubboInterfaceFailedResponse.ValidateAll()
// if the designated constraints aren't met.
type GetDubboInterfaceFailedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDubboInterfaceFailedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDubboInterfaceFailedResponseMultiError) AllErrors() []error { return m }

// GetDubboInterfaceFailedResponseValidationError is the validation error
// returned by GetDubboInterfaceFailedResponse.Validate if the designated
// constraints aren't met.
type GetDubboInterfaceFailedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDubboInterfaceFailedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDubboInterfaceFailedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDubboInterfaceFailedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDubboInterfaceFailedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDubboInterfaceFailedResponseValidationError) ErrorName() string {
	return "GetDubboInterfaceFailedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDubboInterfaceFailedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDubboInterfaceFailedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDubboInterfaceFailedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDubboInterfaceFailedResponseValidationError{}

// Validate checks the field values on GetDubboInterfaceAvgTimeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDubboInterfaceAvgTimeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDubboInterfaceAvgTimeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDubboInterfaceAvgTimeRequestMultiError, or nil if none found.
func (m *GetDubboInterfaceAvgTimeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDubboInterfaceAvgTimeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetInterfaceName()) < 1 {
		err := GetDubboInterfaceAvgTimeRequestValidationError{
			field:  "InterfaceName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetProjectID()) < 1 {
		err := GetDubboInterfaceAvgTimeRequestValidationError{
			field:  "ProjectID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEnv()) < 1 {
		err := GetDubboInterfaceAvgTimeRequestValidationError{
			field:  "Env",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for Point

	// no validation rules for ClusterName

	// no validation rules for AppID

	// no validation rules for TenantID

	if len(errors) > 0 {
		return GetDubboInterfaceAvgTimeRequestMultiError(errors)
	}

	return nil
}

// GetDubboInterfaceAvgTimeRequestMultiError is an error wrapping multiple
// validation errors returned by GetDubboInterfaceAvgTimeRequest.ValidateAll()
// if the designated constraints aren't met.
type GetDubboInterfaceAvgTimeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDubboInterfaceAvgTimeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDubboInterfaceAvgTimeRequestMultiError) AllErrors() []error { return m }

// GetDubboInterfaceAvgTimeRequestValidationError is the validation error
// returned by GetDubboInterfaceAvgTimeRequest.Validate if the designated
// constraints aren't met.
type GetDubboInterfaceAvgTimeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDubboInterfaceAvgTimeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDubboInterfaceAvgTimeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDubboInterfaceAvgTimeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDubboInterfaceAvgTimeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDubboInterfaceAvgTimeRequestValidationError) ErrorName() string {
	return "GetDubboInterfaceAvgTimeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDubboInterfaceAvgTimeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDubboInterfaceAvgTimeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDubboInterfaceAvgTimeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDubboInterfaceAvgTimeRequestValidationError{}

// Validate checks the field values on GetDubboInterfaceAvgTimeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetDubboInterfaceAvgTimeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDubboInterfaceAvgTimeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDubboInterfaceAvgTimeResponseMultiError, or nil if none found.
func (m *GetDubboInterfaceAvgTimeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDubboInterfaceAvgTimeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDubboInterfaceAvgTimeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDubboInterfaceAvgTimeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDubboInterfaceAvgTimeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDubboInterfaceAvgTimeResponseMultiError(errors)
	}

	return nil
}

// GetDubboInterfaceAvgTimeResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetDubboInterfaceAvgTimeResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDubboInterfaceAvgTimeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDubboInterfaceAvgTimeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDubboInterfaceAvgTimeResponseMultiError) AllErrors() []error { return m }

// GetDubboInterfaceAvgTimeResponseValidationError is the validation error
// returned by GetDubboInterfaceAvgTimeResponse.Validate if the designated
// constraints aren't met.
type GetDubboInterfaceAvgTimeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDubboInterfaceAvgTimeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDubboInterfaceAvgTimeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDubboInterfaceAvgTimeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDubboInterfaceAvgTimeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDubboInterfaceAvgTimeResponseValidationError) ErrorName() string {
	return "GetDubboInterfaceAvgTimeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDubboInterfaceAvgTimeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDubboInterfaceAvgTimeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDubboInterfaceAvgTimeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDubboInterfaceAvgTimeResponseValidationError{}

// Validate checks the field values on Interface with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Interface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Interface with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InterfaceMultiError, or nil
// if none found.
func (m *Interface) ValidateAll() error {
	return m.validate(true)
}

func (m *Interface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Interfacename

	{
		sorted_keys := make([]string, len(m.GetProvidermap()))
		i := 0
		for key := range m.GetProvidermap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetProvidermap()[key]
			_ = val

			// no validation rules for Providermap[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, InterfaceValidationError{
							field:  fmt.Sprintf("Providermap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, InterfaceValidationError{
							field:  fmt.Sprintf("Providermap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return InterfaceValidationError{
						field:  fmt.Sprintf("Providermap[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetConsumermap()))
		i := 0
		for key := range m.GetConsumermap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetConsumermap()[key]
			_ = val

			// no validation rules for Consumermap[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, InterfaceValidationError{
							field:  fmt.Sprintf("Consumermap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, InterfaceValidationError{
							field:  fmt.Sprintf("Consumermap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return InterfaceValidationError{
						field:  fmt.Sprintf("Consumermap[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return InterfaceMultiError(errors)
	}

	return nil
}

// InterfaceMultiError is an error wrapping multiple validation errors returned
// by Interface.ValidateAll() if the designated constraints aren't met.
type InterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InterfaceMultiError) AllErrors() []error { return m }

// InterfaceValidationError is the validation error returned by
// Interface.Validate if the designated constraints aren't met.
type InterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InterfaceValidationError) ErrorName() string { return "InterfaceValidationError" }

// Error satisfies the builtin error interface
func (e InterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InterfaceValidationError{}

// Validate checks the field values on InterfaceOwner with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InterfaceOwner) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InterfaceOwner with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InterfaceOwnerMultiError,
// or nil if none found.
func (m *InterfaceOwner) ValidateAll() error {
	return m.validate(true)
}

func (m *InterfaceOwner) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ip

	// no validation rules for Owner

	// no validation rules for ProjectId

	// no validation rules for Env

	// no validation rules for HostIp

	// no validation rules for ApplicationId

	// no validation rules for Feature

	// no validation rules for ServiceName

	if len(errors) > 0 {
		return InterfaceOwnerMultiError(errors)
	}

	return nil
}

// InterfaceOwnerMultiError is an error wrapping multiple validation errors
// returned by InterfaceOwner.ValidateAll() if the designated constraints
// aren't met.
type InterfaceOwnerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InterfaceOwnerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InterfaceOwnerMultiError) AllErrors() []error { return m }

// InterfaceOwnerValidationError is the validation error returned by
// InterfaceOwner.Validate if the designated constraints aren't met.
type InterfaceOwnerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InterfaceOwnerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InterfaceOwnerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InterfaceOwnerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InterfaceOwnerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InterfaceOwnerValidationError) ErrorName() string { return "InterfaceOwnerValidationError" }

// Error satisfies the builtin error interface
func (e InterfaceOwnerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInterfaceOwner.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InterfaceOwnerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InterfaceOwnerValidationError{}

// Validate checks the field values on RequestRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RequestRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestRule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RequestRuleMultiError, or
// nil if none found.
func (m *RequestRule) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LbType

	// no validation rules for MaxRequestPerConn

	// no validation rules for MaxConnections

	// no validation rules for MaxRequests

	if len(errors) > 0 {
		return RequestRuleMultiError(errors)
	}

	return nil
}

// RequestRuleMultiError is an error wrapping multiple validation errors
// returned by RequestRule.ValidateAll() if the designated constraints aren't met.
type RequestRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestRuleMultiError) AllErrors() []error { return m }

// RequestRuleValidationError is the validation error returned by
// RequestRule.Validate if the designated constraints aren't met.
type RequestRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestRuleValidationError) ErrorName() string { return "RequestRuleValidationError" }

// Error satisfies the builtin error interface
func (e RequestRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestRuleValidationError{}

// Validate checks the field values on HostRules with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HostRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostRules with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HostRulesMultiError, or nil
// if none found.
func (m *HostRules) ValidateAll() error {
	return m.validate(true)
}

func (m *HostRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HostRulesValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HostRulesValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HostRulesValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HostRulesMultiError(errors)
	}

	return nil
}

// HostRulesMultiError is an error wrapping multiple validation errors returned
// by HostRules.ValidateAll() if the designated constraints aren't met.
type HostRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostRulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostRulesMultiError) AllErrors() []error { return m }

// HostRulesValidationError is the validation error returned by
// HostRules.Validate if the designated constraints aren't met.
type HostRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostRulesValidationError) ErrorName() string { return "HostRulesValidationError" }

// Error satisfies the builtin error interface
func (e HostRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostRulesValidationError{}

// Validate checks the field values on HostRoute with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HostRoute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostRoute with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HostRouteMultiError, or nil
// if none found.
func (m *HostRoute) ValidateAll() error {
	return m.validate(true)
}

func (m *HostRoute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Branch

	// no validation rules for Weight

	if len(errors) > 0 {
		return HostRouteMultiError(errors)
	}

	return nil
}

// HostRouteMultiError is an error wrapping multiple validation errors returned
// by HostRoute.ValidateAll() if the designated constraints aren't met.
type HostRouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostRouteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostRouteMultiError) AllErrors() []error { return m }

// HostRouteValidationError is the validation error returned by
// HostRoute.Validate if the designated constraints aren't met.
type HostRouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostRouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostRouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostRouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostRouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostRouteValidationError) ErrorName() string { return "HostRouteValidationError" }

// Error satisfies the builtin error interface
func (e HostRouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostRoute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostRouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostRouteValidationError{}

// Validate checks the field values on HostRuntimeRules with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HostRuntimeRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostRuntimeRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostRuntimeRulesMultiError, or nil if none found.
func (m *HostRuntimeRules) ValidateAll() error {
	return m.validate(true)
}

func (m *HostRuntimeRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	for idx, item := range m.GetRule() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostRuntimeRulesValidationError{
						field:  fmt.Sprintf("Rule[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostRuntimeRulesValidationError{
						field:  fmt.Sprintf("Rule[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostRuntimeRulesValidationError{
					field:  fmt.Sprintf("Rule[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HostRuntimeRulesMultiError(errors)
	}

	return nil
}

// HostRuntimeRulesMultiError is an error wrapping multiple validation errors
// returned by HostRuntimeRules.ValidateAll() if the designated constraints
// aren't met.
type HostRuntimeRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostRuntimeRulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostRuntimeRulesMultiError) AllErrors() []error { return m }

// HostRuntimeRulesValidationError is the validation error returned by
// HostRuntimeRules.Validate if the designated constraints aren't met.
type HostRuntimeRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostRuntimeRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostRuntimeRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostRuntimeRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostRuntimeRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostRuntimeRulesValidationError) ErrorName() string { return "HostRuntimeRulesValidationError" }

// Error satisfies the builtin error interface
func (e HostRuntimeRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostRuntimeRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostRuntimeRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostRuntimeRulesValidationError{}

// Validate checks the field values on HostRuntimeRule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HostRuntimeRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostRuntimeRule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostRuntimeRuleMultiError, or nil if none found.
func (m *HostRuntimeRule) ValidateAll() error {
	return m.validate(true)
}

func (m *HostRuntimeRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Weight

	if len(errors) > 0 {
		return HostRuntimeRuleMultiError(errors)
	}

	return nil
}

// HostRuntimeRuleMultiError is an error wrapping multiple validation errors
// returned by HostRuntimeRule.ValidateAll() if the designated constraints
// aren't met.
type HostRuntimeRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostRuntimeRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostRuntimeRuleMultiError) AllErrors() []error { return m }

// HostRuntimeRuleValidationError is the validation error returned by
// HostRuntimeRule.Validate if the designated constraints aren't met.
type HostRuntimeRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostRuntimeRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostRuntimeRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostRuntimeRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostRuntimeRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostRuntimeRuleValidationError) ErrorName() string { return "HostRuntimeRuleValidationError" }

// Error satisfies the builtin error interface
func (e HostRuntimeRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostRuntimeRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostRuntimeRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostRuntimeRuleValidationError{}

// Validate checks the field values on HostRuntimeInterfaces with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HostRuntimeInterfaces) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostRuntimeInterfaces with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostRuntimeInterfacesMultiError, or nil if none found.
func (m *HostRuntimeInterfaces) ValidateAll() error {
	return m.validate(true)
}

func (m *HostRuntimeInterfaces) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Appid

	for idx, item := range m.GetNode() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostRuntimeInterfacesValidationError{
						field:  fmt.Sprintf("Node[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostRuntimeInterfacesValidationError{
						field:  fmt.Sprintf("Node[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostRuntimeInterfacesValidationError{
					field:  fmt.Sprintf("Node[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HostRuntimeInterfacesMultiError(errors)
	}

	return nil
}

// HostRuntimeInterfacesMultiError is an error wrapping multiple validation
// errors returned by HostRuntimeInterfaces.ValidateAll() if the designated
// constraints aren't met.
type HostRuntimeInterfacesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostRuntimeInterfacesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostRuntimeInterfacesMultiError) AllErrors() []error { return m }

// HostRuntimeInterfacesValidationError is the validation error returned by
// HostRuntimeInterfaces.Validate if the designated constraints aren't met.
type HostRuntimeInterfacesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostRuntimeInterfacesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostRuntimeInterfacesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostRuntimeInterfacesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostRuntimeInterfacesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostRuntimeInterfacesValidationError) ErrorName() string {
	return "HostRuntimeInterfacesValidationError"
}

// Error satisfies the builtin error interface
func (e HostRuntimeInterfacesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostRuntimeInterfaces.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostRuntimeInterfacesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostRuntimeInterfacesValidationError{}

// Validate checks the field values on HTTPServices with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HTTPServices) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HTTPServices with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HTTPServicesMultiError, or
// nil if none found.
func (m *HTTPServices) ValidateAll() error {
	return m.validate(true)
}

func (m *HTTPServices) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetServiceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HTTPServicesValidationError{
						field:  fmt.Sprintf("ServiceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HTTPServicesValidationError{
						field:  fmt.Sprintf("ServiceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HTTPServicesValidationError{
					field:  fmt.Sprintf("ServiceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HTTPServicesMultiError(errors)
	}

	return nil
}

// HTTPServicesMultiError is an error wrapping multiple validation errors
// returned by HTTPServices.ValidateAll() if the designated constraints aren't met.
type HTTPServicesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HTTPServicesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HTTPServicesMultiError) AllErrors() []error { return m }

// HTTPServicesValidationError is the validation error returned by
// HTTPServices.Validate if the designated constraints aren't met.
type HTTPServicesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTTPServicesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTTPServicesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTTPServicesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTTPServicesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTTPServicesValidationError) ErrorName() string { return "HTTPServicesValidationError" }

// Error satisfies the builtin error interface
func (e HTTPServicesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTTPServices.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTTPServicesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTTPServicesValidationError{}

// Validate checks the field values on HTTPService with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HTTPService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HTTPService with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HTTPServiceMultiError, or
// nil if none found.
func (m *HTTPService) ValidateAll() error {
	return m.validate(true)
}

func (m *HTTPService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	// no validation rules for ServiceDomain

	for idx, item := range m.GetHttpServiceDto() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HTTPServiceValidationError{
						field:  fmt.Sprintf("HttpServiceDto[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HTTPServiceValidationError{
						field:  fmt.Sprintf("HttpServiceDto[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HTTPServiceValidationError{
					field:  fmt.Sprintf("HttpServiceDto[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HTTPServiceMultiError(errors)
	}

	return nil
}

// HTTPServiceMultiError is an error wrapping multiple validation errors
// returned by HTTPService.ValidateAll() if the designated constraints aren't met.
type HTTPServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HTTPServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HTTPServiceMultiError) AllErrors() []error { return m }

// HTTPServiceValidationError is the validation error returned by
// HTTPService.Validate if the designated constraints aren't met.
type HTTPServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTTPServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTTPServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTTPServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTTPServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTTPServiceValidationError) ErrorName() string { return "HTTPServiceValidationError" }

// Error satisfies the builtin error interface
func (e HTTPServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTTPService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTTPServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTTPServiceValidationError{}

// Validate checks the field values on HTTPServiceItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HTTPServiceItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HTTPServiceItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HTTPServiceItemMultiError, or nil if none found.
func (m *HTTPServiceItem) ValidateAll() error {
	return m.validate(true)
}

func (m *HTTPServiceItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Online

	if len(errors) > 0 {
		return HTTPServiceItemMultiError(errors)
	}

	return nil
}

// HTTPServiceItemMultiError is an error wrapping multiple validation errors
// returned by HTTPServiceItem.ValidateAll() if the designated constraints
// aren't met.
type HTTPServiceItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HTTPServiceItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HTTPServiceItemMultiError) AllErrors() []error { return m }

// HTTPServiceItemValidationError is the validation error returned by
// HTTPServiceItem.Validate if the designated constraints aren't met.
type HTTPServiceItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTTPServiceItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTTPServiceItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTTPServiceItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTTPServiceItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTTPServiceItemValidationError) ErrorName() string { return "HTTPServiceItemValidationError" }

// Error satisfies the builtin error interface
func (e HTTPServiceItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTTPServiceItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTTPServiceItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTTPServiceItemValidationError{}

// Validate checks the field values on DubboInterface with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DubboInterface) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DubboInterface with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DubboInterfaceMultiError,
// or nil if none found.
func (m *DubboInterface) ValidateAll() error {
	return m.validate(true)
}

func (m *DubboInterface) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Total

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DubboInterfaceValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DubboInterfaceValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DubboInterfaceValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DubboInterfaceMultiError(errors)
	}

	return nil
}

// DubboInterfaceMultiError is an error wrapping multiple validation errors
// returned by DubboInterface.ValidateAll() if the designated constraints
// aren't met.
type DubboInterfaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DubboInterfaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DubboInterfaceMultiError) AllErrors() []error { return m }

// DubboInterfaceValidationError is the validation error returned by
// DubboInterface.Validate if the designated constraints aren't met.
type DubboInterfaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DubboInterfaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DubboInterfaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DubboInterfaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DubboInterfaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DubboInterfaceValidationError) ErrorName() string { return "DubboInterfaceValidationError" }

// Error satisfies the builtin error interface
func (e DubboInterfaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDubboInterface.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DubboInterfaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DubboInterfaceValidationError{}

// Validate checks the field values on DubboInterfaceResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DubboInterfaceResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DubboInterfaceResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DubboInterfaceResultMultiError, or nil if none found.
func (m *DubboInterfaceResult) ValidateAll() error {
	return m.validate(true)
}

func (m *DubboInterfaceResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DubboInterfaceResultValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DubboInterfaceResultValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DubboInterfaceResultValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DubboInterfaceResultMultiError(errors)
	}

	return nil
}

// DubboInterfaceResultMultiError is an error wrapping multiple validation
// errors returned by DubboInterfaceResult.ValidateAll() if the designated
// constraints aren't met.
type DubboInterfaceResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DubboInterfaceResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DubboInterfaceResultMultiError) AllErrors() []error { return m }

// DubboInterfaceResultValidationError is the validation error returned by
// DubboInterfaceResult.Validate if the designated constraints aren't met.
type DubboInterfaceResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DubboInterfaceResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DubboInterfaceResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DubboInterfaceResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DubboInterfaceResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DubboInterfaceResultValidationError) ErrorName() string {
	return "DubboInterfaceResultValidationError"
}

// Error satisfies the builtin error interface
func (e DubboInterfaceResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDubboInterfaceResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DubboInterfaceResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DubboInterfaceResultValidationError{}

// Validate checks the field values on DubboMointorMap with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DubboMointorMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DubboMointorMap with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DubboMointorMapMultiError, or nil if none found.
func (m *DubboMointorMap) ValidateAll() error {
	return m.validate(true)
}

func (m *DubboMointorMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DubboMointorMapValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DubboMointorMapValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DubboMointorMapValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DubboMointorMapMultiError(errors)
	}

	return nil
}

// DubboMointorMapMultiError is an error wrapping multiple validation errors
// returned by DubboMointorMap.ValidateAll() if the designated constraints
// aren't met.
type DubboMointorMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DubboMointorMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DubboMointorMapMultiError) AllErrors() []error { return m }

// DubboMointorMapValidationError is the validation error returned by
// DubboMointorMap.Validate if the designated constraints aren't met.
type DubboMointorMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DubboMointorMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DubboMointorMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DubboMointorMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DubboMointorMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DubboMointorMapValidationError) ErrorName() string { return "DubboMointorMapValidationError" }

// Error satisfies the builtin error interface
func (e DubboMointorMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDubboMointorMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DubboMointorMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DubboMointorMapValidationError{}

// Validate checks the field values on DubboMointor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DubboMointor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DubboMointor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DubboMointorMultiError, or
// nil if none found.
func (m *DubboMointor) ValidateAll() error {
	return m.validate(true)
}

func (m *DubboMointor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Tag

	// no validation rules for Unit

	// no validation rules for UnitType

	// no validation rules for ChartType

	// no validation rules for AxisIndex

	if len(errors) > 0 {
		return DubboMointorMultiError(errors)
	}

	return nil
}

// DubboMointorMultiError is an error wrapping multiple validation errors
// returned by DubboMointor.ValidateAll() if the designated constraints aren't met.
type DubboMointorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DubboMointorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DubboMointorMultiError) AllErrors() []error { return m }

// DubboMointorValidationError is the validation error returned by
// DubboMointor.Validate if the designated constraints aren't met.
type DubboMointorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DubboMointorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DubboMointorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DubboMointorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DubboMointorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DubboMointorValidationError) ErrorName() string { return "DubboMointorValidationError" }

// Error satisfies the builtin error interface
func (e DubboMointorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDubboMointor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DubboMointorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DubboMointorValidationError{}

// Validate checks the field values on ServiceIpRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceIpRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceIpRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceIpRequestMultiError, or nil if none found.
func (m *ServiceIpRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceIpRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for Workspace

	// no validation rules for Ip

	if len(errors) > 0 {
		return ServiceIpRequestMultiError(errors)
	}

	return nil
}

// ServiceIpRequestMultiError is an error wrapping multiple validation errors
// returned by ServiceIpRequest.ValidateAll() if the designated constraints
// aren't met.
type ServiceIpRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceIpRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceIpRequestMultiError) AllErrors() []error { return m }

// ServiceIpRequestValidationError is the validation error returned by
// ServiceIpRequest.Validate if the designated constraints aren't met.
type ServiceIpRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceIpRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceIpRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceIpRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceIpRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceIpRequestValidationError) ErrorName() string { return "ServiceIpRequestValidationError" }

// Error satisfies the builtin error interface
func (e ServiceIpRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceIpRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceIpRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceIpRequestValidationError{}

// Validate checks the field values on ServiceIpInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ServiceIpInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceIpInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceIpInfoResponseMultiError, or nil if none found.
func (m *ServiceIpInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceIpInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppID

	// no validation rules for RuntimeID

	// no validation rules for ServiceName

	if len(errors) > 0 {
		return ServiceIpInfoResponseMultiError(errors)
	}

	return nil
}

// ServiceIpInfoResponseMultiError is an error wrapping multiple validation
// errors returned by ServiceIpInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type ServiceIpInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceIpInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceIpInfoResponseMultiError) AllErrors() []error { return m }

// ServiceIpInfoResponseValidationError is the validation error returned by
// ServiceIpInfoResponse.Validate if the designated constraints aren't met.
type ServiceIpInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceIpInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceIpInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceIpInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceIpInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceIpInfoResponseValidationError) ErrorName() string {
	return "ServiceIpInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceIpInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceIpInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceIpInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceIpInfoResponseValidationError{}
