// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: log_query.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ParseRegexpRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParseRegexpRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParseRegexpRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParseRegexpRequestMultiError, or nil if none found.
func (m *ParseRegexpRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ParseRegexpRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pattern

	if len(errors) > 0 {
		return ParseRegexpRequestMultiError(errors)
	}

	return nil
}

// ParseRegexpRequestMultiError is an error wrapping multiple validation errors
// returned by ParseRegexpRequest.ValidateAll() if the designated constraints
// aren't met.
type ParseRegexpRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParseRegexpRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParseRegexpRequestMultiError) AllErrors() []error { return m }

// ParseRegexpRequestValidationError is the validation error returned by
// ParseRegexpRequest.Validate if the designated constraints aren't met.
type ParseRegexpRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParseRegexpRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParseRegexpRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParseRegexpRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParseRegexpRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParseRegexpRequestValidationError) ErrorName() string {
	return "ParseRegexpRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ParseRegexpRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParseRegexpRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParseRegexpRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParseRegexpRequestValidationError{}

// Validate checks the field values on RegexpGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegexpGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegexpGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegexpGroupMultiError, or
// nil if none found.
func (m *RegexpGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *RegexpGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pattern

	// no validation rules for Name

	if len(errors) > 0 {
		return RegexpGroupMultiError(errors)
	}

	return nil
}

// RegexpGroupMultiError is an error wrapping multiple validation errors
// returned by RegexpGroup.ValidateAll() if the designated constraints aren't met.
type RegexpGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegexpGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegexpGroupMultiError) AllErrors() []error { return m }

// RegexpGroupValidationError is the validation error returned by
// RegexpGroup.Validate if the designated constraints aren't met.
type RegexpGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegexpGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegexpGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegexpGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegexpGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegexpGroupValidationError) ErrorName() string { return "RegexpGroupValidationError" }

// Error satisfies the builtin error interface
func (e RegexpGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegexpGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegexpGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegexpGroupValidationError{}

// Validate checks the field values on ParseRegexpResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParseRegexpResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParseRegexpResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParseRegexpResponseMultiError, or nil if none found.
func (m *ParseRegexpResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ParseRegexpResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParseRegexpResponseValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParseRegexpResponseValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParseRegexpResponseValidationError{
					field:  fmt.Sprintf("Groups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParseRegexpResponseMultiError(errors)
	}

	return nil
}

// ParseRegexpResponseMultiError is an error wrapping multiple validation
// errors returned by ParseRegexpResponse.ValidateAll() if the designated
// constraints aren't met.
type ParseRegexpResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParseRegexpResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParseRegexpResponseMultiError) AllErrors() []error { return m }

// ParseRegexpResponseValidationError is the validation error returned by
// ParseRegexpResponse.Validate if the designated constraints aren't met.
type ParseRegexpResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParseRegexpResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParseRegexpResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParseRegexpResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParseRegexpResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParseRegexpResponseValidationError) ErrorName() string {
	return "ParseRegexpResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ParseRegexpResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParseRegexpResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParseRegexpResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParseRegexpResponseValidationError{}

// Validate checks the field values on GetFieldSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFieldSettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFieldSettingsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFieldSettingsRequestMultiError, or nil if none found.
func (m *GetFieldSettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFieldSettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Addon

	if len(errors) > 0 {
		return GetFieldSettingsRequestMultiError(errors)
	}

	return nil
}

// GetFieldSettingsRequestMultiError is an error wrapping multiple validation
// errors returned by GetFieldSettingsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFieldSettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFieldSettingsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFieldSettingsRequestMultiError) AllErrors() []error { return m }

// GetFieldSettingsRequestValidationError is the validation error returned by
// GetFieldSettingsRequest.Validate if the designated constraints aren't met.
type GetFieldSettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFieldSettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFieldSettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFieldSettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFieldSettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFieldSettingsRequestValidationError) ErrorName() string {
	return "GetFieldSettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFieldSettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFieldSettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFieldSettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFieldSettingsRequestValidationError{}

// Validate checks the field values on GetFieldSettingsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFieldSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFieldSettingsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFieldSettingsResponseMultiError, or nil if none found.
func (m *GetFieldSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFieldSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetFieldSettingsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetFieldSettingsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetFieldSettingsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetFieldSettingsResponseMultiError(errors)
	}

	return nil
}

// GetFieldSettingsResponseMultiError is an error wrapping multiple validation
// errors returned by GetFieldSettingsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFieldSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFieldSettingsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFieldSettingsResponseMultiError) AllErrors() []error { return m }

// GetFieldSettingsResponseValidationError is the validation error returned by
// GetFieldSettingsResponse.Validate if the designated constraints aren't met.
type GetFieldSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFieldSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFieldSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFieldSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFieldSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFieldSettingsResponseValidationError) ErrorName() string {
	return "GetFieldSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFieldSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFieldSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFieldSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFieldSettingsResponseValidationError{}

// Validate checks the field values on LogField with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogField) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogField with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogFieldMultiError, or nil
// if none found.
func (m *LogField) ValidateAll() error {
	return m.validate(true)
}

func (m *LogField) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FieldName

	// no validation rules for SupportAggregation

	// no validation rules for Display

	// no validation rules for AllowEdit

	// no validation rules for Group

	if len(errors) > 0 {
		return LogFieldMultiError(errors)
	}

	return nil
}

// LogFieldMultiError is an error wrapping multiple validation errors returned
// by LogField.ValidateAll() if the designated constraints aren't met.
type LogFieldMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogFieldMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogFieldMultiError) AllErrors() []error { return m }

// LogFieldValidationError is the validation error returned by
// LogField.Validate if the designated constraints aren't met.
type LogFieldValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogFieldValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogFieldValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogFieldValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogFieldValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogFieldValidationError) ErrorName() string { return "LogFieldValidationError" }

// Error satisfies the builtin error interface
func (e LogFieldValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogField.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogFieldValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogFieldValidationError{}

// Validate checks the field values on SequentialSearchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SequentialSearchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SequentialSearchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SequentialSearchRequestMultiError, or nil if none found.
func (m *SequentialSearchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SequentialSearchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ClusterName

	// no validation rules for Addon

	// no validation rules for Query

	// no validation rules for Debug

	// no validation rules for Sort

	// no validation rules for Id

	// no validation rules for TimestampNanos

	// no validation rules for Offset

	// no validation rules for Count

	if len(errors) > 0 {
		return SequentialSearchRequestMultiError(errors)
	}

	return nil
}

// SequentialSearchRequestMultiError is an error wrapping multiple validation
// errors returned by SequentialSearchRequest.ValidateAll() if the designated
// constraints aren't met.
type SequentialSearchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SequentialSearchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SequentialSearchRequestMultiError) AllErrors() []error { return m }

// SequentialSearchRequestValidationError is the validation error returned by
// SequentialSearchRequest.Validate if the designated constraints aren't met.
type SequentialSearchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SequentialSearchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SequentialSearchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SequentialSearchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SequentialSearchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SequentialSearchRequestValidationError) ErrorName() string {
	return "SequentialSearchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SequentialSearchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSequentialSearchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SequentialSearchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SequentialSearchRequestValidationError{}

// Validate checks the field values on SequentialSearchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SequentialSearchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SequentialSearchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SequentialSearchResponseMultiError, or nil if none found.
func (m *SequentialSearchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SequentialSearchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SequentialSearchResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SequentialSearchResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SequentialSearchResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SequentialSearchResponseMultiError(errors)
	}

	return nil
}

// SequentialSearchResponseMultiError is an error wrapping multiple validation
// errors returned by SequentialSearchResponse.ValidateAll() if the designated
// constraints aren't met.
type SequentialSearchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SequentialSearchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SequentialSearchResponseMultiError) AllErrors() []error { return m }

// SequentialSearchResponseValidationError is the validation error returned by
// SequentialSearchResponse.Validate if the designated constraints aren't met.
type SequentialSearchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SequentialSearchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SequentialSearchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SequentialSearchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SequentialSearchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SequentialSearchResponseValidationError) ErrorName() string {
	return "SequentialSearchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SequentialSearchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSequentialSearchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SequentialSearchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SequentialSearchResponseValidationError{}

// Validate checks the field values on PagedSearchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PagedSearchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PagedSearchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PagedSearchRequestMultiError, or nil if none found.
func (m *PagedSearchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PagedSearchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ClusterName

	// no validation rules for Addon

	// no validation rules for Query

	// no validation rules for Debug

	// no validation rules for PageNo

	// no validation rules for PageSize

	// no validation rules for Highlight

	if len(errors) > 0 {
		return PagedSearchRequestMultiError(errors)
	}

	return nil
}

// PagedSearchRequestMultiError is an error wrapping multiple validation errors
// returned by PagedSearchRequest.ValidateAll() if the designated constraints
// aren't met.
type PagedSearchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PagedSearchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PagedSearchRequestMultiError) AllErrors() []error { return m }

// PagedSearchRequestValidationError is the validation error returned by
// PagedSearchRequest.Validate if the designated constraints aren't met.
type PagedSearchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PagedSearchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PagedSearchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PagedSearchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PagedSearchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PagedSearchRequestValidationError) ErrorName() string {
	return "PagedSearchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PagedSearchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPagedSearchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PagedSearchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PagedSearchRequestValidationError{}

// Validate checks the field values on PagedSearchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PagedSearchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PagedSearchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PagedSearchResponseMultiError, or nil if none found.
func (m *PagedSearchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PagedSearchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PagedSearchResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PagedSearchResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PagedSearchResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PagedSearchResponseMultiError(errors)
	}

	return nil
}

// PagedSearchResponseMultiError is an error wrapping multiple validation
// errors returned by PagedSearchResponse.ValidateAll() if the designated
// constraints aren't met.
type PagedSearchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PagedSearchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PagedSearchResponseMultiError) AllErrors() []error { return m }

// PagedSearchResponseValidationError is the validation error returned by
// PagedSearchResponse.Validate if the designated constraints aren't met.
type PagedSearchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PagedSearchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PagedSearchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PagedSearchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PagedSearchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PagedSearchResponseValidationError) ErrorName() string {
	return "PagedSearchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PagedSearchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPagedSearchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PagedSearchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PagedSearchResponseValidationError{}

// Validate checks the field values on LogQueryResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogQueryResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogQueryResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogQueryResultMultiError,
// or nil if none found.
func (m *LogQueryResult) ValidateAll() error {
	return m.validate(true)
}

func (m *LogQueryResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LogQueryResultValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LogQueryResultValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LogQueryResultValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LogQueryResultMultiError(errors)
	}

	return nil
}

// LogQueryResultMultiError is an error wrapping multiple validation errors
// returned by LogQueryResult.ValidateAll() if the designated constraints
// aren't met.
type LogQueryResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogQueryResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogQueryResultMultiError) AllErrors() []error { return m }

// LogQueryResultValidationError is the validation error returned by
// LogQueryResult.Validate if the designated constraints aren't met.
type LogQueryResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogQueryResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogQueryResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogQueryResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogQueryResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogQueryResultValidationError) ErrorName() string { return "LogQueryResultValidationError" }

// Error satisfies the builtin error interface
func (e LogQueryResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogQueryResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogQueryResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogQueryResultValidationError{}

// Validate checks the field values on HighlightLog with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HighlightLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HighlightLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HighlightLogMultiError, or
// nil if none found.
func (m *HighlightLog) ValidateAll() error {
	return m.validate(true)
}

func (m *HighlightLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HighlightLogValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HighlightLogValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HighlightLogValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetHighlight()))
		i := 0
		for key := range m.GetHighlight() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetHighlight()[key]
			_ = val

			// no validation rules for Highlight[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, HighlightLogValidationError{
							field:  fmt.Sprintf("Highlight[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, HighlightLogValidationError{
							field:  fmt.Sprintf("Highlight[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return HighlightLogValidationError{
						field:  fmt.Sprintf("Highlight[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return HighlightLogMultiError(errors)
	}

	return nil
}

// HighlightLogMultiError is an error wrapping multiple validation errors
// returned by HighlightLog.ValidateAll() if the designated constraints aren't met.
type HighlightLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HighlightLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HighlightLogMultiError) AllErrors() []error { return m }

// HighlightLogValidationError is the validation error returned by
// HighlightLog.Validate if the designated constraints aren't met.
type HighlightLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HighlightLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HighlightLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HighlightLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HighlightLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HighlightLogValidationError) ErrorName() string { return "HighlightLogValidationError" }

// Error satisfies the builtin error interface
func (e HighlightLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHighlightLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HighlightLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HighlightLogValidationError{}

// Validate checks the field values on LogItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogItem with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LogItemMultiError, or nil if none found.
func (m *LogItem) ValidateAll() error {
	return m.validate(true)
}

func (m *LogItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocId

	// no validation rules for Id

	// no validation rules for Source

	// no validation rules for Stream

	// no validation rules for Content

	// no validation rules for Offset

	// no validation rules for Timestamp

	// no validation rules for TimestampNanos

	// no validation rules for Tags

	if len(errors) > 0 {
		return LogItemMultiError(errors)
	}

	return nil
}

// LogItemMultiError is an error wrapping multiple validation errors returned
// by LogItem.ValidateAll() if the designated constraints aren't met.
type LogItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogItemMultiError) AllErrors() []error { return m }

// LogItemValidationError is the validation error returned by LogItem.Validate
// if the designated constraints aren't met.
type LogItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogItemValidationError) ErrorName() string { return "LogItemValidationError" }

// Error satisfies the builtin error interface
func (e LogItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogItemValidationError{}

// Validate checks the field values on BucketAggregationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BucketAggregationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketAggregationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BucketAggregationRequestMultiError, or nil if none found.
func (m *BucketAggregationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketAggregationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ClusterName

	// no validation rules for Addon

	// no validation rules for Query

	// no validation rules for Debug

	// no validation rules for TermsSize

	if len(errors) > 0 {
		return BucketAggregationRequestMultiError(errors)
	}

	return nil
}

// BucketAggregationRequestMultiError is an error wrapping multiple validation
// errors returned by BucketAggregationRequest.ValidateAll() if the designated
// constraints aren't met.
type BucketAggregationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketAggregationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketAggregationRequestMultiError) AllErrors() []error { return m }

// BucketAggregationRequestValidationError is the validation error returned by
// BucketAggregationRequest.Validate if the designated constraints aren't met.
type BucketAggregationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketAggregationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketAggregationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketAggregationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketAggregationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketAggregationRequestValidationError) ErrorName() string {
	return "BucketAggregationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BucketAggregationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketAggregationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketAggregationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketAggregationRequestValidationError{}

// Validate checks the field values on BucketAggregationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BucketAggregationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketAggregationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BucketAggregationResponseMultiError, or nil if none found.
func (m *BucketAggregationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketAggregationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BucketAggregationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BucketAggregationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BucketAggregationResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BucketAggregationResponseMultiError(errors)
	}

	return nil
}

// BucketAggregationResponseMultiError is an error wrapping multiple validation
// errors returned by BucketAggregationResponse.ValidateAll() if the
// designated constraints aren't met.
type BucketAggregationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketAggregationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketAggregationResponseMultiError) AllErrors() []error { return m }

// BucketAggregationResponseValidationError is the validation error returned by
// BucketAggregationResponse.Validate if the designated constraints aren't met.
type BucketAggregationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketAggregationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketAggregationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketAggregationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketAggregationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketAggregationResponseValidationError) ErrorName() string {
	return "BucketAggregationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BucketAggregationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketAggregationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketAggregationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketAggregationResponseValidationError{}

// Validate checks the field values on LogFieldsAggregationResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogFieldsAggregationResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogFieldsAggregationResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogFieldsAggregationResultMultiError, or nil if none found.
func (m *LogFieldsAggregationResult) ValidateAll() error {
	return m.validate(true)
}

func (m *LogFieldsAggregationResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	{
		sorted_keys := make([]string, len(m.GetAggFields()))
		i := 0
		for key := range m.GetAggFields() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetAggFields()[key]
			_ = val

			// no validation rules for AggFields[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, LogFieldsAggregationResultValidationError{
							field:  fmt.Sprintf("AggFields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, LogFieldsAggregationResultValidationError{
							field:  fmt.Sprintf("AggFields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return LogFieldsAggregationResultValidationError{
						field:  fmt.Sprintf("AggFields[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return LogFieldsAggregationResultMultiError(errors)
	}

	return nil
}

// LogFieldsAggregationResultMultiError is an error wrapping multiple
// validation errors returned by LogFieldsAggregationResult.ValidateAll() if
// the designated constraints aren't met.
type LogFieldsAggregationResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogFieldsAggregationResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogFieldsAggregationResultMultiError) AllErrors() []error { return m }

// LogFieldsAggregationResultValidationError is the validation error returned
// by LogFieldsAggregationResult.Validate if the designated constraints aren't met.
type LogFieldsAggregationResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogFieldsAggregationResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogFieldsAggregationResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogFieldsAggregationResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogFieldsAggregationResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogFieldsAggregationResultValidationError) ErrorName() string {
	return "LogFieldsAggregationResultValidationError"
}

// Error satisfies the builtin error interface
func (e LogFieldsAggregationResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogFieldsAggregationResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogFieldsAggregationResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogFieldsAggregationResultValidationError{}

// Validate checks the field values on LogFieldBucket with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogFieldBucket) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogFieldBucket with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogFieldBucketMultiError,
// or nil if none found.
func (m *LogFieldBucket) ValidateAll() error {
	return m.validate(true)
}

func (m *LogFieldBucket) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBuckets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LogFieldBucketValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LogFieldBucketValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LogFieldBucketValidationError{
					field:  fmt.Sprintf("Buckets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LogFieldBucketMultiError(errors)
	}

	return nil
}

// LogFieldBucketMultiError is an error wrapping multiple validation errors
// returned by LogFieldBucket.ValidateAll() if the designated constraints
// aren't met.
type LogFieldBucketMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogFieldBucketMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogFieldBucketMultiError) AllErrors() []error { return m }

// LogFieldBucketValidationError is the validation error returned by
// LogFieldBucket.Validate if the designated constraints aren't met.
type LogFieldBucketValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogFieldBucketValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogFieldBucketValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogFieldBucketValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogFieldBucketValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogFieldBucketValidationError) ErrorName() string { return "LogFieldBucketValidationError" }

// Error satisfies the builtin error interface
func (e LogFieldBucketValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogFieldBucket.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogFieldBucketValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogFieldBucketValidationError{}

// Validate checks the field values on BucketAgg with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BucketAgg) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketAgg with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BucketAggMultiError, or nil
// if none found.
func (m *BucketAgg) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketAgg) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Count

	if len(errors) > 0 {
		return BucketAggMultiError(errors)
	}

	return nil
}

// BucketAggMultiError is an error wrapping multiple validation errors returned
// by BucketAgg.ValidateAll() if the designated constraints aren't met.
type BucketAggMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketAggMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketAggMultiError) AllErrors() []error { return m }

// BucketAggValidationError is the validation error returned by
// BucketAgg.Validate if the designated constraints aren't met.
type BucketAggValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketAggValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketAggValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketAggValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketAggValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketAggValidationError) ErrorName() string { return "BucketAggValidationError" }

// Error satisfies the builtin error interface
func (e BucketAggValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketAgg.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketAggValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketAggValidationError{}

// Validate checks the field values on HistogramAggregationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistogramAggregationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistogramAggregationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistogramAggregationRequestMultiError, or nil if none found.
func (m *HistogramAggregationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HistogramAggregationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ClusterName

	// no validation rules for Addon

	// no validation rules for Query

	// no validation rules for Debug

	if len(errors) > 0 {
		return HistogramAggregationRequestMultiError(errors)
	}

	return nil
}

// HistogramAggregationRequestMultiError is an error wrapping multiple
// validation errors returned by HistogramAggregationRequest.ValidateAll() if
// the designated constraints aren't met.
type HistogramAggregationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistogramAggregationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistogramAggregationRequestMultiError) AllErrors() []error { return m }

// HistogramAggregationRequestValidationError is the validation error returned
// by HistogramAggregationRequest.Validate if the designated constraints
// aren't met.
type HistogramAggregationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistogramAggregationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistogramAggregationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistogramAggregationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistogramAggregationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistogramAggregationRequestValidationError) ErrorName() string {
	return "HistogramAggregationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HistogramAggregationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistogramAggregationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistogramAggregationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistogramAggregationRequestValidationError{}

// Validate checks the field values on HistogramAggregationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistogramAggregationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistogramAggregationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistogramAggregationResponseMultiError, or nil if none found.
func (m *HistogramAggregationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HistogramAggregationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistogramAggregationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistogramAggregationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistogramAggregationResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HistogramAggregationResponseMultiError(errors)
	}

	return nil
}

// HistogramAggregationResponseMultiError is an error wrapping multiple
// validation errors returned by HistogramAggregationResponse.ValidateAll() if
// the designated constraints aren't met.
type HistogramAggregationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistogramAggregationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistogramAggregationResponseMultiError) AllErrors() []error { return m }

// HistogramAggregationResponseValidationError is the validation error returned
// by HistogramAggregationResponse.Validate if the designated constraints
// aren't met.
type HistogramAggregationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistogramAggregationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistogramAggregationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistogramAggregationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistogramAggregationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistogramAggregationResponseValidationError) ErrorName() string {
	return "HistogramAggregationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HistogramAggregationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistogramAggregationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistogramAggregationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistogramAggregationResponseValidationError{}

// Validate checks the field values on HistogramAggregationResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HistogramAggregationResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistogramAggregationResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HistogramAggregationResultMultiError, or nil if none found.
func (m *HistogramAggregationResult) ValidateAll() error {
	return m.validate(true)
}

func (m *HistogramAggregationResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Total

	// no validation rules for Interval

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HistogramAggregationResultValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HistogramAggregationResultValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HistogramAggregationResultValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HistogramAggregationResultMultiError(errors)
	}

	return nil
}

// HistogramAggregationResultMultiError is an error wrapping multiple
// validation errors returned by HistogramAggregationResult.ValidateAll() if
// the designated constraints aren't met.
type HistogramAggregationResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistogramAggregationResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistogramAggregationResultMultiError) AllErrors() []error { return m }

// HistogramAggregationResultValidationError is the validation error returned
// by HistogramAggregationResult.Validate if the designated constraints aren't met.
type HistogramAggregationResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistogramAggregationResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistogramAggregationResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistogramAggregationResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistogramAggregationResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistogramAggregationResultValidationError) ErrorName() string {
	return "HistogramAggregationResultValidationError"
}

// Error satisfies the builtin error interface
func (e HistogramAggregationResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistogramAggregationResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistogramAggregationResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistogramAggregationResultValidationError{}

// Validate checks the field values on LogStatisticResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogStatisticResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogStatisticResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogStatisticResultMultiError, or nil if none found.
func (m *LogStatisticResult) ValidateAll() error {
	return m.validate(true)
}

func (m *LogStatisticResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LogStatisticResultValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LogStatisticResultValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LogStatisticResultValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LogStatisticResultMultiError(errors)
	}

	return nil
}

// LogStatisticResultMultiError is an error wrapping multiple validation errors
// returned by LogStatisticResult.ValidateAll() if the designated constraints
// aren't met.
type LogStatisticResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogStatisticResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogStatisticResultMultiError) AllErrors() []error { return m }

// LogStatisticResultValidationError is the validation error returned by
// LogStatisticResult.Validate if the designated constraints aren't met.
type LogStatisticResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogStatisticResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogStatisticResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogStatisticResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogStatisticResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogStatisticResultValidationError) ErrorName() string {
	return "LogStatisticResultValidationError"
}

// Error satisfies the builtin error interface
func (e LogStatisticResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogStatisticResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogStatisticResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogStatisticResultValidationError{}

// Validate checks the field values on CountHistogram with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CountHistogram) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountHistogram with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CountHistogramMultiError,
// or nil if none found.
func (m *CountHistogram) ValidateAll() error {
	return m.validate(true)
}

func (m *CountHistogram) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CountHistogramValidationError{
					field:  "Count",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CountHistogramValidationError{
					field:  "Count",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CountHistogramValidationError{
				field:  "Count",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CountHistogramMultiError(errors)
	}

	return nil
}

// CountHistogramMultiError is an error wrapping multiple validation errors
// returned by CountHistogram.ValidateAll() if the designated constraints
// aren't met.
type CountHistogramMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountHistogramMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountHistogramMultiError) AllErrors() []error { return m }

// CountHistogramValidationError is the validation error returned by
// CountHistogram.Validate if the designated constraints aren't met.
type CountHistogramValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountHistogramValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountHistogramValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountHistogramValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountHistogramValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountHistogramValidationError) ErrorName() string { return "CountHistogramValidationError" }

// Error satisfies the builtin error interface
func (e CountHistogramValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountHistogram.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountHistogramValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountHistogramValidationError{}

// Validate checks the field values on ArrayAgg with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArrayAgg) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArrayAgg with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArrayAggMultiError, or nil
// if none found.
func (m *ArrayAgg) ValidateAll() error {
	return m.validate(true)
}

func (m *ArrayAgg) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UnitType

	// no validation rules for Unit

	// no validation rules for ChartType

	// no validation rules for AxisIndex

	// no validation rules for Name

	// no validation rules for Tag

	if len(errors) > 0 {
		return ArrayAggMultiError(errors)
	}

	return nil
}

// ArrayAggMultiError is an error wrapping multiple validation errors returned
// by ArrayAgg.ValidateAll() if the designated constraints aren't met.
type ArrayAggMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArrayAggMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArrayAggMultiError) AllErrors() []error { return m }

// ArrayAggValidationError is the validation error returned by
// ArrayAgg.Validate if the designated constraints aren't met.
type ArrayAggValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArrayAggValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArrayAggValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArrayAggValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArrayAggValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArrayAggValidationError) ErrorName() string { return "ArrayAggValidationError" }

// Error satisfies the builtin error interface
func (e ArrayAggValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArrayAgg.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArrayAggValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArrayAggValidationError{}
