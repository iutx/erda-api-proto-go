// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: trace.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetTraceQueryConditionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTraceQueryConditionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTraceQueryConditionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTraceQueryConditionsRequestMultiError, or nil if none found.
func (m *GetTraceQueryConditionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTraceQueryConditionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TenantID

	if len(errors) > 0 {
		return GetTraceQueryConditionsRequestMultiError(errors)
	}

	return nil
}

// GetTraceQueryConditionsRequestMultiError is an error wrapping multiple
// validation errors returned by GetTraceQueryConditionsRequest.ValidateAll()
// if the designated constraints aren't met.
type GetTraceQueryConditionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTraceQueryConditionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTraceQueryConditionsRequestMultiError) AllErrors() []error { return m }

// GetTraceQueryConditionsRequestValidationError is the validation error
// returned by GetTraceQueryConditionsRequest.Validate if the designated
// constraints aren't met.
type GetTraceQueryConditionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTraceQueryConditionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTraceQueryConditionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTraceQueryConditionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTraceQueryConditionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTraceQueryConditionsRequestValidationError) ErrorName() string {
	return "GetTraceQueryConditionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTraceQueryConditionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTraceQueryConditionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTraceQueryConditionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTraceQueryConditionsRequestValidationError{}

// Validate checks the field values on GetTraceQueryConditionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTraceQueryConditionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTraceQueryConditionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTraceQueryConditionsResponseMultiError, or nil if none found.
func (m *GetTraceQueryConditionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTraceQueryConditionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTraceQueryConditionsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTraceQueryConditionsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTraceQueryConditionsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTraceQueryConditionsResponseMultiError(errors)
	}

	return nil
}

// GetTraceQueryConditionsResponseMultiError is an error wrapping multiple
// validation errors returned by GetTraceQueryConditionsResponse.ValidateAll()
// if the designated constraints aren't met.
type GetTraceQueryConditionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTraceQueryConditionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTraceQueryConditionsResponseMultiError) AllErrors() []error { return m }

// GetTraceQueryConditionsResponseValidationError is the validation error
// returned by GetTraceQueryConditionsResponse.Validate if the designated
// constraints aren't met.
type GetTraceQueryConditionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTraceQueryConditionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTraceQueryConditionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTraceQueryConditionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTraceQueryConditionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTraceQueryConditionsResponseValidationError) ErrorName() string {
	return "GetTraceQueryConditionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTraceQueryConditionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTraceQueryConditionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTraceQueryConditionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTraceQueryConditionsResponseValidationError{}

// Validate checks the field values on TraceQueryConditions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TraceQueryConditions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraceQueryConditions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TraceQueryConditionsMultiError, or nil if none found.
func (m *TraceQueryConditions) ValidateAll() error {
	return m.validate(true)
}

func (m *TraceQueryConditions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSort() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TraceQueryConditionsValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TraceQueryConditionsValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TraceQueryConditionsValidationError{
					field:  fmt.Sprintf("Sort[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTraceStatus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TraceQueryConditionsValidationError{
						field:  fmt.Sprintf("TraceStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TraceQueryConditionsValidationError{
						field:  fmt.Sprintf("TraceStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TraceQueryConditionsValidationError{
					field:  fmt.Sprintf("TraceStatus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOthers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TraceQueryConditionsValidationError{
						field:  fmt.Sprintf("Others[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TraceQueryConditionsValidationError{
						field:  fmt.Sprintf("Others[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TraceQueryConditionsValidationError{
					field:  fmt.Sprintf("Others[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TraceQueryConditionsMultiError(errors)
	}

	return nil
}

// TraceQueryConditionsMultiError is an error wrapping multiple validation
// errors returned by TraceQueryConditions.ValidateAll() if the designated
// constraints aren't met.
type TraceQueryConditionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceQueryConditionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceQueryConditionsMultiError) AllErrors() []error { return m }

// TraceQueryConditionsValidationError is the validation error returned by
// TraceQueryConditions.Validate if the designated constraints aren't met.
type TraceQueryConditionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceQueryConditionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceQueryConditionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceQueryConditionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceQueryConditionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceQueryConditionsValidationError) ErrorName() string {
	return "TraceQueryConditionsValidationError"
}

// Error satisfies the builtin error interface
func (e TraceQueryConditionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraceQueryConditions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceQueryConditionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceQueryConditionsValidationError{}

// Validate checks the field values on TraceQueryCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TraceQueryCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraceQueryCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TraceQueryConditionMultiError, or nil if none found.
func (m *TraceQueryCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *TraceQueryCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	// no validation rules for DisplayName

	if len(errors) > 0 {
		return TraceQueryConditionMultiError(errors)
	}

	return nil
}

// TraceQueryConditionMultiError is an error wrapping multiple validation
// errors returned by TraceQueryCondition.ValidateAll() if the designated
// constraints aren't met.
type TraceQueryConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceQueryConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceQueryConditionMultiError) AllErrors() []error { return m }

// TraceQueryConditionValidationError is the validation error returned by
// TraceQueryCondition.Validate if the designated constraints aren't met.
type TraceQueryConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceQueryConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceQueryConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceQueryConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceQueryConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceQueryConditionValidationError) ErrorName() string {
	return "TraceQueryConditionValidationError"
}

// Error satisfies the builtin error interface
func (e TraceQueryConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraceQueryCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceQueryConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceQueryConditionValidationError{}

// Validate checks the field values on OtherTraceQueryCondition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OtherTraceQueryCondition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OtherTraceQueryCondition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OtherTraceQueryConditionMultiError, or nil if none found.
func (m *OtherTraceQueryCondition) ValidateAll() error {
	return m.validate(true)
}

func (m *OtherTraceQueryCondition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	// no validation rules for DisplayName

	// no validation rules for Type

	// no validation rules for ParamKey

	if len(errors) > 0 {
		return OtherTraceQueryConditionMultiError(errors)
	}

	return nil
}

// OtherTraceQueryConditionMultiError is an error wrapping multiple validation
// errors returned by OtherTraceQueryCondition.ValidateAll() if the designated
// constraints aren't met.
type OtherTraceQueryConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OtherTraceQueryConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OtherTraceQueryConditionMultiError) AllErrors() []error { return m }

// OtherTraceQueryConditionValidationError is the validation error returned by
// OtherTraceQueryCondition.Validate if the designated constraints aren't met.
type OtherTraceQueryConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OtherTraceQueryConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OtherTraceQueryConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OtherTraceQueryConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OtherTraceQueryConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OtherTraceQueryConditionValidationError) ErrorName() string {
	return "OtherTraceQueryConditionValidationError"
}

// Error satisfies the builtin error interface
func (e OtherTraceQueryConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOtherTraceQueryCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OtherTraceQueryConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OtherTraceQueryConditionValidationError{}

// Validate checks the field values on GetTraceDebugRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTraceDebugRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTraceDebugRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTraceDebugRequestMultiError, or nil if none found.
func (m *GetTraceDebugRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTraceDebugRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRequestID()) < 1 {
		err := GetTraceDebugRequestValidationError{
			field:  "RequestID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := GetTraceDebugRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTraceDebugRequestMultiError(errors)
	}

	return nil
}

// GetTraceDebugRequestMultiError is an error wrapping multiple validation
// errors returned by GetTraceDebugRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTraceDebugRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTraceDebugRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTraceDebugRequestMultiError) AllErrors() []error { return m }

// GetTraceDebugRequestValidationError is the validation error returned by
// GetTraceDebugRequest.Validate if the designated constraints aren't met.
type GetTraceDebugRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTraceDebugRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTraceDebugRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTraceDebugRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTraceDebugRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTraceDebugRequestValidationError) ErrorName() string {
	return "GetTraceDebugRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTraceDebugRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTraceDebugRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTraceDebugRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTraceDebugRequestValidationError{}

// Validate checks the field values on CreateTraceDebugRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTraceDebugRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTraceDebugRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTraceDebugRequestMultiError, or nil if none found.
func (m *CreateTraceDebugRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTraceDebugRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestID

	// no validation rules for ScopeID

	// no validation rules for Url

	// no validation rules for Query

	// no validation rules for Header

	// no validation rules for Body

	// no validation rules for Status

	// no validation rules for StatusName

	// no validation rules for ResponseCode

	// no validation rules for ResponseBody

	// no validation rules for Method

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for ProjectID

	// no validation rules for Name

	if len(errors) > 0 {
		return CreateTraceDebugRequestMultiError(errors)
	}

	return nil
}

// CreateTraceDebugRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTraceDebugRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTraceDebugRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTraceDebugRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTraceDebugRequestMultiError) AllErrors() []error { return m }

// CreateTraceDebugRequestValidationError is the validation error returned by
// CreateTraceDebugRequest.Validate if the designated constraints aren't met.
type CreateTraceDebugRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTraceDebugRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTraceDebugRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTraceDebugRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTraceDebugRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTraceDebugRequestValidationError) ErrorName() string {
	return "CreateTraceDebugRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTraceDebugRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTraceDebugRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTraceDebugRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTraceDebugRequestValidationError{}

// Validate checks the field values on StopTraceDebugRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopTraceDebugRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopTraceDebugRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopTraceDebugRequestMultiError, or nil if none found.
func (m *StopTraceDebugRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StopTraceDebugRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRequestID()) < 1 {
		err := StopTraceDebugRequestValidationError{
			field:  "RequestID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := StopTraceDebugRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StopTraceDebugRequestMultiError(errors)
	}

	return nil
}

// StopTraceDebugRequestMultiError is an error wrapping multiple validation
// errors returned by StopTraceDebugRequest.ValidateAll() if the designated
// constraints aren't met.
type StopTraceDebugRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopTraceDebugRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopTraceDebugRequestMultiError) AllErrors() []error { return m }

// StopTraceDebugRequestValidationError is the validation error returned by
// StopTraceDebugRequest.Validate if the designated constraints aren't met.
type StopTraceDebugRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopTraceDebugRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopTraceDebugRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopTraceDebugRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopTraceDebugRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopTraceDebugRequestValidationError) ErrorName() string {
	return "StopTraceDebugRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StopTraceDebugRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopTraceDebugRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopTraceDebugRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopTraceDebugRequestValidationError{}

// Validate checks the field values on GetTraceDebugStatusByRequestIDRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetTraceDebugStatusByRequestIDRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTraceDebugStatusByRequestIDRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetTraceDebugStatusByRequestIDRequestMultiError, or nil if none found.
func (m *GetTraceDebugStatusByRequestIDRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTraceDebugStatusByRequestIDRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRequestID()) < 1 {
		err := GetTraceDebugStatusByRequestIDRequestValidationError{
			field:  "RequestID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := GetTraceDebugStatusByRequestIDRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTraceDebugStatusByRequestIDRequestMultiError(errors)
	}

	return nil
}

// GetTraceDebugStatusByRequestIDRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetTraceDebugStatusByRequestIDRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTraceDebugStatusByRequestIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTraceDebugStatusByRequestIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTraceDebugStatusByRequestIDRequestMultiError) AllErrors() []error { return m }

// GetTraceDebugStatusByRequestIDRequestValidationError is the validation error
// returned by GetTraceDebugStatusByRequestIDRequest.Validate if the
// designated constraints aren't met.
type GetTraceDebugStatusByRequestIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTraceDebugStatusByRequestIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTraceDebugStatusByRequestIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTraceDebugStatusByRequestIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTraceDebugStatusByRequestIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTraceDebugStatusByRequestIDRequestValidationError) ErrorName() string {
	return "GetTraceDebugStatusByRequestIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTraceDebugStatusByRequestIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTraceDebugStatusByRequestIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTraceDebugStatusByRequestIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTraceDebugStatusByRequestIDRequestValidationError{}

// Validate checks the field values on GetTraceDebugHistoriesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTraceDebugHistoriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTraceDebugHistoriesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTraceDebugHistoriesRequestMultiError, or nil if none found.
func (m *GetTraceDebugHistoriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTraceDebugHistoriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := GetTraceDebugHistoriesRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Limit

	if len(errors) > 0 {
		return GetTraceDebugHistoriesRequestMultiError(errors)
	}

	return nil
}

// GetTraceDebugHistoriesRequestMultiError is an error wrapping multiple
// validation errors returned by GetTraceDebugHistoriesRequest.ValidateAll()
// if the designated constraints aren't met.
type GetTraceDebugHistoriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTraceDebugHistoriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTraceDebugHistoriesRequestMultiError) AllErrors() []error { return m }

// GetTraceDebugHistoriesRequestValidationError is the validation error
// returned by GetTraceDebugHistoriesRequest.Validate if the designated
// constraints aren't met.
type GetTraceDebugHistoriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTraceDebugHistoriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTraceDebugHistoriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTraceDebugHistoriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTraceDebugHistoriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTraceDebugHistoriesRequestValidationError) ErrorName() string {
	return "GetTraceDebugHistoriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTraceDebugHistoriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTraceDebugHistoriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTraceDebugHistoriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTraceDebugHistoriesRequestValidationError{}

// Validate checks the field values on GetSpansRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSpansRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSpansRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSpansRequestMultiError, or nil if none found.
func (m *GetSpansRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSpansRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTraceID()) < 1 {
		err := GetSpansRequestValidationError{
			field:  "TraceID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetScopeID()) < 1 {
		err := GetSpansRequestValidationError{
			field:  "ScopeID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Limit

	// no validation rules for OrgName

	// no validation rules for StartTime

	if len(errors) > 0 {
		return GetSpansRequestMultiError(errors)
	}

	return nil
}

// GetSpansRequestMultiError is an error wrapping multiple validation errors
// returned by GetSpansRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSpansRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSpansRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSpansRequestMultiError) AllErrors() []error { return m }

// GetSpansRequestValidationError is the validation error returned by
// GetSpansRequest.Validate if the designated constraints aren't met.
type GetSpansRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSpansRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSpansRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSpansRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSpansRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSpansRequestValidationError) ErrorName() string { return "GetSpansRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetSpansRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSpansRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSpansRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSpansRequestValidationError{}

// Validate checks the field values on GetSpanDashboardsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSpanDashboardsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSpanDashboardsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSpanDashboardsRequestMultiError, or nil if none found.
func (m *GetSpanDashboardsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSpanDashboardsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTenantID()) < 1 {
		err := GetSpanDashboardsRequestValidationError{
			field:  "TenantID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := GetSpanDashboardsRequestValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetServiceInstanceID()) < 1 {
		err := GetSpanDashboardsRequestValidationError{
			field:  "ServiceInstanceID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StartTime

	// no validation rules for EndTime

	if len(errors) > 0 {
		return GetSpanDashboardsRequestMultiError(errors)
	}

	return nil
}

// GetSpanDashboardsRequestMultiError is an error wrapping multiple validation
// errors returned by GetSpanDashboardsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetSpanDashboardsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSpanDashboardsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSpanDashboardsRequestMultiError) AllErrors() []error { return m }

// GetSpanDashboardsRequestValidationError is the validation error returned by
// GetSpanDashboardsRequest.Validate if the designated constraints aren't met.
type GetSpanDashboardsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSpanDashboardsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSpanDashboardsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSpanDashboardsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSpanDashboardsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSpanDashboardsRequestValidationError) ErrorName() string {
	return "GetSpanDashboardsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSpanDashboardsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSpanDashboardsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSpanDashboardsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSpanDashboardsRequestValidationError{}

// Validate checks the field values on GetTracesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTracesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTracesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTracesRequestMultiError, or nil if none found.
func (m *GetTracesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTracesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTenantID()) < 1 {
		err := GetTracesRequestValidationError{
			field:  "TenantID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for Limit

	// no validation rules for TraceID

	// no validation rules for DurationMin

	// no validation rules for DurationMax

	// no validation rules for Sort

	// no validation rules for PageNo

	// no validation rules for PageSize

	for idx, item := range m.GetConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTracesRequestValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTracesRequestValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTracesRequestValidationError{
					field:  fmt.Sprintf("Conditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTracesRequestMultiError(errors)
	}

	return nil
}

// GetTracesRequestMultiError is an error wrapping multiple validation errors
// returned by GetTracesRequest.ValidateAll() if the designated constraints
// aren't met.
type GetTracesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTracesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTracesRequestMultiError) AllErrors() []error { return m }

// GetTracesRequestValidationError is the validation error returned by
// GetTracesRequest.Validate if the designated constraints aren't met.
type GetTracesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTracesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTracesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTracesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTracesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTracesRequestValidationError) ErrorName() string { return "GetTracesRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetTracesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTracesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTracesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTracesRequestValidationError{}

// Validate checks the field values on Condition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionMultiError, or nil
// if none found.
func (m *Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceID

	// no validation rules for ServiceName

	// no validation rules for RpcMethod

	// no validation rules for HttpPath

	// no validation rules for Operator

	if len(errors) > 0 {
		return ConditionMultiError(errors)
	}

	return nil
}

// ConditionMultiError is an error wrapping multiple validation errors returned
// by Condition.ValidateAll() if the designated constraints aren't met.
type ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionMultiError) AllErrors() []error { return m }

// ConditionValidationError is the validation error returned by
// Condition.Validate if the designated constraints aren't met.
type ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionValidationError) ErrorName() string { return "ConditionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionValidationError{}

// Validate checks the field values on GetSpansResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSpansResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSpansResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSpansResponseMultiError, or nil if none found.
func (m *GetSpansResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSpansResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSpans() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSpansResponseValidationError{
						field:  fmt.Sprintf("Spans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSpansResponseValidationError{
						field:  fmt.Sprintf("Spans[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSpansResponseValidationError{
					field:  fmt.Sprintf("Spans[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Duration

	// no validation rules for ServiceCount

	// no validation rules for Depth

	// no validation rules for SpanCount

	if len(errors) > 0 {
		return GetSpansResponseMultiError(errors)
	}

	return nil
}

// GetSpansResponseMultiError is an error wrapping multiple validation errors
// returned by GetSpansResponse.ValidateAll() if the designated constraints
// aren't met.
type GetSpansResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSpansResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSpansResponseMultiError) AllErrors() []error { return m }

// GetSpansResponseValidationError is the validation error returned by
// GetSpansResponse.Validate if the designated constraints aren't met.
type GetSpansResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSpansResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSpansResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSpansResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSpansResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSpansResponseValidationError) ErrorName() string { return "GetSpansResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetSpansResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSpansResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSpansResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSpansResponseValidationError{}

// Validate checks the field values on SpanAnalysis with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SpanAnalysis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpanAnalysis with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpanAnalysisMultiError, or
// nil if none found.
func (m *SpanAnalysis) ValidateAll() error {
	return m.validate(true)
}

func (m *SpanAnalysis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DashboardID

	if len(errors) > 0 {
		return SpanAnalysisMultiError(errors)
	}

	return nil
}

// SpanAnalysisMultiError is an error wrapping multiple validation errors
// returned by SpanAnalysis.ValidateAll() if the designated constraints aren't met.
type SpanAnalysisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpanAnalysisMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpanAnalysisMultiError) AllErrors() []error { return m }

// SpanAnalysisValidationError is the validation error returned by
// SpanAnalysis.Validate if the designated constraints aren't met.
type SpanAnalysisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpanAnalysisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpanAnalysisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpanAnalysisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpanAnalysisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpanAnalysisValidationError) ErrorName() string { return "SpanAnalysisValidationError" }

// Error satisfies the builtin error interface
func (e SpanAnalysisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpanAnalysis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpanAnalysisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpanAnalysisValidationError{}

// Validate checks the field values on GetSpanDashboardsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSpanDashboardsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSpanDashboardsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSpanDashboardsResponseMultiError, or nil if none found.
func (m *GetSpanDashboardsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSpanDashboardsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCallAnalysis()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSpanDashboardsResponseValidationError{
					field:  "CallAnalysis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSpanDashboardsResponseValidationError{
					field:  "CallAnalysis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCallAnalysis()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSpanDashboardsResponseValidationError{
				field:  "CallAnalysis",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetServiceAnalysis()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSpanDashboardsResponseValidationError{
					field:  "ServiceAnalysis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSpanDashboardsResponseValidationError{
					field:  "ServiceAnalysis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceAnalysis()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSpanDashboardsResponseValidationError{
				field:  "ServiceAnalysis",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSpanDashboardsResponseMultiError(errors)
	}

	return nil
}

// GetSpanDashboardsResponseMultiError is an error wrapping multiple validation
// errors returned by GetSpanDashboardsResponse.ValidateAll() if the
// designated constraints aren't met.
type GetSpanDashboardsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSpanDashboardsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSpanDashboardsResponseMultiError) AllErrors() []error { return m }

// GetSpanDashboardsResponseValidationError is the validation error returned by
// GetSpanDashboardsResponse.Validate if the designated constraints aren't met.
type GetSpanDashboardsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSpanDashboardsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSpanDashboardsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSpanDashboardsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSpanDashboardsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSpanDashboardsResponseValidationError) ErrorName() string {
	return "GetSpanDashboardsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSpanDashboardsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSpanDashboardsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSpanDashboardsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSpanDashboardsResponseValidationError{}

// Validate checks the field values on GetTracesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTracesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTracesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTracesResponseMultiError, or nil if none found.
func (m *GetTracesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTracesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTracesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTracesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTracesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for PageNo

	// no validation rules for PageSize

	// no validation rules for Total

	if len(errors) > 0 {
		return GetTracesResponseMultiError(errors)
	}

	return nil
}

// GetTracesResponseMultiError is an error wrapping multiple validation errors
// returned by GetTracesResponse.ValidateAll() if the designated constraints
// aren't met.
type GetTracesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTracesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTracesResponseMultiError) AllErrors() []error { return m }

// GetTracesResponseValidationError is the validation error returned by
// GetTracesResponse.Validate if the designated constraints aren't met.
type GetTracesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTracesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTracesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTracesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTracesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTracesResponseValidationError) ErrorName() string {
	return "GetTracesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTracesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTracesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTracesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTracesResponseValidationError{}

// Validate checks the field values on GetTraceDebugHistoriesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTraceDebugHistoriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTraceDebugHistoriesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTraceDebugHistoriesResponseMultiError, or nil if none found.
func (m *GetTraceDebugHistoriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTraceDebugHistoriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTraceDebugHistoriesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTraceDebugHistoriesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTraceDebugHistoriesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTraceDebugHistoriesResponseMultiError(errors)
	}

	return nil
}

// GetTraceDebugHistoriesResponseMultiError is an error wrapping multiple
// validation errors returned by GetTraceDebugHistoriesResponse.ValidateAll()
// if the designated constraints aren't met.
type GetTraceDebugHistoriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTraceDebugHistoriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTraceDebugHistoriesResponseMultiError) AllErrors() []error { return m }

// GetTraceDebugHistoriesResponseValidationError is the validation error
// returned by GetTraceDebugHistoriesResponse.Validate if the designated
// constraints aren't met.
type GetTraceDebugHistoriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTraceDebugHistoriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTraceDebugHistoriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTraceDebugHistoriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTraceDebugHistoriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTraceDebugHistoriesResponseValidationError) ErrorName() string {
	return "GetTraceDebugHistoriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTraceDebugHistoriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTraceDebugHistoriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTraceDebugHistoriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTraceDebugHistoriesResponseValidationError{}

// Validate checks the field values on GetTraceDebugResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTraceDebugResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTraceDebugResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTraceDebugResponseMultiError, or nil if none found.
func (m *GetTraceDebugResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTraceDebugResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTraceDebugResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTraceDebugResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTraceDebugResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTraceDebugResponseMultiError(errors)
	}

	return nil
}

// GetTraceDebugResponseMultiError is an error wrapping multiple validation
// errors returned by GetTraceDebugResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTraceDebugResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTraceDebugResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTraceDebugResponseMultiError) AllErrors() []error { return m }

// GetTraceDebugResponseValidationError is the validation error returned by
// GetTraceDebugResponse.Validate if the designated constraints aren't met.
type GetTraceDebugResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTraceDebugResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTraceDebugResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTraceDebugResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTraceDebugResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTraceDebugResponseValidationError) ErrorName() string {
	return "GetTraceDebugResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTraceDebugResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTraceDebugResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTraceDebugResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTraceDebugResponseValidationError{}

// Validate checks the field values on CreateTraceDebugResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTraceDebugResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTraceDebugResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTraceDebugResponseMultiError, or nil if none found.
func (m *CreateTraceDebugResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTraceDebugResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTraceDebugResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTraceDebugResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTraceDebugResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTraceDebugResponseMultiError(errors)
	}

	return nil
}

// CreateTraceDebugResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTraceDebugResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTraceDebugResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTraceDebugResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTraceDebugResponseMultiError) AllErrors() []error { return m }

// CreateTraceDebugResponseValidationError is the validation error returned by
// CreateTraceDebugResponse.Validate if the designated constraints aren't met.
type CreateTraceDebugResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTraceDebugResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTraceDebugResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTraceDebugResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTraceDebugResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTraceDebugResponseValidationError) ErrorName() string {
	return "CreateTraceDebugResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTraceDebugResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTraceDebugResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTraceDebugResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTraceDebugResponseValidationError{}

// Validate checks the field values on StopTraceDebugResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopTraceDebugResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopTraceDebugResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopTraceDebugResponseMultiError, or nil if none found.
func (m *StopTraceDebugResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StopTraceDebugResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StopTraceDebugResponseMultiError(errors)
	}

	return nil
}

// StopTraceDebugResponseMultiError is an error wrapping multiple validation
// errors returned by StopTraceDebugResponse.ValidateAll() if the designated
// constraints aren't met.
type StopTraceDebugResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopTraceDebugResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopTraceDebugResponseMultiError) AllErrors() []error { return m }

// StopTraceDebugResponseValidationError is the validation error returned by
// StopTraceDebugResponse.Validate if the designated constraints aren't met.
type StopTraceDebugResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopTraceDebugResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopTraceDebugResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopTraceDebugResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopTraceDebugResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopTraceDebugResponseValidationError) ErrorName() string {
	return "StopTraceDebugResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StopTraceDebugResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopTraceDebugResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopTraceDebugResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopTraceDebugResponseValidationError{}

// Validate checks the field values on GetTraceDebugStatusByRequestIDResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetTraceDebugStatusByRequestIDResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetTraceDebugStatusByRequestIDResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GetTraceDebugStatusByRequestIDResponseMultiError, or nil if none found.
func (m *GetTraceDebugStatusByRequestIDResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTraceDebugStatusByRequestIDResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTraceDebugStatusByRequestIDResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTraceDebugStatusByRequestIDResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTraceDebugStatusByRequestIDResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTraceDebugStatusByRequestIDResponseMultiError(errors)
	}

	return nil
}

// GetTraceDebugStatusByRequestIDResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetTraceDebugStatusByRequestIDResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTraceDebugStatusByRequestIDResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTraceDebugStatusByRequestIDResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTraceDebugStatusByRequestIDResponseMultiError) AllErrors() []error { return m }

// GetTraceDebugStatusByRequestIDResponseValidationError is the validation
// error returned by GetTraceDebugStatusByRequestIDResponse.Validate if the
// designated constraints aren't met.
type GetTraceDebugStatusByRequestIDResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTraceDebugStatusByRequestIDResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTraceDebugStatusByRequestIDResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTraceDebugStatusByRequestIDResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTraceDebugStatusByRequestIDResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTraceDebugStatusByRequestIDResponseValidationError) ErrorName() string {
	return "GetTraceDebugStatusByRequestIDResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTraceDebugStatusByRequestIDResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTraceDebugStatusByRequestIDResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTraceDebugStatusByRequestIDResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTraceDebugStatusByRequestIDResponseValidationError{}

// Validate checks the field values on TraceDebug with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TraceDebug) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraceDebug with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TraceDebugMultiError, or
// nil if none found.
func (m *TraceDebug) ValidateAll() error {
	return m.validate(true)
}

func (m *TraceDebug) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetHistory() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TraceDebugValidationError{
						field:  fmt.Sprintf("History[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TraceDebugValidationError{
						field:  fmt.Sprintf("History[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TraceDebugValidationError{
					field:  fmt.Sprintf("History[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Limit

	// no validation rules for Offset

	// no validation rules for Total

	if len(errors) > 0 {
		return TraceDebugMultiError(errors)
	}

	return nil
}

// TraceDebugMultiError is an error wrapping multiple validation errors
// returned by TraceDebug.ValidateAll() if the designated constraints aren't met.
type TraceDebugMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceDebugMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceDebugMultiError) AllErrors() []error { return m }

// TraceDebugValidationError is the validation error returned by
// TraceDebug.Validate if the designated constraints aren't met.
type TraceDebugValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceDebugValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceDebugValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceDebugValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceDebugValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceDebugValidationError) ErrorName() string { return "TraceDebugValidationError" }

// Error satisfies the builtin error interface
func (e TraceDebugValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraceDebug.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceDebugValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceDebugValidationError{}

// Validate checks the field values on TraceDebugStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TraceDebugStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraceDebugStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TraceDebugStatusMultiError, or nil if none found.
func (m *TraceDebugStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TraceDebugStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestID

	// no validation rules for Status

	// no validation rules for StatusName

	// no validation rules for ScopeID

	if len(errors) > 0 {
		return TraceDebugStatusMultiError(errors)
	}

	return nil
}

// TraceDebugStatusMultiError is an error wrapping multiple validation errors
// returned by TraceDebugStatus.ValidateAll() if the designated constraints
// aren't met.
type TraceDebugStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceDebugStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceDebugStatusMultiError) AllErrors() []error { return m }

// TraceDebugStatusValidationError is the validation error returned by
// TraceDebugStatus.Validate if the designated constraints aren't met.
type TraceDebugStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceDebugStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceDebugStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceDebugStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceDebugStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceDebugStatusValidationError) ErrorName() string { return "TraceDebugStatusValidationError" }

// Error satisfies the builtin error interface
func (e TraceDebugStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraceDebugStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceDebugStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceDebugStatusValidationError{}

// Validate checks the field values on TraceDebugHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TraceDebugHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraceDebugHistory with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TraceDebugHistoryMultiError, or nil if none found.
func (m *TraceDebugHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *TraceDebugHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequestID

	// no validation rules for ScopeID

	// no validation rules for Url

	// no validation rules for Query

	// no validation rules for Header

	// no validation rules for Body

	// no validation rules for Status

	// no validation rules for StatusName

	// no validation rules for ResponseCode

	// no validation rules for ResponseBody

	// no validation rules for Method

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	// no validation rules for Name

	if len(errors) > 0 {
		return TraceDebugHistoryMultiError(errors)
	}

	return nil
}

// TraceDebugHistoryMultiError is an error wrapping multiple validation errors
// returned by TraceDebugHistory.ValidateAll() if the designated constraints
// aren't met.
type TraceDebugHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceDebugHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceDebugHistoryMultiError) AllErrors() []error { return m }

// TraceDebugHistoryValidationError is the validation error returned by
// TraceDebugHistory.Validate if the designated constraints aren't met.
type TraceDebugHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceDebugHistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceDebugHistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceDebugHistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceDebugHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceDebugHistoryValidationError) ErrorName() string {
	return "TraceDebugHistoryValidationError"
}

// Error satisfies the builtin error interface
func (e TraceDebugHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraceDebugHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceDebugHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceDebugHistoryValidationError{}

// Validate checks the field values on Span with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Span) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Span with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SpanMultiError, or nil if none found.
func (m *Span) ValidateAll() error {
	return m.validate(true)
}

func (m *Span) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TraceId

	// no validation rules for OperationName

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for ParentSpanId

	// no validation rules for Timestamp

	// no validation rules for Tags

	// no validation rules for Duration

	// no validation rules for SelfDuration

	if len(errors) > 0 {
		return SpanMultiError(errors)
	}

	return nil
}

// SpanMultiError is an error wrapping multiple validation errors returned by
// Span.ValidateAll() if the designated constraints aren't met.
type SpanMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpanMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpanMultiError) AllErrors() []error { return m }

// SpanValidationError is the validation error returned by Span.Validate if the
// designated constraints aren't met.
type SpanValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpanValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpanValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpanValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpanValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpanValidationError) ErrorName() string { return "SpanValidationError" }

// Error satisfies the builtin error interface
func (e SpanValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpan.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpanValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpanValidationError{}

// Validate checks the field values on Trace with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Trace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trace with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TraceMultiError, or nil if none found.
func (m *Trace) ValidateAll() error {
	return m.validate(true)
}

func (m *Trace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Duration

	// no validation rules for StartTime

	// no validation rules for SpanCount

	if len(errors) > 0 {
		return TraceMultiError(errors)
	}

	return nil
}

// TraceMultiError is an error wrapping multiple validation errors returned by
// Trace.ValidateAll() if the designated constraints aren't met.
type TraceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceMultiError) AllErrors() []error { return m }

// TraceValidationError is the validation error returned by Trace.Validate if
// the designated constraints aren't met.
type TraceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceValidationError) ErrorName() string { return "TraceValidationError" }

// Error satisfies the builtin error interface
func (e TraceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceValidationError{}

// Validate checks the field values on SpanEvent with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SpanEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpanEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpanEventMultiError, or nil
// if none found.
func (m *SpanEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *SpanEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Timestamp

	// no validation rules for Events

	if len(errors) > 0 {
		return SpanEventMultiError(errors)
	}

	return nil
}

// SpanEventMultiError is an error wrapping multiple validation errors returned
// by SpanEvent.ValidateAll() if the designated constraints aren't met.
type SpanEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpanEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpanEventMultiError) AllErrors() []error { return m }

// SpanEventValidationError is the validation error returned by
// SpanEvent.Validate if the designated constraints aren't met.
type SpanEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpanEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpanEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpanEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpanEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpanEventValidationError) ErrorName() string { return "SpanEventValidationError" }

// Error satisfies the builtin error interface
func (e SpanEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpanEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpanEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpanEventValidationError{}

// Validate checks the field values on SpanEventRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SpanEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpanEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpanEventRequestMultiError, or nil if none found.
func (m *SpanEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SpanEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpanID

	// no validation rules for StartTime

	if len(errors) > 0 {
		return SpanEventRequestMultiError(errors)
	}

	return nil
}

// SpanEventRequestMultiError is an error wrapping multiple validation errors
// returned by SpanEventRequest.ValidateAll() if the designated constraints
// aren't met.
type SpanEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpanEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpanEventRequestMultiError) AllErrors() []error { return m }

// SpanEventRequestValidationError is the validation error returned by
// SpanEventRequest.Validate if the designated constraints aren't met.
type SpanEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpanEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpanEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpanEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpanEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpanEventRequestValidationError) ErrorName() string { return "SpanEventRequestValidationError" }

// Error satisfies the builtin error interface
func (e SpanEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpanEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpanEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpanEventRequestValidationError{}

// Validate checks the field values on SpanEventResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SpanEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpanEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpanEventResponseMultiError, or nil if none found.
func (m *SpanEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SpanEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSpanEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SpanEventResponseValidationError{
						field:  fmt.Sprintf("SpanEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SpanEventResponseValidationError{
						field:  fmt.Sprintf("SpanEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SpanEventResponseValidationError{
					field:  fmt.Sprintf("SpanEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SpanEventResponseMultiError(errors)
	}

	return nil
}

// SpanEventResponseMultiError is an error wrapping multiple validation errors
// returned by SpanEventResponse.ValidateAll() if the designated constraints
// aren't met.
type SpanEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpanEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpanEventResponseMultiError) AllErrors() []error { return m }

// SpanEventResponseValidationError is the validation error returned by
// SpanEventResponse.Validate if the designated constraints aren't met.
type SpanEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpanEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpanEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpanEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpanEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpanEventResponseValidationError) ErrorName() string {
	return "SpanEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SpanEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpanEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpanEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpanEventResponseValidationError{}
