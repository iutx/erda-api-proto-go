// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: apm_diagnotor.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ListServicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServicesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServicesRequestMultiError, or nil if none found.
func (m *ListServicesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServicesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTerminusKey()) < 1 {
		err := ListServicesRequestValidationError{
			field:  "TerminusKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListServicesRequestMultiError(errors)
	}

	return nil
}

// ListServicesRequestMultiError is an error wrapping multiple validation
// errors returned by ListServicesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListServicesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServicesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServicesRequestMultiError) AllErrors() []error { return m }

// ListServicesRequestValidationError is the validation error returned by
// ListServicesRequest.Validate if the designated constraints aren't met.
type ListServicesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServicesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServicesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServicesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServicesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServicesRequestValidationError) ErrorName() string {
	return "ListServicesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListServicesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServicesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServicesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServicesRequestValidationError{}

// Validate checks the field values on ListServicesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListServicesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListServicesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListServicesResponseMultiError, or nil if none found.
func (m *ListServicesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListServicesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListServicesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListServicesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListServicesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListServicesResponseMultiError(errors)
	}

	return nil
}

// ListServicesResponseMultiError is an error wrapping multiple validation
// errors returned by ListServicesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListServicesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListServicesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListServicesResponseMultiError) AllErrors() []error { return m }

// ListServicesResponseValidationError is the validation error returned by
// ListServicesResponse.Validate if the designated constraints aren't met.
type ListServicesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListServicesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListServicesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListServicesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListServicesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListServicesResponseValidationError) ErrorName() string {
	return "ListServicesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListServicesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListServicesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListServicesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListServicesResponseValidationError{}

// Validate checks the field values on ServiceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceInfoMultiError, or
// nil if none found.
func (m *ServiceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgName

	// no validation rules for OrgID

	// no validation rules for ClusterName

	// no validation rules for ProjectName

	// no validation rules for ProjectID

	// no validation rules for ApplicationName

	// no validation rules for ApplicationID

	// no validation rules for Service

	for idx, item := range m.GetInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceInfoValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceInfoValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceInfoValidationError{
					field:  fmt.Sprintf("Instances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceInfoMultiError(errors)
	}

	return nil
}

// ServiceInfoMultiError is an error wrapping multiple validation errors
// returned by ServiceInfo.ValidateAll() if the designated constraints aren't met.
type ServiceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceInfoMultiError) AllErrors() []error { return m }

// ServiceInfoValidationError is the validation error returned by
// ServiceInfo.Validate if the designated constraints aren't met.
type ServiceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceInfoValidationError) ErrorName() string { return "ServiceInfoValidationError" }

// Error satisfies the builtin error interface
func (e ServiceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceInfoValidationError{}

// Validate checks the field values on InstanceInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceInfoMultiError, or
// nil if none found.
func (m *InstanceInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PodName

	// no validation rules for Namespace

	// no validation rules for HostIP

	// no validation rules for Ip

	// no validation rules for RuntimeName

	// no validation rules for RuntimeID

	if len(errors) > 0 {
		return InstanceInfoMultiError(errors)
	}

	return nil
}

// InstanceInfoMultiError is an error wrapping multiple validation errors
// returned by InstanceInfo.ValidateAll() if the designated constraints aren't met.
type InstanceInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceInfoMultiError) AllErrors() []error { return m }

// InstanceInfoValidationError is the validation error returned by
// InstanceInfo.Validate if the designated constraints aren't met.
type InstanceInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceInfoValidationError) ErrorName() string { return "InstanceInfoValidationError" }

// Error satisfies the builtin error interface
func (e InstanceInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceInfoValidationError{}

// Validate checks the field values on StartDiagnosisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartDiagnosisRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartDiagnosisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartDiagnosisRequestMultiError, or nil if none found.
func (m *StartDiagnosisRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartDiagnosisRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTerminusKey()) < 1 {
		err := StartDiagnosisRequestValidationError{
			field:  "TerminusKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstanceIP()) < 1 {
		err := StartDiagnosisRequestValidationError{
			field:  "InstanceIP",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	if len(errors) > 0 {
		return StartDiagnosisRequestMultiError(errors)
	}

	return nil
}

// StartDiagnosisRequestMultiError is an error wrapping multiple validation
// errors returned by StartDiagnosisRequest.ValidateAll() if the designated
// constraints aren't met.
type StartDiagnosisRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartDiagnosisRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartDiagnosisRequestMultiError) AllErrors() []error { return m }

// StartDiagnosisRequestValidationError is the validation error returned by
// StartDiagnosisRequest.Validate if the designated constraints aren't met.
type StartDiagnosisRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartDiagnosisRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartDiagnosisRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartDiagnosisRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartDiagnosisRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartDiagnosisRequestValidationError) ErrorName() string {
	return "StartDiagnosisRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartDiagnosisRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartDiagnosisRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartDiagnosisRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartDiagnosisRequestValidationError{}

// Validate checks the field values on StartDiagnosisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartDiagnosisResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartDiagnosisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartDiagnosisResponseMultiError, or nil if none found.
func (m *StartDiagnosisResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartDiagnosisResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartDiagnosisResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartDiagnosisResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartDiagnosisResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartDiagnosisResponseMultiError(errors)
	}

	return nil
}

// StartDiagnosisResponseMultiError is an error wrapping multiple validation
// errors returned by StartDiagnosisResponse.ValidateAll() if the designated
// constraints aren't met.
type StartDiagnosisResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartDiagnosisResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartDiagnosisResponseMultiError) AllErrors() []error { return m }

// StartDiagnosisResponseValidationError is the validation error returned by
// StartDiagnosisResponse.Validate if the designated constraints aren't met.
type StartDiagnosisResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartDiagnosisResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartDiagnosisResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartDiagnosisResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartDiagnosisResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartDiagnosisResponseValidationError) ErrorName() string {
	return "StartDiagnosisResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartDiagnosisResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartDiagnosisResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartDiagnosisResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartDiagnosisResponseValidationError{}

// Validate checks the field values on QueryDiagnosisStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryDiagnosisStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryDiagnosisStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryDiagnosisStatusRequestMultiError, or nil if none found.
func (m *QueryDiagnosisStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryDiagnosisStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTerminusKey()) < 1 {
		err := QueryDiagnosisStatusRequestValidationError{
			field:  "TerminusKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstanceIP()) < 1 {
		err := QueryDiagnosisStatusRequestValidationError{
			field:  "InstanceIP",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	if len(errors) > 0 {
		return QueryDiagnosisStatusRequestMultiError(errors)
	}

	return nil
}

// QueryDiagnosisStatusRequestMultiError is an error wrapping multiple
// validation errors returned by QueryDiagnosisStatusRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryDiagnosisStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryDiagnosisStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryDiagnosisStatusRequestMultiError) AllErrors() []error { return m }

// QueryDiagnosisStatusRequestValidationError is the validation error returned
// by QueryDiagnosisStatusRequest.Validate if the designated constraints
// aren't met.
type QueryDiagnosisStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryDiagnosisStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryDiagnosisStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryDiagnosisStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryDiagnosisStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryDiagnosisStatusRequestValidationError) ErrorName() string {
	return "QueryDiagnosisStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryDiagnosisStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryDiagnosisStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryDiagnosisStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryDiagnosisStatusRequestValidationError{}

// Validate checks the field values on QueryDiagnosisStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryDiagnosisStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryDiagnosisStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryDiagnosisStatusResponseMultiError, or nil if none found.
func (m *QueryDiagnosisStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryDiagnosisStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryDiagnosisStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryDiagnosisStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryDiagnosisStatusResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryDiagnosisStatusResponseMultiError(errors)
	}

	return nil
}

// QueryDiagnosisStatusResponseMultiError is an error wrapping multiple
// validation errors returned by QueryDiagnosisStatusResponse.ValidateAll() if
// the designated constraints aren't met.
type QueryDiagnosisStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryDiagnosisStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryDiagnosisStatusResponseMultiError) AllErrors() []error { return m }

// QueryDiagnosisStatusResponseValidationError is the validation error returned
// by QueryDiagnosisStatusResponse.Validate if the designated constraints
// aren't met.
type QueryDiagnosisStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryDiagnosisStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryDiagnosisStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryDiagnosisStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryDiagnosisStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryDiagnosisStatusResponseValidationError) ErrorName() string {
	return "QueryDiagnosisStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryDiagnosisStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryDiagnosisStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryDiagnosisStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryDiagnosisStatusResponseValidationError{}

// Validate checks the field values on StopDiagnosisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopDiagnosisRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopDiagnosisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopDiagnosisRequestMultiError, or nil if none found.
func (m *StopDiagnosisRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StopDiagnosisRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTerminusKey()) < 1 {
		err := StopDiagnosisRequestValidationError{
			field:  "TerminusKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstanceIP()) < 1 {
		err := StopDiagnosisRequestValidationError{
			field:  "InstanceIP",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	if len(errors) > 0 {
		return StopDiagnosisRequestMultiError(errors)
	}

	return nil
}

// StopDiagnosisRequestMultiError is an error wrapping multiple validation
// errors returned by StopDiagnosisRequest.ValidateAll() if the designated
// constraints aren't met.
type StopDiagnosisRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopDiagnosisRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopDiagnosisRequestMultiError) AllErrors() []error { return m }

// StopDiagnosisRequestValidationError is the validation error returned by
// StopDiagnosisRequest.Validate if the designated constraints aren't met.
type StopDiagnosisRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopDiagnosisRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopDiagnosisRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopDiagnosisRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopDiagnosisRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopDiagnosisRequestValidationError) ErrorName() string {
	return "StopDiagnosisRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StopDiagnosisRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopDiagnosisRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopDiagnosisRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopDiagnosisRequestValidationError{}

// Validate checks the field values on StopDiagnosisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopDiagnosisResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopDiagnosisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopDiagnosisResponseMultiError, or nil if none found.
func (m *StopDiagnosisResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StopDiagnosisResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return StopDiagnosisResponseMultiError(errors)
	}

	return nil
}

// StopDiagnosisResponseMultiError is an error wrapping multiple validation
// errors returned by StopDiagnosisResponse.ValidateAll() if the designated
// constraints aren't met.
type StopDiagnosisResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopDiagnosisResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopDiagnosisResponseMultiError) AllErrors() []error { return m }

// StopDiagnosisResponseValidationError is the validation error returned by
// StopDiagnosisResponse.Validate if the designated constraints aren't met.
type StopDiagnosisResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopDiagnosisResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopDiagnosisResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopDiagnosisResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopDiagnosisResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopDiagnosisResponseValidationError) ErrorName() string {
	return "StopDiagnosisResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StopDiagnosisResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopDiagnosisResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopDiagnosisResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopDiagnosisResponseValidationError{}

// Validate checks the field values on ListProcessesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProcessesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProcessesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProcessesRequestMultiError, or nil if none found.
func (m *ListProcessesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProcessesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTerminusKey()) < 1 {
		err := ListProcessesRequestValidationError{
			field:  "TerminusKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetInstanceIP()) < 1 {
		err := ListProcessesRequestValidationError{
			field:  "InstanceIP",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClusterName

	if len(errors) > 0 {
		return ListProcessesRequestMultiError(errors)
	}

	return nil
}

// ListProcessesRequestMultiError is an error wrapping multiple validation
// errors returned by ListProcessesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListProcessesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProcessesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProcessesRequestMultiError) AllErrors() []error { return m }

// ListProcessesRequestValidationError is the validation error returned by
// ListProcessesRequest.Validate if the designated constraints aren't met.
type ListProcessesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProcessesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProcessesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProcessesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProcessesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProcessesRequestValidationError) ErrorName() string {
	return "ListProcessesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProcessesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProcessesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProcessesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProcessesRequestValidationError{}

// Validate checks the field values on ListProcessesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProcessesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProcessesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProcessesResponseMultiError, or nil if none found.
func (m *ListProcessesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProcessesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProcessesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProcessesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProcessesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListProcessesResponseMultiError(errors)
	}

	return nil
}

// ListProcessesResponseMultiError is an error wrapping multiple validation
// errors returned by ListProcessesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListProcessesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProcessesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProcessesResponseMultiError) AllErrors() []error { return m }

// ListProcessesResponseValidationError is the validation error returned by
// ListProcessesResponse.Validate if the designated constraints aren't met.
type ListProcessesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProcessesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProcessesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProcessesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProcessesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProcessesResponseValidationError) ErrorName() string {
	return "ListProcessesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListProcessesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProcessesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProcessesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProcessesResponseValidationError{}
