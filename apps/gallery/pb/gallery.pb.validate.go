// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gallery.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ListOpusReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListOpusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListOpusReqMultiError, or
// nil if none found.
func (m *ListOpusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Keyword

	// no validation rules for PageNo

	// no validation rules for PageSize

	if len(errors) > 0 {
		return ListOpusReqMultiError(errors)
	}

	return nil
}

// ListOpusReqMultiError is an error wrapping multiple validation errors
// returned by ListOpusReq.ValidateAll() if the designated constraints aren't met.
type ListOpusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusReqMultiError) AllErrors() []error { return m }

// ListOpusReqValidationError is the validation error returned by
// ListOpusReq.Validate if the designated constraints aren't met.
type ListOpusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusReqValidationError) ErrorName() string { return "ListOpusReqValidationError" }

// Error satisfies the builtin error interface
func (e ListOpusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusReqValidationError{}

// Validate checks the field values on ListOpusResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListOpusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListOpusRespMultiError, or
// nil if none found.
func (m *ListOpusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOpusRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOpusRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOpusRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListOpusRespMultiError(errors)
	}

	return nil
}

// ListOpusRespMultiError is an error wrapping multiple validation errors
// returned by ListOpusResp.ValidateAll() if the designated constraints aren't met.
type ListOpusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusRespMultiError) AllErrors() []error { return m }

// ListOpusRespValidationError is the validation error returned by
// ListOpusResp.Validate if the designated constraints aren't met.
type ListOpusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusRespValidationError) ErrorName() string { return "ListOpusRespValidationError" }

// Error satisfies the builtin error interface
func (e ListOpusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusRespValidationError{}

// Validate checks the field values on ListOpusRespData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListOpusRespData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusRespData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOpusRespDataMultiError, or nil if none found.
func (m *ListOpusRespData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusRespData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOpusRespDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOpusRespDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOpusRespDataValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListOpusRespDataMultiError(errors)
	}

	return nil
}

// ListOpusRespDataMultiError is an error wrapping multiple validation errors
// returned by ListOpusRespData.ValidateAll() if the designated constraints
// aren't met.
type ListOpusRespDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusRespDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusRespDataMultiError) AllErrors() []error { return m }

// ListOpusRespDataValidationError is the validation error returned by
// ListOpusRespData.Validate if the designated constraints aren't met.
type ListOpusRespDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusRespDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusRespDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusRespDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusRespDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusRespDataValidationError) ErrorName() string { return "ListOpusRespDataValidationError" }

// Error satisfies the builtin error interface
func (e ListOpusRespDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusRespData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusRespDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusRespDataValidationError{}

// Validate checks the field values on ListOpusRespDataItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOpusRespDataItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusRespDataItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOpusRespDataItemMultiError, or nil if none found.
func (m *ListOpusRespDataItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusRespDataItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOpusRespDataItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOpusRespDataItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOpusRespDataItemValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOpusRespDataItemValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOpusRespDataItemValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOpusRespDataItemValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OrgID

	// no validation rules for OrgName

	// no validation rules for CreatorID

	// no validation rules for UpdaterID

	// no validation rules for Type

	// no validation rules for TypeName

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Summary

	// no validation rules for Catalog

	// no validation rules for CatalogName

	// no validation rules for LogoURL

	if len(errors) > 0 {
		return ListOpusRespDataItemMultiError(errors)
	}

	return nil
}

// ListOpusRespDataItemMultiError is an error wrapping multiple validation
// errors returned by ListOpusRespDataItem.ValidateAll() if the designated
// constraints aren't met.
type ListOpusRespDataItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusRespDataItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusRespDataItemMultiError) AllErrors() []error { return m }

// ListOpusRespDataItemValidationError is the validation error returned by
// ListOpusRespDataItem.Validate if the designated constraints aren't met.
type ListOpusRespDataItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusRespDataItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusRespDataItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusRespDataItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusRespDataItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusRespDataItemValidationError) ErrorName() string {
	return "ListOpusRespDataItemValidationError"
}

// Error satisfies the builtin error interface
func (e ListOpusRespDataItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusRespDataItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusRespDataItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusRespDataItemValidationError{}

// Validate checks the field values on Presentation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Presentation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Presentation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PresentationMultiError, or
// nil if none found.
func (m *Presentation) ValidateAll() error {
	return m.validate(true)
}

func (m *Presentation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Desc

	// no validation rules for ContactName

	// no validation rules for ContactURL

	// no validation rules for ContactEmail

	// no validation rules for IsOpenSourced

	// no validation rules for OpensourceURL

	// no validation rules for LicenseName

	// no validation rules for LicenseURL

	// no validation rules for HomepageName

	// no validation rules for HomepageURL

	// no validation rules for HomepageLogoURL

	// no validation rules for IsDownloadable

	// no validation rules for DownloadURL

	// no validation rules for Readme

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PresentationValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PresentationValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PresentationValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetForms() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PresentationValidationError{
						field:  fmt.Sprintf("Forms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PresentationValidationError{
						field:  fmt.Sprintf("Forms[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PresentationValidationError{
					field:  fmt.Sprintf("Forms[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Ref

	if len(errors) > 0 {
		return PresentationMultiError(errors)
	}

	return nil
}

// PresentationMultiError is an error wrapping multiple validation errors
// returned by Presentation.ValidateAll() if the designated constraints aren't met.
type PresentationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PresentationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PresentationMultiError) AllErrors() []error { return m }

// PresentationValidationError is the validation error returned by
// Presentation.Validate if the designated constraints aren't met.
type PresentationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PresentationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PresentationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PresentationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PresentationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PresentationValidationError) ErrorName() string { return "PresentationValidationError" }

// Error satisfies the builtin error interface
func (e PresentationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPresentation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PresentationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PresentationValidationError{}

// Validate checks the field values on Readme with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Readme) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Readme with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReadmeMultiError, or nil if none found.
func (m *Readme) ValidateAll() error {
	return m.validate(true)
}

func (m *Readme) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Lang

	// no validation rules for LangName

	// no validation rules for Source

	// no validation rules for Text

	if len(errors) > 0 {
		return ReadmeMultiError(errors)
	}

	return nil
}

// ReadmeMultiError is an error wrapping multiple validation errors returned by
// Readme.ValidateAll() if the designated constraints aren't met.
type ReadmeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReadmeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReadmeMultiError) AllErrors() []error { return m }

// ReadmeValidationError is the validation error returned by Readme.Validate if
// the designated constraints aren't met.
type ReadmeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReadmeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReadmeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReadmeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReadmeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReadmeValidationError) ErrorName() string { return "ReadmeValidationError" }

// Error satisfies the builtin error interface
func (e ReadmeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReadme.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReadmeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReadmeValidationError{}

// Validate checks the field values on Installation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Installation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Installation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstallationMultiError, or
// nil if none found.
func (m *Installation) ValidateAll() error {
	return m.validate(true)
}

func (m *Installation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Installer

	// no validation rules for Spec

	if len(errors) > 0 {
		return InstallationMultiError(errors)
	}

	return nil
}

// InstallationMultiError is an error wrapping multiple validation errors
// returned by Installation.ValidateAll() if the designated constraints aren't met.
type InstallationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallationMultiError) AllErrors() []error { return m }

// InstallationValidationError is the validation error returned by
// Installation.Validate if the designated constraints aren't met.
type InstallationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallationValidationError) ErrorName() string { return "InstallationValidationError" }

// Error satisfies the builtin error interface
func (e InstallationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallationValidationError{}

// Validate checks the field values on Parameters with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Parameters with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParametersMultiError, or
// nil if none found.
func (m *Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParametersValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParametersValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParametersValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParametersMultiError(errors)
	}

	return nil
}

// ParametersMultiError is an error wrapping multiple validation errors
// returned by Parameters.ValidateAll() if the designated constraints aren't met.
type ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParametersMultiError) AllErrors() []error { return m }

// ParametersValidationError is the validation error returned by
// Parameters.Validate if the designated constraints aren't met.
type ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParametersValidationError) ErrorName() string { return "ParametersValidationError" }

// Error satisfies the builtin error interface
func (e ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParametersValidationError{}

// Validate checks the field values on Parameter with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Parameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Parameter with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParameterMultiError, or nil
// if none found.
func (m *Parameter) ValidateAll() error {
	return m.validate(true)
}

func (m *Parameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for In

	// no validation rules for Description

	// no validation rules for Style

	// no validation rules for Explode

	// no validation rules for AllowEmptyValue

	// no validation rules for AllowReserved

	// no validation rules for Deprecated

	// no validation rules for Required

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParameterValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParameterValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ParameterMultiError(errors)
	}

	return nil
}

// ParameterMultiError is an error wrapping multiple validation errors returned
// by Parameter.ValidateAll() if the designated constraints aren't met.
type ParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParameterMultiError) AllErrors() []error { return m }

// ParameterValidationError is the validation error returned by
// Parameter.Validate if the designated constraints aren't met.
type ParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParameterValidationError) ErrorName() string { return "ParameterValidationError" }

// Error satisfies the builtin error interface
func (e ParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParameterValidationError{}

// Validate checks the field values on Form with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Form) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Form with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FormMultiError, or nil if none found.
func (m *Form) ValidateAll() error {
	return m.validate(true)
}

func (m *Form) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	for idx, item := range m.GetLine() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FormValidationError{
						field:  fmt.Sprintf("Line[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FormValidationError{
						field:  fmt.Sprintf("Line[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FormValidationError{
					field:  fmt.Sprintf("Line[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FormMultiError(errors)
	}

	return nil
}

// FormMultiError is an error wrapping multiple validation errors returned by
// Form.ValidateAll() if the designated constraints aren't met.
type FormMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FormMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FormMultiError) AllErrors() []error { return m }

// FormValidationError is the validation error returned by Form.Validate if the
// designated constraints aren't met.
type FormValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FormValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FormValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FormValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FormValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FormValidationError) ErrorName() string { return "FormValidationError" }

// Error satisfies the builtin error interface
func (e FormValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FormValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FormValidationError{}

// Validate checks the field values on Line with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Line) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Line with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LineMultiError, or nil if none found.
func (m *Line) ValidateAll() error {
	return m.validate(true)
}

func (m *Line) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LineMultiError(errors)
	}

	return nil
}

// LineMultiError is an error wrapping multiple validation errors returned by
// Line.ValidateAll() if the designated constraints aren't met.
type LineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LineMultiError) AllErrors() []error { return m }

// LineValidationError is the validation error returned by Line.Validate if the
// designated constraints aren't met.
type LineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LineValidationError) ErrorName() string { return "LineValidationError" }

// Error satisfies the builtin error interface
func (e LineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LineValidationError{}

// Validate checks the field values on Schema with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schema) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schema with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SchemaMultiError, or nil if none found.
func (m *Schema) ValidateAll() error {
	return m.validate(true)
}

func (m *Schema) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Title

	// no validation rules for Format

	// no validation rules for Description

	// no validation rules for Deprecated

	if all {
		switch v := interface{}(m.GetItems()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Items",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SchemaValidationError{
					field:  "Items",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItems()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SchemaValidationError{
				field:  "Items",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetProperties()))
		i := 0
		for key := range m.GetProperties() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetProperties()[key]
			_ = val

			// no validation rules for Properties[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SchemaValidationError{
							field:  fmt.Sprintf("Properties[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SchemaValidationError{
							field:  fmt.Sprintf("Properties[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SchemaValidationError{
						field:  fmt.Sprintf("Properties[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return SchemaMultiError(errors)
	}

	return nil
}

// SchemaMultiError is an error wrapping multiple validation errors returned by
// Schema.ValidateAll() if the designated constraints aren't met.
type SchemaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchemaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchemaMultiError) AllErrors() []error { return m }

// SchemaValidationError is the validation error returned by Schema.Validate if
// the designated constraints aren't met.
type SchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchemaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchemaValidationError) ErrorName() string { return "SchemaValidationError" }

// Error satisfies the builtin error interface
func (e SchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchemaValidationError{}

// Validate checks the field values on ListOpusTypesRespData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOpusTypesRespData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusTypesRespData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOpusTypesRespDataMultiError, or nil if none found.
func (m *ListOpusTypesRespData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusTypesRespData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOpusTypesRespDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOpusTypesRespDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOpusTypesRespDataValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListOpusTypesRespDataMultiError(errors)
	}

	return nil
}

// ListOpusTypesRespDataMultiError is an error wrapping multiple validation
// errors returned by ListOpusTypesRespData.ValidateAll() if the designated
// constraints aren't met.
type ListOpusTypesRespDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusTypesRespDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusTypesRespDataMultiError) AllErrors() []error { return m }

// ListOpusTypesRespDataValidationError is the validation error returned by
// ListOpusTypesRespData.Validate if the designated constraints aren't met.
type ListOpusTypesRespDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusTypesRespDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusTypesRespDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusTypesRespDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusTypesRespDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusTypesRespDataValidationError) ErrorName() string {
	return "ListOpusTypesRespDataValidationError"
}

// Error satisfies the builtin error interface
func (e ListOpusTypesRespDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusTypesRespData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusTypesRespDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusTypesRespDataValidationError{}

// Validate checks the field values on CatalogInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CatalogInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CatalogInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CatalogInfoMultiError, or
// nil if none found.
func (m *CatalogInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CatalogInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Name

	if len(errors) > 0 {
		return CatalogInfoMultiError(errors)
	}

	return nil
}

// CatalogInfoMultiError is an error wrapping multiple validation errors
// returned by CatalogInfo.ValidateAll() if the designated constraints aren't met.
type CatalogInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CatalogInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CatalogInfoMultiError) AllErrors() []error { return m }

// CatalogInfoValidationError is the validation error returned by
// CatalogInfo.Validate if the designated constraints aren't met.
type CatalogInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CatalogInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CatalogInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CatalogInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CatalogInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CatalogInfoValidationError) ErrorName() string { return "CatalogInfoValidationError" }

// Error satisfies the builtin error interface
func (e CatalogInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCatalogInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CatalogInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CatalogInfoValidationError{}

// Validate checks the field values on OpusType with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpusType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpusType with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpusTypeMultiError, or nil
// if none found.
func (m *OpusType) ValidateAll() error {
	return m.validate(true)
}

func (m *OpusType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for DisplayName

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OpusTypeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OpusTypeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OpusTypeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OpusTypeMultiError(errors)
	}

	return nil
}

// OpusTypeMultiError is an error wrapping multiple validation errors returned
// by OpusType.ValidateAll() if the designated constraints aren't met.
type OpusTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpusTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpusTypeMultiError) AllErrors() []error { return m }

// OpusTypeValidationError is the validation error returned by
// OpusType.Validate if the designated constraints aren't met.
type OpusTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpusTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpusTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpusTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpusTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpusTypeValidationError) ErrorName() string { return "OpusTypeValidationError" }

// Error satisfies the builtin error interface
func (e OpusTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpusType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpusTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpusTypeValidationError{}

// Validate checks the field values on PutOnArtifactsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutOnArtifactsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutOnArtifactsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutOnArtifactsReqMultiError, or nil if none found.
func (m *PutOnArtifactsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PutOnArtifactsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for UserID

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for DisplayName

	// no validation rules for Summary

	// no validation rules for Catalog

	// no validation rules for LogoURL

	// no validation rules for Desc

	// no validation rules for ContactName

	// no validation rules for ContactURL

	// no validation rules for ContactEmail

	// no validation rules for IsOpenSourced

	// no validation rules for OpensourceURL

	// no validation rules for LicenseName

	// no validation rules for LicenseURL

	// no validation rules for HomepageName

	// no validation rules for HomepageURL

	// no validation rules for HomepageLogoURL

	// no validation rules for IsDownloadable

	// no validation rules for DownloadURL

	for idx, item := range m.GetReadme() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PutOnArtifactsReqValidationError{
						field:  fmt.Sprintf("Readme[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PutOnArtifactsReqValidationError{
						field:  fmt.Sprintf("Readme[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PutOnArtifactsReqValidationError{
					field:  fmt.Sprintf("Readme[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetInstallation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutOnArtifactsReqValidationError{
					field:  "Installation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutOnArtifactsReqValidationError{
					field:  "Installation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstallation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutOnArtifactsReqValidationError{
				field:  "Installation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PutOnArtifactsReqMultiError(errors)
	}

	return nil
}

// PutOnArtifactsReqMultiError is an error wrapping multiple validation errors
// returned by PutOnArtifactsReq.ValidateAll() if the designated constraints
// aren't met.
type PutOnArtifactsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutOnArtifactsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutOnArtifactsReqMultiError) AllErrors() []error { return m }

// PutOnArtifactsReqValidationError is the validation error returned by
// PutOnArtifactsReq.Validate if the designated constraints aren't met.
type PutOnArtifactsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutOnArtifactsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutOnArtifactsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutOnArtifactsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutOnArtifactsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutOnArtifactsReqValidationError) ErrorName() string {
	return "PutOnArtifactsReqValidationError"
}

// Error satisfies the builtin error interface
func (e PutOnArtifactsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutOnArtifactsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutOnArtifactsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutOnArtifactsReqValidationError{}

// Validate checks the field values on ArtifactsInstallation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ArtifactsInstallation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArtifactsInstallation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ArtifactsInstallationMultiError, or nil if none found.
func (m *ArtifactsInstallation) ValidateAll() error {
	return m.validate(true)
}

func (m *ArtifactsInstallation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReleaseID

	if len(errors) > 0 {
		return ArtifactsInstallationMultiError(errors)
	}

	return nil
}

// ArtifactsInstallationMultiError is an error wrapping multiple validation
// errors returned by ArtifactsInstallation.ValidateAll() if the designated
// constraints aren't met.
type ArtifactsInstallationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArtifactsInstallationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArtifactsInstallationMultiError) AllErrors() []error { return m }

// ArtifactsInstallationValidationError is the validation error returned by
// ArtifactsInstallation.Validate if the designated constraints aren't met.
type ArtifactsInstallationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArtifactsInstallationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArtifactsInstallationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArtifactsInstallationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArtifactsInstallationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArtifactsInstallationValidationError) ErrorName() string {
	return "ArtifactsInstallationValidationError"
}

// Error satisfies the builtin error interface
func (e ArtifactsInstallationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArtifactsInstallation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArtifactsInstallationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArtifactsInstallationValidationError{}

// Validate checks the field values on PutOffArtifactsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutOffArtifactsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutOffArtifactsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutOffArtifactsReqMultiError, or nil if none found.
func (m *PutOffArtifactsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PutOffArtifactsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for UserID

	// no validation rules for OpusID

	// no validation rules for VersionID

	if len(errors) > 0 {
		return PutOffArtifactsReqMultiError(errors)
	}

	return nil
}

// PutOffArtifactsReqMultiError is an error wrapping multiple validation errors
// returned by PutOffArtifactsReq.ValidateAll() if the designated constraints
// aren't met.
type PutOffArtifactsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutOffArtifactsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutOffArtifactsReqMultiError) AllErrors() []error { return m }

// PutOffArtifactsReqValidationError is the validation error returned by
// PutOffArtifactsReq.Validate if the designated constraints aren't met.
type PutOffArtifactsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutOffArtifactsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutOffArtifactsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutOffArtifactsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutOffArtifactsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutOffArtifactsReqValidationError) ErrorName() string {
	return "PutOffArtifactsReqValidationError"
}

// Error satisfies the builtin error interface
func (e PutOffArtifactsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutOffArtifactsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutOffArtifactsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutOffArtifactsReqValidationError{}

// Validate checks the field values on PutOnExtensionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutOnExtensionsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutOnExtensionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutOnExtensionsReqMultiError, or nil if none found.
func (m *PutOnExtensionsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PutOnExtensionsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for UserID

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for DisplayName

	// no validation rules for DisplayNameI18N

	// no validation rules for Summary

	// no validation rules for SummaryI18N

	// no validation rules for Catalog

	// no validation rules for LogoURL

	// no validation rules for Level

	// no validation rules for Mode

	// no validation rules for Desc

	// no validation rules for DescI18N

	// no validation rules for ContactName

	// no validation rules for ContactURL

	// no validation rules for ContactEmail

	// no validation rules for IsOpenSourced

	// no validation rules for OpensourceURL

	// no validation rules for LicenseName

	// no validation rules for LicenseURL

	// no validation rules for HomepageName

	// no validation rules for HomepageURL

	// no validation rules for HomepageLogoURL

	// no validation rules for IsDownloadable

	// no validation rules for DownloadURL

	for idx, item := range m.GetReadme() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PutOnExtensionsReqValidationError{
						field:  fmt.Sprintf("Readme[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PutOnExtensionsReqValidationError{
						field:  fmt.Sprintf("Readme[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PutOnExtensionsReqValidationError{
					field:  fmt.Sprintf("Readme[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for I18N

	// no validation rules for IsDefault

	if len(errors) > 0 {
		return PutOnExtensionsReqMultiError(errors)
	}

	return nil
}

// PutOnExtensionsReqMultiError is an error wrapping multiple validation errors
// returned by PutOnExtensionsReq.ValidateAll() if the designated constraints
// aren't met.
type PutOnExtensionsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutOnExtensionsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutOnExtensionsReqMultiError) AllErrors() []error { return m }

// PutOnExtensionsReqValidationError is the validation error returned by
// PutOnExtensionsReq.Validate if the designated constraints aren't met.
type PutOnExtensionsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutOnExtensionsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutOnExtensionsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutOnExtensionsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutOnExtensionsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutOnExtensionsReqValidationError) ErrorName() string {
	return "PutOnExtensionsReqValidationError"
}

// Error satisfies the builtin error interface
func (e PutOnExtensionsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutOnExtensionsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutOnExtensionsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutOnExtensionsReqValidationError{}

// Validate checks the field values on ListOpusVersionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOpusVersionsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusVersionsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOpusVersionsReqMultiError, or nil if none found.
func (m *ListOpusVersionsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusVersionsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OpusID

	if len(errors) > 0 {
		return ListOpusVersionsReqMultiError(errors)
	}

	return nil
}

// ListOpusVersionsReqMultiError is an error wrapping multiple validation
// errors returned by ListOpusVersionsReq.ValidateAll() if the designated
// constraints aren't met.
type ListOpusVersionsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusVersionsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusVersionsReqMultiError) AllErrors() []error { return m }

// ListOpusVersionsReqValidationError is the validation error returned by
// ListOpusVersionsReq.Validate if the designated constraints aren't met.
type ListOpusVersionsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusVersionsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusVersionsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusVersionsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusVersionsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusVersionsReqValidationError) ErrorName() string {
	return "ListOpusVersionsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListOpusVersionsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusVersionsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusVersionsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusVersionsReqValidationError{}

// Validate checks the field values on ListOpusVersionsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOpusVersionsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusVersionsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOpusVersionsRespMultiError, or nil if none found.
func (m *ListOpusVersionsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusVersionsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOpusVersionsRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOpusVersionsRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOpusVersionsRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListOpusVersionsRespMultiError(errors)
	}

	return nil
}

// ListOpusVersionsRespMultiError is an error wrapping multiple validation
// errors returned by ListOpusVersionsResp.ValidateAll() if the designated
// constraints aren't met.
type ListOpusVersionsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusVersionsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusVersionsRespMultiError) AllErrors() []error { return m }

// ListOpusVersionsRespValidationError is the validation error returned by
// ListOpusVersionsResp.Validate if the designated constraints aren't met.
type ListOpusVersionsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusVersionsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusVersionsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusVersionsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusVersionsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusVersionsRespValidationError) ErrorName() string {
	return "ListOpusVersionsRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListOpusVersionsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusVersionsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusVersionsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusVersionsRespValidationError{}

// Validate checks the field values on ListOpusVersionsRespData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOpusVersionsRespData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusVersionsRespData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListOpusVersionsRespDataMultiError, or nil if none found.
func (m *ListOpusVersionsRespData) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusVersionsRespData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOpusVersionsRespDataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOpusVersionsRespDataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOpusVersionsRespDataValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOpusVersionsRespDataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOpusVersionsRespDataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOpusVersionsRespDataValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OrgID

	// no validation rules for OrgName

	// no validation rules for CreatorID

	// no validation rules for UpdaterID

	// no validation rules for Level

	// no validation rules for Type

	// no validation rules for TypeName

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Catalog

	// no validation rules for DefaultVersionID

	// no validation rules for LatestVersionID

	for idx, item := range m.GetVersions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListOpusVersionsRespDataValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListOpusVersionsRespDataValidationError{
						field:  fmt.Sprintf("Versions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListOpusVersionsRespDataValidationError{
					field:  fmt.Sprintf("Versions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListOpusVersionsRespDataMultiError(errors)
	}

	return nil
}

// ListOpusVersionsRespDataMultiError is an error wrapping multiple validation
// errors returned by ListOpusVersionsRespData.ValidateAll() if the designated
// constraints aren't met.
type ListOpusVersionsRespDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusVersionsRespDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusVersionsRespDataMultiError) AllErrors() []error { return m }

// ListOpusVersionsRespDataValidationError is the validation error returned by
// ListOpusVersionsRespData.Validate if the designated constraints aren't met.
type ListOpusVersionsRespDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusVersionsRespDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusVersionsRespDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusVersionsRespDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusVersionsRespDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusVersionsRespDataValidationError) ErrorName() string {
	return "ListOpusVersionsRespDataValidationError"
}

// Error satisfies the builtin error interface
func (e ListOpusVersionsRespDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusVersionsRespData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusVersionsRespDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusVersionsRespDataValidationError{}

// Validate checks the field values on ListOpusVersionRespDataVersion with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListOpusVersionRespDataVersion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListOpusVersionRespDataVersion with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListOpusVersionRespDataVersionMultiError, or nil if none found.
func (m *ListOpusVersionRespDataVersion) ValidateAll() error {
	return m.validate(true)
}

func (m *ListOpusVersionRespDataVersion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOpusVersionRespDataVersionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOpusVersionRespDataVersionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOpusVersionRespDataVersionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListOpusVersionRespDataVersionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListOpusVersionRespDataVersionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListOpusVersionRespDataVersionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatorID

	// no validation rules for UpdaterID

	// no validation rules for Version

	// no validation rules for Summary

	// no validation rules for LogoURL

	// no validation rules for IsValid

	// no validation rules for Ref

	// no validation rules for Desc

	// no validation rules for ContactName

	// no validation rules for ContactURL

	// no validation rules for ContactEmail

	// no validation rules for IsOpenSourced

	// no validation rules for OpensourceURL

	// no validation rules for LicenceName

	// no validation rules for LicenceURL

	// no validation rules for HomepageName

	// no validation rules for HomepageURL

	// no validation rules for HomepageLogoURL

	// no validation rules for IsDownloadable

	// no validation rules for DownloadURL

	// no validation rules for ReadmeLang

	// no validation rules for ReadmeLangName

	// no validation rules for Readme

	if len(errors) > 0 {
		return ListOpusVersionRespDataVersionMultiError(errors)
	}

	return nil
}

// ListOpusVersionRespDataVersionMultiError is an error wrapping multiple
// validation errors returned by ListOpusVersionRespDataVersion.ValidateAll()
// if the designated constraints aren't met.
type ListOpusVersionRespDataVersionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOpusVersionRespDataVersionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOpusVersionRespDataVersionMultiError) AllErrors() []error { return m }

// ListOpusVersionRespDataVersionValidationError is the validation error
// returned by ListOpusVersionRespDataVersion.Validate if the designated
// constraints aren't met.
type ListOpusVersionRespDataVersionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOpusVersionRespDataVersionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOpusVersionRespDataVersionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOpusVersionRespDataVersionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOpusVersionRespDataVersionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOpusVersionRespDataVersionValidationError) ErrorName() string {
	return "ListOpusVersionRespDataVersionValidationError"
}

// Error satisfies the builtin error interface
func (e ListOpusVersionRespDataVersionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOpusVersionRespDataVersion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOpusVersionRespDataVersionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOpusVersionRespDataVersionValidationError{}

// Validate checks the field values on PutOnOpusResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PutOnOpusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutOnOpusResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PutOnOpusRespMultiError, or
// nil if none found.
func (m *PutOnOpusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *PutOnOpusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OpusID

	// no validation rules for VersionID

	if len(errors) > 0 {
		return PutOnOpusRespMultiError(errors)
	}

	return nil
}

// PutOnOpusRespMultiError is an error wrapping multiple validation errors
// returned by PutOnOpusResp.ValidateAll() if the designated constraints
// aren't met.
type PutOnOpusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutOnOpusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutOnOpusRespMultiError) AllErrors() []error { return m }

// PutOnOpusRespValidationError is the validation error returned by
// PutOnOpusResp.Validate if the designated constraints aren't met.
type PutOnOpusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutOnOpusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutOnOpusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutOnOpusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutOnOpusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutOnOpusRespValidationError) ErrorName() string { return "PutOnOpusRespValidationError" }

// Error satisfies the builtin error interface
func (e PutOnOpusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutOnOpusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutOnOpusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutOnOpusRespValidationError{}

// Validate checks the field values on I18N with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *I18N) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on I18N with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in I18NMultiError, or nil if none found.
func (m *I18N) ValidateAll() error {
	return m.validate(true)
}

func (m *I18N) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Lang

	if len(errors) > 0 {
		return I18NMultiError(errors)
	}

	return nil
}

// I18NMultiError is an error wrapping multiple validation errors returned by
// I18N.ValidateAll() if the designated constraints aren't met.
type I18NMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m I18NMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m I18NMultiError) AllErrors() []error { return m }

// I18NValidationError is the validation error returned by I18N.Validate if the
// designated constraints aren't met.
type I18NValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e I18NValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e I18NValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e I18NValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e I18NValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e I18NValidationError) ErrorName() string { return "I18NValidationError" }

// Error satisfies the builtin error interface
func (e I18NValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sI18N.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = I18NValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = I18NValidationError{}
