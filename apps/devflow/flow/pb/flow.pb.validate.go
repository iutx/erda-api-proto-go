// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: flow.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on IssueRelationExtra with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueRelationExtra) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueRelationExtra with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueRelationExtraMultiError, or nil if none found.
func (m *IssueRelationExtra) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueRelationExtra) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppID

	// no validation rules for RepoMergeID

	if len(errors) > 0 {
		return IssueRelationExtraMultiError(errors)
	}

	return nil
}

// IssueRelationExtraMultiError is an error wrapping multiple validation errors
// returned by IssueRelationExtra.ValidateAll() if the designated constraints
// aren't met.
type IssueRelationExtraMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueRelationExtraMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueRelationExtraMultiError) AllErrors() []error { return m }

// IssueRelationExtraValidationError is the validation error returned by
// IssueRelationExtra.Validate if the designated constraints aren't met.
type IssueRelationExtraValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueRelationExtraValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueRelationExtraValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueRelationExtraValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueRelationExtraValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueRelationExtraValidationError) ErrorName() string {
	return "IssueRelationExtraValidationError"
}

// Error satisfies the builtin error interface
func (e IssueRelationExtraValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueRelationExtra.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueRelationExtraValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueRelationExtraValidationError{}

// Validate checks the field values on DevFlowNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DevFlowNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DevFlowNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DevFlowNodeMultiError, or
// nil if none found.
func (m *DevFlowNode) ValidateAll() error {
	return m.validate(true)
}

func (m *DevFlowNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RepoMergeID

	// no validation rules for AppID

	// no validation rules for TargetBranch

	// no validation rules for SourceBranch

	// no validation rules for IsJoinTempBranch

	// no validation rules for JoinTempBranchStatus

	// no validation rules for TempBranch

	// no validation rules for IssueID

	// no validation rules for MergeID

	// no validation rules for AppName

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowNodeValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowNodeValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowNodeValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBaseCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowNodeValidationError{
					field:  "BaseCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowNodeValidationError{
					field:  "BaseCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowNodeValidationError{
				field:  "BaseCommit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CanJoin

	if all {
		switch v := interface{}(m.GetMergeRequestInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowNodeValidationError{
					field:  "MergeRequestInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowNodeValidationError{
					field:  "MergeRequestInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMergeRequestInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowNodeValidationError{
				field:  "MergeRequestInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DevFlowNodeMultiError(errors)
	}

	return nil
}

// DevFlowNodeMultiError is an error wrapping multiple validation errors
// returned by DevFlowNode.ValidateAll() if the designated constraints aren't met.
type DevFlowNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DevFlowNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DevFlowNodeMultiError) AllErrors() []error { return m }

// DevFlowNodeValidationError is the validation error returned by
// DevFlowNode.Validate if the designated constraints aren't met.
type DevFlowNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DevFlowNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DevFlowNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DevFlowNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DevFlowNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DevFlowNodeValidationError) ErrorName() string { return "DevFlowNodeValidationError" }

// Error satisfies the builtin error interface
func (e DevFlowNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDevFlowNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DevFlowNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DevFlowNodeValidationError{}

// Validate checks the field values on CreateFlowNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateFlowNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateFlowNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateFlowNodeRequestMultiError, or nil if none found.
func (m *CreateFlowNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFlowNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetIssueID() <= 0 {
		err := CreateFlowNodeRequestValidationError{
			field:  "IssueID",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetAppID() <= 0 {
		err := CreateFlowNodeRequestValidationError{
			field:  "AppID",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFlowRuleName()) < 1 {
		err := CreateFlowNodeRequestValidationError{
			field:  "FlowRuleName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetCurrentBranch()) < 1 {
		err := CreateFlowNodeRequestValidationError{
			field:  "CurrentBranch",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateFlowNodeRequestMultiError(errors)
	}

	return nil
}

// CreateFlowNodeRequestMultiError is an error wrapping multiple validation
// errors returned by CreateFlowNodeRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateFlowNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFlowNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFlowNodeRequestMultiError) AllErrors() []error { return m }

// CreateFlowNodeRequestValidationError is the validation error returned by
// CreateFlowNodeRequest.Validate if the designated constraints aren't met.
type CreateFlowNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFlowNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFlowNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFlowNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFlowNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFlowNodeRequestValidationError) ErrorName() string {
	return "CreateFlowNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFlowNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFlowNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFlowNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFlowNodeRequestValidationError{}

// Validate checks the field values on CreateFlowNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateFlowNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateFlowNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateFlowNodeResponseMultiError, or nil if none found.
func (m *CreateFlowNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFlowNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateFlowNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateFlowNodeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateFlowNodeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateFlowNodeResponseMultiError(errors)
	}

	return nil
}

// CreateFlowNodeResponseMultiError is an error wrapping multiple validation
// errors returned by CreateFlowNodeResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateFlowNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFlowNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFlowNodeResponseMultiError) AllErrors() []error { return m }

// CreateFlowNodeResponseValidationError is the validation error returned by
// CreateFlowNodeResponse.Validate if the designated constraints aren't met.
type CreateFlowNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFlowNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFlowNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFlowNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFlowNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFlowNodeResponseValidationError) ErrorName() string {
	return "CreateFlowNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFlowNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFlowNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFlowNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFlowNodeResponseValidationError{}

// Validate checks the field values on DevFlow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DevFlow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DevFlow with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DevFlowMultiError, or nil if none found.
func (m *DevFlow) ValidateAll() error {
	return m.validate(true)
}

func (m *DevFlow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for OrgID

	// no validation rules for OrgName

	// no validation rules for Creator

	// no validation rules for Branch

	// no validation rules for IssueID

	// no validation rules for FlowRuleName

	// no validation rules for AppID

	// no validation rules for AppName

	// no validation rules for JoinTempBranchStatus

	// no validation rules for IsJoinTempBranch

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DevFlowMultiError(errors)
	}

	return nil
}

// DevFlowMultiError is an error wrapping multiple validation errors returned
// by DevFlow.ValidateAll() if the designated constraints aren't met.
type DevFlowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DevFlowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DevFlowMultiError) AllErrors() []error { return m }

// DevFlowValidationError is the validation error returned by DevFlow.Validate
// if the designated constraints aren't met.
type DevFlowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DevFlowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DevFlowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DevFlowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DevFlowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DevFlowValidationError) ErrorName() string { return "DevFlowValidationError" }

// Error satisfies the builtin error interface
func (e DevFlowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDevFlow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DevFlowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DevFlowValidationError{}

// Validate checks the field values on OperationMergeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationMergeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationMergeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationMergeRequestMultiError, or nil if none found.
func (m *OperationMergeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationMergeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDevFlowID()) < 1 {
		err := OperationMergeRequestValidationError{
			field:  "DevFlowID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetEnable() == nil {
		err := OperationMergeRequestValidationError{
			field:  "Enable",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetEnable()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationMergeRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationMergeRequestValidationError{
					field:  "Enable",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnable()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationMergeRequestValidationError{
				field:  "Enable",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationMergeRequestMultiError(errors)
	}

	return nil
}

// OperationMergeRequestMultiError is an error wrapping multiple validation
// errors returned by OperationMergeRequest.ValidateAll() if the designated
// constraints aren't met.
type OperationMergeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationMergeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationMergeRequestMultiError) AllErrors() []error { return m }

// OperationMergeRequestValidationError is the validation error returned by
// OperationMergeRequest.Validate if the designated constraints aren't met.
type OperationMergeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationMergeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationMergeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationMergeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationMergeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationMergeRequestValidationError) ErrorName() string {
	return "OperationMergeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperationMergeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationMergeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationMergeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationMergeRequestValidationError{}

// Validate checks the field values on OperationMergeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationMergeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationMergeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationMergeResponseMultiError, or nil if none found.
func (m *OperationMergeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationMergeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OperationMergeResponseMultiError(errors)
	}

	return nil
}

// OperationMergeResponseMultiError is an error wrapping multiple validation
// errors returned by OperationMergeResponse.ValidateAll() if the designated
// constraints aren't met.
type OperationMergeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationMergeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationMergeResponseMultiError) AllErrors() []error { return m }

// OperationMergeResponseValidationError is the validation error returned by
// OperationMergeResponse.Validate if the designated constraints aren't met.
type OperationMergeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationMergeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationMergeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationMergeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationMergeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationMergeResponseValidationError) ErrorName() string {
	return "OperationMergeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperationMergeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationMergeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationMergeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationMergeResponseValidationError{}

// Validate checks the field values on DeleteFlowNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFlowNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFlowNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFlowNodeRequestMultiError, or nil if none found.
func (m *DeleteFlowNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFlowNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDevFlowID()) < 1 {
		err := DeleteFlowNodeRequestValidationError{
			field:  "DevFlowID",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DeleteBranch

	if len(errors) > 0 {
		return DeleteFlowNodeRequestMultiError(errors)
	}

	return nil
}

// DeleteFlowNodeRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteFlowNodeRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteFlowNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFlowNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFlowNodeRequestMultiError) AllErrors() []error { return m }

// DeleteFlowNodeRequestValidationError is the validation error returned by
// DeleteFlowNodeRequest.Validate if the designated constraints aren't met.
type DeleteFlowNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFlowNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFlowNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFlowNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFlowNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFlowNodeRequestValidationError) ErrorName() string {
	return "DeleteFlowNodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFlowNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFlowNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFlowNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFlowNodeRequestValidationError{}

// Validate checks the field values on DeleteFlowNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFlowNodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFlowNodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFlowNodeResponseMultiError, or nil if none found.
func (m *DeleteFlowNodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFlowNodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteFlowNodeResponseMultiError(errors)
	}

	return nil
}

// DeleteFlowNodeResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteFlowNodeResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteFlowNodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFlowNodeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFlowNodeResponseMultiError) AllErrors() []error { return m }

// DeleteFlowNodeResponseValidationError is the validation error returned by
// DeleteFlowNodeResponse.Validate if the designated constraints aren't met.
type DeleteFlowNodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFlowNodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFlowNodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFlowNodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFlowNodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFlowNodeResponseValidationError) ErrorName() string {
	return "DeleteFlowNodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFlowNodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFlowNodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFlowNodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFlowNodeResponseValidationError{}

// Validate checks the field values on ReconstructionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReconstructionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconstructionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReconstructionRequestMultiError, or nil if none found.
func (m *ReconstructionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconstructionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MergeID

	if len(errors) > 0 {
		return ReconstructionRequestMultiError(errors)
	}

	return nil
}

// ReconstructionRequestMultiError is an error wrapping multiple validation
// errors returned by ReconstructionRequest.ValidateAll() if the designated
// constraints aren't met.
type ReconstructionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconstructionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconstructionRequestMultiError) AllErrors() []error { return m }

// ReconstructionRequestValidationError is the validation error returned by
// ReconstructionRequest.Validate if the designated constraints aren't met.
type ReconstructionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconstructionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconstructionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconstructionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconstructionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconstructionRequestValidationError) ErrorName() string {
	return "ReconstructionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReconstructionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconstructionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconstructionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconstructionRequestValidationError{}

// Validate checks the field values on ReconstructionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReconstructionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconstructionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReconstructionResponseMultiError, or nil if none found.
func (m *ReconstructionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconstructionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReconstructionResponseMultiError(errors)
	}

	return nil
}

// ReconstructionResponseMultiError is an error wrapping multiple validation
// errors returned by ReconstructionResponse.ValidateAll() if the designated
// constraints aren't met.
type ReconstructionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconstructionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconstructionResponseMultiError) AllErrors() []error { return m }

// ReconstructionResponseValidationError is the validation error returned by
// ReconstructionResponse.Validate if the designated constraints aren't met.
type ReconstructionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconstructionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconstructionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconstructionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconstructionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconstructionResponseValidationError) ErrorName() string {
	return "ReconstructionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReconstructionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconstructionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconstructionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconstructionResponseValidationError{}

// Validate checks the field values on PipelineStepInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PipelineStepInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineStepInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineStepInfoMultiError, or nil if none found.
func (m *PipelineStepInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineStepInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for PipelineID

	// no validation rules for YmlName

	// no validation rules for HasOnPushBranch

	// no validation rules for Inode

	// no validation rules for PInode

	if len(errors) > 0 {
		return PipelineStepInfoMultiError(errors)
	}

	return nil
}

// PipelineStepInfoMultiError is an error wrapping multiple validation errors
// returned by PipelineStepInfo.ValidateAll() if the designated constraints
// aren't met.
type PipelineStepInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineStepInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineStepInfoMultiError) AllErrors() []error { return m }

// PipelineStepInfoValidationError is the validation error returned by
// PipelineStepInfo.Validate if the designated constraints aren't met.
type PipelineStepInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineStepInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineStepInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineStepInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineStepInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineStepInfoValidationError) ErrorName() string { return "PipelineStepInfoValidationError" }

// Error satisfies the builtin error interface
func (e PipelineStepInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineStepInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineStepInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineStepInfoValidationError{}

// Validate checks the field values on GetDevFlowInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDevFlowInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDevFlowInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDevFlowInfoRequestMultiError, or nil if none found.
func (m *GetDevFlowInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDevFlowInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IssueID

	// no validation rules for AppID

	// no validation rules for Branch

	if len(errors) > 0 {
		return GetDevFlowInfoRequestMultiError(errors)
	}

	return nil
}

// GetDevFlowInfoRequestMultiError is an error wrapping multiple validation
// errors returned by GetDevFlowInfoRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDevFlowInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDevFlowInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDevFlowInfoRequestMultiError) AllErrors() []error { return m }

// GetDevFlowInfoRequestValidationError is the validation error returned by
// GetDevFlowInfoRequest.Validate if the designated constraints aren't met.
type GetDevFlowInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDevFlowInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDevFlowInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDevFlowInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDevFlowInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDevFlowInfoRequestValidationError) ErrorName() string {
	return "GetDevFlowInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDevFlowInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDevFlowInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDevFlowInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDevFlowInfoRequestValidationError{}

// Validate checks the field values on ChangeBranch with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChangeBranch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeBranch with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChangeBranchMultiError, or
// nil if none found.
func (m *ChangeBranch) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeBranch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChangeBranchValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChangeBranchValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChangeBranchValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BranchName

	// no validation rules for Status

	if len(errors) > 0 {
		return ChangeBranchMultiError(errors)
	}

	return nil
}

// ChangeBranchMultiError is an error wrapping multiple validation errors
// returned by ChangeBranch.ValidateAll() if the designated constraints aren't met.
type ChangeBranchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeBranchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeBranchMultiError) AllErrors() []error { return m }

// ChangeBranchValidationError is the validation error returned by
// ChangeBranch.Validate if the designated constraints aren't met.
type ChangeBranchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeBranchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeBranchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeBranchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeBranchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeBranchValidationError) ErrorName() string { return "ChangeBranchValidationError" }

// Error satisfies the builtin error interface
func (e ChangeBranchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeBranch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeBranchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeBranchValidationError{}

// Validate checks the field values on DevFlowInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DevFlowInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DevFlowInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DevFlowInfoMultiError, or
// nil if none found.
func (m *DevFlowInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DevFlowInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDevFlow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "DevFlow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "DevFlow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDevFlow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowInfoValidationError{
				field:  "DevFlow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HasPermission

	if all {
		switch v := interface{}(m.GetCodeNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "CodeNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "CodeNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCodeNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowInfoValidationError{
				field:  "CodeNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTempMergeNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "TempMergeNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "TempMergeNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTempMergeNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowInfoValidationError{
				field:  "TempMergeNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPipelineNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "PipelineNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "PipelineNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipelineNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowInfoValidationError{
				field:  "PipelineNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMergeRequestNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "MergeRequestNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DevFlowInfoValidationError{
					field:  "MergeRequestNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMergeRequestNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DevFlowInfoValidationError{
				field:  "MergeRequestNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DevFlowInfoMultiError(errors)
	}

	return nil
}

// DevFlowInfoMultiError is an error wrapping multiple validation errors
// returned by DevFlowInfo.ValidateAll() if the designated constraints aren't met.
type DevFlowInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DevFlowInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DevFlowInfoMultiError) AllErrors() []error { return m }

// DevFlowInfoValidationError is the validation error returned by
// DevFlowInfo.Validate if the designated constraints aren't met.
type DevFlowInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DevFlowInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DevFlowInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DevFlowInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DevFlowInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DevFlowInfoValidationError) ErrorName() string { return "DevFlowInfoValidationError" }

// Error satisfies the builtin error interface
func (e DevFlowInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDevFlowInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DevFlowInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DevFlowInfoValidationError{}

// Validate checks the field values on CodeNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CodeNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CodeNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CodeNodeMultiError, or nil
// if none found.
func (m *CodeNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CodeNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrentBranch

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CodeNodeValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CodeNodeValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CodeNodeValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsJoinTempBranch

	// no validation rules for JoinTempBranchStatus

	// no validation rules for CanJoin

	// no validation rules for Exist

	// no validation rules for SourceBranch

	if len(errors) > 0 {
		return CodeNodeMultiError(errors)
	}

	return nil
}

// CodeNodeMultiError is an error wrapping multiple validation errors returned
// by CodeNode.ValidateAll() if the designated constraints aren't met.
type CodeNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CodeNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CodeNodeMultiError) AllErrors() []error { return m }

// CodeNodeValidationError is the validation error returned by
// CodeNode.Validate if the designated constraints aren't met.
type CodeNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CodeNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CodeNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CodeNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CodeNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CodeNodeValidationError) ErrorName() string { return "CodeNodeValidationError" }

// Error satisfies the builtin error interface
func (e CodeNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCodeNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CodeNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CodeNodeValidationError{}

// Validate checks the field values on TempMergeNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TempMergeNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TempMergeNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TempMergeNodeMultiError, or
// nil if none found.
func (m *TempMergeNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TempMergeNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TempBranch

	if all {
		switch v := interface{}(m.GetBaseCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TempMergeNodeValidationError{
					field:  "BaseCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TempMergeNodeValidationError{
					field:  "BaseCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TempMergeNodeValidationError{
				field:  "BaseCommit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChangeBranch() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TempMergeNodeValidationError{
						field:  fmt.Sprintf("ChangeBranch[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TempMergeNodeValidationError{
						field:  fmt.Sprintf("ChangeBranch[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TempMergeNodeValidationError{
					field:  fmt.Sprintf("ChangeBranch[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TempMergeNodeMultiError(errors)
	}

	return nil
}

// TempMergeNodeMultiError is an error wrapping multiple validation errors
// returned by TempMergeNode.ValidateAll() if the designated constraints
// aren't met.
type TempMergeNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TempMergeNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TempMergeNodeMultiError) AllErrors() []error { return m }

// TempMergeNodeValidationError is the validation error returned by
// TempMergeNode.Validate if the designated constraints aren't met.
type TempMergeNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TempMergeNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TempMergeNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TempMergeNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TempMergeNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TempMergeNodeValidationError) ErrorName() string { return "TempMergeNodeValidationError" }

// Error satisfies the builtin error interface
func (e TempMergeNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTempMergeNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TempMergeNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TempMergeNodeValidationError{}

// Validate checks the field values on PipelineNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineNodeMultiError, or
// nil if none found.
func (m *PipelineNode) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPipelineStepInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineNodeValidationError{
						field:  fmt.Sprintf("PipelineStepInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineNodeValidationError{
						field:  fmt.Sprintf("PipelineStepInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineNodeValidationError{
					field:  fmt.Sprintf("PipelineStepInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PipelineNodeMultiError(errors)
	}

	return nil
}

// PipelineNodeMultiError is an error wrapping multiple validation errors
// returned by PipelineNode.ValidateAll() if the designated constraints aren't met.
type PipelineNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineNodeMultiError) AllErrors() []error { return m }

// PipelineNodeValidationError is the validation error returned by
// PipelineNode.Validate if the designated constraints aren't met.
type PipelineNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineNodeValidationError) ErrorName() string { return "PipelineNodeValidationError" }

// Error satisfies the builtin error interface
func (e PipelineNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineNodeValidationError{}

// Validate checks the field values on MergeRequestNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MergeRequestNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeRequestNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MergeRequestNodeMultiError, or nil if none found.
func (m *MergeRequestNode) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeRequestNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CurrentBranch

	// no validation rules for TargetBranch

	// no validation rules for Title

	// no validation rules for Desc

	if all {
		switch v := interface{}(m.GetMergeRequestInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeRequestNodeValidationError{
					field:  "MergeRequestInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeRequestNodeValidationError{
					field:  "MergeRequestInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMergeRequestInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeRequestNodeValidationError{
				field:  "MergeRequestInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MergeRequestNodeMultiError(errors)
	}

	return nil
}

// MergeRequestNodeMultiError is an error wrapping multiple validation errors
// returned by MergeRequestNode.ValidateAll() if the designated constraints
// aren't met.
type MergeRequestNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeRequestNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeRequestNodeMultiError) AllErrors() []error { return m }

// MergeRequestNodeValidationError is the validation error returned by
// MergeRequestNode.Validate if the designated constraints aren't met.
type MergeRequestNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeRequestNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeRequestNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeRequestNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeRequestNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeRequestNodeValidationError) ErrorName() string { return "MergeRequestNodeValidationError" }

// Error satisfies the builtin error interface
func (e MergeRequestNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeRequestNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeRequestNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeRequestNodeValidationError{}

// Validate checks the field values on GetDevFlowInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDevFlowInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDevFlowInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDevFlowInfoResponseMultiError, or nil if none found.
func (m *GetDevFlowInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDevFlowInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDevFlowInfos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDevFlowInfoResponseValidationError{
						field:  fmt.Sprintf("DevFlowInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDevFlowInfoResponseValidationError{
						field:  fmt.Sprintf("DevFlowInfos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDevFlowInfoResponseValidationError{
					field:  fmt.Sprintf("DevFlowInfos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetDevFlowInfoResponseMultiError(errors)
	}

	return nil
}

// GetDevFlowInfoResponseMultiError is an error wrapping multiple validation
// errors returned by GetDevFlowInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDevFlowInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDevFlowInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDevFlowInfoResponseMultiError) AllErrors() []error { return m }

// GetDevFlowInfoResponseValidationError is the validation error returned by
// GetDevFlowInfoResponse.Validate if the designated constraints aren't met.
type GetDevFlowInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDevFlowInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDevFlowInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDevFlowInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDevFlowInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDevFlowInfoResponseValidationError) ErrorName() string {
	return "GetDevFlowInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDevFlowInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDevFlowInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDevFlowInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDevFlowInfoResponseValidationError{}

// Validate checks the field values on Commit with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Commit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Commit with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CommitMultiError, or nil if none found.
func (m *Commit) ValidateAll() error {
	return m.validate(true)
}

func (m *Commit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	if all {
		switch v := interface{}(m.GetAuthor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitValidationError{
					field:  "Author",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitValidationError{
					field:  "Author",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitValidationError{
				field:  "Author",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCommitter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitValidationError{
					field:  "Committer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitValidationError{
					field:  "Committer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommitter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitValidationError{
				field:  "Committer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CommitMessage

	// no validation rules for ParentSha

	if len(errors) > 0 {
		return CommitMultiError(errors)
	}

	return nil
}

// CommitMultiError is an error wrapping multiple validation errors returned by
// Commit.ValidateAll() if the designated constraints aren't met.
type CommitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitMultiError) AllErrors() []error { return m }

// CommitValidationError is the validation error returned by Commit.Validate if
// the designated constraints aren't met.
type CommitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitValidationError) ErrorName() string { return "CommitValidationError" }

// Error satisfies the builtin error interface
func (e CommitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitValidationError{}

// Validate checks the field values on Signature with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Signature) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Signature with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignatureMultiError, or nil
// if none found.
func (m *Signature) ValidateAll() error {
	return m.validate(true)
}

func (m *Signature) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Email

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetWhen()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignatureValidationError{
					field:  "When",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignatureValidationError{
					field:  "When",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhen()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignatureValidationError{
				field:  "When",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SignatureMultiError(errors)
	}

	return nil
}

// SignatureMultiError is an error wrapping multiple validation errors returned
// by Signature.ValidateAll() if the designated constraints aren't met.
type SignatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignatureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignatureMultiError) AllErrors() []error { return m }

// SignatureValidationError is the validation error returned by
// Signature.Validate if the designated constraints aren't met.
type SignatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignatureValidationError) ErrorName() string { return "SignatureValidationError" }

// Error satisfies the builtin error interface
func (e SignatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignatureValidationError{}

// Validate checks the field values on FlowCallbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FlowCallbackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowCallbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FlowCallbackRequestMultiError, or nil if none found.
func (m *FlowCallbackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowCallbackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetContent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FlowCallbackRequestValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FlowCallbackRequestValidationError{
					field:  "Content",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FlowCallbackRequestValidationError{
				field:  "Content",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProjectID

	// no validation rules for OrgID

	// no validation rules for ApplicationID

	if len(errors) > 0 {
		return FlowCallbackRequestMultiError(errors)
	}

	return nil
}

// FlowCallbackRequestMultiError is an error wrapping multiple validation
// errors returned by FlowCallbackRequest.ValidateAll() if the designated
// constraints aren't met.
type FlowCallbackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowCallbackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowCallbackRequestMultiError) AllErrors() []error { return m }

// FlowCallbackRequestValidationError is the validation error returned by
// FlowCallbackRequest.Validate if the designated constraints aren't met.
type FlowCallbackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowCallbackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowCallbackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowCallbackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowCallbackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowCallbackRequestValidationError) ErrorName() string {
	return "FlowCallbackRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FlowCallbackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowCallbackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowCallbackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowCallbackRequestValidationError{}

// Validate checks the field values on FlowEventData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlowEventData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowEventData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlowEventDataMultiError, or
// nil if none found.
func (m *FlowEventData) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowEventData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetParams()))
		i := 0
		for key := range m.GetParams() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetParams()[key]
			_ = val

			// no validation rules for Params[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, FlowEventDataValidationError{
							field:  fmt.Sprintf("Params[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, FlowEventDataValidationError{
							field:  fmt.Sprintf("Params[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return FlowEventDataValidationError{
						field:  fmt.Sprintf("Params[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for IssueID

	// no validation rules for Operator

	// no validation rules for TempBranch

	// no validation rules for SourceBranch

	// no validation rules for TargetBranch

	// no validation rules for AppName

	// no validation rules for ProjectName

	// no validation rules for IsJoinTempBranch

	if len(errors) > 0 {
		return FlowEventDataMultiError(errors)
	}

	return nil
}

// FlowEventDataMultiError is an error wrapping multiple validation errors
// returned by FlowEventData.ValidateAll() if the designated constraints
// aren't met.
type FlowEventDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowEventDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowEventDataMultiError) AllErrors() []error { return m }

// FlowEventDataValidationError is the validation error returned by
// FlowEventData.Validate if the designated constraints aren't met.
type FlowEventDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowEventDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowEventDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowEventDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowEventDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowEventDataValidationError) ErrorName() string { return "FlowEventDataValidationError" }

// Error satisfies the builtin error interface
func (e FlowEventDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowEventData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowEventDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowEventDataValidationError{}

// Validate checks the field values on FlowCallbackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FlowCallbackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlowCallbackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FlowCallbackResponseMultiError, or nil if none found.
func (m *FlowCallbackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FlowCallbackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FlowCallbackResponseMultiError(errors)
	}

	return nil
}

// FlowCallbackResponseMultiError is an error wrapping multiple validation
// errors returned by FlowCallbackResponse.ValidateAll() if the designated
// constraints aren't met.
type FlowCallbackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlowCallbackResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlowCallbackResponseMultiError) AllErrors() []error { return m }

// FlowCallbackResponseValidationError is the validation error returned by
// FlowCallbackResponse.Validate if the designated constraints aren't met.
type FlowCallbackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlowCallbackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlowCallbackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlowCallbackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlowCallbackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlowCallbackResponseValidationError) ErrorName() string {
	return "FlowCallbackResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FlowCallbackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlowCallbackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlowCallbackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlowCallbackResponseValidationError{}
