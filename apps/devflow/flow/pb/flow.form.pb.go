// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: flow.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	pb "github.com/erda-project/erda-proto-go/openapiv1/gittar/pb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*IssueRelationExtra)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DevFlowNode)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateFlowNodeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateFlowNodeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DevFlow)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OperationMergeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OperationMergeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteFlowNodeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteFlowNodeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReconstructionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReconstructionResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineStepInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetDevFlowInfoRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ChangeBranch)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DevFlowInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CodeNode)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TempMergeNode)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineNode)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MergeRequestNode)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetDevFlowInfoResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Commit)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Signature)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FlowCallbackRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FlowEventData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FlowCallbackResponse)(nil)

// IssueRelationExtra implement urlenc.URLValuesUnmarshaler.
func (m *IssueRelationExtra) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "repoMergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoMergeID = val
			}
		}
	}
	return nil
}

// DevFlowNode implement urlenc.URLValuesUnmarshaler.
func (m *DevFlowNode) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "repoMergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoMergeID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "targetBranch":
				m.TargetBranch = vals[0]
			case "sourceBranch":
				m.SourceBranch = vals[0]
			case "isJoinTempBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsJoinTempBranch = val
			case "joinTempBranchStatus":
				m.JoinTempBranchStatus = vals[0]
			case "tempBranch":
				m.TempBranch = vals[0]
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "mergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeID = val
			case "appName":
				m.AppName = vals[0]
			case "commit":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
			case "commit.ID":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.ID = vals[0]
			case "commit.author":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
			case "commit.author.email":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				m.Commit.Author.Email = vals[0]
			case "commit.author.name":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				m.Commit.Author.Name = vals[0]
			case "commit.author.When":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
			case "commit.author.When.seconds":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Commit.Author.When.Seconds = val
			case "commit.author.When.nanos":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Commit.Author.When.Nanos = int32(val)
			case "commit.committer":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
			case "commit.committer.email":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				m.Commit.Committer.Email = vals[0]
			case "commit.committer.name":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				m.Commit.Committer.Name = vals[0]
			case "commit.committer.When":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
			case "commit.committer.When.seconds":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Commit.Committer.When.Seconds = val
			case "commit.committer.When.nanos":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Commit.Committer.When.Nanos = int32(val)
			case "commit.commitMessage":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.CommitMessage = vals[0]
			case "commit.parentSha":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.ParentSha = vals[0]
			case "baseCommit":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
			case "baseCommit.ID":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				m.BaseCommit.ID = vals[0]
			case "baseCommit.author":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
			case "baseCommit.author.email":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				m.BaseCommit.Author.Email = vals[0]
			case "baseCommit.author.name":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				m.BaseCommit.Author.Name = vals[0]
			case "baseCommit.author.When":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				if m.BaseCommit.Author.When == nil {
					m.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
			case "baseCommit.author.When.seconds":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				if m.BaseCommit.Author.When == nil {
					m.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BaseCommit.Author.When.Seconds = val
			case "baseCommit.author.When.nanos":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				if m.BaseCommit.Author.When == nil {
					m.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.BaseCommit.Author.When.Nanos = int32(val)
			case "baseCommit.committer":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
			case "baseCommit.committer.email":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				m.BaseCommit.Committer.Email = vals[0]
			case "baseCommit.committer.name":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				m.BaseCommit.Committer.Name = vals[0]
			case "baseCommit.committer.When":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				if m.BaseCommit.Committer.When == nil {
					m.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
			case "baseCommit.committer.When.seconds":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				if m.BaseCommit.Committer.When == nil {
					m.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BaseCommit.Committer.When.Seconds = val
			case "baseCommit.committer.When.nanos":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				if m.BaseCommit.Committer.When == nil {
					m.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.BaseCommit.Committer.When.Nanos = int32(val)
			case "baseCommit.commitMessage":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				m.BaseCommit.CommitMessage = vals[0]
			case "baseCommit.parentSha":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				m.BaseCommit.ParentSha = vals[0]
			case "canJoin":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CanJoin = val
			case "mergeRequestInfo":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
			case "mergeRequestInfo.id":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.Id = val
			case "mergeRequestInfo.repoMergeId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.RepoMergeId = val
			case "mergeRequestInfo.appID":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.AppID = val
			case "mergeRequestInfo.repoID":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.RepoID = val
			case "mergeRequestInfo.title":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.Title = vals[0]
			case "mergeRequestInfo.authorId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.AuthorId = vals[0]
			case "mergeRequestInfo.authorUser":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.description":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.Description = vals[0]
			case "mergeRequestInfo.assigneeId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.AssigneeId = vals[0]
			case "mergeRequestInfo.assigneeUser":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUserId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.MergeUserId = vals[0]
			case "mergeRequestInfo.mergeUser":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUserId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.CloseUserId = vals[0]
			case "mergeRequestInfo.closeUser":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.sourceBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.SourceBranch = vals[0]
			case "mergeRequestInfo.targetBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.TargetBranch = vals[0]
			case "mergeRequestInfo.sourceSha":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.SourceSha = vals[0]
			case "mergeRequestInfo.targetSha":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.TargetSha = vals[0]
			case "mergeRequestInfo.removeSourceBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestInfo.RemoveSourceBranch = val
			case "mergeRequestInfo.state":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.State = vals[0]
			case "mergeRequestInfo.isCheckRunValid":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestInfo.IsCheckRunValid = val
			case "mergeRequestInfo.targetBranchRule":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.defaultCommitMessage":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.DefaultCommitMessage = vals[0]
			case "mergeRequestInfo.createdAt":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestInfo.createdAt.seconds":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.CreatedAt.Seconds = val
			case "mergeRequestInfo.createdAt.nanos":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.CreatedAt.Nanos = int32(val)
			case "mergeRequestInfo.updatedAt":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestInfo.updatedAt.seconds":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.UpdatedAt.Seconds = val
			case "mergeRequestInfo.updatedAt.nanos":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.UpdatedAt.Nanos = int32(val)
			case "mergeRequestInfo.closeAt":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestInfo.closeAt.seconds":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.CloseAt.Seconds = val
			case "mergeRequestInfo.closeAt.nanos":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.CloseAt.Nanos = int32(val)
			case "mergeRequestInfo.mergeAt":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestInfo.mergeAt.seconds":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.MergeAt.Seconds = val
			case "mergeRequestInfo.mergeAt.nanos":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.MergeAt.Nanos = int32(val)
			case "mergeRequestInfo.link":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.Link = vals[0]
			case "mergeRequestInfo.score":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.Score = val
			case "mergeRequestInfo.scoreNum":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.ScoreNum = val
			case "mergeRequestInfo.rebaseBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.RebaseBranch = vals[0]
			case "mergeRequestInfo.eventName":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.EventName = vals[0]
			case "mergeRequestInfo.checkRuns":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.joinTempBranchStatus":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.JoinTempBranchStatus = vals[0]
			case "mergeRequestInfo.isJoinTempBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestInfo.IsJoinTempBranch = val
			}
		}
	}
	return nil
}

// CreateFlowNodeRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateFlowNodeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "flowRuleName":
				m.FlowRuleName = vals[0]
			case "currentBranch":
				m.CurrentBranch = vals[0]
			}
		}
	}
	return nil
}

// CreateFlowNodeResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateFlowNodeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				m.Data.ID = vals[0]
			case "data.orgID":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.orgName":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				m.Data.OrgName = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				m.Data.Creator = vals[0]
			case "data.branch":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				m.Data.Branch = vals[0]
			case "data.issueID":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueID = val
			case "data.flowRuleName":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				m.Data.FlowRuleName = vals[0]
			case "data.appID":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AppID = val
			case "data.appName":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				m.Data.AppName = vals[0]
			case "data.joinTempBranchStatus":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				m.Data.JoinTempBranchStatus = vals[0]
			case "data.isJoinTempBranch":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.IsJoinTempBranch = val
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &DevFlow{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// DevFlow implement urlenc.URLValuesUnmarshaler.
func (m *DevFlow) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "orgName":
				m.OrgName = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "branch":
				m.Branch = vals[0]
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "flowRuleName":
				m.FlowRuleName = vals[0]
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "appName":
				m.AppName = vals[0]
			case "joinTempBranchStatus":
				m.JoinTempBranchStatus = vals[0]
			case "isJoinTempBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsJoinTempBranch = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// OperationMergeRequest implement urlenc.URLValuesUnmarshaler.
func (m *OperationMergeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "devFlowID":
				m.DevFlowID = vals[0]
			case "enable":
				if m.Enable == nil {
					m.Enable = &wrapperspb.BoolValue{}
				}
			case "enable.value":
				if m.Enable == nil {
					m.Enable = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable.Value = val
			}
		}
	}
	return nil
}

// OperationMergeResponse implement urlenc.URLValuesUnmarshaler.
func (m *OperationMergeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DeleteFlowNodeRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteFlowNodeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "devFlowID":
				m.DevFlowID = vals[0]
			case "deleteBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.DeleteBranch = val
			}
		}
	}
	return nil
}

// DeleteFlowNodeResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteFlowNodeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ReconstructionRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReconstructionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "mergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeID = val
			}
		}
	}
	return nil
}

// ReconstructionResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReconstructionResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineStepInfo implement urlenc.URLValuesUnmarshaler.
func (m *PipelineStepInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "status":
				m.Status = vals[0]
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			case "ymlName":
				m.YmlName = vals[0]
			case "hasOnPushBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.HasOnPushBranch = val
			case "inode":
				m.Inode = vals[0]
			case "pInode":
				m.PInode = vals[0]
			}
		}
	}
	return nil
}

// GetDevFlowInfoRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetDevFlowInfoRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branch":
				m.Branch = vals[0]
			}
		}
	}
	return nil
}

// ChangeBranch implement urlenc.URLValuesUnmarshaler.
func (m *ChangeBranch) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "commit":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
			case "commit.ID":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.ID = vals[0]
			case "commit.author":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
			case "commit.author.email":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				m.Commit.Author.Email = vals[0]
			case "commit.author.name":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				m.Commit.Author.Name = vals[0]
			case "commit.author.When":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
			case "commit.author.When.seconds":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Commit.Author.When.Seconds = val
			case "commit.author.When.nanos":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Commit.Author.When.Nanos = int32(val)
			case "commit.committer":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
			case "commit.committer.email":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				m.Commit.Committer.Email = vals[0]
			case "commit.committer.name":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				m.Commit.Committer.Name = vals[0]
			case "commit.committer.When":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
			case "commit.committer.When.seconds":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Commit.Committer.When.Seconds = val
			case "commit.committer.When.nanos":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Commit.Committer.When.Nanos = int32(val)
			case "commit.commitMessage":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.CommitMessage = vals[0]
			case "commit.parentSha":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.ParentSha = vals[0]
			case "branchName":
				m.BranchName = vals[0]
			case "status":
				m.Status = vals[0]
			}
		}
	}
	return nil
}

// DevFlowInfo implement urlenc.URLValuesUnmarshaler.
func (m *DevFlowInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "devFlow":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
			case "devFlow.ID":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				m.DevFlow.ID = vals[0]
			case "devFlow.orgID":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlow.OrgID = val
			case "devFlow.orgName":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				m.DevFlow.OrgName = vals[0]
			case "devFlow.creator":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				m.DevFlow.Creator = vals[0]
			case "devFlow.branch":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				m.DevFlow.Branch = vals[0]
			case "devFlow.issueID":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlow.IssueID = val
			case "devFlow.flowRuleName":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				m.DevFlow.FlowRuleName = vals[0]
			case "devFlow.appID":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlow.AppID = val
			case "devFlow.appName":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				m.DevFlow.AppName = vals[0]
			case "devFlow.joinTempBranchStatus":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				m.DevFlow.JoinTempBranchStatus = vals[0]
			case "devFlow.isJoinTempBranch":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.DevFlow.IsJoinTempBranch = val
			case "devFlow.createdAt":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				if m.DevFlow.CreatedAt == nil {
					m.DevFlow.CreatedAt = &timestamppb.Timestamp{}
				}
			case "devFlow.createdAt.seconds":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				if m.DevFlow.CreatedAt == nil {
					m.DevFlow.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlow.CreatedAt.Seconds = val
			case "devFlow.createdAt.nanos":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				if m.DevFlow.CreatedAt == nil {
					m.DevFlow.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.DevFlow.CreatedAt.Nanos = int32(val)
			case "devFlow.updatedAt":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				if m.DevFlow.UpdatedAt == nil {
					m.DevFlow.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "devFlow.updatedAt.seconds":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				if m.DevFlow.UpdatedAt == nil {
					m.DevFlow.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlow.UpdatedAt.Seconds = val
			case "devFlow.updatedAt.nanos":
				if m.DevFlow == nil {
					m.DevFlow = &DevFlow{}
				}
				if m.DevFlow.UpdatedAt == nil {
					m.DevFlow.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.DevFlow.UpdatedAt.Nanos = int32(val)
			case "hasPermission":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.HasPermission = val
			case "codeNode":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
			case "codeNode.currentBranch":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				m.CodeNode.CurrentBranch = vals[0]
			case "codeNode.commit":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
			case "codeNode.commit.ID":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				m.CodeNode.Commit.ID = vals[0]
			case "codeNode.commit.author":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Author == nil {
					m.CodeNode.Commit.Author = &Signature{}
				}
			case "codeNode.commit.author.email":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Author == nil {
					m.CodeNode.Commit.Author = &Signature{}
				}
				m.CodeNode.Commit.Author.Email = vals[0]
			case "codeNode.commit.author.name":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Author == nil {
					m.CodeNode.Commit.Author = &Signature{}
				}
				m.CodeNode.Commit.Author.Name = vals[0]
			case "codeNode.commit.author.When":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Author == nil {
					m.CodeNode.Commit.Author = &Signature{}
				}
				if m.CodeNode.Commit.Author.When == nil {
					m.CodeNode.Commit.Author.When = &timestamppb.Timestamp{}
				}
			case "codeNode.commit.author.When.seconds":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Author == nil {
					m.CodeNode.Commit.Author = &Signature{}
				}
				if m.CodeNode.Commit.Author.When == nil {
					m.CodeNode.Commit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CodeNode.Commit.Author.When.Seconds = val
			case "codeNode.commit.author.When.nanos":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Author == nil {
					m.CodeNode.Commit.Author = &Signature{}
				}
				if m.CodeNode.Commit.Author.When == nil {
					m.CodeNode.Commit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CodeNode.Commit.Author.When.Nanos = int32(val)
			case "codeNode.commit.committer":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Committer == nil {
					m.CodeNode.Commit.Committer = &Signature{}
				}
			case "codeNode.commit.committer.email":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Committer == nil {
					m.CodeNode.Commit.Committer = &Signature{}
				}
				m.CodeNode.Commit.Committer.Email = vals[0]
			case "codeNode.commit.committer.name":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Committer == nil {
					m.CodeNode.Commit.Committer = &Signature{}
				}
				m.CodeNode.Commit.Committer.Name = vals[0]
			case "codeNode.commit.committer.When":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Committer == nil {
					m.CodeNode.Commit.Committer = &Signature{}
				}
				if m.CodeNode.Commit.Committer.When == nil {
					m.CodeNode.Commit.Committer.When = &timestamppb.Timestamp{}
				}
			case "codeNode.commit.committer.When.seconds":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Committer == nil {
					m.CodeNode.Commit.Committer = &Signature{}
				}
				if m.CodeNode.Commit.Committer.When == nil {
					m.CodeNode.Commit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CodeNode.Commit.Committer.When.Seconds = val
			case "codeNode.commit.committer.When.nanos":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				if m.CodeNode.Commit.Committer == nil {
					m.CodeNode.Commit.Committer = &Signature{}
				}
				if m.CodeNode.Commit.Committer.When == nil {
					m.CodeNode.Commit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CodeNode.Commit.Committer.When.Nanos = int32(val)
			case "codeNode.commit.commitMessage":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				m.CodeNode.Commit.CommitMessage = vals[0]
			case "codeNode.commit.parentSha":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				if m.CodeNode.Commit == nil {
					m.CodeNode.Commit = &Commit{}
				}
				m.CodeNode.Commit.ParentSha = vals[0]
			case "codeNode.isJoinTempBranch":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CodeNode.IsJoinTempBranch = val
			case "codeNode.joinTempBranchStatus":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				m.CodeNode.JoinTempBranchStatus = vals[0]
			case "codeNode.canJoin":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CodeNode.CanJoin = val
			case "codeNode.exist":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CodeNode.Exist = val
			case "codeNode.sourceBranch":
				if m.CodeNode == nil {
					m.CodeNode = &CodeNode{}
				}
				m.CodeNode.SourceBranch = vals[0]
			case "tempMergeNode":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
			case "tempMergeNode.tempBranch":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				m.TempMergeNode.TempBranch = vals[0]
			case "tempMergeNode.baseCommit":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
			case "tempMergeNode.baseCommit.ID":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				m.TempMergeNode.BaseCommit.ID = vals[0]
			case "tempMergeNode.baseCommit.author":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Author == nil {
					m.TempMergeNode.BaseCommit.Author = &Signature{}
				}
			case "tempMergeNode.baseCommit.author.email":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Author == nil {
					m.TempMergeNode.BaseCommit.Author = &Signature{}
				}
				m.TempMergeNode.BaseCommit.Author.Email = vals[0]
			case "tempMergeNode.baseCommit.author.name":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Author == nil {
					m.TempMergeNode.BaseCommit.Author = &Signature{}
				}
				m.TempMergeNode.BaseCommit.Author.Name = vals[0]
			case "tempMergeNode.baseCommit.author.When":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Author == nil {
					m.TempMergeNode.BaseCommit.Author = &Signature{}
				}
				if m.TempMergeNode.BaseCommit.Author.When == nil {
					m.TempMergeNode.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
			case "tempMergeNode.baseCommit.author.When.seconds":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Author == nil {
					m.TempMergeNode.BaseCommit.Author = &Signature{}
				}
				if m.TempMergeNode.BaseCommit.Author.When == nil {
					m.TempMergeNode.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TempMergeNode.BaseCommit.Author.When.Seconds = val
			case "tempMergeNode.baseCommit.author.When.nanos":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Author == nil {
					m.TempMergeNode.BaseCommit.Author = &Signature{}
				}
				if m.TempMergeNode.BaseCommit.Author.When == nil {
					m.TempMergeNode.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TempMergeNode.BaseCommit.Author.When.Nanos = int32(val)
			case "tempMergeNode.baseCommit.committer":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Committer == nil {
					m.TempMergeNode.BaseCommit.Committer = &Signature{}
				}
			case "tempMergeNode.baseCommit.committer.email":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Committer == nil {
					m.TempMergeNode.BaseCommit.Committer = &Signature{}
				}
				m.TempMergeNode.BaseCommit.Committer.Email = vals[0]
			case "tempMergeNode.baseCommit.committer.name":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Committer == nil {
					m.TempMergeNode.BaseCommit.Committer = &Signature{}
				}
				m.TempMergeNode.BaseCommit.Committer.Name = vals[0]
			case "tempMergeNode.baseCommit.committer.When":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Committer == nil {
					m.TempMergeNode.BaseCommit.Committer = &Signature{}
				}
				if m.TempMergeNode.BaseCommit.Committer.When == nil {
					m.TempMergeNode.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
			case "tempMergeNode.baseCommit.committer.When.seconds":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Committer == nil {
					m.TempMergeNode.BaseCommit.Committer = &Signature{}
				}
				if m.TempMergeNode.BaseCommit.Committer.When == nil {
					m.TempMergeNode.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TempMergeNode.BaseCommit.Committer.When.Seconds = val
			case "tempMergeNode.baseCommit.committer.When.nanos":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				if m.TempMergeNode.BaseCommit.Committer == nil {
					m.TempMergeNode.BaseCommit.Committer = &Signature{}
				}
				if m.TempMergeNode.BaseCommit.Committer.When == nil {
					m.TempMergeNode.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TempMergeNode.BaseCommit.Committer.When.Nanos = int32(val)
			case "tempMergeNode.baseCommit.commitMessage":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				m.TempMergeNode.BaseCommit.CommitMessage = vals[0]
			case "tempMergeNode.baseCommit.parentSha":
				if m.TempMergeNode == nil {
					m.TempMergeNode = &TempMergeNode{}
				}
				if m.TempMergeNode.BaseCommit == nil {
					m.TempMergeNode.BaseCommit = &Commit{}
				}
				m.TempMergeNode.BaseCommit.ParentSha = vals[0]
			case "pipelineNode":
				if m.PipelineNode == nil {
					m.PipelineNode = &PipelineNode{}
				}
			case "mergeRequestNode":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
			case "mergeRequestNode.currentBranch":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				m.MergeRequestNode.CurrentBranch = vals[0]
			case "mergeRequestNode.targetBranch":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				m.MergeRequestNode.TargetBranch = vals[0]
			case "mergeRequestNode.title":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				m.MergeRequestNode.Title = vals[0]
			case "mergeRequestNode.desc":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				m.MergeRequestNode.Desc = vals[0]
			case "mergeRequestNode.mergeRequestInfo":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
			case "mergeRequestNode.mergeRequestInfo.id":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.Id = val
			case "mergeRequestNode.mergeRequestInfo.repoMergeId":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.RepoMergeId = val
			case "mergeRequestNode.mergeRequestInfo.appID":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.AppID = val
			case "mergeRequestNode.mergeRequestInfo.repoID":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.RepoID = val
			case "mergeRequestNode.mergeRequestInfo.title":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.Title = vals[0]
			case "mergeRequestNode.mergeRequestInfo.authorId":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.AuthorId = vals[0]
			case "mergeRequestNode.mergeRequestInfo.authorUser":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.authorUser.null_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.authorUser.number_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.authorUser.string_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.authorUser.bool_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.authorUser.struct_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.authorUser.list_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.description":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.Description = vals[0]
			case "mergeRequestNode.mergeRequestInfo.assigneeId":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.AssigneeId = vals[0]
			case "mergeRequestNode.mergeRequestInfo.assigneeUser":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.assigneeUser.null_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.assigneeUser.number_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.assigneeUser.string_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.assigneeUser.bool_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.assigneeUser.struct_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.assigneeUser.list_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.mergeUserId":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.MergeUserId = vals[0]
			case "mergeRequestNode.mergeRequestInfo.mergeUser":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.mergeUser.null_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.mergeUser.number_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.mergeUser.string_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.mergeUser.bool_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.mergeUser.struct_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.mergeUser.list_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.closeUserId":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.CloseUserId = vals[0]
			case "mergeRequestNode.mergeRequestInfo.closeUser":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.closeUser.null_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.closeUser.number_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.closeUser.string_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.closeUser.bool_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.closeUser.struct_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.closeUser.list_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.sourceBranch":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.SourceBranch = vals[0]
			case "mergeRequestNode.mergeRequestInfo.targetBranch":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.TargetBranch = vals[0]
			case "mergeRequestNode.mergeRequestInfo.sourceSha":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.SourceSha = vals[0]
			case "mergeRequestNode.mergeRequestInfo.targetSha":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.TargetSha = vals[0]
			case "mergeRequestNode.mergeRequestInfo.removeSourceBranch":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.RemoveSourceBranch = val
			case "mergeRequestNode.mergeRequestInfo.state":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.State = vals[0]
			case "mergeRequestNode.mergeRequestInfo.isCheckRunValid":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.IsCheckRunValid = val
			case "mergeRequestNode.mergeRequestInfo.targetBranchRule":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.targetBranchRule.null_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.targetBranchRule.number_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.targetBranchRule.string_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.targetBranchRule.bool_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.targetBranchRule.struct_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.targetBranchRule.list_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.defaultCommitMessage":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.DefaultCommitMessage = vals[0]
			case "mergeRequestNode.mergeRequestInfo.createdAt":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestNode.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestNode.mergeRequestInfo.createdAt.seconds":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestNode.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.CreatedAt.Seconds = val
			case "mergeRequestNode.mergeRequestInfo.createdAt.nanos":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestNode.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.CreatedAt.Nanos = int32(val)
			case "mergeRequestNode.mergeRequestInfo.updatedAt":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestNode.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestNode.mergeRequestInfo.updatedAt.seconds":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestNode.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.UpdatedAt.Seconds = val
			case "mergeRequestNode.mergeRequestInfo.updatedAt.nanos":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestNode.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.UpdatedAt.Nanos = int32(val)
			case "mergeRequestNode.mergeRequestInfo.closeAt":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestNode.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestNode.mergeRequestInfo.closeAt.seconds":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestNode.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.CloseAt.Seconds = val
			case "mergeRequestNode.mergeRequestInfo.closeAt.nanos":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestNode.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.CloseAt.Nanos = int32(val)
			case "mergeRequestNode.mergeRequestInfo.mergeAt":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestNode.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestNode.mergeRequestInfo.mergeAt.seconds":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestNode.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.MergeAt.Seconds = val
			case "mergeRequestNode.mergeRequestInfo.mergeAt.nanos":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestNode.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestNode.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.MergeAt.Nanos = int32(val)
			case "mergeRequestNode.mergeRequestInfo.link":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.Link = vals[0]
			case "mergeRequestNode.mergeRequestInfo.score":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.Score = val
			case "mergeRequestNode.mergeRequestInfo.scoreNum":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.ScoreNum = val
			case "mergeRequestNode.mergeRequestInfo.rebaseBranch":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.RebaseBranch = vals[0]
			case "mergeRequestNode.mergeRequestInfo.eventName":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.EventName = vals[0]
			case "mergeRequestNode.mergeRequestInfo.checkRuns":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.checkRuns.null_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.checkRuns.number_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.checkRuns.string_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.checkRuns.bool_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.checkRuns.struct_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.checkRuns.list_value":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestNode.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestNode.mergeRequestInfo.joinTempBranchStatus":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestNode.MergeRequestInfo.JoinTempBranchStatus = vals[0]
			case "mergeRequestNode.mergeRequestInfo.isJoinTempBranch":
				if m.MergeRequestNode == nil {
					m.MergeRequestNode = &MergeRequestNode{}
				}
				if m.MergeRequestNode.MergeRequestInfo == nil {
					m.MergeRequestNode.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestNode.MergeRequestInfo.IsJoinTempBranch = val
			}
		}
	}
	return nil
}

// CodeNode implement urlenc.URLValuesUnmarshaler.
func (m *CodeNode) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "currentBranch":
				m.CurrentBranch = vals[0]
			case "commit":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
			case "commit.ID":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.ID = vals[0]
			case "commit.author":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
			case "commit.author.email":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				m.Commit.Author.Email = vals[0]
			case "commit.author.name":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				m.Commit.Author.Name = vals[0]
			case "commit.author.When":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
			case "commit.author.When.seconds":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Commit.Author.When.Seconds = val
			case "commit.author.When.nanos":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Author == nil {
					m.Commit.Author = &Signature{}
				}
				if m.Commit.Author.When == nil {
					m.Commit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Commit.Author.When.Nanos = int32(val)
			case "commit.committer":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
			case "commit.committer.email":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				m.Commit.Committer.Email = vals[0]
			case "commit.committer.name":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				m.Commit.Committer.Name = vals[0]
			case "commit.committer.When":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
			case "commit.committer.When.seconds":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Commit.Committer.When.Seconds = val
			case "commit.committer.When.nanos":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				if m.Commit.Committer == nil {
					m.Commit.Committer = &Signature{}
				}
				if m.Commit.Committer.When == nil {
					m.Commit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Commit.Committer.When.Nanos = int32(val)
			case "commit.commitMessage":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.CommitMessage = vals[0]
			case "commit.parentSha":
				if m.Commit == nil {
					m.Commit = &Commit{}
				}
				m.Commit.ParentSha = vals[0]
			case "isJoinTempBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsJoinTempBranch = val
			case "joinTempBranchStatus":
				m.JoinTempBranchStatus = vals[0]
			case "canJoin":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CanJoin = val
			case "exist":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Exist = val
			case "sourceBranch":
				m.SourceBranch = vals[0]
			}
		}
	}
	return nil
}

// TempMergeNode implement urlenc.URLValuesUnmarshaler.
func (m *TempMergeNode) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tempBranch":
				m.TempBranch = vals[0]
			case "baseCommit":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
			case "baseCommit.ID":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				m.BaseCommit.ID = vals[0]
			case "baseCommit.author":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
			case "baseCommit.author.email":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				m.BaseCommit.Author.Email = vals[0]
			case "baseCommit.author.name":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				m.BaseCommit.Author.Name = vals[0]
			case "baseCommit.author.When":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				if m.BaseCommit.Author.When == nil {
					m.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
			case "baseCommit.author.When.seconds":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				if m.BaseCommit.Author.When == nil {
					m.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BaseCommit.Author.When.Seconds = val
			case "baseCommit.author.When.nanos":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Author == nil {
					m.BaseCommit.Author = &Signature{}
				}
				if m.BaseCommit.Author.When == nil {
					m.BaseCommit.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.BaseCommit.Author.When.Nanos = int32(val)
			case "baseCommit.committer":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
			case "baseCommit.committer.email":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				m.BaseCommit.Committer.Email = vals[0]
			case "baseCommit.committer.name":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				m.BaseCommit.Committer.Name = vals[0]
			case "baseCommit.committer.When":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				if m.BaseCommit.Committer.When == nil {
					m.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
			case "baseCommit.committer.When.seconds":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				if m.BaseCommit.Committer.When == nil {
					m.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BaseCommit.Committer.When.Seconds = val
			case "baseCommit.committer.When.nanos":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				if m.BaseCommit.Committer == nil {
					m.BaseCommit.Committer = &Signature{}
				}
				if m.BaseCommit.Committer.When == nil {
					m.BaseCommit.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.BaseCommit.Committer.When.Nanos = int32(val)
			case "baseCommit.commitMessage":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				m.BaseCommit.CommitMessage = vals[0]
			case "baseCommit.parentSha":
				if m.BaseCommit == nil {
					m.BaseCommit = &Commit{}
				}
				m.BaseCommit.ParentSha = vals[0]
			}
		}
	}
	return nil
}

// PipelineNode implement urlenc.URLValuesUnmarshaler.
func (m *PipelineNode) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// MergeRequestNode implement urlenc.URLValuesUnmarshaler.
func (m *MergeRequestNode) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "currentBranch":
				m.CurrentBranch = vals[0]
			case "targetBranch":
				m.TargetBranch = vals[0]
			case "title":
				m.Title = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "mergeRequestInfo":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
			case "mergeRequestInfo.id":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.Id = val
			case "mergeRequestInfo.repoMergeId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.RepoMergeId = val
			case "mergeRequestInfo.appID":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.AppID = val
			case "mergeRequestInfo.repoID":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.RepoID = val
			case "mergeRequestInfo.title":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.Title = vals[0]
			case "mergeRequestInfo.authorId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.AuthorId = vals[0]
			case "mergeRequestInfo.authorUser":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.authorUser.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AuthorUser = val
					} else {
						m.MergeRequestInfo.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.description":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.Description = vals[0]
			case "mergeRequestInfo.assigneeId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.AssigneeId = vals[0]
			case "mergeRequestInfo.assigneeUser":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.assigneeUser.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.AssigneeUser = val
					} else {
						m.MergeRequestInfo.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUserId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.MergeUserId = vals[0]
			case "mergeRequestInfo.mergeUser":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.mergeUser.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.MergeUser = val
					} else {
						m.MergeRequestInfo.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUserId":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.CloseUserId = vals[0]
			case "mergeRequestInfo.closeUser":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.closeUser.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CloseUser = val
					} else {
						m.MergeRequestInfo.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.sourceBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.SourceBranch = vals[0]
			case "mergeRequestInfo.targetBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.TargetBranch = vals[0]
			case "mergeRequestInfo.sourceSha":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.SourceSha = vals[0]
			case "mergeRequestInfo.targetSha":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.TargetSha = vals[0]
			case "mergeRequestInfo.removeSourceBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestInfo.RemoveSourceBranch = val
			case "mergeRequestInfo.state":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.State = vals[0]
			case "mergeRequestInfo.isCheckRunValid":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestInfo.IsCheckRunValid = val
			case "mergeRequestInfo.targetBranchRule":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.targetBranchRule.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.TargetBranchRule = val
					} else {
						m.MergeRequestInfo.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.defaultCommitMessage":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.DefaultCommitMessage = vals[0]
			case "mergeRequestInfo.createdAt":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestInfo.createdAt.seconds":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.CreatedAt.Seconds = val
			case "mergeRequestInfo.createdAt.nanos":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CreatedAt == nil {
					m.MergeRequestInfo.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.CreatedAt.Nanos = int32(val)
			case "mergeRequestInfo.updatedAt":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestInfo.updatedAt.seconds":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.UpdatedAt.Seconds = val
			case "mergeRequestInfo.updatedAt.nanos":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.UpdatedAt == nil {
					m.MergeRequestInfo.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.UpdatedAt.Nanos = int32(val)
			case "mergeRequestInfo.closeAt":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestInfo.closeAt.seconds":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.CloseAt.Seconds = val
			case "mergeRequestInfo.closeAt.nanos":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.CloseAt == nil {
					m.MergeRequestInfo.CloseAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.CloseAt.Nanos = int32(val)
			case "mergeRequestInfo.mergeAt":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
			case "mergeRequestInfo.mergeAt.seconds":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.MergeAt.Seconds = val
			case "mergeRequestInfo.mergeAt.nanos":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if m.MergeRequestInfo.MergeAt == nil {
					m.MergeRequestInfo.MergeAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.MergeAt.Nanos = int32(val)
			case "mergeRequestInfo.link":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.Link = vals[0]
			case "mergeRequestInfo.score":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.Score = val
			case "mergeRequestInfo.scoreNum":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestInfo.ScoreNum = val
			case "mergeRequestInfo.rebaseBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.RebaseBranch = vals[0]
			case "mergeRequestInfo.eventName":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.EventName = vals[0]
			case "mergeRequestInfo.checkRuns":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.null_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.number_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.string_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.bool_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.struct_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.checkRuns.list_value":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeRequestInfo.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeRequestInfo.CheckRuns = val
					} else {
						m.MergeRequestInfo.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeRequestInfo.joinTempBranchStatus":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				m.MergeRequestInfo.JoinTempBranchStatus = vals[0]
			case "mergeRequestInfo.isJoinTempBranch":
				if m.MergeRequestInfo == nil {
					m.MergeRequestInfo = &pb.MergeRequestInfo{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.MergeRequestInfo.IsJoinTempBranch = val
			}
		}
	}
	return nil
}

// GetDevFlowInfoResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetDevFlowInfoResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// Commit implement urlenc.URLValuesUnmarshaler.
func (m *Commit) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "author":
				if m.Author == nil {
					m.Author = &Signature{}
				}
			case "author.email":
				if m.Author == nil {
					m.Author = &Signature{}
				}
				m.Author.Email = vals[0]
			case "author.name":
				if m.Author == nil {
					m.Author = &Signature{}
				}
				m.Author.Name = vals[0]
			case "author.When":
				if m.Author == nil {
					m.Author = &Signature{}
				}
				if m.Author.When == nil {
					m.Author.When = &timestamppb.Timestamp{}
				}
			case "author.When.seconds":
				if m.Author == nil {
					m.Author = &Signature{}
				}
				if m.Author.When == nil {
					m.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Author.When.Seconds = val
			case "author.When.nanos":
				if m.Author == nil {
					m.Author = &Signature{}
				}
				if m.Author.When == nil {
					m.Author.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Author.When.Nanos = int32(val)
			case "committer":
				if m.Committer == nil {
					m.Committer = &Signature{}
				}
			case "committer.email":
				if m.Committer == nil {
					m.Committer = &Signature{}
				}
				m.Committer.Email = vals[0]
			case "committer.name":
				if m.Committer == nil {
					m.Committer = &Signature{}
				}
				m.Committer.Name = vals[0]
			case "committer.When":
				if m.Committer == nil {
					m.Committer = &Signature{}
				}
				if m.Committer.When == nil {
					m.Committer.When = &timestamppb.Timestamp{}
				}
			case "committer.When.seconds":
				if m.Committer == nil {
					m.Committer = &Signature{}
				}
				if m.Committer.When == nil {
					m.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Committer.When.Seconds = val
			case "committer.When.nanos":
				if m.Committer == nil {
					m.Committer = &Signature{}
				}
				if m.Committer.When == nil {
					m.Committer.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Committer.When.Nanos = int32(val)
			case "commitMessage":
				m.CommitMessage = vals[0]
			case "parentSha":
				m.ParentSha = vals[0]
			}
		}
	}
	return nil
}

// Signature implement urlenc.URLValuesUnmarshaler.
func (m *Signature) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "email":
				m.Email = vals[0]
			case "name":
				m.Name = vals[0]
			case "When":
				if m.When == nil {
					m.When = &timestamppb.Timestamp{}
				}
			case "When.seconds":
				if m.When == nil {
					m.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.When.Seconds = val
			case "When.nanos":
				if m.When == nil {
					m.When = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.When.Nanos = int32(val)
			}
		}
	}
	return nil
}

// FlowCallbackRequest implement urlenc.URLValuesUnmarshaler.
func (m *FlowCallbackRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "content":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
			case "content.issueID":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Content.IssueID = val
			case "content.operator":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
				m.Content.Operator = vals[0]
			case "content.tempBranch":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
				m.Content.TempBranch = vals[0]
			case "content.sourceBranch":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
				m.Content.SourceBranch = vals[0]
			case "content.targetBranch":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
				m.Content.TargetBranch = vals[0]
			case "content.appName":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
				m.Content.AppName = vals[0]
			case "content.projectName":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
				m.Content.ProjectName = vals[0]
			case "content.isJoinTempBranch":
				if m.Content == nil {
					m.Content = &FlowEventData{}
				}
				m.Content.IsJoinTempBranch = vals[0]
			case "projectID":
				m.ProjectID = vals[0]
			case "orgID":
				m.OrgID = vals[0]
			case "applicationID":
				m.ApplicationID = vals[0]
			}
		}
	}
	return nil
}

// FlowEventData implement urlenc.URLValuesUnmarshaler.
func (m *FlowEventData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "operator":
				m.Operator = vals[0]
			case "tempBranch":
				m.TempBranch = vals[0]
			case "sourceBranch":
				m.SourceBranch = vals[0]
			case "targetBranch":
				m.TargetBranch = vals[0]
			case "appName":
				m.AppName = vals[0]
			case "projectName":
				m.ProjectName = vals[0]
			case "isJoinTempBranch":
				m.IsJoinTempBranch = vals[0]
			}
		}
	}
	return nil
}

// FlowCallbackResponse implement urlenc.URLValuesUnmarshaler.
func (m *FlowCallbackResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}
