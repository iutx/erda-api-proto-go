// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: dop.proto

package pb

import (
	context "context"
	http1 "net/http"
	strconv "strconv"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// DopHandler is the server API for Dop service.
type DopHandler interface {
	// GET /api/cicd-crons
	AADAPTOR_CICD_CRON_LIST(context.Context, *AADAPTOR_CICD_CRON_LIST_Request) (*PipelineCronListResponse, error)
	// GET /api/cicds/actions/app-all-valid-branch-workspaces
	ADAPTOR_CICD_BRANCHES_ALL_VALID(context.Context, *ADAPTOR_CICD_BRANCHES_ALL_VALID_Request) (*PipelineAppAllValidBranchWorkspaceResponse, error)
	// POST /api/cicds/{pipelineID}/actions/cancel
	ADAPTOR_CICD_CANCEL(context.Context, *ADAPTOR_CICD_CANCEL_Request) (*PipelineCancelResponse, error)
	// POST /api/cicds/multinamespace/configs
	ADAPTOR_CICD_CONFIG_GET(context.Context, *ADAPTOR_CICD_CONFIG_GET_Request) (*emptypb.Empty, error)
	// GET /api/cicds/actions/fetch-config-namespaces
	ADAPTOR_CICD_CONFIG_NAMESPACES(context.Context, *ADAPTOR_CICD_CONFIG_NAMESPACES_Request) (*PipelineConfigNamespacesFetchResponse, error)
	// GET /api/cicds/actions/list-workspaces
	ADAPTOR_CICD_CONFIG_WORKSPACES(context.Context, *ADAPTOR_CICD_CONFIG_WORKSPACES_Request) (*PipelineConfigNamespacesFetchResponse, error)
	// POST /api/cicds
	ADAPTOR_CICD_CREATE(context.Context, *PipelineCreateRequest) (*PipelineCreateResponse, error)
	// PUT /api/cicd-crons/{cronID}/actions/start
	ADAPTOR_CICD_CRON_START(context.Context, *ADAPTOR_CICD_CRON_START_Request) (*PipelineCronStartResponse, error)
	// PUT /api/cicd-crons/{cronID}/actions/stop
	ADAPTOR_CICD_CRON_STOP(context.Context, *ADAPTOR_CICD_CRON_STOP_Request) (*PipelineCronStopResponse, error)
	// GET /api/cicds/actions/fetch-pipeline-id
	ADAPTOR_CICD_FETCH_PIPELINE_ID(context.Context, *ADAPTOR_CICD_FETCH_PIPELINE_ID_Request) (*emptypb.Empty, error)
	// POST /api/cicd-pipeline/filetree
	ADAPTOR_CICD_FILETREE_CREATE(context.Context, *UnifiedFileTreeNodeCreateRequest) (*emptypb.Empty, error)
	// DELETE /api/cicd-pipeline/filetree/{inode}
	ADAPTOR_CICD_FILETREE_DELETE(context.Context, *UnifiedFileTreeNodeDeleteRequest) (*emptypb.Empty, error)
	// GET /api/cicd-pipeline/filetree/{inode}/actions/find-ancestors
	ADAPTOR_CICD_FILETREE_FIND_ANCESTORS(context.Context, *UnifiedFileTreeNodeFindAncestorsRequest) (*emptypb.Empty, error)
	// GET /api/cicd-pipeline/filetree/actions/fuzzy-search
	ADAPTOR_CICD_FILETREE_FUZZY_SEARCH(context.Context, *UnifiedFileTreeNodeFuzzySearchRequest) (*emptypb.Empty, error)
	// GET /api/cicd-pipeline/filetree/{inode}
	ADAPTOR_CICD_FILETREE_GET(context.Context, *UnifiedFileTreeNodeGetRequest) (*emptypb.Empty, error)
	// GET /api/cicd-pipeline/filetree/actions/get-inode-by-pipeline
	ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE(context.Context, *ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_Request) (*emptypb.Empty, error)
	// GET /api/cicd-pipeline/filetree
	ADAPTOR_CICD_FILETREE_LIST(context.Context, *UnifiedFileTreeNodeListRequest) (*emptypb.Empty, error)
	// GET /api/cicds/{pipelineid}/actions/get-branch-rule
	ADAPTOR_CICD_GET_BRANCH_RULE(context.Context, *ADAPTOR_CICD_GET_BRANCH_RULE_Request) (*PipelineGetBranchRuleResponse, error)
	// GET /api/cicds/actions/app-invoked-combos
	ADAPTOR_CICD_INVOKED_COMBO(context.Context, *PipelineInvokedComboRequest) (*PipelineInvokedComboResponse, error)
	// GET /api/cicds
	ADAPTOR_CICD_LIST(context.Context, *PipelinePageListRequest) (*PipelinePageListResponse, error)
	// PUT /api/cicds/{pipelineID}
	ADAPTOR_CICD_OPERATE(context.Context, *PipelineOperateRequest) (*PipelineOperateResponse, error)
	// GET /api/cicds/actions/pipeline-detail
	ADAPTOR_CICD_PIPELINE_DETAIL(context.Context, *ADAPTOR_CICD_PIPELINE_DETAIL_Request) (*emptypb.Empty, error)
	// GET /api/cicds/actions/pipelineYmls
	ADAPTOR_CICD_PIPELINE_YML_LIST(context.Context, *CICDPipelineYmlListRequest) (*CICDPipelineYmlListResponse, error)
	// POST /api/cicds-project
	ADAPTOR_CICD_PROJECT_CREATE(context.Context, *ADAPTOR_CICD_PROJECT_CREATE_Request) (*emptypb.Empty, error)
	// GET /api/cicds-project/actions/pipeline-detail
	ADAPTOR_CICD_PROJECT_DETAIL(context.Context, *ADAPTOR_CICD_PROJECT_DETAIL_Request) (*emptypb.Empty, error)
	// POST /api/cicds/{pipelineID}/actions/rerun
	ADAPTOR_CICD_RERUN(context.Context, *ADAPTOR_CICD_RERUN_Request) (*PipelineRerunResponse, error)
	// POST /api/cicds/{pipelineID}/actions/rerun-failed
	ADAPTOR_CICD_RERUN_FAILED(context.Context, *PipelineRerunFailedResponse) (*emptypb.Empty, error)
	// POST /api/cicds/{pipelineID}/actions/run
	ADAPTOR_CICD_RUN(context.Context, *ADAPTOR_CICD_RUN_Request) (*PipelineRunResponse, error)
	// GET /api/cicd/{pipelineID}/tasks/{taskID}/logs
	ADAPTOR_CICD_TASK_LOG(context.Context, *ADAPTOR_CICD_TASK_LOG_Request) (*emptypb.Empty, error)
	// GET /api/cicd/{pipelineID}/tasks/{taskID}/logs/actions/download
	ADAPTOR_CICD_TASK_LOG_DOWNLOAD(context.Context, *ADAPTOR_CICD_TASK_LOG_DOWNLOAD_Request) (*emptypb.Empty, error)
	// GET /api/apim-ws/api-docs/filetree/{inode}
	APIDocWebsocket(context.Context, *APIDocWebsocket_Request) (*emptypb.Empty, error)
	// POST /api/apitests/actions/attempt-test
	APITEST_ATTEMPT(context.Context, *APITestsAttemptRequest) (*APITestsAttemptResponse, error)
	// GET /api/projects/{projectID}/applications-resources
	APPLICATIONS_RESOURCES_LIST(context.Context, *APPLICATIONS_RESOURCES_LIST_Request) (*emptypb.Empty, error)
	// GET /api/applications/{application}/actions/get-publish-item-relations
	APP_PUBLISH_ITEM_RELATION_GET(context.Context, *APP_PUBLISH_ITEM_RELATION_GET_Request) (*QueryAppPublishItemRelationResponse, error)
	// POST /api/applications/{application}/actions/update-publish-item-relations
	APP_PUBLISH_ITEM_RELATION_UPDATE(context.Context, *UpdateAppPublishItemRelationRequest) (*UpdateAppPublishItemRelationResponse, error)
	// POST /api/qa/actions/sonar-results-store
	CI_SONAR_STORE(context.Context, *SonarStoreRequest) (*SonarStoreResponse, error)
	// POST /api/applications
	CMDB_APPLICATION_CREATE(context.Context, *ApplicationCreateRequest) (*ApplicationCreateResponse, error)
	// DELETE /api/applications/{applicationId}
	CMDB_APPLICATION_DELETE(context.Context, *ApplicationDeleteRequest) (*ApplicationDeleteResponse, error)
	// PUT /api/applications/{applicationID}/actions/init
	CMDB_APPLICATION_INIT(context.Context, *ApplicationInitRequest) (*emptypb.Empty, error)
	// PUT /api/applications/{applicationID}
	CMDB_APPLICATION_UPDATE(context.Context, *ApplicationUpdateRequest) (*ApplicationUpdateResponse, error)
	// POST /api/branch-rules
	CMDB_BRANCH_RULE_CREATE(context.Context, *CreateBranchRuleRequest) (*CreateBranchRuleResponse, error)
	// DELETE /api/branch-rules/{id}
	CMDB_BRANCH_RULE_DELETE(context.Context, *CMDB_BRANCH_RULE_DELETE_Request) (*DeleteBranchRuleResponse, error)
	// GET /api/branch-rules
	CMDB_BRANCH_RULE_QUERY(context.Context, *QueryBranchRuleRequest) (*QueryBranchRuleResponse, error)
	// PUT /api/branch-rules/{ID}
	CMDB_BRANCH_RULE_UPDATE(context.Context, *UpdateBranchRuleRequest) (*UpdateBranchRuleResponse, error)
	// GET /api/certificates/actions/list-application-quotes
	CMDB_CERTIFICATES_APP_LIST(context.Context, *AppCertificateListRequest) (*PagingAppCertificateDTO, error)
	// GET /api/certificates/actions/list-certificates
	CMDB_CERTIFICATES_LIST(context.Context, *CertificateListRequest) (*CertificateListResponse, error)
	// DELETE /api/certificates/actions/application-cancel-quote
	CMDB_CERTIFICATE_APP_CANCEL(context.Context, *CMDB_CERTIFICATE_APP_CANCEL_Request) (*emptypb.Empty, error)
	// POST /api/certificates/actions/push-configs
	CMDB_CERTIFICATE_APP_CONFIG(context.Context, *PushCertificateConfigsRequest) (*emptypb.Empty, error)
	// POST /api/certificates/actions/application-quote
	CMDB_CERTIFICATE_APP_QUOTE(context.Context, *CertificateQuoteRequest) (*emptypb.Empty, error)
	// POST /api/certificates
	CMDB_CERTIFICATE_CREATE(context.Context, *CertificateCreateRequest) (*CertificateCreateResponse, error)
	// DELETE /api/certificates/{certificatesID}
	CMDB_CERTIFICATE_DELETE(context.Context, *CMDB_CERTIFICATE_DELETE_Request) (*CertificateDeleteResponse, error)
	// GET /api/certificates/{certificateID}
	CMDB_CERTIFICATE_GET(context.Context, *CMDB_CERTIFICATE_GET_Request) (*CertificateDetailResponse, error)
	// PUT /api/certificates/{certificateID}
	CMDB_CERTIFICATE_UPDATE(context.Context, *CertificateUpdateRequest) (*CertificateUpdateResponse, error)
	// POST /api/comments
	CMDB_COMMENT_CREATE(context.Context, *CommentCreateRequest) (*CommentCreateResponse, error)
	// GET /api/comments
	CMDB_COMMENT_LIST(context.Context, *CommentListRequest) (*CommentListResponse, error)
	// PUT /api/comments/{commentID}
	CMDB_COMMENT_UPDATE(context.Context, *CommentUpdateRequest) (*CommentUpdateResponse, error)
	// POST /api/iterations
	CMDB_ITERATION_CREATE(context.Context, *IterationCreateRequest) (*IterationCreateResponse, error)
	// DELETE /api/iterations/{id}
	CMDB_ITERATION_DELETE(context.Context, *CMDB_ITERATION_DELETE_Request) (*emptypb.Empty, error)
	// GET /api/iterations/{id}
	CMDB_ITERATION_GET(context.Context, *CMDB_ITERATION_GET_Request) (*IterationGetResponse, error)
	// GET /api/iterations
	CMDB_ITERATION_PAGING(context.Context, *IterationPagingRequest) (*IterationPagingResponse, error)
	// PUT /api/iterations/{id}
	CMDB_ITERATION_UPDATE(context.Context, *IterationUpdateRequest) (*IterationUpdateResponse, error)
	// POST /api/lib-references
	CMDB_LIBREFERENCE_CREATE(context.Context, *LibReferenceCreateRequest) (*LibReferenceCreateResponse, error)
	// DELETE /api/lib-references/{id}
	CMDB_LIBREFERENCE_DELETE(context.Context, *CMDB_LIBREFERENCE_DELETE_Request) (*emptypb.Empty, error)
	// GET /api/lib-references
	CMDB_LIBREFERENCE_LIST(context.Context, *LibReferenceListRequest) (*LibReferenceListResponse, error)
	// GET /api/lib-references/actions/fetch-versions
	CMDB_LIBREFERENCE_LIST_VERSION(context.Context, *CMDB_LIBREFERENCE_LIST_VERSION_Request) (*emptypb.Empty, error)
	// GET /api/publishers/actions/list-my-publishers
	CMDB_MY_PUBLISHERS_LIST(context.Context, *PublisherListRequest) (*PublisherListResponse, error)
	// POST /api/orgs
	CMDB_ORG_CREATE(context.Context, *OrgCreateRequest) (*OrgCreateResponse, error)
	// DELETE /api/orgs/{orgID}
	CMDB_ORG_DELETE(context.Context, *CMDB_ORG_DELETE_Request) (*emptypb.Empty, error)
	// GET /api/orgs/{orgID}
	CMDB_ORG_FETCH(context.Context, *OrgFetchRequest) (*OrgSearchResponse, error)
	// GET /api/orgs/actions/get-by-domain
	CMDB_ORG_GET_BY_DOMAIN(context.Context, *OrgGetByDomainRequest) (*OrgGetByDomainResponse, error)
	// GET /api/orgs/{orgID}/nexus
	CMDB_ORG_NEXUS_FETCH(context.Context, *OrgNexusGetRequest) (*OrgNexusGetResponse, error)
	// GET /api/orgs/{orgID}/show-nexus-password
	CMDB_ORG_NEXUS_SHOW_PASSWORD(context.Context, *OrgNexusShowPasswordRequest) (*OrgNexusShowPasswordResponse, error)
	// GET /api/orgs/actions/list-public
	CMDB_ORG_PUBLIC(context.Context, *OrgSearchRequest) (*OrgSearchResponse, error)
	// POST /api/orgs/{orgID}/actions/create-publisher
	CMDB_ORG_PUBLISHER_CREATE(context.Context, *CMDB_ORG_PUBLISHER_CREATE_Request) (*emptypb.Empty, error)
	// GET /api/orgs/{orgID}/actions/create-publisher
	CMDB_ORG_PUBLISHER_CREATE_GET(context.Context, *CMDB_ORG_PUBLISHER_CREATE_GET_Request) (*emptypb.Empty, error)
	// GET /api/orgs/actions/fetch-resources
	CMDB_ORG_RESOURCE_GET(context.Context, *CMDB_ORG_RESOURCE_GET_Request) (*OrgResourceInfo, error)
	// GET /api/orgs
	CMDB_ORG_SEARCH(context.Context, *OrgSearchRequest) (*OrgSearchResponse, error)
	// PUT /api/orgs/{orgID}
	CMDB_ORG_UPDATE(context.Context, *OrgUpdateRequest) (*OrgUpdateRequestBody, error)
	// GET /api/projects
	CMDB_PROJECTS_FETCH(context.Context, *ProjectListRequest) (*ProjectListResponse, error)
	// POST /api/projects
	CMDB_PROJECT_CREATE(context.Context, *ProjectCreateRequest) (*ProjectCreateResponse, error)
	// DELETE /api/projects/{projectID}
	CMDB_PROJECT_DELETE(context.Context, *ProjectDeleteRequest) (*ProjectDeleteResponse, error)
	// GET /api/projects/{projectIDOrName}
	CMDB_PROJECT_DETAIL(context.Context, *ProjectDetailRequest) (*ProjectDetailResponse, error)
	// GET /api/publishers
	CMDB_PUBLISHERS_LIST(context.Context, *PublisherListRequest) (*PublisherListResponse, error)
	// POST /api/publishers
	CMDB_PUBLISHER_CREATE(context.Context, *PublisherCreateRequest) (*PublisherCreateResponse, error)
	// DELETE /api/publishers/{publisherID}
	CMDB_PUBLISHER_DELETE(context.Context, *CMDB_PUBLISHER_DELETE_Request) (*PublisherDeleteResponse, error)
	// GET /api/publishers/{publisherID}
	CMDB_PUBLISHER_GET(context.Context, *CMDB_PUBLISHER_GET_Request) (*PublisherDetailResponse, error)
	// PUT /api/publishers
	CMDB_PUBLISHER_UPDATE(context.Context, *PublisherUpdateRequest) (*PublisherUpdateResponse, error)
	// GET /api/members/actions/list-roles
	CMDB_ROLES_LIST(context.Context, *CMDB_ROLES_LIST_Request) (*MemberRoleListResponse, error)
	// PUT /api/tickets/{ticketID}/actions/close
	CMDB_TICKET_CLOSE(context.Context, *TicketCloseRequest) (*TicketCloseResponse, error)
	// POST /api/tickets
	CMDB_TICKET_CREATE(context.Context, *TicketCreateRequest) (*TicketCreateResponse, error)
	// DELETE /api/tickets/{ticketID}
	CMDB_TICKET_DELETE(context.Context, *TicketDeleteRequest) (*TicketDeleteResponse, error)
	// GET /api/tickets/{ticketID}
	CMDB_TICKET_FETCH(context.Context, *TicketFetchRequest) (*TicketFetchResponse, error)
	// GET /api/tickets
	CMDB_TICKET_LIST(context.Context, *TicketListRequest) (*TicketListResponse, error)
	// PUT /api/tickets/{ticketID}/actions/reopen
	CMDB_TICKET_REOPEN(context.Context, *TicketReopenRequest) (*TicketReopenResponse, error)
	// PUT /api/tickets/{ticketID}
	CMDB_TICKET_UPDATE(context.Context, *TicketUpdateRequest) (*TicketUpdateResponse, error)
	// POST /api/code-coverage/actions/end-callBack
	CODE_COVERAGE_END_CALLBACK(context.Context, *CodeCoverageUpdateRequest) (*emptypb.Empty, error)
	// POST /api/code-coverage/actions/ready-callBack
	CODE_COVERAGE_READY_CALLBACK(context.Context, *CodeCoverageUpdateRequest) (*emptypb.Empty, error)
	// GET /api/code-coverage/actions/status
	CODE_COVERAGE_READY_STATUS(context.Context, *CodeCoverageUpdateRequest) (*emptypb.Empty, error)
	// POST /api/code-coverage/actions/report-callBack
	CODE_COVERAGE_REPORT_CALLBACK(context.Context, *CodeCoverageUpdateRequest) (*emptypb.Empty, error)
	// POST /api/api-assets
	CreateAPIAsset(context.Context, *APIAssetCreateRequest) (*emptypb.Empty, error)
	// POST /api/api-assets/{assetID}/versions
	CreateAPIAssetVersion(context.Context, *APIAssetVersionCreateRequest) (*CreateAPIAssetVersionBody, error)
	// POST /api/api-access
	CreateAccess(context.Context, *CreateAccessReq) (*emptypb.Empty, error)
	// POST /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/attempt-test
	CreateAttempTest(context.Context, *APITestReq) (*Header, error)
	// POST /api/api-clients
	CreateClient(context.Context, *CreateClientReq) (*emptypb.Empty, error)
	// POST /api/api-clients/{clientID}/contracts
	CreateContract(context.Context, *CreateContractReq) (*emptypb.Empty, error)
	// POST /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/minors/{minor}/instantiations
	CreateInstantiation(context.Context, *CreateInstantiationReq) (*emptypb.Empty, error)
	// POST /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas
	CreateSLA(context.Context, *CreateSLAReq) (*Header, error)
	// DELETE /api/api-assets/{assetID}/versions/{versionID}
	DeleteAPIAssetVersion(context.Context, *DeleteAPIAssetVersion_Request) (*emptypb.Empty, error)
	// DELETE /api/api-assets/{assetID}
	DeleteAPIAssets(context.Context, *DeleteAPIAssets_Request) (*emptypb.Empty, error)
	// DELETE /api/api-access/{accessID}
	DeleteAccess(context.Context, *DeleteAccess_Request) (*emptypb.Empty, error)
	// DELETE /api/api-clients/{clientID}
	DeleteClient(context.Context, *DeleteClient_Request) (*emptypb.Empty, error)
	// DELETE /api/api-clients/{clientID}/contracts/{contractID}
	DeleteContract(context.Context, *GetContractReq) (*emptypb.Empty, error)
	// DELETE /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas/{slaID}
	DeleteSLA(context.Context, *DeleteSLAReq) (*Header, error)
	// GET /api/api-assets/{assetID}/versions/{versionID}/export
	ExportSpec(context.Context, *DownloadSpecTextReq) (*emptypb.Empty, error)
	// POST /api/apim/{treeName}/filetree
	FileTreeCreateNode(context.Context, *APIDocCreateNodeReq) (*emptypb.Empty, error)
	// DELETE /api/apim/{treeName}/filetree/{inode}
	FileTreeDeleteNode(context.Context, *FileTreeDeleteNode_Request) (*emptypb.Empty, error)
	// GET /api/apim/{treeName}/filetree/{inode}
	FileTreeGetNode(context.Context, *FileTreeGetNode_Request) (*emptypb.Empty, error)
	// GET /api/apim/{treeName}/filetree
	FileTreeListNodes(context.Context, *FileTreeListNodes_Request) (*emptypb.Empty, error)
	// POST /api/apim/{treeName}/filetree/{inode}/actions/{action}
	FileTreeMvCpNode(context.Context, *FileTreeMvCpNode_Request) (*emptypb.Empty, error)
	// PUT /api/apim/{treeName}/filetree/{inode}
	FileTreeUpdateNode(context.Context, *FileTreeUpdateNode_Request) (*emptypb.Empty, error)
	// GET /api/api-assets/{assetID}/versions/{versionID}
	GetAPIAssetVersion(context.Context, *GetAPIAssetVersionReq) (*GetAssetVersionRsp, error)
	// GET /api/api-assets/{assetID}
	GetAPIAssets(context.Context, *GetAPIAssetReq) (*APIAssetGetResponse, error)
	// GET /api/api-access/{accessID}
	GetAccess(context.Context, *GetAccess_Request) (*emptypb.Empty, error)
	// GET /api/api-clients/{clientID}
	GetClient(context.Context, *GetClientReq) (*emptypb.Empty, error)
	// GET /api/api-clients/{clientID}/contracts/{contractID}
	GetContract(context.Context, *GetContractReq) (*emptypb.Empty, error)
	// GET /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/minors/{minor}/instantiations
	GetInstantiations(context.Context, *GetInstantiationsReq) (*GetAddonInstanceDetailResponse, error)
	// GET /api/apim/operations/{id}
	GetOperation(context.Context, *GetOperationReq) (*BaseResponse, error)
	// GET /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas/{slaID}
	GetSLA(context.Context, *ListSLAsReq) (*ListSLAsRsp, error)
	// GET /api/api-assets/{assetID}/versions
	ListAPIAssetVersions(context.Context, *GetAPIAssetVersionReq) (*GetAssetVersionRsp, error)
	// GET /api/api-assets/{assetID}/api-gateways
	ListAPIGateways(context.Context, *ListAPIGatewaysReq) (*ListAPIGatewaysResp, error)
	// GET /api/api-access
	ListAccess(context.Context, *ListAccessReq) (*ListAccessRsp, error)
	// GET /api/api-clients/{clientID}/contracts
	ListContract(context.Context, *ListContractsReq) (*ListContractsRsp, error)
	// GET /api/api-clients/{clientID}/contracts/{contractID}/operation-records
	ListContractRecords(context.Context, *ListContractRecordsReq) (*ListContractRecordsRsp, error)
	// GET /api/api-instantiations
	ListInstantiations(context.Context, *ListInstantiations_Request) (*emptypb.Empty, error)
	// GET /api/api-clients
	ListMyClients(context.Context, *ListMyClientsReq) (*emptypb.Empty, error)
	// GET /api/api-gateways/{projectID}
	ListProjectAPIGateways(context.Context, *ListProjectAPIGatewaysReq) (*ListAPIGatewaysResp, error)
	// GET /api/api-app-services/{appID}
	ListRuntimeServices(context.Context, *ListRuntimeServices_Request) (*Header, error)
	// GET /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas
	ListSLA(context.Context, *GetSLAReq) (*GetSLARsp, error)
	// GET /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/clients
	ListSwaggerVersionClients(context.Context, *ListSwaggerVersionClientsReq) (*ListSwaggerVersionRsp, error)
	// GET /api/api-assets/{assetID}/swagger-versions
	ListSwaggerVersions(context.Context, *ListSwaggerVersionsReq) (*ListSwaggerVersionRsp, error)
	// GET /api/publish-items/{publishItemId}/certification
	PUBLISH_ITEM_CERTIFICATION_GET(context.Context, *PUBLISH_ITEM_CERTIFICATION_GET_Request) (*emptypb.Empty, error)
	// GET /api/publish-items/{publishItemId}/statistics/channels
	PUBLISH_ITEM_CHANNELS(context.Context, *PublishItemStatisticsDetailRequest) (*PublishItemStatisticsDetailData, error)
	// GET /api/publish-items/{publishItemId}/err/effacts
	PUBLISH_ITEM_ERR_EFFACTS(context.Context, *PUBLISH_ITEM_ERR_EFFACTS_Request) (*emptypb.Empty, error)
	// GET /api/publish-items/{publishItemId}/err/list
	PUBLISH_ITEM_ERR_LIST(context.Context, *PUBLISH_ITEM_ERR_LIST_Request) (*PublishItemStatisticsErrListData, error)
	// GET /api/publish-items/{publishItemId}/err/rate
	PUBLISH_ITEM_ERR_RATE(context.Context, *PUBLISH_ITEM_ERR_RATE_Request) (*emptypb.Empty, error)
	// GET /api/publish-items/{publishItemId}/err/trend
	PUBLISH_ITEM_ERR_TREND(context.Context, *PUBLISH_ITEM_ERR_TREND_Request) (*PublishItemStatisticsErrTrendData, error)
	// GET /api/publish-items/{publishItemId}/metrics/{metricName}
	PUBLISH_ITEM_METIRCS_COMMON(context.Context, *PUBLISH_ITEM_METIRCS_COMMON_Request) (*emptypb.Empty, error)
	// GET /api/publish-items/{publishItemId}/metrics/{metricName}/histogram
	PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON(context.Context, *PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_Request) (*emptypb.Empty, error)
	// GET /api/publish-items/{publishItemId}/statistics/trend
	PUBLISH_ITEM_STATISTICS_TREND(context.Context, *PUBLISH_ITEM_STATISTICS_TREND_Request) (*PublishItemStatisticsTrendData, error)
	// GET /api/publish-items/{publishItemId}/statistics/users
	PUBLISH_ITEM_USERS(context.Context, *PUBLISH_ITEM_USERS_Request) (*emptypb.Empty, error)
	// GET /api/publish-items/{publishItemId}/statistics/versions
	PUBLISH_ITEM_VERSION_INFO_LIST(context.Context, *PublishItemStatisticsDetailRequest) (*PublishItemStatisticsDetailData, error)
	// GET /api/api-assets
	PagingAPIAssets(context.Context, *PagingAPIAssetsReq) (*APIAssetPagingResponse, error)
	// POST /api/orgs/{orgID}/projects/{projectID}/package/actions/export
	ProjectPackageExport(context.Context, *ExportProjectPackageRequest) (*emptypb.Empty, error)
	// POST /api/orgs/{orgID}/projects/{projectID}/package/actions/import
	ProjectPackageImport(context.Context, *ImportProjectPackageRequest) (*emptypb.Empty, error)
	// POST /api/projects/package/actions/parse
	ProjectPackageParse(context.Context, *ProjectPackageParse_Request) (*emptypb.Empty, error)
	// GET /api/orgs/{orgID}/projects/{projectID}/template/actions/export
	ProjectTemplateExport(context.Context, *ExportProjectTemplateRequest) (*emptypb.Empty, error)
	// POST /api/orgs/{orgID}/projects/{projectID}/template/actions/import
	ProjectTemplateImport(context.Context, *ImportProjectTemplateRequest) (*emptypb.Empty, error)
	// POST /api/projects/template/actions/parse
	ProjectTemplateParse(context.Context, *ImportProjectTemplateRequest) (*emptypb.Empty, error)
	// GET /api/apim/metrics/**
	ProxyMetrics(context.Context, *ProxyMetrics_Request) (*emptypb.Empty, error)
	// POST /api/apitests/actions/cancel-testplan
	QA_APITESTS_CANCEL(context.Context, *ApiTestCancelRequest) (*ApiTestCancelResponse, error)
	// GET /api/apitests/{id}
	QA_APITESTS_GET(context.Context, *QA_APITESTS_GET_Request) (*ApiTestsGetResponse, error)
	// PUT /api/apitests/{id}
	QA_APITESTS_UPDATE(context.Context, *ApiTestsUpdateRequest) (*ApiTestsUpdateResponse, error)
	// GET /api/autotests/spaces/{id}
	QA_AUTOTEST_SPACE_GET(context.Context, *QA_AUTOTEST_SPACE_GET_Request) (*AutoTestSpaceResponse, error)
	// GET /api/apitests/pipeline/{pipelineID}/task/{taskID}/logs
	QA_PIPELINE_TASK_LOGS(context.Context, *QA_PIPELINE_TASK_LOGS_Request) (*DashboardSpotLogResponse, error)
	// GET /api/test-file-records/{id}
	QA_RECORDS_GET(context.Context, *QA_RECORDS_GET_Request) (*GetTestFileRecordResponse, error)
	// GET /api/test-file-records
	QA_RECORDS_LIST(context.Context, *ListTestFileRecordsRequest) (*ListTestFileRecordsResponse, error)
	// GET /api/qa/actions/get-sonar-credential
	QA_SONAR_GET_CREDENTIAL(context.Context, *QA_SONAR_GET_CREDENTIAL_Request) (*SonarCredentialGetResponse, error)
	// GET /api/qa
	QA_SONAR_ISSUES(context.Context, *QA_SONAR_ISSUES_Request) (*SonarIssueResponse, error)
	// DELETE /api/sonar-metric-rules/actions/batch-delete
	QA_SONAR_METRIC_RULES_BATCH_DELETE(context.Context, *SonarMetricRulesBatchDeleteRequest) (*emptypb.Empty, error)
	// POST /api/sonar-metric-rules/actions/batch-insert
	QA_SONAR_METRIC_RULES_BATCH_INSERT(context.Context, *SonarMetricRulesBatchInsertRequest) (*emptypb.Empty, error)
	// DELETE /api/sonar-metric-rules/{ID}
	QA_SONAR_METRIC_RULES_DELETE(context.Context, *SonarMetricRulesDeleteRequest) (*emptypb.Empty, error)
	// GET /api/sonar-metric-rules/{id}
	QA_SONAR_METRIC_RULES_GET(context.Context, *QA_SONAR_METRIC_RULES_GET_Request) (*emptypb.Empty, error)
	// GET /api/sonar-metric-rules
	QA_SONAR_METRIC_RULES_PAGING(context.Context, *SonarMetricRulesPagingRequest) (*emptypb.Empty, error)
	// GET /api/sonar-metric-rules/actions/query-metric-definition
	QA_SONAR_METRIC_RULES_QUERY_DEFINITION(context.Context, *SonarMetricRulesDefinitionListRequest) (*emptypb.Empty, error)
	// GET /api/sonar-metric-rules/actions/query-list
	QA_SONAR_METRIC_RULES_QUERY_LIST(context.Context, *SonarMetricRulesListRequest) (*emptypb.Empty, error)
	// PUT /api/sonar-metric-rules/{ID}
	QA_SONAR_METRIC_RULES_UPDATE(context.Context, *SonarMetricRulesUpdateRequest) (*emptypb.Empty, error)
	// POST /api/testenv
	QA_TESTENV_CREATE(context.Context, *QA_TESTENV_CREATE_Request) (*APITestEnvCreateRequest, error)
	// DELETE /api/testenv/{id}
	QA_TESTENV_DELETE(context.Context, *QA_TESTENV_DELETE_Request) (*APITestEnvDeleteResponse, error)
	// GET /api/testenv/{id}
	QA_TESTENV_GET(context.Context, *QA_TESTENV_GET_Request) (*APITestEnvGetResponse, error)
	// GET /api/testenv/actions/list-envs
	QA_TESTENV_LIST(context.Context, *QA_TESTENV_LIST_Request) (*APITestEnvListResponse, error)
	// PUT /api/testenv/{id}
	QA_TESTENV_UPDATE(context.Context, *APITestEnvUpdateRequest) (*APITestEnvUpdateResponse, error)
	// GET /api/apitests/pipeline/{pipelineId}
	QA_TESTPLAN_PIPELINE_DETAIL(context.Context, *QA_TESTPLAN_PIPELINE_DETAIL_Request) (*PipelineDetailResponse, error)
	// GET /api/apitests/logs
	SPOT_APITESTS_LOGS(context.Context, *SPOT_APITESTS_LOGS_Request) (*emptypb.Empty, error)
	// GET /api/apitests/logs/actions/download
	SPOT_APITESTS_LOGS_DOWNLOAD(context.Context, *SPOT_APITESTS_LOGS_DOWNLOAD_Request) (*emptypb.Empty, error)
	// GET /api/apim/operations
	SearchOperations(context.Context, *SearchOperationsReq) (*BaseResponse, error)
	// PUT /api/api-assets/{assetID}
	UpdateAPIAssset(context.Context, *UpdateAPIAssetReq) (*emptypb.Empty, error)
	// PUT /api/api-access/{accessID}
	UpdateAccess(context.Context, *UpdateAccess_Request) (*emptypb.Empty, error)
	// PUT /api/api-assets/{assetID}/versions/{versionID}
	UpdateAssetVersion(context.Context, *UpdateAssetVersionReq) (*Header, error)
	// PUT /api/api-clients/{clientID}
	UpdateClient(context.Context, *UpdateClientReq) (*emptypb.Empty, error)
	// PUT /api/api-clients/{clientID}/contracts/{contractID}
	UpdateContract(context.Context, *UpdateContract_Request) (*emptypb.Empty, error)
	// PUT /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/minors/{minor}/instantiations/{instantiationID}
	UpdateInstantiation(context.Context, *UpdateInstantiationReq) (*emptypb.Empty, error)
	// PUT /api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas/{slaID}
	UpdateSLA(context.Context, *UpdateSLAReq) (*Header, error)
	// POST /api/apim/validate-swagger
	ValidateSwagger(context.Context, *ValidateSwagger_Request) (*emptypb.Empty, error)
}

// RegisterDopHandler register DopHandler to http.Router.
func RegisterDopHandler(r http.Router, srv DopHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_AADAPTOR_CICD_CRON_LIST := func(method, path string, fn func(context.Context, *AADAPTOR_CICD_CRON_LIST_Request) (*PipelineCronListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AADAPTOR_CICD_CRON_LIST_Request))
		}
		var AADAPTOR_CICD_CRON_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			AADAPTOR_CICD_CRON_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "AADAPTOR_CICD_CRON_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, AADAPTOR_CICD_CRON_LIST_info)
				}
				r = r.WithContext(ctx)
				var in AADAPTOR_CICD_CRON_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_BRANCHES_ALL_VALID := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_BRANCHES_ALL_VALID_Request) (*PipelineAppAllValidBranchWorkspaceResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_BRANCHES_ALL_VALID_Request))
		}
		var ADAPTOR_CICD_BRANCHES_ALL_VALID_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_BRANCHES_ALL_VALID_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_BRANCHES_ALL_VALID", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_BRANCHES_ALL_VALID_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_BRANCHES_ALL_VALID_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_CANCEL := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_CANCEL_Request) (*PipelineCancelResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_CANCEL_Request))
		}
		var ADAPTOR_CICD_CANCEL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_CANCEL_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_CANCEL", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_CANCEL_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_CANCEL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_CONFIG_GET := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_CONFIG_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_CONFIG_GET_Request))
		}
		var ADAPTOR_CICD_CONFIG_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_CONFIG_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_CONFIG_GET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_CONFIG_GET_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_CONFIG_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_CONFIG_NAMESPACES := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_CONFIG_NAMESPACES_Request) (*PipelineConfigNamespacesFetchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_CONFIG_NAMESPACES_Request))
		}
		var ADAPTOR_CICD_CONFIG_NAMESPACES_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_CONFIG_NAMESPACES_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_CONFIG_NAMESPACES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_CONFIG_NAMESPACES_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_CONFIG_NAMESPACES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_CONFIG_WORKSPACES := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_CONFIG_WORKSPACES_Request) (*PipelineConfigNamespacesFetchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_CONFIG_WORKSPACES_Request))
		}
		var ADAPTOR_CICD_CONFIG_WORKSPACES_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_CONFIG_WORKSPACES_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_CONFIG_WORKSPACES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_CONFIG_WORKSPACES_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_CONFIG_WORKSPACES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_CREATE := func(method, path string, fn func(context.Context, *PipelineCreateRequest) (*PipelineCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PipelineCreateRequest))
		}
		var ADAPTOR_CICD_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in PipelineCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_CRON_START := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_CRON_START_Request) (*PipelineCronStartResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_CRON_START_Request))
		}
		var ADAPTOR_CICD_CRON_START_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_CRON_START_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_CRON_START", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_CRON_START_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_CRON_START_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "cronID":
							in.CronID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_CRON_STOP := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_CRON_STOP_Request) (*PipelineCronStopResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_CRON_STOP_Request))
		}
		var ADAPTOR_CICD_CRON_STOP_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_CRON_STOP_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_CRON_STOP", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_CRON_STOP_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_CRON_STOP_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "cronID":
							in.CronID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_FETCH_PIPELINE_ID := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_FETCH_PIPELINE_ID_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_FETCH_PIPELINE_ID_Request))
		}
		var ADAPTOR_CICD_FETCH_PIPELINE_ID_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_FETCH_PIPELINE_ID_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_FETCH_PIPELINE_ID", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_FETCH_PIPELINE_ID_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_FETCH_PIPELINE_ID_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_FILETREE_CREATE := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeCreateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeCreateRequest))
		}
		var ADAPTOR_CICD_FILETREE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_FILETREE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_FILETREE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_FILETREE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_FILETREE_DELETE := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeDeleteRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeDeleteRequest))
		}
		var ADAPTOR_CICD_FILETREE_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_FILETREE_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_FILETREE_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_FILETREE_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeDeleteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_FILETREE_FIND_ANCESTORS := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeFindAncestorsRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeFindAncestorsRequest))
		}
		var ADAPTOR_CICD_FILETREE_FIND_ANCESTORS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_FILETREE_FIND_ANCESTORS_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_FILETREE_FIND_ANCESTORS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_FILETREE_FIND_ANCESTORS_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeFindAncestorsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_FILETREE_FUZZY_SEARCH := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeFuzzySearchRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeFuzzySearchRequest))
		}
		var ADAPTOR_CICD_FILETREE_FUZZY_SEARCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_FILETREE_FUZZY_SEARCH_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_FILETREE_FUZZY_SEARCH", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_FILETREE_FUZZY_SEARCH_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeFuzzySearchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_FILETREE_GET := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeGetRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeGetRequest))
		}
		var ADAPTOR_CICD_FILETREE_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_FILETREE_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_FILETREE_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_FILETREE_GET_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeGetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_Request))
		}
		var ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_FILETREE_LIST := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeListRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeListRequest))
		}
		var ADAPTOR_CICD_FILETREE_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_FILETREE_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_FILETREE_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_FILETREE_LIST_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_GET_BRANCH_RULE := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_GET_BRANCH_RULE_Request) (*PipelineGetBranchRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_GET_BRANCH_RULE_Request))
		}
		var ADAPTOR_CICD_GET_BRANCH_RULE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_GET_BRANCH_RULE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_GET_BRANCH_RULE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_GET_BRANCH_RULE_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_GET_BRANCH_RULE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineid":
							in.Pipelineid = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_INVOKED_COMBO := func(method, path string, fn func(context.Context, *PipelineInvokedComboRequest) (*PipelineInvokedComboResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PipelineInvokedComboRequest))
		}
		var ADAPTOR_CICD_INVOKED_COMBO_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_INVOKED_COMBO_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_INVOKED_COMBO", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_INVOKED_COMBO_info)
				}
				r = r.WithContext(ctx)
				var in PipelineInvokedComboRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_LIST := func(method, path string, fn func(context.Context, *PipelinePageListRequest) (*PipelinePageListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PipelinePageListRequest))
		}
		var ADAPTOR_CICD_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_LIST_info)
				}
				r = r.WithContext(ctx)
				var in PipelinePageListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_OPERATE := func(method, path string, fn func(context.Context, *PipelineOperateRequest) (*PipelineOperateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PipelineOperateRequest))
		}
		var ADAPTOR_CICD_OPERATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_OPERATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_OPERATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_OPERATE_info)
				}
				r = r.WithContext(ctx)
				var in PipelineOperateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_PIPELINE_DETAIL := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_PIPELINE_DETAIL_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_PIPELINE_DETAIL_Request))
		}
		var ADAPTOR_CICD_PIPELINE_DETAIL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_PIPELINE_DETAIL_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_PIPELINE_DETAIL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_PIPELINE_DETAIL_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_PIPELINE_DETAIL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_PIPELINE_YML_LIST := func(method, path string, fn func(context.Context, *CICDPipelineYmlListRequest) (*CICDPipelineYmlListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CICDPipelineYmlListRequest))
		}
		var ADAPTOR_CICD_PIPELINE_YML_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_PIPELINE_YML_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_PIPELINE_YML_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_PIPELINE_YML_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CICDPipelineYmlListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_PROJECT_CREATE := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_PROJECT_CREATE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_PROJECT_CREATE_Request))
		}
		var ADAPTOR_CICD_PROJECT_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_PROJECT_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_PROJECT_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_PROJECT_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_PROJECT_CREATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_PROJECT_DETAIL := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_PROJECT_DETAIL_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_PROJECT_DETAIL_Request))
		}
		var ADAPTOR_CICD_PROJECT_DETAIL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_PROJECT_DETAIL_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_PROJECT_DETAIL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_PROJECT_DETAIL_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_PROJECT_DETAIL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_RERUN := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_RERUN_Request) (*PipelineRerunResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_RERUN_Request))
		}
		var ADAPTOR_CICD_RERUN_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_RERUN_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_RERUN", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_RERUN_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_RERUN_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_RERUN_FAILED := func(method, path string, fn func(context.Context, *PipelineRerunFailedResponse) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PipelineRerunFailedResponse))
		}
		var ADAPTOR_CICD_RERUN_FAILED_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_RERUN_FAILED_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_RERUN_FAILED", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_RERUN_FAILED_info)
				}
				r = r.WithContext(ctx)
				var in PipelineRerunFailedResponse
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_RUN := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_RUN_Request) (*PipelineRunResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_RUN_Request))
		}
		var ADAPTOR_CICD_RUN_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_RUN_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_RUN", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_RUN_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_RUN_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_TASK_LOG := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_TASK_LOG_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_TASK_LOG_Request))
		}
		var ADAPTOR_CICD_TASK_LOG_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_TASK_LOG_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_TASK_LOG", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_TASK_LOG_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_TASK_LOG_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						case "taskID":
							in.TaskID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADAPTOR_CICD_TASK_LOG_DOWNLOAD := func(method, path string, fn func(context.Context, *ADAPTOR_CICD_TASK_LOG_DOWNLOAD_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADAPTOR_CICD_TASK_LOG_DOWNLOAD_Request))
		}
		var ADAPTOR_CICD_TASK_LOG_DOWNLOAD_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADAPTOR_CICD_TASK_LOG_DOWNLOAD_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ADAPTOR_CICD_TASK_LOG_DOWNLOAD", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADAPTOR_CICD_TASK_LOG_DOWNLOAD_info)
				}
				r = r.WithContext(ctx)
				var in ADAPTOR_CICD_TASK_LOG_DOWNLOAD_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						case "taskID":
							in.TaskID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_APIDocWebsocket := func(method, path string, fn func(context.Context, *APIDocWebsocket_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APIDocWebsocket_Request))
		}
		var APIDocWebsocket_info transport.ServiceInfo
		if h.Interceptor != nil {
			APIDocWebsocket_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "APIDocWebsocket", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, APIDocWebsocket_info)
				}
				r = r.WithContext(ctx)
				var in APIDocWebsocket_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_APITEST_ATTEMPT := func(method, path string, fn func(context.Context, *APITestsAttemptRequest) (*APITestsAttemptResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APITestsAttemptRequest))
		}
		var APITEST_ATTEMPT_info transport.ServiceInfo
		if h.Interceptor != nil {
			APITEST_ATTEMPT_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "APITEST_ATTEMPT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, APITEST_ATTEMPT_info)
				}
				r = r.WithContext(ctx)
				var in APITestsAttemptRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_APPLICATIONS_RESOURCES_LIST := func(method, path string, fn func(context.Context, *APPLICATIONS_RESOURCES_LIST_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APPLICATIONS_RESOURCES_LIST_Request))
		}
		var APPLICATIONS_RESOURCES_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			APPLICATIONS_RESOURCES_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "APPLICATIONS_RESOURCES_LIST", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, APPLICATIONS_RESOURCES_LIST_info)
				}
				r = r.WithContext(ctx)
				var in APPLICATIONS_RESOURCES_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_APP_PUBLISH_ITEM_RELATION_GET := func(method, path string, fn func(context.Context, *APP_PUBLISH_ITEM_RELATION_GET_Request) (*QueryAppPublishItemRelationResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APP_PUBLISH_ITEM_RELATION_GET_Request))
		}
		var APP_PUBLISH_ITEM_RELATION_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			APP_PUBLISH_ITEM_RELATION_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "APP_PUBLISH_ITEM_RELATION_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, APP_PUBLISH_ITEM_RELATION_GET_info)
				}
				r = r.WithContext(ctx)
				var in APP_PUBLISH_ITEM_RELATION_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "application":
							in.Application = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_APP_PUBLISH_ITEM_RELATION_UPDATE := func(method, path string, fn func(context.Context, *UpdateAppPublishItemRelationRequest) (*UpdateAppPublishItemRelationResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAppPublishItemRelationRequest))
		}
		var APP_PUBLISH_ITEM_RELATION_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			APP_PUBLISH_ITEM_RELATION_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "APP_PUBLISH_ITEM_RELATION_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, APP_PUBLISH_ITEM_RELATION_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAppPublishItemRelationRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "application":
							in.Application = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CI_SONAR_STORE := func(method, path string, fn func(context.Context, *SonarStoreRequest) (*SonarStoreResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SonarStoreRequest))
		}
		var CI_SONAR_STORE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CI_SONAR_STORE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CI_SONAR_STORE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CI_SONAR_STORE_info)
				}
				r = r.WithContext(ctx)
				var in SonarStoreRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPLICATION_CREATE := func(method, path string, fn func(context.Context, *ApplicationCreateRequest) (*ApplicationCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplicationCreateRequest))
		}
		var CMDB_APPLICATION_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPLICATION_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_APPLICATION_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPLICATION_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ApplicationCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPLICATION_DELETE := func(method, path string, fn func(context.Context, *ApplicationDeleteRequest) (*ApplicationDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplicationDeleteRequest))
		}
		var CMDB_APPLICATION_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPLICATION_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_APPLICATION_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPLICATION_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in ApplicationDeleteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "applicationId":
							in.ApplicationId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPLICATION_INIT := func(method, path string, fn func(context.Context, *ApplicationInitRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplicationInitRequest))
		}
		var CMDB_APPLICATION_INIT_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPLICATION_INIT_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_APPLICATION_INIT", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPLICATION_INIT_info)
				}
				r = r.WithContext(ctx)
				var in ApplicationInitRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "applicationID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ApplicationID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPLICATION_UPDATE := func(method, path string, fn func(context.Context, *ApplicationUpdateRequest) (*ApplicationUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplicationUpdateRequest))
		}
		var CMDB_APPLICATION_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPLICATION_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_APPLICATION_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPLICATION_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in ApplicationUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "applicationID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ApplicationID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_BRANCH_RULE_CREATE := func(method, path string, fn func(context.Context, *CreateBranchRuleRequest) (*CreateBranchRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateBranchRuleRequest))
		}
		var CMDB_BRANCH_RULE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_BRANCH_RULE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_BRANCH_RULE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_BRANCH_RULE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateBranchRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_BRANCH_RULE_DELETE := func(method, path string, fn func(context.Context, *CMDB_BRANCH_RULE_DELETE_Request) (*DeleteBranchRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_BRANCH_RULE_DELETE_Request))
		}
		var CMDB_BRANCH_RULE_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_BRANCH_RULE_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_BRANCH_RULE_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_BRANCH_RULE_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_BRANCH_RULE_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_BRANCH_RULE_QUERY := func(method, path string, fn func(context.Context, *QueryBranchRuleRequest) (*QueryBranchRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryBranchRuleRequest))
		}
		var CMDB_BRANCH_RULE_QUERY_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_BRANCH_RULE_QUERY_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_BRANCH_RULE_QUERY", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_BRANCH_RULE_QUERY_info)
				}
				r = r.WithContext(ctx)
				var in QueryBranchRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_BRANCH_RULE_UPDATE := func(method, path string, fn func(context.Context, *UpdateBranchRuleRequest) (*UpdateBranchRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateBranchRuleRequest))
		}
		var CMDB_BRANCH_RULE_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_BRANCH_RULE_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_BRANCH_RULE_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_BRANCH_RULE_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in UpdateBranchRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATES_APP_LIST := func(method, path string, fn func(context.Context, *AppCertificateListRequest) (*PagingAppCertificateDTO, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AppCertificateListRequest))
		}
		var CMDB_CERTIFICATES_APP_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATES_APP_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATES_APP_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATES_APP_LIST_info)
				}
				r = r.WithContext(ctx)
				var in AppCertificateListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATES_LIST := func(method, path string, fn func(context.Context, *CertificateListRequest) (*CertificateListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CertificateListRequest))
		}
		var CMDB_CERTIFICATES_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATES_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATES_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATES_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CertificateListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATE_APP_CANCEL := func(method, path string, fn func(context.Context, *CMDB_CERTIFICATE_APP_CANCEL_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_CERTIFICATE_APP_CANCEL_Request))
		}
		var CMDB_CERTIFICATE_APP_CANCEL_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATE_APP_CANCEL_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATE_APP_CANCEL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATE_APP_CANCEL_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_CERTIFICATE_APP_CANCEL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATE_APP_CONFIG := func(method, path string, fn func(context.Context, *PushCertificateConfigsRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PushCertificateConfigsRequest))
		}
		var CMDB_CERTIFICATE_APP_CONFIG_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATE_APP_CONFIG_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATE_APP_CONFIG", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATE_APP_CONFIG_info)
				}
				r = r.WithContext(ctx)
				var in PushCertificateConfigsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATE_APP_QUOTE := func(method, path string, fn func(context.Context, *CertificateQuoteRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CertificateQuoteRequest))
		}
		var CMDB_CERTIFICATE_APP_QUOTE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATE_APP_QUOTE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATE_APP_QUOTE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATE_APP_QUOTE_info)
				}
				r = r.WithContext(ctx)
				var in CertificateQuoteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATE_CREATE := func(method, path string, fn func(context.Context, *CertificateCreateRequest) (*CertificateCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CertificateCreateRequest))
		}
		var CMDB_CERTIFICATE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CertificateCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATE_DELETE := func(method, path string, fn func(context.Context, *CMDB_CERTIFICATE_DELETE_Request) (*CertificateDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_CERTIFICATE_DELETE_Request))
		}
		var CMDB_CERTIFICATE_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATE_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATE_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATE_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_CERTIFICATE_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "certificatesID":
							in.CertificatesID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATE_GET := func(method, path string, fn func(context.Context, *CMDB_CERTIFICATE_GET_Request) (*CertificateDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_CERTIFICATE_GET_Request))
		}
		var CMDB_CERTIFICATE_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATE_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATE_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATE_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_CERTIFICATE_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "certificateID":
							in.CertificateID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CERTIFICATE_UPDATE := func(method, path string, fn func(context.Context, *CertificateUpdateRequest) (*CertificateUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CertificateUpdateRequest))
		}
		var CMDB_CERTIFICATE_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CERTIFICATE_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_CERTIFICATE_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CERTIFICATE_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in CertificateUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "certificateID":
							in.CertificateID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_COMMENT_CREATE := func(method, path string, fn func(context.Context, *CommentCreateRequest) (*CommentCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CommentCreateRequest))
		}
		var CMDB_COMMENT_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_COMMENT_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_COMMENT_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_COMMENT_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CommentCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_COMMENT_LIST := func(method, path string, fn func(context.Context, *CommentListRequest) (*CommentListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CommentListRequest))
		}
		var CMDB_COMMENT_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_COMMENT_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_COMMENT_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_COMMENT_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CommentListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_COMMENT_UPDATE := func(method, path string, fn func(context.Context, *CommentUpdateRequest) (*CommentUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CommentUpdateRequest))
		}
		var CMDB_COMMENT_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_COMMENT_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_COMMENT_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_COMMENT_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in CommentUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "commentID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.CommentID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ITERATION_CREATE := func(method, path string, fn func(context.Context, *IterationCreateRequest) (*IterationCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*IterationCreateRequest))
		}
		var CMDB_ITERATION_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ITERATION_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ITERATION_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ITERATION_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in IterationCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ITERATION_DELETE := func(method, path string, fn func(context.Context, *CMDB_ITERATION_DELETE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_ITERATION_DELETE_Request))
		}
		var CMDB_ITERATION_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ITERATION_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ITERATION_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ITERATION_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_ITERATION_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ITERATION_GET := func(method, path string, fn func(context.Context, *CMDB_ITERATION_GET_Request) (*IterationGetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_ITERATION_GET_Request))
		}
		var CMDB_ITERATION_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ITERATION_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ITERATION_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ITERATION_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_ITERATION_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ITERATION_PAGING := func(method, path string, fn func(context.Context, *IterationPagingRequest) (*IterationPagingResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*IterationPagingRequest))
		}
		var CMDB_ITERATION_PAGING_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ITERATION_PAGING_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ITERATION_PAGING", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ITERATION_PAGING_info)
				}
				r = r.WithContext(ctx)
				var in IterationPagingRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ITERATION_UPDATE := func(method, path string, fn func(context.Context, *IterationUpdateRequest) (*IterationUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*IterationUpdateRequest))
		}
		var CMDB_ITERATION_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ITERATION_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ITERATION_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ITERATION_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in IterationUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LIBREFERENCE_CREATE := func(method, path string, fn func(context.Context, *LibReferenceCreateRequest) (*LibReferenceCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*LibReferenceCreateRequest))
		}
		var CMDB_LIBREFERENCE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LIBREFERENCE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_LIBREFERENCE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LIBREFERENCE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in LibReferenceCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LIBREFERENCE_DELETE := func(method, path string, fn func(context.Context, *CMDB_LIBREFERENCE_DELETE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_LIBREFERENCE_DELETE_Request))
		}
		var CMDB_LIBREFERENCE_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LIBREFERENCE_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_LIBREFERENCE_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LIBREFERENCE_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_LIBREFERENCE_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LIBREFERENCE_LIST := func(method, path string, fn func(context.Context, *LibReferenceListRequest) (*LibReferenceListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*LibReferenceListRequest))
		}
		var CMDB_LIBREFERENCE_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LIBREFERENCE_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_LIBREFERENCE_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LIBREFERENCE_LIST_info)
				}
				r = r.WithContext(ctx)
				var in LibReferenceListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LIBREFERENCE_LIST_VERSION := func(method, path string, fn func(context.Context, *CMDB_LIBREFERENCE_LIST_VERSION_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_LIBREFERENCE_LIST_VERSION_Request))
		}
		var CMDB_LIBREFERENCE_LIST_VERSION_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LIBREFERENCE_LIST_VERSION_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_LIBREFERENCE_LIST_VERSION", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LIBREFERENCE_LIST_VERSION_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_LIBREFERENCE_LIST_VERSION_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MY_PUBLISHERS_LIST := func(method, path string, fn func(context.Context, *PublisherListRequest) (*PublisherListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PublisherListRequest))
		}
		var CMDB_MY_PUBLISHERS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MY_PUBLISHERS_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_MY_PUBLISHERS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MY_PUBLISHERS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in PublisherListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_CREATE := func(method, path string, fn func(context.Context, *OrgCreateRequest) (*OrgCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgCreateRequest))
		}
		var CMDB_ORG_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in OrgCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_DELETE := func(method, path string, fn func(context.Context, *CMDB_ORG_DELETE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_ORG_DELETE_Request))
		}
		var CMDB_ORG_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_ORG_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_FETCH := func(method, path string, fn func(context.Context, *OrgFetchRequest) (*OrgSearchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgFetchRequest))
		}
		var CMDB_ORG_FETCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_FETCH_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_FETCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_FETCH_info)
				}
				r = r.WithContext(ctx)
				var in OrgFetchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_GET_BY_DOMAIN := func(method, path string, fn func(context.Context, *OrgGetByDomainRequest) (*OrgGetByDomainResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgGetByDomainRequest))
		}
		var CMDB_ORG_GET_BY_DOMAIN_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_GET_BY_DOMAIN_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_GET_BY_DOMAIN", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_GET_BY_DOMAIN_info)
				}
				r = r.WithContext(ctx)
				var in OrgGetByDomainRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_NEXUS_FETCH := func(method, path string, fn func(context.Context, *OrgNexusGetRequest) (*OrgNexusGetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgNexusGetRequest))
		}
		var CMDB_ORG_NEXUS_FETCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_NEXUS_FETCH_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_NEXUS_FETCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_NEXUS_FETCH_info)
				}
				r = r.WithContext(ctx)
				var in OrgNexusGetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_NEXUS_SHOW_PASSWORD := func(method, path string, fn func(context.Context, *OrgNexusShowPasswordRequest) (*OrgNexusShowPasswordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgNexusShowPasswordRequest))
		}
		var CMDB_ORG_NEXUS_SHOW_PASSWORD_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_NEXUS_SHOW_PASSWORD_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_NEXUS_SHOW_PASSWORD", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_NEXUS_SHOW_PASSWORD_info)
				}
				r = r.WithContext(ctx)
				var in OrgNexusShowPasswordRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_PUBLIC := func(method, path string, fn func(context.Context, *OrgSearchRequest) (*OrgSearchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgSearchRequest))
		}
		var CMDB_ORG_PUBLIC_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_PUBLIC_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_PUBLIC", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_PUBLIC_info)
				}
				r = r.WithContext(ctx)
				var in OrgSearchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_PUBLISHER_CREATE := func(method, path string, fn func(context.Context, *CMDB_ORG_PUBLISHER_CREATE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_ORG_PUBLISHER_CREATE_Request))
		}
		var CMDB_ORG_PUBLISHER_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_PUBLISHER_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_PUBLISHER_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_PUBLISHER_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_ORG_PUBLISHER_CREATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_PUBLISHER_CREATE_GET := func(method, path string, fn func(context.Context, *CMDB_ORG_PUBLISHER_CREATE_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_ORG_PUBLISHER_CREATE_GET_Request))
		}
		var CMDB_ORG_PUBLISHER_CREATE_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_PUBLISHER_CREATE_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_PUBLISHER_CREATE_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_PUBLISHER_CREATE_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_ORG_PUBLISHER_CREATE_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_RESOURCE_GET := func(method, path string, fn func(context.Context, *CMDB_ORG_RESOURCE_GET_Request) (*OrgResourceInfo, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_ORG_RESOURCE_GET_Request))
		}
		var CMDB_ORG_RESOURCE_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_RESOURCE_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_RESOURCE_GET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_RESOURCE_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_ORG_RESOURCE_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_SEARCH := func(method, path string, fn func(context.Context, *OrgSearchRequest) (*OrgSearchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgSearchRequest))
		}
		var CMDB_ORG_SEARCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_SEARCH_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_SEARCH", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_SEARCH_info)
				}
				r = r.WithContext(ctx)
				var in OrgSearchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ORG_UPDATE := func(method, path string, fn func(context.Context, *OrgUpdateRequest) (*OrgUpdateRequestBody, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgUpdateRequest))
		}
		var CMDB_ORG_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ORG_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ORG_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ORG_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in OrgUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.OrgID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECTS_FETCH := func(method, path string, fn func(context.Context, *ProjectListRequest) (*ProjectListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectListRequest))
		}
		var CMDB_PROJECTS_FETCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECTS_FETCH_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PROJECTS_FETCH", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECTS_FETCH_info)
				}
				r = r.WithContext(ctx)
				var in ProjectListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_CREATE := func(method, path string, fn func(context.Context, *ProjectCreateRequest) (*ProjectCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectCreateRequest))
		}
		var CMDB_PROJECT_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PROJECT_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ProjectCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_DELETE := func(method, path string, fn func(context.Context, *ProjectDeleteRequest) (*ProjectDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectDeleteRequest))
		}
		var CMDB_PROJECT_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PROJECT_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in ProjectDeleteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_DETAIL := func(method, path string, fn func(context.Context, *ProjectDetailRequest) (*ProjectDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectDetailRequest))
		}
		var CMDB_PROJECT_DETAIL_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_DETAIL_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PROJECT_DETAIL", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_DETAIL_info)
				}
				r = r.WithContext(ctx)
				var in ProjectDetailRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectIDOrName":
							in.ProjectIDOrName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PUBLISHERS_LIST := func(method, path string, fn func(context.Context, *PublisherListRequest) (*PublisherListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PublisherListRequest))
		}
		var CMDB_PUBLISHERS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PUBLISHERS_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PUBLISHERS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PUBLISHERS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in PublisherListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PUBLISHER_CREATE := func(method, path string, fn func(context.Context, *PublisherCreateRequest) (*PublisherCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PublisherCreateRequest))
		}
		var CMDB_PUBLISHER_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PUBLISHER_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PUBLISHER_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PUBLISHER_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in PublisherCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PUBLISHER_DELETE := func(method, path string, fn func(context.Context, *CMDB_PUBLISHER_DELETE_Request) (*PublisherDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_PUBLISHER_DELETE_Request))
		}
		var CMDB_PUBLISHER_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PUBLISHER_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PUBLISHER_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PUBLISHER_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_PUBLISHER_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publisherID":
							in.PublisherID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PUBLISHER_GET := func(method, path string, fn func(context.Context, *CMDB_PUBLISHER_GET_Request) (*PublisherDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_PUBLISHER_GET_Request))
		}
		var CMDB_PUBLISHER_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PUBLISHER_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PUBLISHER_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PUBLISHER_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_PUBLISHER_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publisherID":
							in.PublisherID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PUBLISHER_UPDATE := func(method, path string, fn func(context.Context, *PublisherUpdateRequest) (*PublisherUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PublisherUpdateRequest))
		}
		var CMDB_PUBLISHER_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PUBLISHER_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_PUBLISHER_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PUBLISHER_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in PublisherUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ROLES_LIST := func(method, path string, fn func(context.Context, *CMDB_ROLES_LIST_Request) (*MemberRoleListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_ROLES_LIST_Request))
		}
		var CMDB_ROLES_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ROLES_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_ROLES_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ROLES_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_ROLES_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_TICKET_CLOSE := func(method, path string, fn func(context.Context, *TicketCloseRequest) (*TicketCloseResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TicketCloseRequest))
		}
		var CMDB_TICKET_CLOSE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_TICKET_CLOSE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_TICKET_CLOSE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_TICKET_CLOSE_info)
				}
				r = r.WithContext(ctx)
				var in TicketCloseRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ticketID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.TicketID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_TICKET_CREATE := func(method, path string, fn func(context.Context, *TicketCreateRequest) (*TicketCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TicketCreateRequest))
		}
		var CMDB_TICKET_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_TICKET_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_TICKET_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_TICKET_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in TicketCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_TICKET_DELETE := func(method, path string, fn func(context.Context, *TicketDeleteRequest) (*TicketDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TicketDeleteRequest))
		}
		var CMDB_TICKET_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_TICKET_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_TICKET_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_TICKET_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in TicketDeleteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ticketID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.TicketID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_TICKET_FETCH := func(method, path string, fn func(context.Context, *TicketFetchRequest) (*TicketFetchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TicketFetchRequest))
		}
		var CMDB_TICKET_FETCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_TICKET_FETCH_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_TICKET_FETCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_TICKET_FETCH_info)
				}
				r = r.WithContext(ctx)
				var in TicketFetchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ticketID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.TicketID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_TICKET_LIST := func(method, path string, fn func(context.Context, *TicketListRequest) (*TicketListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TicketListRequest))
		}
		var CMDB_TICKET_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_TICKET_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_TICKET_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_TICKET_LIST_info)
				}
				r = r.WithContext(ctx)
				var in TicketListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_TICKET_REOPEN := func(method, path string, fn func(context.Context, *TicketReopenRequest) (*TicketReopenResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TicketReopenRequest))
		}
		var CMDB_TICKET_REOPEN_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_TICKET_REOPEN_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_TICKET_REOPEN", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_TICKET_REOPEN_info)
				}
				r = r.WithContext(ctx)
				var in TicketReopenRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ticketID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.TicketID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_TICKET_UPDATE := func(method, path string, fn func(context.Context, *TicketUpdateRequest) (*TicketUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TicketUpdateRequest))
		}
		var CMDB_TICKET_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_TICKET_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CMDB_TICKET_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_TICKET_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in TicketUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ticketID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.TicketID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CODE_COVERAGE_END_CALLBACK := func(method, path string, fn func(context.Context, *CodeCoverageUpdateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CodeCoverageUpdateRequest))
		}
		var CODE_COVERAGE_END_CALLBACK_info transport.ServiceInfo
		if h.Interceptor != nil {
			CODE_COVERAGE_END_CALLBACK_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CODE_COVERAGE_END_CALLBACK", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CODE_COVERAGE_END_CALLBACK_info)
				}
				r = r.WithContext(ctx)
				var in CodeCoverageUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CODE_COVERAGE_READY_CALLBACK := func(method, path string, fn func(context.Context, *CodeCoverageUpdateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CodeCoverageUpdateRequest))
		}
		var CODE_COVERAGE_READY_CALLBACK_info transport.ServiceInfo
		if h.Interceptor != nil {
			CODE_COVERAGE_READY_CALLBACK_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CODE_COVERAGE_READY_CALLBACK", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CODE_COVERAGE_READY_CALLBACK_info)
				}
				r = r.WithContext(ctx)
				var in CodeCoverageUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CODE_COVERAGE_READY_STATUS := func(method, path string, fn func(context.Context, *CodeCoverageUpdateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CodeCoverageUpdateRequest))
		}
		var CODE_COVERAGE_READY_STATUS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CODE_COVERAGE_READY_STATUS_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CODE_COVERAGE_READY_STATUS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CODE_COVERAGE_READY_STATUS_info)
				}
				r = r.WithContext(ctx)
				var in CodeCoverageUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CODE_COVERAGE_REPORT_CALLBACK := func(method, path string, fn func(context.Context, *CodeCoverageUpdateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CodeCoverageUpdateRequest))
		}
		var CODE_COVERAGE_REPORT_CALLBACK_info transport.ServiceInfo
		if h.Interceptor != nil {
			CODE_COVERAGE_REPORT_CALLBACK_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CODE_COVERAGE_REPORT_CALLBACK", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CODE_COVERAGE_REPORT_CALLBACK_info)
				}
				r = r.WithContext(ctx)
				var in CodeCoverageUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateAPIAsset := func(method, path string, fn func(context.Context, *APIAssetCreateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APIAssetCreateRequest))
		}
		var CreateAPIAsset_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateAPIAsset_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CreateAPIAsset", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateAPIAsset_info)
				}
				r = r.WithContext(ctx)
				var in APIAssetCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateAPIAssetVersion := func(method, path string, fn func(context.Context, *APIAssetVersionCreateRequest) (*CreateAPIAssetVersionBody, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APIAssetVersionCreateRequest))
		}
		var CreateAPIAssetVersion_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateAPIAssetVersion_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CreateAPIAssetVersion", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateAPIAssetVersion_info)
				}
				r = r.WithContext(ctx)
				var in APIAssetVersionCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateAccess := func(method, path string, fn func(context.Context, *CreateAccessReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateAccessReq))
		}
		var CreateAccess_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateAccess_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CreateAccess", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateAccess_info)
				}
				r = r.WithContext(ctx)
				var in CreateAccessReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateAttempTest := func(method, path string, fn func(context.Context, *APITestReq) (*Header, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APITestReq))
		}
		var CreateAttempTest_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateAttempTest_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CreateAttempTest", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateAttempTest_info)
				}
				r = r.WithContext(ctx)
				var in APITestReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateClient := func(method, path string, fn func(context.Context, *CreateClientReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateClientReq))
		}
		var CreateClient_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateClient_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CreateClient", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateClient_info)
				}
				r = r.WithContext(ctx)
				var in CreateClientReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateContract := func(method, path string, fn func(context.Context, *CreateContractReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateContractReq))
		}
		var CreateContract_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateContract_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CreateContract", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateContract_info)
				}
				r = r.WithContext(ctx)
				var in CreateContractReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateInstantiation := func(method, path string, fn func(context.Context, *CreateInstantiationReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateInstantiationReq))
		}
		var CreateInstantiation_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateInstantiation_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CreateInstantiation", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateInstantiation_info)
				}
				r = r.WithContext(ctx)
				var in CreateInstantiationReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						case "minor":
							in.Minor = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateSLA := func(method, path string, fn func(context.Context, *CreateSLAReq) (*Header, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateSLAReq))
		}
		var CreateSLA_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateSLA_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "CreateSLA", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateSLA_info)
				}
				r = r.WithContext(ctx)
				var in CreateSLAReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteAPIAssetVersion := func(method, path string, fn func(context.Context, *DeleteAPIAssetVersion_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteAPIAssetVersion_Request))
		}
		var DeleteAPIAssetVersion_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteAPIAssetVersion_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "DeleteAPIAssetVersion", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteAPIAssetVersion_info)
				}
				r = r.WithContext(ctx)
				var in DeleteAPIAssetVersion_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "versionID":
							in.VersionID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteAPIAssets := func(method, path string, fn func(context.Context, *DeleteAPIAssets_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteAPIAssets_Request))
		}
		var DeleteAPIAssets_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteAPIAssets_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "DeleteAPIAssets", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteAPIAssets_info)
				}
				r = r.WithContext(ctx)
				var in DeleteAPIAssets_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteAccess := func(method, path string, fn func(context.Context, *DeleteAccess_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteAccess_Request))
		}
		var DeleteAccess_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteAccess_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "DeleteAccess", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteAccess_info)
				}
				r = r.WithContext(ctx)
				var in DeleteAccess_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "accessID":
							in.AccessID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteClient := func(method, path string, fn func(context.Context, *DeleteClient_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteClient_Request))
		}
		var DeleteClient_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteClient_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "DeleteClient", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteClient_info)
				}
				r = r.WithContext(ctx)
				var in DeleteClient_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteContract := func(method, path string, fn func(context.Context, *GetContractReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetContractReq))
		}
		var DeleteContract_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteContract_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "DeleteContract", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteContract_info)
				}
				r = r.WithContext(ctx)
				var in GetContractReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						case "contractID":
							in.ContractID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteSLA := func(method, path string, fn func(context.Context, *DeleteSLAReq) (*Header, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteSLAReq))
		}
		var DeleteSLA_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteSLA_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "DeleteSLA", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteSLA_info)
				}
				r = r.WithContext(ctx)
				var in DeleteSLAReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						case "slaID":
							in.SlaID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ExportSpec := func(method, path string, fn func(context.Context, *DownloadSpecTextReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DownloadSpecTextReq))
		}
		var ExportSpec_info transport.ServiceInfo
		if h.Interceptor != nil {
			ExportSpec_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ExportSpec", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ExportSpec_info)
				}
				r = r.WithContext(ctx)
				var in DownloadSpecTextReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "versionID":
							in.VersionID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FileTreeCreateNode := func(method, path string, fn func(context.Context, *APIDocCreateNodeReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APIDocCreateNodeReq))
		}
		var FileTreeCreateNode_info transport.ServiceInfo
		if h.Interceptor != nil {
			FileTreeCreateNode_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "FileTreeCreateNode", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FileTreeCreateNode_info)
				}
				r = r.WithContext(ctx)
				var in APIDocCreateNodeReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "treeName":
							in.TreeName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FileTreeDeleteNode := func(method, path string, fn func(context.Context, *FileTreeDeleteNode_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*FileTreeDeleteNode_Request))
		}
		var FileTreeDeleteNode_info transport.ServiceInfo
		if h.Interceptor != nil {
			FileTreeDeleteNode_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "FileTreeDeleteNode", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FileTreeDeleteNode_info)
				}
				r = r.WithContext(ctx)
				var in FileTreeDeleteNode_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "treeName":
							in.TreeName = val
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FileTreeGetNode := func(method, path string, fn func(context.Context, *FileTreeGetNode_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*FileTreeGetNode_Request))
		}
		var FileTreeGetNode_info transport.ServiceInfo
		if h.Interceptor != nil {
			FileTreeGetNode_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "FileTreeGetNode", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FileTreeGetNode_info)
				}
				r = r.WithContext(ctx)
				var in FileTreeGetNode_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "treeName":
							in.TreeName = val
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FileTreeListNodes := func(method, path string, fn func(context.Context, *FileTreeListNodes_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*FileTreeListNodes_Request))
		}
		var FileTreeListNodes_info transport.ServiceInfo
		if h.Interceptor != nil {
			FileTreeListNodes_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "FileTreeListNodes", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FileTreeListNodes_info)
				}
				r = r.WithContext(ctx)
				var in FileTreeListNodes_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "treeName":
							in.TreeName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FileTreeMvCpNode := func(method, path string, fn func(context.Context, *FileTreeMvCpNode_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*FileTreeMvCpNode_Request))
		}
		var FileTreeMvCpNode_info transport.ServiceInfo
		if h.Interceptor != nil {
			FileTreeMvCpNode_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "FileTreeMvCpNode", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FileTreeMvCpNode_info)
				}
				r = r.WithContext(ctx)
				var in FileTreeMvCpNode_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "treeName":
							in.TreeName = val
						case "inode":
							in.Inode = val
						case "action":
							in.Action = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FileTreeUpdateNode := func(method, path string, fn func(context.Context, *FileTreeUpdateNode_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*FileTreeUpdateNode_Request))
		}
		var FileTreeUpdateNode_info transport.ServiceInfo
		if h.Interceptor != nil {
			FileTreeUpdateNode_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "FileTreeUpdateNode", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FileTreeUpdateNode_info)
				}
				r = r.WithContext(ctx)
				var in FileTreeUpdateNode_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "treeName":
							in.TreeName = val
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAPIAssetVersion := func(method, path string, fn func(context.Context, *GetAPIAssetVersionReq) (*GetAssetVersionRsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAPIAssetVersionReq))
		}
		var GetAPIAssetVersion_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAPIAssetVersion_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "GetAPIAssetVersion", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAPIAssetVersion_info)
				}
				r = r.WithContext(ctx)
				var in GetAPIAssetVersionReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "versionID":
							in.VersionID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAPIAssets := func(method, path string, fn func(context.Context, *GetAPIAssetReq) (*APIAssetGetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAPIAssetReq))
		}
		var GetAPIAssets_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAPIAssets_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "GetAPIAssets", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAPIAssets_info)
				}
				r = r.WithContext(ctx)
				var in GetAPIAssetReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAccess := func(method, path string, fn func(context.Context, *GetAccess_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAccess_Request))
		}
		var GetAccess_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAccess_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "GetAccess", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAccess_info)
				}
				r = r.WithContext(ctx)
				var in GetAccess_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "accessID":
							in.AccessID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetClient := func(method, path string, fn func(context.Context, *GetClientReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetClientReq))
		}
		var GetClient_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetClient_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "GetClient", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetClient_info)
				}
				r = r.WithContext(ctx)
				var in GetClientReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetContract := func(method, path string, fn func(context.Context, *GetContractReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetContractReq))
		}
		var GetContract_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetContract_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "GetContract", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetContract_info)
				}
				r = r.WithContext(ctx)
				var in GetContractReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						case "contractID":
							in.ContractID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetInstantiations := func(method, path string, fn func(context.Context, *GetInstantiationsReq) (*GetAddonInstanceDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetInstantiationsReq))
		}
		var GetInstantiations_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetInstantiations_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "GetInstantiations", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetInstantiations_info)
				}
				r = r.WithContext(ctx)
				var in GetInstantiationsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						case "minor":
							in.Minor = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetOperation := func(method, path string, fn func(context.Context, *GetOperationReq) (*BaseResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetOperationReq))
		}
		var GetOperation_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetOperation_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "GetOperation", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetOperation_info)
				}
				r = r.WithContext(ctx)
				var in GetOperationReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetSLA := func(method, path string, fn func(context.Context, *ListSLAsReq) (*ListSLAsRsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListSLAsReq))
		}
		var GetSLA_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetSLA_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "GetSLA", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetSLA_info)
				}
				r = r.WithContext(ctx)
				var in ListSLAsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						case "slaID":
							in.SlaID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListAPIAssetVersions := func(method, path string, fn func(context.Context, *GetAPIAssetVersionReq) (*GetAssetVersionRsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAPIAssetVersionReq))
		}
		var ListAPIAssetVersions_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListAPIAssetVersions_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListAPIAssetVersions", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListAPIAssetVersions_info)
				}
				r = r.WithContext(ctx)
				var in GetAPIAssetVersionReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListAPIGateways := func(method, path string, fn func(context.Context, *ListAPIGatewaysReq) (*ListAPIGatewaysResp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListAPIGatewaysReq))
		}
		var ListAPIGateways_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListAPIGateways_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListAPIGateways", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListAPIGateways_info)
				}
				r = r.WithContext(ctx)
				var in ListAPIGatewaysReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListAccess := func(method, path string, fn func(context.Context, *ListAccessReq) (*ListAccessRsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListAccessReq))
		}
		var ListAccess_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListAccess_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListAccess", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListAccess_info)
				}
				r = r.WithContext(ctx)
				var in ListAccessReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListContract := func(method, path string, fn func(context.Context, *ListContractsReq) (*ListContractsRsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListContractsReq))
		}
		var ListContract_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListContract_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListContract", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListContract_info)
				}
				r = r.WithContext(ctx)
				var in ListContractsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListContractRecords := func(method, path string, fn func(context.Context, *ListContractRecordsReq) (*ListContractRecordsRsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListContractRecordsReq))
		}
		var ListContractRecords_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListContractRecords_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListContractRecords", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListContractRecords_info)
				}
				r = r.WithContext(ctx)
				var in ListContractRecordsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						case "contractID":
							in.ContractID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListInstantiations := func(method, path string, fn func(context.Context, *ListInstantiations_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListInstantiations_Request))
		}
		var ListInstantiations_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListInstantiations_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListInstantiations", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListInstantiations_info)
				}
				r = r.WithContext(ctx)
				var in ListInstantiations_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListMyClients := func(method, path string, fn func(context.Context, *ListMyClientsReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListMyClientsReq))
		}
		var ListMyClients_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListMyClients_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListMyClients", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListMyClients_info)
				}
				r = r.WithContext(ctx)
				var in ListMyClientsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListProjectAPIGateways := func(method, path string, fn func(context.Context, *ListProjectAPIGatewaysReq) (*ListAPIGatewaysResp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListProjectAPIGatewaysReq))
		}
		var ListProjectAPIGateways_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListProjectAPIGateways_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListProjectAPIGateways", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListProjectAPIGateways_info)
				}
				r = r.WithContext(ctx)
				var in ListProjectAPIGatewaysReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListRuntimeServices := func(method, path string, fn func(context.Context, *ListRuntimeServices_Request) (*Header, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListRuntimeServices_Request))
		}
		var ListRuntimeServices_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListRuntimeServices_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListRuntimeServices", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListRuntimeServices_info)
				}
				r = r.WithContext(ctx)
				var in ListRuntimeServices_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "appID":
							in.AppID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListSLA := func(method, path string, fn func(context.Context, *GetSLAReq) (*GetSLARsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetSLAReq))
		}
		var ListSLA_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListSLA_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListSLA", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListSLA_info)
				}
				r = r.WithContext(ctx)
				var in GetSLAReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListSwaggerVersionClients := func(method, path string, fn func(context.Context, *ListSwaggerVersionClientsReq) (*ListSwaggerVersionRsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListSwaggerVersionClientsReq))
		}
		var ListSwaggerVersionClients_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListSwaggerVersionClients_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListSwaggerVersionClients", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListSwaggerVersionClients_info)
				}
				r = r.WithContext(ctx)
				var in ListSwaggerVersionClientsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListSwaggerVersions := func(method, path string, fn func(context.Context, *ListSwaggerVersionsReq) (*ListSwaggerVersionRsp, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListSwaggerVersionsReq))
		}
		var ListSwaggerVersions_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListSwaggerVersions_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ListSwaggerVersions", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListSwaggerVersions_info)
				}
				r = r.WithContext(ctx)
				var in ListSwaggerVersionsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_CERTIFICATION_GET := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_CERTIFICATION_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_CERTIFICATION_GET_Request))
		}
		var PUBLISH_ITEM_CERTIFICATION_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_CERTIFICATION_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_CERTIFICATION_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_CERTIFICATION_GET_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_CERTIFICATION_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_CHANNELS := func(method, path string, fn func(context.Context, *PublishItemStatisticsDetailRequest) (*PublishItemStatisticsDetailData, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PublishItemStatisticsDetailRequest))
		}
		var PUBLISH_ITEM_CHANNELS_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_CHANNELS_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_CHANNELS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_CHANNELS_info)
				}
				r = r.WithContext(ctx)
				var in PublishItemStatisticsDetailRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_ERR_EFFACTS := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_ERR_EFFACTS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_ERR_EFFACTS_Request))
		}
		var PUBLISH_ITEM_ERR_EFFACTS_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_ERR_EFFACTS_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_ERR_EFFACTS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_ERR_EFFACTS_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_ERR_EFFACTS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_ERR_LIST := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_ERR_LIST_Request) (*PublishItemStatisticsErrListData, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_ERR_LIST_Request))
		}
		var PUBLISH_ITEM_ERR_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_ERR_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_ERR_LIST", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_ERR_LIST_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_ERR_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_ERR_RATE := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_ERR_RATE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_ERR_RATE_Request))
		}
		var PUBLISH_ITEM_ERR_RATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_ERR_RATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_ERR_RATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_ERR_RATE_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_ERR_RATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_ERR_TREND := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_ERR_TREND_Request) (*PublishItemStatisticsErrTrendData, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_ERR_TREND_Request))
		}
		var PUBLISH_ITEM_ERR_TREND_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_ERR_TREND_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_ERR_TREND", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_ERR_TREND_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_ERR_TREND_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_METIRCS_COMMON := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_METIRCS_COMMON_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_METIRCS_COMMON_Request))
		}
		var PUBLISH_ITEM_METIRCS_COMMON_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_METIRCS_COMMON_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_METIRCS_COMMON", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_METIRCS_COMMON_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_METIRCS_COMMON_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						case "metricName":
							in.MetricName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_Request))
		}
		var PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						case "metricName":
							in.MetricName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_STATISTICS_TREND := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_STATISTICS_TREND_Request) (*PublishItemStatisticsTrendData, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_STATISTICS_TREND_Request))
		}
		var PUBLISH_ITEM_STATISTICS_TREND_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_STATISTICS_TREND_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_STATISTICS_TREND", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_STATISTICS_TREND_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_STATISTICS_TREND_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_USERS := func(method, path string, fn func(context.Context, *PUBLISH_ITEM_USERS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PUBLISH_ITEM_USERS_Request))
		}
		var PUBLISH_ITEM_USERS_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_USERS_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_USERS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_USERS_info)
				}
				r = r.WithContext(ctx)
				var in PUBLISH_ITEM_USERS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PUBLISH_ITEM_VERSION_INFO_LIST := func(method, path string, fn func(context.Context, *PublishItemStatisticsDetailRequest) (*PublishItemStatisticsDetailData, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PublishItemStatisticsDetailRequest))
		}
		var PUBLISH_ITEM_VERSION_INFO_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			PUBLISH_ITEM_VERSION_INFO_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PUBLISH_ITEM_VERSION_INFO_LIST", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PUBLISH_ITEM_VERSION_INFO_LIST_info)
				}
				r = r.WithContext(ctx)
				var in PublishItemStatisticsDetailRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "publishItemId":
							in.PublishItemId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PagingAPIAssets := func(method, path string, fn func(context.Context, *PagingAPIAssetsReq) (*APIAssetPagingResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PagingAPIAssetsReq))
		}
		var PagingAPIAssets_info transport.ServiceInfo
		if h.Interceptor != nil {
			PagingAPIAssets_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "PagingAPIAssets", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PagingAPIAssets_info)
				}
				r = r.WithContext(ctx)
				var in PagingAPIAssetsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ProjectPackageExport := func(method, path string, fn func(context.Context, *ExportProjectPackageRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ExportProjectPackageRequest))
		}
		var ProjectPackageExport_info transport.ServiceInfo
		if h.Interceptor != nil {
			ProjectPackageExport_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ProjectPackageExport", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ProjectPackageExport_info)
				}
				r = r.WithContext(ctx)
				var in ExportProjectPackageRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						case "projectID":
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ProjectPackageImport := func(method, path string, fn func(context.Context, *ImportProjectPackageRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ImportProjectPackageRequest))
		}
		var ProjectPackageImport_info transport.ServiceInfo
		if h.Interceptor != nil {
			ProjectPackageImport_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ProjectPackageImport", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ProjectPackageImport_info)
				}
				r = r.WithContext(ctx)
				var in ImportProjectPackageRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							in.OrgID = val
						case "projectID":
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ProjectPackageParse := func(method, path string, fn func(context.Context, *ProjectPackageParse_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectPackageParse_Request))
		}
		var ProjectPackageParse_info transport.ServiceInfo
		if h.Interceptor != nil {
			ProjectPackageParse_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ProjectPackageParse", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ProjectPackageParse_info)
				}
				r = r.WithContext(ctx)
				var in ProjectPackageParse_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ProjectTemplateExport := func(method, path string, fn func(context.Context, *ExportProjectTemplateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ExportProjectTemplateRequest))
		}
		var ProjectTemplateExport_info transport.ServiceInfo
		if h.Interceptor != nil {
			ProjectTemplateExport_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ProjectTemplateExport", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ProjectTemplateExport_info)
				}
				r = r.WithContext(ctx)
				var in ExportProjectTemplateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.OrgID = val
						case "projectID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ProjectTemplateImport := func(method, path string, fn func(context.Context, *ImportProjectTemplateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ImportProjectTemplateRequest))
		}
		var ProjectTemplateImport_info transport.ServiceInfo
		if h.Interceptor != nil {
			ProjectTemplateImport_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ProjectTemplateImport", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ProjectTemplateImport_info)
				}
				r = r.WithContext(ctx)
				var in ImportProjectTemplateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "orgID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.OrgID = val
						case "projectID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ProjectTemplateParse := func(method, path string, fn func(context.Context, *ImportProjectTemplateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ImportProjectTemplateRequest))
		}
		var ProjectTemplateParse_info transport.ServiceInfo
		if h.Interceptor != nil {
			ProjectTemplateParse_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ProjectTemplateParse", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ProjectTemplateParse_info)
				}
				r = r.WithContext(ctx)
				var in ImportProjectTemplateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ProxyMetrics := func(method, path string, fn func(context.Context, *ProxyMetrics_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProxyMetrics_Request))
		}
		var ProxyMetrics_info transport.ServiceInfo
		if h.Interceptor != nil {
			ProxyMetrics_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ProxyMetrics", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ProxyMetrics_info)
				}
				r = r.WithContext(ctx)
				var in ProxyMetrics_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_APITESTS_CANCEL := func(method, path string, fn func(context.Context, *ApiTestCancelRequest) (*ApiTestCancelResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApiTestCancelRequest))
		}
		var QA_APITESTS_CANCEL_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_APITESTS_CANCEL_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_APITESTS_CANCEL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_APITESTS_CANCEL_info)
				}
				r = r.WithContext(ctx)
				var in ApiTestCancelRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_APITESTS_GET := func(method, path string, fn func(context.Context, *QA_APITESTS_GET_Request) (*ApiTestsGetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_APITESTS_GET_Request))
		}
		var QA_APITESTS_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_APITESTS_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_APITESTS_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_APITESTS_GET_info)
				}
				r = r.WithContext(ctx)
				var in QA_APITESTS_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_APITESTS_UPDATE := func(method, path string, fn func(context.Context, *ApiTestsUpdateRequest) (*ApiTestsUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApiTestsUpdateRequest))
		}
		var QA_APITESTS_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_APITESTS_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_APITESTS_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_APITESTS_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in ApiTestsUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_AUTOTEST_SPACE_GET := func(method, path string, fn func(context.Context, *QA_AUTOTEST_SPACE_GET_Request) (*AutoTestSpaceResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_AUTOTEST_SPACE_GET_Request))
		}
		var QA_AUTOTEST_SPACE_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_AUTOTEST_SPACE_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_AUTOTEST_SPACE_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_AUTOTEST_SPACE_GET_info)
				}
				r = r.WithContext(ctx)
				var in QA_AUTOTEST_SPACE_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_PIPELINE_TASK_LOGS := func(method, path string, fn func(context.Context, *QA_PIPELINE_TASK_LOGS_Request) (*DashboardSpotLogResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_PIPELINE_TASK_LOGS_Request))
		}
		var QA_PIPELINE_TASK_LOGS_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_PIPELINE_TASK_LOGS_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_PIPELINE_TASK_LOGS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_PIPELINE_TASK_LOGS_info)
				}
				r = r.WithContext(ctx)
				var in QA_PIPELINE_TASK_LOGS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						case "taskID":
							in.TaskID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_RECORDS_GET := func(method, path string, fn func(context.Context, *QA_RECORDS_GET_Request) (*GetTestFileRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_RECORDS_GET_Request))
		}
		var QA_RECORDS_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_RECORDS_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_RECORDS_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_RECORDS_GET_info)
				}
				r = r.WithContext(ctx)
				var in QA_RECORDS_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_RECORDS_LIST := func(method, path string, fn func(context.Context, *ListTestFileRecordsRequest) (*ListTestFileRecordsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListTestFileRecordsRequest))
		}
		var QA_RECORDS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_RECORDS_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_RECORDS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_RECORDS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListTestFileRecordsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_GET_CREDENTIAL := func(method, path string, fn func(context.Context, *QA_SONAR_GET_CREDENTIAL_Request) (*SonarCredentialGetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_SONAR_GET_CREDENTIAL_Request))
		}
		var QA_SONAR_GET_CREDENTIAL_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_GET_CREDENTIAL_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_GET_CREDENTIAL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_GET_CREDENTIAL_info)
				}
				r = r.WithContext(ctx)
				var in QA_SONAR_GET_CREDENTIAL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_ISSUES := func(method, path string, fn func(context.Context, *QA_SONAR_ISSUES_Request) (*SonarIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_SONAR_ISSUES_Request))
		}
		var QA_SONAR_ISSUES_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_ISSUES_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_ISSUES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_ISSUES_info)
				}
				r = r.WithContext(ctx)
				var in QA_SONAR_ISSUES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_METRIC_RULES_BATCH_DELETE := func(method, path string, fn func(context.Context, *SonarMetricRulesBatchDeleteRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SonarMetricRulesBatchDeleteRequest))
		}
		var QA_SONAR_METRIC_RULES_BATCH_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_METRIC_RULES_BATCH_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_METRIC_RULES_BATCH_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_METRIC_RULES_BATCH_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in SonarMetricRulesBatchDeleteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_METRIC_RULES_BATCH_INSERT := func(method, path string, fn func(context.Context, *SonarMetricRulesBatchInsertRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SonarMetricRulesBatchInsertRequest))
		}
		var QA_SONAR_METRIC_RULES_BATCH_INSERT_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_METRIC_RULES_BATCH_INSERT_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_METRIC_RULES_BATCH_INSERT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_METRIC_RULES_BATCH_INSERT_info)
				}
				r = r.WithContext(ctx)
				var in SonarMetricRulesBatchInsertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_METRIC_RULES_DELETE := func(method, path string, fn func(context.Context, *SonarMetricRulesDeleteRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SonarMetricRulesDeleteRequest))
		}
		var QA_SONAR_METRIC_RULES_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_METRIC_RULES_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_METRIC_RULES_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_METRIC_RULES_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in SonarMetricRulesDeleteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_METRIC_RULES_GET := func(method, path string, fn func(context.Context, *QA_SONAR_METRIC_RULES_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_SONAR_METRIC_RULES_GET_Request))
		}
		var QA_SONAR_METRIC_RULES_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_METRIC_RULES_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_METRIC_RULES_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_METRIC_RULES_GET_info)
				}
				r = r.WithContext(ctx)
				var in QA_SONAR_METRIC_RULES_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_METRIC_RULES_PAGING := func(method, path string, fn func(context.Context, *SonarMetricRulesPagingRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SonarMetricRulesPagingRequest))
		}
		var QA_SONAR_METRIC_RULES_PAGING_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_METRIC_RULES_PAGING_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_METRIC_RULES_PAGING", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_METRIC_RULES_PAGING_info)
				}
				r = r.WithContext(ctx)
				var in SonarMetricRulesPagingRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_METRIC_RULES_QUERY_DEFINITION := func(method, path string, fn func(context.Context, *SonarMetricRulesDefinitionListRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SonarMetricRulesDefinitionListRequest))
		}
		var QA_SONAR_METRIC_RULES_QUERY_DEFINITION_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_METRIC_RULES_QUERY_DEFINITION_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_METRIC_RULES_QUERY_DEFINITION", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_METRIC_RULES_QUERY_DEFINITION_info)
				}
				r = r.WithContext(ctx)
				var in SonarMetricRulesDefinitionListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_METRIC_RULES_QUERY_LIST := func(method, path string, fn func(context.Context, *SonarMetricRulesListRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SonarMetricRulesListRequest))
		}
		var QA_SONAR_METRIC_RULES_QUERY_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_METRIC_RULES_QUERY_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_METRIC_RULES_QUERY_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_METRIC_RULES_QUERY_LIST_info)
				}
				r = r.WithContext(ctx)
				var in SonarMetricRulesListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_SONAR_METRIC_RULES_UPDATE := func(method, path string, fn func(context.Context, *SonarMetricRulesUpdateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SonarMetricRulesUpdateRequest))
		}
		var QA_SONAR_METRIC_RULES_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_SONAR_METRIC_RULES_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_SONAR_METRIC_RULES_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_SONAR_METRIC_RULES_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in SonarMetricRulesUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_TESTENV_CREATE := func(method, path string, fn func(context.Context, *QA_TESTENV_CREATE_Request) (*APITestEnvCreateRequest, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_TESTENV_CREATE_Request))
		}
		var QA_TESTENV_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_TESTENV_CREATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_TESTENV_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_TESTENV_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in QA_TESTENV_CREATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_TESTENV_DELETE := func(method, path string, fn func(context.Context, *QA_TESTENV_DELETE_Request) (*APITestEnvDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_TESTENV_DELETE_Request))
		}
		var QA_TESTENV_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_TESTENV_DELETE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_TESTENV_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_TESTENV_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in QA_TESTENV_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_TESTENV_GET := func(method, path string, fn func(context.Context, *QA_TESTENV_GET_Request) (*APITestEnvGetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_TESTENV_GET_Request))
		}
		var QA_TESTENV_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_TESTENV_GET_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_TESTENV_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_TESTENV_GET_info)
				}
				r = r.WithContext(ctx)
				var in QA_TESTENV_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_TESTENV_LIST := func(method, path string, fn func(context.Context, *QA_TESTENV_LIST_Request) (*APITestEnvListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_TESTENV_LIST_Request))
		}
		var QA_TESTENV_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_TESTENV_LIST_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_TESTENV_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_TESTENV_LIST_info)
				}
				r = r.WithContext(ctx)
				var in QA_TESTENV_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_TESTENV_UPDATE := func(method, path string, fn func(context.Context, *APITestEnvUpdateRequest) (*APITestEnvUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*APITestEnvUpdateRequest))
		}
		var QA_TESTENV_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_TESTENV_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_TESTENV_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_TESTENV_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in APITestEnvUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_TESTPLAN_PIPELINE_DETAIL := func(method, path string, fn func(context.Context, *QA_TESTPLAN_PIPELINE_DETAIL_Request) (*PipelineDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_TESTPLAN_PIPELINE_DETAIL_Request))
		}
		var QA_TESTPLAN_PIPELINE_DETAIL_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_TESTPLAN_PIPELINE_DETAIL_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "QA_TESTPLAN_PIPELINE_DETAIL", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_TESTPLAN_PIPELINE_DETAIL_info)
				}
				r = r.WithContext(ctx)
				var in QA_TESTPLAN_PIPELINE_DETAIL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineId":
							in.PipelineId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SPOT_APITESTS_LOGS := func(method, path string, fn func(context.Context, *SPOT_APITESTS_LOGS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SPOT_APITESTS_LOGS_Request))
		}
		var SPOT_APITESTS_LOGS_info transport.ServiceInfo
		if h.Interceptor != nil {
			SPOT_APITESTS_LOGS_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "SPOT_APITESTS_LOGS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SPOT_APITESTS_LOGS_info)
				}
				r = r.WithContext(ctx)
				var in SPOT_APITESTS_LOGS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SPOT_APITESTS_LOGS_DOWNLOAD := func(method, path string, fn func(context.Context, *SPOT_APITESTS_LOGS_DOWNLOAD_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SPOT_APITESTS_LOGS_DOWNLOAD_Request))
		}
		var SPOT_APITESTS_LOGS_DOWNLOAD_info transport.ServiceInfo
		if h.Interceptor != nil {
			SPOT_APITESTS_LOGS_DOWNLOAD_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "SPOT_APITESTS_LOGS_DOWNLOAD", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SPOT_APITESTS_LOGS_DOWNLOAD_info)
				}
				r = r.WithContext(ctx)
				var in SPOT_APITESTS_LOGS_DOWNLOAD_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SearchOperations := func(method, path string, fn func(context.Context, *SearchOperationsReq) (*BaseResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SearchOperationsReq))
		}
		var SearchOperations_info transport.ServiceInfo
		if h.Interceptor != nil {
			SearchOperations_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "SearchOperations", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SearchOperations_info)
				}
				r = r.WithContext(ctx)
				var in SearchOperationsReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAPIAssset := func(method, path string, fn func(context.Context, *UpdateAPIAssetReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAPIAssetReq))
		}
		var UpdateAPIAssset_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAPIAssset_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "UpdateAPIAssset", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAPIAssset_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAPIAssetReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAccess := func(method, path string, fn func(context.Context, *UpdateAccess_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAccess_Request))
		}
		var UpdateAccess_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAccess_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "UpdateAccess", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAccess_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAccess_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "accessID":
							in.AccessID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAssetVersion := func(method, path string, fn func(context.Context, *UpdateAssetVersionReq) (*Header, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAssetVersionReq))
		}
		var UpdateAssetVersion_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAssetVersion_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "UpdateAssetVersion", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAssetVersion_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAssetVersionReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "versionID":
							in.VersionID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateClient := func(method, path string, fn func(context.Context, *UpdateClientReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateClientReq))
		}
		var UpdateClient_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateClient_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "UpdateClient", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateClient_info)
				}
				r = r.WithContext(ctx)
				var in UpdateClientReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateContract := func(method, path string, fn func(context.Context, *UpdateContract_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateContract_Request))
		}
		var UpdateContract_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateContract_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "UpdateContract", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateContract_info)
				}
				r = r.WithContext(ctx)
				var in UpdateContract_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "clientID":
							in.ClientID = val
						case "contractID":
							in.ContractID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateInstantiation := func(method, path string, fn func(context.Context, *UpdateInstantiationReq) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateInstantiationReq))
		}
		var UpdateInstantiation_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateInstantiation_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "UpdateInstantiation", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateInstantiation_info)
				}
				r = r.WithContext(ctx)
				var in UpdateInstantiationReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						case "minor":
							in.Minor = val
						case "instantiationID":
							in.InstantiationID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateSLA := func(method, path string, fn func(context.Context, *UpdateSLAReq) (*Header, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateSLAReq))
		}
		var UpdateSLA_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateSLA_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "UpdateSLA", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateSLA_info)
				}
				r = r.WithContext(ctx)
				var in UpdateSLAReq
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "assetID":
							in.AssetID = val
						case "swaggerVersion":
							in.SwaggerVersion = val
						case "slaID":
							in.SlaID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ValidateSwagger := func(method, path string, fn func(context.Context, *ValidateSwagger_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ValidateSwagger_Request))
		}
		var ValidateSwagger_info transport.ServiceInfo
		if h.Interceptor != nil {
			ValidateSwagger_info = transport.NewServiceInfo("erda.openapiv1.dop.dop", "ValidateSwagger", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ValidateSwagger_info)
				}
				r = r.WithContext(ctx)
				var in ValidateSwagger_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_AADAPTOR_CICD_CRON_LIST("GET", "/api/cicd-crons", srv.AADAPTOR_CICD_CRON_LIST)
	add_ADAPTOR_CICD_BRANCHES_ALL_VALID("GET", "/api/cicds/actions/app-all-valid-branch-workspaces", srv.ADAPTOR_CICD_BRANCHES_ALL_VALID)
	add_ADAPTOR_CICD_CANCEL("POST", "/api/cicds/{pipelineID}/actions/cancel", srv.ADAPTOR_CICD_CANCEL)
	add_ADAPTOR_CICD_CONFIG_GET("POST", "/api/cicds/multinamespace/configs", srv.ADAPTOR_CICD_CONFIG_GET)
	add_ADAPTOR_CICD_CONFIG_NAMESPACES("GET", "/api/cicds/actions/fetch-config-namespaces", srv.ADAPTOR_CICD_CONFIG_NAMESPACES)
	add_ADAPTOR_CICD_CONFIG_WORKSPACES("GET", "/api/cicds/actions/list-workspaces", srv.ADAPTOR_CICD_CONFIG_WORKSPACES)
	add_ADAPTOR_CICD_CREATE("POST", "/api/cicds", srv.ADAPTOR_CICD_CREATE)
	add_ADAPTOR_CICD_CRON_START("PUT", "/api/cicd-crons/{cronID}/actions/start", srv.ADAPTOR_CICD_CRON_START)
	add_ADAPTOR_CICD_CRON_STOP("PUT", "/api/cicd-crons/{cronID}/actions/stop", srv.ADAPTOR_CICD_CRON_STOP)
	add_ADAPTOR_CICD_FETCH_PIPELINE_ID("GET", "/api/cicds/actions/fetch-pipeline-id", srv.ADAPTOR_CICD_FETCH_PIPELINE_ID)
	add_ADAPTOR_CICD_FILETREE_CREATE("POST", "/api/cicd-pipeline/filetree", srv.ADAPTOR_CICD_FILETREE_CREATE)
	add_ADAPTOR_CICD_FILETREE_DELETE("DELETE", "/api/cicd-pipeline/filetree/{inode}", srv.ADAPTOR_CICD_FILETREE_DELETE)
	add_ADAPTOR_CICD_FILETREE_FIND_ANCESTORS("GET", "/api/cicd-pipeline/filetree/{inode}/actions/find-ancestors", srv.ADAPTOR_CICD_FILETREE_FIND_ANCESTORS)
	add_ADAPTOR_CICD_FILETREE_FUZZY_SEARCH("GET", "/api/cicd-pipeline/filetree/actions/fuzzy-search", srv.ADAPTOR_CICD_FILETREE_FUZZY_SEARCH)
	add_ADAPTOR_CICD_FILETREE_GET("GET", "/api/cicd-pipeline/filetree/{inode}", srv.ADAPTOR_CICD_FILETREE_GET)
	add_ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE("GET", "/api/cicd-pipeline/filetree/actions/get-inode-by-pipeline", srv.ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE)
	add_ADAPTOR_CICD_FILETREE_LIST("GET", "/api/cicd-pipeline/filetree", srv.ADAPTOR_CICD_FILETREE_LIST)
	add_ADAPTOR_CICD_GET_BRANCH_RULE("GET", "/api/cicds/{pipelineid}/actions/get-branch-rule", srv.ADAPTOR_CICD_GET_BRANCH_RULE)
	add_ADAPTOR_CICD_INVOKED_COMBO("GET", "/api/cicds/actions/app-invoked-combos", srv.ADAPTOR_CICD_INVOKED_COMBO)
	add_ADAPTOR_CICD_LIST("GET", "/api/cicds", srv.ADAPTOR_CICD_LIST)
	add_ADAPTOR_CICD_OPERATE("PUT", "/api/cicds/{pipelineID}", srv.ADAPTOR_CICD_OPERATE)
	add_ADAPTOR_CICD_PIPELINE_DETAIL("GET", "/api/cicds/actions/pipeline-detail", srv.ADAPTOR_CICD_PIPELINE_DETAIL)
	add_ADAPTOR_CICD_PIPELINE_YML_LIST("GET", "/api/cicds/actions/pipelineYmls", srv.ADAPTOR_CICD_PIPELINE_YML_LIST)
	add_ADAPTOR_CICD_PROJECT_CREATE("POST", "/api/cicds-project", srv.ADAPTOR_CICD_PROJECT_CREATE)
	add_ADAPTOR_CICD_PROJECT_DETAIL("GET", "/api/cicds-project/actions/pipeline-detail", srv.ADAPTOR_CICD_PROJECT_DETAIL)
	add_ADAPTOR_CICD_RERUN("POST", "/api/cicds/{pipelineID}/actions/rerun", srv.ADAPTOR_CICD_RERUN)
	add_ADAPTOR_CICD_RERUN_FAILED("POST", "/api/cicds/{pipelineID}/actions/rerun-failed", srv.ADAPTOR_CICD_RERUN_FAILED)
	add_ADAPTOR_CICD_RUN("POST", "/api/cicds/{pipelineID}/actions/run", srv.ADAPTOR_CICD_RUN)
	add_ADAPTOR_CICD_TASK_LOG("GET", "/api/cicd/{pipelineID}/tasks/{taskID}/logs", srv.ADAPTOR_CICD_TASK_LOG)
	add_ADAPTOR_CICD_TASK_LOG_DOWNLOAD("GET", "/api/cicd/{pipelineID}/tasks/{taskID}/logs/actions/download", srv.ADAPTOR_CICD_TASK_LOG_DOWNLOAD)
	add_APIDocWebsocket("GET", "/api/apim-ws/api-docs/filetree/{inode}", srv.APIDocWebsocket)
	add_APITEST_ATTEMPT("POST", "/api/apitests/actions/attempt-test", srv.APITEST_ATTEMPT)
	add_APPLICATIONS_RESOURCES_LIST("GET", "/api/projects/{projectID}/applications-resources", srv.APPLICATIONS_RESOURCES_LIST)
	add_APP_PUBLISH_ITEM_RELATION_GET("GET", "/api/applications/{application}/actions/get-publish-item-relations", srv.APP_PUBLISH_ITEM_RELATION_GET)
	add_APP_PUBLISH_ITEM_RELATION_UPDATE("POST", "/api/applications/{application}/actions/update-publish-item-relations", srv.APP_PUBLISH_ITEM_RELATION_UPDATE)
	add_CI_SONAR_STORE("POST", "/api/qa/actions/sonar-results-store", srv.CI_SONAR_STORE)
	add_CMDB_APPLICATION_CREATE("POST", "/api/applications", srv.CMDB_APPLICATION_CREATE)
	add_CMDB_APPLICATION_DELETE("DELETE", "/api/applications/{applicationId}", srv.CMDB_APPLICATION_DELETE)
	add_CMDB_APPLICATION_INIT("PUT", "/api/applications/{applicationID}/actions/init", srv.CMDB_APPLICATION_INIT)
	add_CMDB_APPLICATION_UPDATE("PUT", "/api/applications/{applicationID}", srv.CMDB_APPLICATION_UPDATE)
	add_CMDB_BRANCH_RULE_CREATE("POST", "/api/branch-rules", srv.CMDB_BRANCH_RULE_CREATE)
	add_CMDB_BRANCH_RULE_DELETE("DELETE", "/api/branch-rules/{id}", srv.CMDB_BRANCH_RULE_DELETE)
	add_CMDB_BRANCH_RULE_QUERY("GET", "/api/branch-rules", srv.CMDB_BRANCH_RULE_QUERY)
	add_CMDB_BRANCH_RULE_UPDATE("PUT", "/api/branch-rules/{ID}", srv.CMDB_BRANCH_RULE_UPDATE)
	add_CMDB_CERTIFICATES_APP_LIST("GET", "/api/certificates/actions/list-application-quotes", srv.CMDB_CERTIFICATES_APP_LIST)
	add_CMDB_CERTIFICATES_LIST("GET", "/api/certificates/actions/list-certificates", srv.CMDB_CERTIFICATES_LIST)
	add_CMDB_CERTIFICATE_APP_CANCEL("DELETE", "/api/certificates/actions/application-cancel-quote", srv.CMDB_CERTIFICATE_APP_CANCEL)
	add_CMDB_CERTIFICATE_APP_CONFIG("POST", "/api/certificates/actions/push-configs", srv.CMDB_CERTIFICATE_APP_CONFIG)
	add_CMDB_CERTIFICATE_APP_QUOTE("POST", "/api/certificates/actions/application-quote", srv.CMDB_CERTIFICATE_APP_QUOTE)
	add_CMDB_CERTIFICATE_CREATE("POST", "/api/certificates", srv.CMDB_CERTIFICATE_CREATE)
	add_CMDB_CERTIFICATE_DELETE("DELETE", "/api/certificates/{certificatesID}", srv.CMDB_CERTIFICATE_DELETE)
	add_CMDB_CERTIFICATE_GET("GET", "/api/certificates/{certificateID}", srv.CMDB_CERTIFICATE_GET)
	add_CMDB_CERTIFICATE_UPDATE("PUT", "/api/certificates/{certificateID}", srv.CMDB_CERTIFICATE_UPDATE)
	add_CMDB_COMMENT_CREATE("POST", "/api/comments", srv.CMDB_COMMENT_CREATE)
	add_CMDB_COMMENT_LIST("GET", "/api/comments", srv.CMDB_COMMENT_LIST)
	add_CMDB_COMMENT_UPDATE("PUT", "/api/comments/{commentID}", srv.CMDB_COMMENT_UPDATE)
	add_CMDB_ITERATION_CREATE("POST", "/api/iterations", srv.CMDB_ITERATION_CREATE)
	add_CMDB_ITERATION_DELETE("DELETE", "/api/iterations/{id}", srv.CMDB_ITERATION_DELETE)
	add_CMDB_ITERATION_GET("GET", "/api/iterations/{id}", srv.CMDB_ITERATION_GET)
	add_CMDB_ITERATION_PAGING("GET", "/api/iterations", srv.CMDB_ITERATION_PAGING)
	add_CMDB_ITERATION_UPDATE("PUT", "/api/iterations/{id}", srv.CMDB_ITERATION_UPDATE)
	add_CMDB_LIBREFERENCE_CREATE("POST", "/api/lib-references", srv.CMDB_LIBREFERENCE_CREATE)
	add_CMDB_LIBREFERENCE_DELETE("DELETE", "/api/lib-references/{id}", srv.CMDB_LIBREFERENCE_DELETE)
	add_CMDB_LIBREFERENCE_LIST("GET", "/api/lib-references", srv.CMDB_LIBREFERENCE_LIST)
	add_CMDB_LIBREFERENCE_LIST_VERSION("GET", "/api/lib-references/actions/fetch-versions", srv.CMDB_LIBREFERENCE_LIST_VERSION)
	add_CMDB_MY_PUBLISHERS_LIST("GET", "/api/publishers/actions/list-my-publishers", srv.CMDB_MY_PUBLISHERS_LIST)
	add_CMDB_ORG_CREATE("POST", "/api/orgs", srv.CMDB_ORG_CREATE)
	add_CMDB_ORG_DELETE("DELETE", "/api/orgs/{orgID}", srv.CMDB_ORG_DELETE)
	add_CMDB_ORG_FETCH("GET", "/api/orgs/{orgID}", srv.CMDB_ORG_FETCH)
	add_CMDB_ORG_GET_BY_DOMAIN("GET", "/api/orgs/actions/get-by-domain", srv.CMDB_ORG_GET_BY_DOMAIN)
	add_CMDB_ORG_NEXUS_FETCH("GET", "/api/orgs/{orgID}/nexus", srv.CMDB_ORG_NEXUS_FETCH)
	add_CMDB_ORG_NEXUS_SHOW_PASSWORD("GET", "/api/orgs/{orgID}/show-nexus-password", srv.CMDB_ORG_NEXUS_SHOW_PASSWORD)
	add_CMDB_ORG_PUBLIC("GET", "/api/orgs/actions/list-public", srv.CMDB_ORG_PUBLIC)
	add_CMDB_ORG_PUBLISHER_CREATE("POST", "/api/orgs/{orgID}/actions/create-publisher", srv.CMDB_ORG_PUBLISHER_CREATE)
	add_CMDB_ORG_PUBLISHER_CREATE_GET("GET", "/api/orgs/{orgID}/actions/create-publisher", srv.CMDB_ORG_PUBLISHER_CREATE_GET)
	add_CMDB_ORG_RESOURCE_GET("GET", "/api/orgs/actions/fetch-resources", srv.CMDB_ORG_RESOURCE_GET)
	add_CMDB_ORG_SEARCH("GET", "/api/orgs", srv.CMDB_ORG_SEARCH)
	add_CMDB_ORG_UPDATE("PUT", "/api/orgs/{orgID}", srv.CMDB_ORG_UPDATE)
	add_CMDB_PROJECTS_FETCH("GET", "/api/projects", srv.CMDB_PROJECTS_FETCH)
	add_CMDB_PROJECT_CREATE("POST", "/api/projects", srv.CMDB_PROJECT_CREATE)
	add_CMDB_PROJECT_DELETE("DELETE", "/api/projects/{projectID}", srv.CMDB_PROJECT_DELETE)
	add_CMDB_PROJECT_DETAIL("GET", "/api/projects/{projectIDOrName}", srv.CMDB_PROJECT_DETAIL)
	add_CMDB_PUBLISHERS_LIST("GET", "/api/publishers", srv.CMDB_PUBLISHERS_LIST)
	add_CMDB_PUBLISHER_CREATE("POST", "/api/publishers", srv.CMDB_PUBLISHER_CREATE)
	add_CMDB_PUBLISHER_DELETE("DELETE", "/api/publishers/{publisherID}", srv.CMDB_PUBLISHER_DELETE)
	add_CMDB_PUBLISHER_GET("GET", "/api/publishers/{publisherID}", srv.CMDB_PUBLISHER_GET)
	add_CMDB_PUBLISHER_UPDATE("PUT", "/api/publishers", srv.CMDB_PUBLISHER_UPDATE)
	add_CMDB_ROLES_LIST("GET", "/api/members/actions/list-roles", srv.CMDB_ROLES_LIST)
	add_CMDB_TICKET_CLOSE("PUT", "/api/tickets/{ticketID}/actions/close", srv.CMDB_TICKET_CLOSE)
	add_CMDB_TICKET_CREATE("POST", "/api/tickets", srv.CMDB_TICKET_CREATE)
	add_CMDB_TICKET_DELETE("DELETE", "/api/tickets/{ticketID}", srv.CMDB_TICKET_DELETE)
	add_CMDB_TICKET_FETCH("GET", "/api/tickets/{ticketID}", srv.CMDB_TICKET_FETCH)
	add_CMDB_TICKET_LIST("GET", "/api/tickets", srv.CMDB_TICKET_LIST)
	add_CMDB_TICKET_REOPEN("PUT", "/api/tickets/{ticketID}/actions/reopen", srv.CMDB_TICKET_REOPEN)
	add_CMDB_TICKET_UPDATE("PUT", "/api/tickets/{ticketID}", srv.CMDB_TICKET_UPDATE)
	add_CODE_COVERAGE_END_CALLBACK("POST", "/api/code-coverage/actions/end-callBack", srv.CODE_COVERAGE_END_CALLBACK)
	add_CODE_COVERAGE_READY_CALLBACK("POST", "/api/code-coverage/actions/ready-callBack", srv.CODE_COVERAGE_READY_CALLBACK)
	add_CODE_COVERAGE_READY_STATUS("GET", "/api/code-coverage/actions/status", srv.CODE_COVERAGE_READY_STATUS)
	add_CODE_COVERAGE_REPORT_CALLBACK("POST", "/api/code-coverage/actions/report-callBack", srv.CODE_COVERAGE_REPORT_CALLBACK)
	add_CreateAPIAsset("POST", "/api/api-assets", srv.CreateAPIAsset)
	add_CreateAPIAssetVersion("POST", "/api/api-assets/{assetID}/versions", srv.CreateAPIAssetVersion)
	add_CreateAccess("POST", "/api/api-access", srv.CreateAccess)
	add_CreateAttempTest("POST", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/attempt-test", srv.CreateAttempTest)
	add_CreateClient("POST", "/api/api-clients", srv.CreateClient)
	add_CreateContract("POST", "/api/api-clients/{clientID}/contracts", srv.CreateContract)
	add_CreateInstantiation("POST", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/minors/{minor}/instantiations", srv.CreateInstantiation)
	add_CreateSLA("POST", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas", srv.CreateSLA)
	add_DeleteAPIAssetVersion("DELETE", "/api/api-assets/{assetID}/versions/{versionID}", srv.DeleteAPIAssetVersion)
	add_DeleteAPIAssets("DELETE", "/api/api-assets/{assetID}", srv.DeleteAPIAssets)
	add_DeleteAccess("DELETE", "/api/api-access/{accessID}", srv.DeleteAccess)
	add_DeleteClient("DELETE", "/api/api-clients/{clientID}", srv.DeleteClient)
	add_DeleteContract("DELETE", "/api/api-clients/{clientID}/contracts/{contractID}", srv.DeleteContract)
	add_DeleteSLA("DELETE", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas/{slaID}", srv.DeleteSLA)
	add_ExportSpec("GET", "/api/api-assets/{assetID}/versions/{versionID}/export", srv.ExportSpec)
	add_FileTreeCreateNode("POST", "/api/apim/{treeName}/filetree", srv.FileTreeCreateNode)
	add_FileTreeDeleteNode("DELETE", "/api/apim/{treeName}/filetree/{inode}", srv.FileTreeDeleteNode)
	add_FileTreeGetNode("GET", "/api/apim/{treeName}/filetree/{inode}", srv.FileTreeGetNode)
	add_FileTreeListNodes("GET", "/api/apim/{treeName}/filetree", srv.FileTreeListNodes)
	add_FileTreeMvCpNode("POST", "/api/apim/{treeName}/filetree/{inode}/actions/{action}", srv.FileTreeMvCpNode)
	add_FileTreeUpdateNode("PUT", "/api/apim/{treeName}/filetree/{inode}", srv.FileTreeUpdateNode)
	add_GetAPIAssetVersion("GET", "/api/api-assets/{assetID}/versions/{versionID}", srv.GetAPIAssetVersion)
	add_GetAPIAssets("GET", "/api/api-assets/{assetID}", srv.GetAPIAssets)
	add_GetAccess("GET", "/api/api-access/{accessID}", srv.GetAccess)
	add_GetClient("GET", "/api/api-clients/{clientID}", srv.GetClient)
	add_GetContract("GET", "/api/api-clients/{clientID}/contracts/{contractID}", srv.GetContract)
	add_GetInstantiations("GET", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/minors/{minor}/instantiations", srv.GetInstantiations)
	add_GetOperation("GET", "/api/apim/operations/{id}", srv.GetOperation)
	add_GetSLA("GET", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas/{slaID}", srv.GetSLA)
	add_ListAPIAssetVersions("GET", "/api/api-assets/{assetID}/versions", srv.ListAPIAssetVersions)
	add_ListAPIGateways("GET", "/api/api-assets/{assetID}/api-gateways", srv.ListAPIGateways)
	add_ListAccess("GET", "/api/api-access", srv.ListAccess)
	add_ListContract("GET", "/api/api-clients/{clientID}/contracts", srv.ListContract)
	add_ListContractRecords("GET", "/api/api-clients/{clientID}/contracts/{contractID}/operation-records", srv.ListContractRecords)
	add_ListInstantiations("GET", "/api/api-instantiations", srv.ListInstantiations)
	add_ListMyClients("GET", "/api/api-clients", srv.ListMyClients)
	add_ListProjectAPIGateways("GET", "/api/api-gateways/{projectID}", srv.ListProjectAPIGateways)
	add_ListRuntimeServices("GET", "/api/api-app-services/{appID}", srv.ListRuntimeServices)
	add_ListSLA("GET", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas", srv.ListSLA)
	add_ListSwaggerVersionClients("GET", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/clients", srv.ListSwaggerVersionClients)
	add_ListSwaggerVersions("GET", "/api/api-assets/{assetID}/swagger-versions", srv.ListSwaggerVersions)
	add_PUBLISH_ITEM_CERTIFICATION_GET("GET", "/api/publish-items/{publishItemId}/certification", srv.PUBLISH_ITEM_CERTIFICATION_GET)
	add_PUBLISH_ITEM_CHANNELS("GET", "/api/publish-items/{publishItemId}/statistics/channels", srv.PUBLISH_ITEM_CHANNELS)
	add_PUBLISH_ITEM_ERR_EFFACTS("GET", "/api/publish-items/{publishItemId}/err/effacts", srv.PUBLISH_ITEM_ERR_EFFACTS)
	add_PUBLISH_ITEM_ERR_LIST("GET", "/api/publish-items/{publishItemId}/err/list", srv.PUBLISH_ITEM_ERR_LIST)
	add_PUBLISH_ITEM_ERR_RATE("GET", "/api/publish-items/{publishItemId}/err/rate", srv.PUBLISH_ITEM_ERR_RATE)
	add_PUBLISH_ITEM_ERR_TREND("GET", "/api/publish-items/{publishItemId}/err/trend", srv.PUBLISH_ITEM_ERR_TREND)
	add_PUBLISH_ITEM_METIRCS_COMMON("GET", "/api/publish-items/{publishItemId}/metrics/{metricName}", srv.PUBLISH_ITEM_METIRCS_COMMON)
	add_PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON("GET", "/api/publish-items/{publishItemId}/metrics/{metricName}/histogram", srv.PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON)
	add_PUBLISH_ITEM_STATISTICS_TREND("GET", "/api/publish-items/{publishItemId}/statistics/trend", srv.PUBLISH_ITEM_STATISTICS_TREND)
	add_PUBLISH_ITEM_USERS("GET", "/api/publish-items/{publishItemId}/statistics/users", srv.PUBLISH_ITEM_USERS)
	add_PUBLISH_ITEM_VERSION_INFO_LIST("GET", "/api/publish-items/{publishItemId}/statistics/versions", srv.PUBLISH_ITEM_VERSION_INFO_LIST)
	add_PagingAPIAssets("GET", "/api/api-assets", srv.PagingAPIAssets)
	add_ProjectPackageExport("POST", "/api/orgs/{orgID}/projects/{projectID}/package/actions/export", srv.ProjectPackageExport)
	add_ProjectPackageImport("POST", "/api/orgs/{orgID}/projects/{projectID}/package/actions/import", srv.ProjectPackageImport)
	add_ProjectPackageParse("POST", "/api/projects/package/actions/parse", srv.ProjectPackageParse)
	add_ProjectTemplateExport("GET", "/api/orgs/{orgID}/projects/{projectID}/template/actions/export", srv.ProjectTemplateExport)
	add_ProjectTemplateImport("POST", "/api/orgs/{orgID}/projects/{projectID}/template/actions/import", srv.ProjectTemplateImport)
	add_ProjectTemplateParse("POST", "/api/projects/template/actions/parse", srv.ProjectTemplateParse)
	add_ProxyMetrics("GET", "/api/apim/metrics/**", srv.ProxyMetrics)
	add_QA_APITESTS_CANCEL("POST", "/api/apitests/actions/cancel-testplan", srv.QA_APITESTS_CANCEL)
	add_QA_APITESTS_GET("GET", "/api/apitests/{id}", srv.QA_APITESTS_GET)
	add_QA_APITESTS_UPDATE("PUT", "/api/apitests/{id}", srv.QA_APITESTS_UPDATE)
	add_QA_AUTOTEST_SPACE_GET("GET", "/api/autotests/spaces/{id}", srv.QA_AUTOTEST_SPACE_GET)
	add_QA_PIPELINE_TASK_LOGS("GET", "/api/apitests/pipeline/{pipelineID}/task/{taskID}/logs", srv.QA_PIPELINE_TASK_LOGS)
	add_QA_RECORDS_GET("GET", "/api/test-file-records/{id}", srv.QA_RECORDS_GET)
	add_QA_RECORDS_LIST("GET", "/api/test-file-records", srv.QA_RECORDS_LIST)
	add_QA_SONAR_GET_CREDENTIAL("GET", "/api/qa/actions/get-sonar-credential", srv.QA_SONAR_GET_CREDENTIAL)
	add_QA_SONAR_ISSUES("GET", "/api/qa", srv.QA_SONAR_ISSUES)
	add_QA_SONAR_METRIC_RULES_BATCH_DELETE("DELETE", "/api/sonar-metric-rules/actions/batch-delete", srv.QA_SONAR_METRIC_RULES_BATCH_DELETE)
	add_QA_SONAR_METRIC_RULES_BATCH_INSERT("POST", "/api/sonar-metric-rules/actions/batch-insert", srv.QA_SONAR_METRIC_RULES_BATCH_INSERT)
	add_QA_SONAR_METRIC_RULES_DELETE("DELETE", "/api/sonar-metric-rules/{ID}", srv.QA_SONAR_METRIC_RULES_DELETE)
	add_QA_SONAR_METRIC_RULES_GET("GET", "/api/sonar-metric-rules/{id}", srv.QA_SONAR_METRIC_RULES_GET)
	add_QA_SONAR_METRIC_RULES_PAGING("GET", "/api/sonar-metric-rules", srv.QA_SONAR_METRIC_RULES_PAGING)
	add_QA_SONAR_METRIC_RULES_QUERY_DEFINITION("GET", "/api/sonar-metric-rules/actions/query-metric-definition", srv.QA_SONAR_METRIC_RULES_QUERY_DEFINITION)
	add_QA_SONAR_METRIC_RULES_QUERY_LIST("GET", "/api/sonar-metric-rules/actions/query-list", srv.QA_SONAR_METRIC_RULES_QUERY_LIST)
	add_QA_SONAR_METRIC_RULES_UPDATE("PUT", "/api/sonar-metric-rules/{ID}", srv.QA_SONAR_METRIC_RULES_UPDATE)
	add_QA_TESTENV_CREATE("POST", "/api/testenv", srv.QA_TESTENV_CREATE)
	add_QA_TESTENV_DELETE("DELETE", "/api/testenv/{id}", srv.QA_TESTENV_DELETE)
	add_QA_TESTENV_GET("GET", "/api/testenv/{id}", srv.QA_TESTENV_GET)
	add_QA_TESTENV_LIST("GET", "/api/testenv/actions/list-envs", srv.QA_TESTENV_LIST)
	add_QA_TESTENV_UPDATE("PUT", "/api/testenv/{id}", srv.QA_TESTENV_UPDATE)
	add_QA_TESTPLAN_PIPELINE_DETAIL("GET", "/api/apitests/pipeline/{pipelineId}", srv.QA_TESTPLAN_PIPELINE_DETAIL)
	add_SPOT_APITESTS_LOGS("GET", "/api/apitests/logs", srv.SPOT_APITESTS_LOGS)
	add_SPOT_APITESTS_LOGS_DOWNLOAD("GET", "/api/apitests/logs/actions/download", srv.SPOT_APITESTS_LOGS_DOWNLOAD)
	add_SearchOperations("GET", "/api/apim/operations", srv.SearchOperations)
	add_UpdateAPIAssset("PUT", "/api/api-assets/{assetID}", srv.UpdateAPIAssset)
	add_UpdateAccess("PUT", "/api/api-access/{accessID}", srv.UpdateAccess)
	add_UpdateAssetVersion("PUT", "/api/api-assets/{assetID}/versions/{versionID}", srv.UpdateAssetVersion)
	add_UpdateClient("PUT", "/api/api-clients/{clientID}", srv.UpdateClient)
	add_UpdateContract("PUT", "/api/api-clients/{clientID}/contracts/{contractID}", srv.UpdateContract)
	add_UpdateInstantiation("PUT", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/minors/{minor}/instantiations/{instantiationID}", srv.UpdateInstantiation)
	add_UpdateSLA("PUT", "/api/api-assets/{assetID}/swagger-versions/{swaggerVersion}/slas/{slaID}", srv.UpdateSLA)
	add_ValidateSwagger("POST", "/api/apim/validate-swagger", srv.ValidateSwagger)
}
