// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: dop.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*AADAPTOR_CICD_CRON_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_BRANCHES_ALL_VALID_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_CANCEL_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_CONFIG_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_CONFIG_NAMESPACES_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_CONFIG_WORKSPACES_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_CRON_START_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_CRON_STOP_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_FETCH_PIPELINE_ID_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_GET_BRANCH_RULE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_PIPELINE_DETAIL_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_PROJECT_CREATE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_PROJECT_DETAIL_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_RERUN_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_RUN_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_TASK_LOG_DOWNLOAD_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADAPTOR_CICD_TASK_LOG_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APIAssetCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APIAssetGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APIAssetPagingResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APIAssetVersionCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APIAssetVersionInstanceCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APIDocCreateNodeReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APIDocWebsocket_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestEnvCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestEnvData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestEnvDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestEnvGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestEnvListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestEnvUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestEnvUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestsAttemptRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APITestsAttemptResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APPLICATIONS_RESOURCES_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*APP_PUBLISH_ITEM_RELATION_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AndroidCertificateAutoDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AndroidCertificateDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AndroidCertificateKeyDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AndroidCertificateKeyStoreDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AndroidCertificateManualDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AndroidCertificateManualKeyStoreDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApiTestCancelRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApiTestCancelResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApiTestInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApiTestsGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApiTestsUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApiTestsUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AppCertificateListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AppPublishItemRelation)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationCertificateDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationInitRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationStats)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationUpdateRequestBody)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationWorkspace)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Artifact)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AuditMessage)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestSpaceResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BaseModel)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BaseResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BlockoutConfig)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CICDPipelineYmlListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CICDPipelineYmlListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_BRANCH_RULE_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_CERTIFICATE_APP_CANCEL_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_CERTIFICATE_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_CERTIFICATE_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_ITERATION_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_ITERATION_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_LIBREFERENCE_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_LIBREFERENCE_LIST_VERSION_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_ORG_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_ORG_PUBLISHER_CREATE_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_ORG_PUBLISHER_CREATE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_ORG_RESOURCE_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_PUBLISHER_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_PUBLISHER_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_ROLES_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateFileDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateQuoteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CertificateUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CodeCoverageUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Comment)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CommentCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CommentCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CommentListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CommentListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CommentListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CommentUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CommentUpdateRequestBody)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CommentUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAPIAssetVersionBody)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAccessReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateBranchRuleRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateBranchRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateClientReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateContractReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateInstantiationReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateSLAReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DashboardSpotLogData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DashboardSpotLogLine)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DashboardSpotLogResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteAPIAssetVersion_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteAPIAssets_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteAccess_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteBranchRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteClient_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteSLAReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DownloadSpecTextReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ErrorResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExportProjectPackageRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExportProjectTemplateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FileTreeDeleteNode_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FileTreeGetNode_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FileTreeListNodes_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FileTreeMvCpNode_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FileTreeUpdateNode_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAPIAssetReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAPIAssetVersionReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAccess_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAddonInstanceDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAssetVersionRsp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetClientReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetContractReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetInstantiationsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOperationReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOperationURIParameters)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetSLAReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetSLARsp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetTestFileRecordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Header)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IOSCertificateDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IOSCertificateKeyChainP12DTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IOSCertificateKeyDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IRComment)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ISummary)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ISummaryState)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ImportProjectPackageRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ImportProjectTemplateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*InstanceDetailRes)(nil)
var _ urlenc.URLValuesUnmarshaler = (*InstanceReferenceRes)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Iteration)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IterationCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IterationCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IterationGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IterationPagingRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IterationPagingResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IterationUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IterationUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LibReference)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LibReferenceCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LibReferenceCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LibReferenceListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LibReferenceListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LibReferenceListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAPIGatewayRespData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAPIGatewaysReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAPIGatewaysResp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAccessReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAccessRsp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListContractRecordsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListContractRecordsRsp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListContractsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListContractsRsp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListInstantiations_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListMyClientsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListProjectAPIGatewaysReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListRuntimeServices_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListSLAsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListSLAsRsp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListSwaggerVersionClientsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListSwaggerVersionRsp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListSwaggerVersionsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListTestFileRecordsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListTestFileRecordsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberRoleListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MessageCertificateKeyDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MonitorKeys)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgFetchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgGetByDomainRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgGetByDomainResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgNexusGetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgNexusGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgNexusShowPasswordRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgNexusShowPasswordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgResourceInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgSearchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgSearchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OrgUpdateRequestBody)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_CERTIFICATION_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_ERR_EFFACTS_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_ERR_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_ERR_RATE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_ERR_TREND_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_METIRCS_COMMON_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_STATISTICS_TREND_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PUBLISH_ITEM_USERS_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingAPIAssetsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingAppCertificateDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingCertificateDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingOrgDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingProjectDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingPublisherDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineAppAllValidBranchWorkspaceResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCancelResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineConfigNamespacesFetchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCronDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCronListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCronStartResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCronStopResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineGetBranchRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineInvokedCombo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineInvokedComboRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineInvokedComboResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineOperateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineOperateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelinePageListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelinePageListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRerunFailedResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRerunResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRunResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTaskOperateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectDetailRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectPackageParse_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectPackageRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectResourceUsage)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectStats)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProxyMetrics_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsDetailData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsDetailRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsErrListData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsErrListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsErrTrendData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsErrTrendResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsTrendData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemStatisticsTrendResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublisherUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PushCertificateConfigs)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PushCertificateConfigsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_APITESTS_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_AUTOTEST_SPACE_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_PIPELINE_TASK_LOGS_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_RECORDS_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_SONAR_GET_CREDENTIAL_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_SONAR_ISSUES_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_SONAR_METRIC_RULES_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_TESTENV_CREATE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_TESTENV_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_TESTENV_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_TESTENV_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_TESTPLAN_PIPELINE_DETAIL_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAppPublishItemRelationResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryBranchRuleRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryBranchRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RoleInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RoleList)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SLAModel)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SPOT_APITESTS_LOGS_DOWNLOAD_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SPOT_APITESTS_LOGS_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SearchOperationQueryParameters)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SearchOperationsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarCredentialGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarMetricRuleDto)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarMetricRulesBatchDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarMetricRulesBatchInsertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarMetricRulesDefinitionListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarMetricRulesDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarMetricRulesListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarMetricRulesPagingRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarMetricRulesUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarStoreRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SonarStoreResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestFileRecord)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestIssuesStatistics)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Ticket)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketCloseRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketCloseResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketFetchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketFetchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketReopenRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketReopenResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketUpdateRequestBody)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TicketUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeFindAncestorsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeFuzzySearchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeGetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAPIAssetReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAccess_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAppPublishItemRelationRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAppPublishItemRelationResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAssetVersionReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateBranchRuleRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateBranchRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateClientReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateContract_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateInstantiationReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateSLAReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ValidBranch)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ValidateSwagger_Request)(nil)

// AADAPTOR_CICD_CRON_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *AADAPTOR_CICD_CRON_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_BRANCHES_ALL_VALID_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_BRANCHES_ALL_VALID_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_CANCEL_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_CANCEL_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				m.PipelineID = vals[0]
			}
		}
	}
	return nil
}

// ADAPTOR_CICD_CONFIG_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_CONFIG_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_CONFIG_NAMESPACES_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_CONFIG_NAMESPACES_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_CONFIG_WORKSPACES_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_CONFIG_WORKSPACES_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_CRON_START_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_CRON_START_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "cronID":
				m.CronID = vals[0]
			}
		}
	}
	return nil
}

// ADAPTOR_CICD_CRON_STOP_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_CRON_STOP_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "cronID":
				m.CronID = vals[0]
			}
		}
	}
	return nil
}

// ADAPTOR_CICD_FETCH_PIPELINE_ID_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_FETCH_PIPELINE_ID_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_FILETREE_GET_PIPELINE_FILETREE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_GET_BRANCH_RULE_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_GET_BRANCH_RULE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineid":
				m.Pipelineid = vals[0]
			}
		}
	}
	return nil
}

// ADAPTOR_CICD_PIPELINE_DETAIL_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_PIPELINE_DETAIL_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_PROJECT_CREATE_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_PROJECT_CREATE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_PROJECT_DETAIL_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_PROJECT_DETAIL_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ADAPTOR_CICD_RERUN_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_RERUN_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				m.PipelineID = vals[0]
			}
		}
	}
	return nil
}

// ADAPTOR_CICD_RUN_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_RUN_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				m.PipelineID = vals[0]
			}
		}
	}
	return nil
}

// ADAPTOR_CICD_TASK_LOG_DOWNLOAD_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_TASK_LOG_DOWNLOAD_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				m.PipelineID = vals[0]
			case "taskID":
				m.TaskID = vals[0]
			}
		}
	}
	return nil
}

// ADAPTOR_CICD_TASK_LOG_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADAPTOR_CICD_TASK_LOG_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				m.PipelineID = vals[0]
			case "taskID":
				m.TaskID = vals[0]
			}
		}
	}
	return nil
}

// APIAssetCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *APIAssetCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "assetID":
				m.AssetID = vals[0]
			case "assetName":
				m.AssetName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "source":
				m.Source = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			}
		}
	}
	return nil
}

// APIAssetGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *APIAssetGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// APIAssetPagingResponse implement urlenc.URLValuesUnmarshaler.
func (m *APIAssetPagingResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// APIAssetVersionCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *APIAssetVersionCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "aPIAssetID":
				m.APIAssetID = vals[0]
			case "major":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Major = val
			case "minor":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Minor = val
			case "patch":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Patch = val
			case "desc":
				m.Desc = vals[0]
			case "specProtocol":
				m.SpecProtocol = vals[0]
			case "specDiceFileUUID":
				m.SpecDiceFileUUID = vals[0]
			case "spec":
				m.Spec = vals[0]
			case "inode":
				m.Inode = vals[0]
			case "source":
				m.Source = vals[0]
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branch":
				m.Branch = vals[0]
			case "serviceName":
				m.ServiceName = vals[0]
			case "assetID":
				m.AssetID = vals[0]
			}
		}
	}
	return nil
}

// APIAssetVersionInstanceCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *APIAssetVersionInstanceCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "instanceType":
				m.InstanceType = vals[0]
			case "runtimeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RuntimeID = val
			case "serviceName":
				m.ServiceName = vals[0]
			case "endpointID":
				m.EndpointID = vals[0]
			case "uRL":
				m.URL = vals[0]
			case "assetID":
				m.AssetID = vals[0]
			case "versionID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.VersionID = val
			}
		}
	}
	return nil
}

// APIDocCreateNodeReq implement urlenc.URLValuesUnmarshaler.
func (m *APIDocCreateNodeReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			case "treeName":
				m.TreeName = vals[0]
			}
		}
	}
	return nil
}

// APIDocWebsocket_Request implement urlenc.URLValuesUnmarshaler.
func (m *APIDocWebsocket_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			}
		}
	}
	return nil
}

// APITestEnvCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *APITestEnvCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "aPITestEnvData":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.APITestEnvData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.APITestEnvData = val
					} else {
						m.APITestEnvData = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// APITestEnvData implement urlenc.URLValuesUnmarshaler.
func (m *APITestEnvData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "envID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EnvID = val
			case "envType":
				m.EnvType = vals[0]
			case "name":
				m.Name = vals[0]
			case "domain":
				m.Domain = vals[0]
			}
		}
	}
	return nil
}

// APITestEnvDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *APITestEnvDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// APITestEnvGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *APITestEnvGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// APITestEnvListResponse implement urlenc.URLValuesUnmarshaler.
func (m *APITestEnvListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// APITestEnvUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *APITestEnvUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "aPITestEnvData":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.APITestEnvData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.APITestEnvData = val
					} else {
						m.APITestEnvData = structpb.NewStringValue(vals[0])
					}
				}
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// APITestEnvUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *APITestEnvUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// APITestReq implement urlenc.URLValuesUnmarshaler.
func (m *APITestReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clientID":
				m.ClientID = vals[0]
			case "clientSecret":
				m.ClientSecret = vals[0]
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			}
		}
	}
	return nil
}

// APITestsAttemptRequest implement urlenc.URLValuesUnmarshaler.
func (m *APITestsAttemptRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectTestEnvID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectTestEnvID = val
			case "usecaseTestEnvID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UsecaseTestEnvID = val
			}
		}
	}
	return nil
}

// APITestsAttemptResponse implement urlenc.URLValuesUnmarshaler.
func (m *APITestsAttemptResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// APPLICATIONS_RESOURCES_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *APPLICATIONS_RESOURCES_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				m.ProjectID = vals[0]
			}
		}
	}
	return nil
}

// APP_PUBLISH_ITEM_RELATION_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *APP_PUBLISH_ITEM_RELATION_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "application":
				m.Application = vals[0]
			}
		}
	}
	return nil
}

// AndroidCertificateAutoDTO implement urlenc.URLValuesUnmarshaler.
func (m *AndroidCertificateAutoDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "oU":
				m.OU = vals[0]
			case "org":
				m.Org = vals[0]
			case "city":
				m.City = vals[0]
			case "province":
				m.Province = vals[0]
			case "state":
				m.State = vals[0]
			case "debugKeyStore":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.DebugKeyStore = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.DebugKeyStore = val
					} else {
						m.DebugKeyStore = structpb.NewStringValue(vals[0])
					}
				}
			case "releaseKeyStore":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ReleaseKeyStore = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ReleaseKeyStore = val
					} else {
						m.ReleaseKeyStore = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AndroidCertificateDTO implement urlenc.URLValuesUnmarshaler.
func (m *AndroidCertificateDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "isManualCreate":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsManualCreate = val
			case "manualInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ManualInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ManualInfo = val
					} else {
						m.ManualInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "autoInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AutoInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AutoInfo = val
					} else {
						m.AutoInfo = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AndroidCertificateKeyDTO implement urlenc.URLValuesUnmarshaler.
func (m *AndroidCertificateKeyDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "debugKeyStoreFile":
				m.DebugKeyStoreFile = vals[0]
			case "debugKeyStoreAlias":
				m.DebugKeyStoreAlias = vals[0]
			case "debugKeyPassword":
				m.DebugKeyPassword = vals[0]
			case "debugStorePassword":
				m.DebugStorePassword = vals[0]
			case "releaseKeyStoreFile":
				m.ReleaseKeyStoreFile = vals[0]
			case "releaseKeyStoreAlias":
				m.ReleaseKeyStoreAlias = vals[0]
			case "releaseKeyPassword":
				m.ReleaseKeyPassword = vals[0]
			case "releaseStorePassword":
				m.ReleaseStorePassword = vals[0]
			}
		}
	}
	return nil
}

// AndroidCertificateKeyStoreDTO implement urlenc.URLValuesUnmarshaler.
func (m *AndroidCertificateKeyStoreDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "alias":
				m.Alias = vals[0]
			case "keyPassword":
				m.KeyPassword = vals[0]
			case "storePassword":
				m.StorePassword = vals[0]
			}
		}
	}
	return nil
}

// AndroidCertificateManualDTO implement urlenc.URLValuesUnmarshaler.
func (m *AndroidCertificateManualDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "debugKeyStore":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.DebugKeyStore = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.DebugKeyStore = val
					} else {
						m.DebugKeyStore = structpb.NewStringValue(vals[0])
					}
				}
			case "releaseKeyStore":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ReleaseKeyStore = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ReleaseKeyStore = val
					} else {
						m.ReleaseKeyStore = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AndroidCertificateManualKeyStoreDTO implement urlenc.URLValuesUnmarshaler.
func (m *AndroidCertificateManualKeyStoreDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "certificateFileDTO":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.CertificateFileDTO = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.CertificateFileDTO = val
					} else {
						m.CertificateFileDTO = structpb.NewStringValue(vals[0])
					}
				}
			case "androidCertificateKeyStoreDTO":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AndroidCertificateKeyStoreDTO = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AndroidCertificateKeyStoreDTO = val
					} else {
						m.AndroidCertificateKeyStoreDTO = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApiTestCancelRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApiTestCancelRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			}
		}
	}
	return nil
}

// ApiTestCancelResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApiTestCancelResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// ApiTestInfo implement urlenc.URLValuesUnmarshaler.
func (m *ApiTestInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "apiID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApiID = val
			case "usecaseID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UsecaseID = val
			case "usecaseOrder":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UsecaseOrder = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "status":
				m.Status = vals[0]
			case "apiInfo":
				m.ApiInfo = vals[0]
			case "apiRequest":
				m.ApiRequest = vals[0]
			case "apiResponse":
				m.ApiResponse = vals[0]
			case "assertResult":
				m.AssertResult = vals[0]
			}
		}
	}
	return nil
}

// ApiTestsGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApiTestsGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApiTestsUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApiTestsUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "apiTestInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ApiTestInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ApiTestInfo = val
					} else {
						m.ApiTestInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "isResult":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsResult = val
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// ApiTestsUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApiTestsUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AppCertificateListRequest implement urlenc.URLValuesUnmarshaler.
func (m *AppCertificateListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "status":
				m.Status = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// AppPublishItemRelation implement urlenc.URLValuesUnmarshaler.
func (m *AppPublishItemRelation) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "env":
				m.Env = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "appID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "publishItemID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemID = val
			case "publishItemName":
				m.PublishItemName = vals[0]
			case "publisherID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublisherID = val
			case "publisherName":
				m.PublisherName = vals[0]
			case "publishItemNs":
				m.PublishItemNs = vals
			case "aK":
				m.AK = vals[0]
			case "aI":
				m.AI = vals[0]
			}
		}
	}
	return nil
}

// ApplicationCertificateDTO implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationCertificateDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "certificateID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CertificateID = val
			case "approvalID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApprovalID = val
			case "name":
				m.Name = vals[0]
			case "type":
				m.Type = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "status":
				m.Status = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "operator":
				m.Operator = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "androidInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AndroidInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AndroidInfo = val
					} else {
						m.AndroidInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "iOSInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IOSInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IOSInfo = val
					} else {
						m.IOSInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "messageInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MessageInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MessageInfo = val
					} else {
						m.MessageInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "pushConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.PushConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.PushConfig = val
					} else {
						m.PushConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// ApplicationCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "mode":
				m.Mode = vals[0]
			case "isExternalRepo":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsExternalRepo = val
			case "repoConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.RepoConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.RepoConfig = val
					} else {
						m.RepoConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "sonarConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.SonarConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.SonarConfig = val
					} else {
						m.SonarConfig = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApplicationCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApplicationDTO implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "mode":
				m.Mode = vals[0]
			case "pined":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Pined = val
			case "desc":
				m.Desc = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "creator":
				m.Creator = vals[0]
			case "unBlockStart":
				if m.UnBlockStart == nil {
					m.UnBlockStart = &timestamppb.Timestamp{}
				}
			case "unBlockStart.seconds":
				if m.UnBlockStart == nil {
					m.UnBlockStart = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UnBlockStart.Seconds = val
			case "unBlockStart.nanos":
				if m.UnBlockStart == nil {
					m.UnBlockStart = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UnBlockStart.Nanos = int32(val)
			case "unBlockEnd":
				if m.UnBlockEnd == nil {
					m.UnBlockEnd = &timestamppb.Timestamp{}
				}
			case "unBlockEnd.seconds":
				if m.UnBlockEnd == nil {
					m.UnBlockEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UnBlockEnd.Seconds = val
			case "unBlockEnd.nanos":
				if m.UnBlockEnd == nil {
					m.UnBlockEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UnBlockEnd.Nanos = int32(val)
			case "blockStatus":
				m.BlockStatus = vals[0]
			case "stats":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Stats = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Stats = val
					} else {
						m.Stats = structpb.NewStringValue(vals[0])
					}
				}
			case "gitRepo":
				m.GitRepo = vals[0]
			case "gitRepoAbbrev":
				m.GitRepoAbbrev = vals[0]
			case "gitRepoNew":
				m.GitRepoNew = vals[0]
			case "token":
				m.Token = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "orgName":
				m.OrgName = vals[0]
			case "orgDisplayName":
				m.OrgDisplayName = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "projectDisplayName":
				m.ProjectDisplayName = vals[0]
			case "isExternalRepo":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsExternalRepo = val
			case "repoConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.RepoConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.RepoConfig = val
					} else {
						m.RepoConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "sonarConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.SonarConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.SonarConfig = val
					} else {
						m.SonarConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "memberRoles":
				m.MemberRoles = vals
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "extra":
				m.Extra = vals[0]
			}
		}
	}
	return nil
}

// ApplicationDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				m.ProjectID = vals[0]
			case "applicationId":
				m.ApplicationId = vals[0]
			}
		}
	}
	return nil
}

// ApplicationDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApplicationInitRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationInitRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "applicationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "mobileAppName":
				m.MobileAppName = vals[0]
			case "mobileDisplayName":
				m.MobileDisplayName = vals[0]
			case "bundleID":
				m.BundleID = vals[0]
			case "packageName":
				m.PackageName = vals[0]
			}
		}
	}
	return nil
}

// ApplicationStats implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationStats) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "countRuntimes":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CountRuntimes = val
			case "countMembers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CountMembers = val
			case "timeLastModified":
				m.TimeLastModified = vals[0]
			}
		}
	}
	return nil
}

// ApplicationUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApplicationUpdateRequestBody implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationUpdateRequestBody) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "repoConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.RepoConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.RepoConfig = val
					} else {
						m.RepoConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "sonarConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.SonarConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.SonarConfig = val
					} else {
						m.SonarConfig = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApplicationUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApplicationWorkspace implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationWorkspace) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			case "workspace":
				m.Workspace = vals[0]
			case "configNamespace":
				m.ConfigNamespace = vals[0]
			}
		}
	}
	return nil
}

// Artifact implement urlenc.URLValuesUnmarshaler.
func (m *Artifact) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			}
		}
	}
	return nil
}

// AuditMessage implement urlenc.URLValuesUnmarshaler.
func (m *AuditMessage) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "messageZH":
				m.MessageZH = vals[0]
			case "messageEN":
				m.MessageEN = vals[0]
			}
		}
	}
	return nil
}

// AutoTestSpaceResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestSpaceResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// BaseModel implement urlenc.URLValuesUnmarshaler.
func (m *BaseModel) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "creatorID":
				m.CreatorID = vals[0]
			case "updaterID":
				m.UpdaterID = vals[0]
			}
		}
	}
	return nil
}

// BaseResponse implement urlenc.URLValuesUnmarshaler.
func (m *BaseResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "success":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Success = val
			case "err":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Err = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Err = val
					} else {
						m.Err = structpb.NewStringValue(vals[0])
					}
				}
			case "data":
				list := make([]uint32, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 32)
					if err != nil {
						return err
					}
					list = append(list, uint32(val))
				}
				m.Data = list
			}
		}
	}
	return nil
}

// BlockoutConfig implement urlenc.URLValuesUnmarshaler.
func (m *BlockoutConfig) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "blockDEV":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.BlockDEV = val
			case "blockTEST":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.BlockTEST = val
			case "blockStage":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.BlockStage = val
			case "blockProd":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.BlockProd = val
			}
		}
	}
	return nil
}

// CICDPipelineYmlListRequest implement urlenc.URLValuesUnmarshaler.
func (m *CICDPipelineYmlListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branch":
				m.Branch = vals[0]
			}
		}
	}
	return nil
}

// CICDPipelineYmlListResponse implement urlenc.URLValuesUnmarshaler.
func (m *CICDPipelineYmlListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals
			}
		}
	}
	return nil
}

// CMDB_BRANCH_RULE_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_BRANCH_RULE_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// CMDB_CERTIFICATE_APP_CANCEL_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_CERTIFICATE_APP_CANCEL_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_CERTIFICATE_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_CERTIFICATE_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "certificatesID":
				m.CertificatesID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_CERTIFICATE_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_CERTIFICATE_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "certificateID":
				m.CertificateID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_ITERATION_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_ITERATION_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// CMDB_ITERATION_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_ITERATION_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// CMDB_LIBREFERENCE_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_LIBREFERENCE_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// CMDB_LIBREFERENCE_LIST_VERSION_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_LIBREFERENCE_LIST_VERSION_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_ORG_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_ORG_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				m.OrgID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_ORG_PUBLISHER_CREATE_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_ORG_PUBLISHER_CREATE_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				m.OrgID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_ORG_PUBLISHER_CREATE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_ORG_PUBLISHER_CREATE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				m.OrgID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_ORG_RESOURCE_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_ORG_RESOURCE_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_PUBLISHER_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_PUBLISHER_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publisherID":
				m.PublisherID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_PUBLISHER_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_PUBLISHER_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publisherID":
				m.PublisherID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_ROLES_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_ROLES_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CertificateCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *CertificateCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "type":
				m.Type = vals[0]
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "androidInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AndroidInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AndroidInfo = val
					} else {
						m.AndroidInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "iOSInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IOSInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IOSInfo = val
					} else {
						m.IOSInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "messageInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MessageInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MessageInfo = val
					} else {
						m.MessageInfo = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CertificateCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *CertificateCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CertificateDTO implement urlenc.URLValuesUnmarshaler.
func (m *CertificateDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "type":
				m.Type = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "creator":
				m.Creator = vals[0]
			case "operator":
				m.Operator = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "androidInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AndroidInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AndroidInfo = val
					} else {
						m.AndroidInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "iOSInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IOSInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IOSInfo = val
					} else {
						m.IOSInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "messageInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MessageInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MessageInfo = val
					} else {
						m.MessageInfo = structpb.NewStringValue(vals[0])
					}
				}
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// CertificateDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *CertificateDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CertificateDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *CertificateDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "certificateDTO":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.CertificateDTO = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.CertificateDTO = val
					} else {
						m.CertificateDTO = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CertificateFileDTO implement urlenc.URLValuesUnmarshaler.
func (m *CertificateFileDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "uUID":
				m.UUID = vals[0]
			case "fileName":
				m.FileName = vals[0]
			}
		}
	}
	return nil
}

// CertificateListRequest implement urlenc.URLValuesUnmarshaler.
func (m *CertificateListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "query":
				m.Query = vals[0]
			case "name":
				m.Name = vals[0]
			case "type":
				m.Type = vals[0]
			case "status":
				m.Status = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// CertificateListResponse implement urlenc.URLValuesUnmarshaler.
func (m *CertificateListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CertificateQuoteRequest implement urlenc.URLValuesUnmarshaler.
func (m *CertificateQuoteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "certificateID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CertificateID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			}
		}
	}
	return nil
}

// CertificateUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *CertificateUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "uUID":
				m.UUID = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "filename":
				m.Filename = vals[0]
			case "certificateID":
				m.CertificateID = vals[0]
			}
		}
	}
	return nil
}

// CertificateUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *CertificateUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CodeCoverageUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *CodeCoverageUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "status":
				m.Status = vals[0]
			case "msg":
				m.Msg = vals[0]
			case "reportXmlUUID":
				m.ReportXmlUUID = vals[0]
			case "reportTarUrl":
				m.ReportTarUrl = vals[0]
			}
		}
	}
	return nil
}

// Comment implement urlenc.URLValuesUnmarshaler.
func (m *Comment) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "commentID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CommentID = val
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			case "commentType":
				m.CommentType = vals[0]
			case "content":
				m.Content = vals[0]
			case "iRComment":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IRComment = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IRComment = val
					} else {
						m.IRComment = structpb.NewStringValue(vals[0])
					}
				}
			case "userID":
				m.UserID = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// CommentCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *CommentCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			case "commentType":
				m.CommentType = vals[0]
			case "content":
				m.Content = vals[0]
			case "iRComment":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IRComment = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IRComment = val
					} else {
						m.IRComment = structpb.NewStringValue(vals[0])
					}
				}
			case "userID":
				m.UserID = vals[0]
			}
		}
	}
	return nil
}

// CommentCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *CommentCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// CommentListRequest implement urlenc.URLValuesUnmarshaler.
func (m *CommentListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			}
		}
	}
	return nil
}

// CommentListResponse implement urlenc.URLValuesUnmarshaler.
func (m *CommentListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CommentListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *CommentListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// CommentUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *CommentUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "commentID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CommentID = val
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CommentUpdateRequestBody implement urlenc.URLValuesUnmarshaler.
func (m *CommentUpdateRequestBody) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "content":
				m.Content = vals[0]
			}
		}
	}
	return nil
}

// CommentUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *CommentUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// CreateAPIAssetVersionBody implement urlenc.URLValuesUnmarshaler.
func (m *CreateAPIAssetVersionBody) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "assetID":
				m.AssetID = vals[0]
			case "major":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Major = val
			case "minor":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Minor = val
			case "patch":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Patch = val
			case "specProtocol":
				m.SpecProtocol = vals[0]
			case "specDiceFileUUID":
				m.SpecDiceFileUUID = vals[0]
			}
		}
	}
	return nil
}

// CreateAccessReq implement urlenc.URLValuesUnmarshaler.
func (m *CreateAccessReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CreateBranchRuleRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateBranchRuleRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScopeID = val
			case "rule":
				m.Rule = vals[0]
			case "isProtect":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsProtect = val
			case "needApproval":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NeedApproval = val
			case "isTriggerPipeline":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsTriggerPipeline = val
			case "workspace":
				m.Workspace = vals[0]
			case "artifactWorkspace":
				m.ArtifactWorkspace = vals[0]
			case "desc":
				m.Desc = vals[0]
			}
		}
	}
	return nil
}

// CreateBranchRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateBranchRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CreateClientReq implement urlenc.URLValuesUnmarshaler.
func (m *CreateClientReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CreateContractReq implement urlenc.URLValuesUnmarshaler.
func (m *CreateContractReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			case "clientID":
				m.ClientID = vals[0]
			}
		}
	}
	return nil
}

// CreateInstantiationReq implement urlenc.URLValuesUnmarshaler.
func (m *CreateInstantiationReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			case "minor":
				m.Minor = vals[0]
			}
		}
	}
	return nil
}

// CreateSLAReq implement urlenc.URLValuesUnmarshaler.
func (m *CreateSLAReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			}
		}
	}
	return nil
}

// DashboardSpotLogData implement urlenc.URLValuesUnmarshaler.
func (m *DashboardSpotLogData) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DashboardSpotLogLine implement urlenc.URLValuesUnmarshaler.
func (m *DashboardSpotLogLine) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "source":
				m.Source = vals[0]
			case "stream":
				m.Stream = vals[0]
			case "timeStamp":
				m.TimeStamp = vals[0]
			case "content":
				m.Content = vals[0]
			case "offset":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Offset = val
			case "level":
				m.Level = vals[0]
			case "requestID":
				m.RequestID = vals[0]
			}
		}
	}
	return nil
}

// DashboardSpotLogResponse implement urlenc.URLValuesUnmarshaler.
func (m *DashboardSpotLogResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// DeleteAPIAssetVersion_Request implement urlenc.URLValuesUnmarshaler.
func (m *DeleteAPIAssetVersion_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "assetID":
				m.AssetID = vals[0]
			case "versionID":
				m.VersionID = vals[0]
			}
		}
	}
	return nil
}

// DeleteAPIAssets_Request implement urlenc.URLValuesUnmarshaler.
func (m *DeleteAPIAssets_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "assetID":
				m.AssetID = vals[0]
			}
		}
	}
	return nil
}

// DeleteAccess_Request implement urlenc.URLValuesUnmarshaler.
func (m *DeleteAccess_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "accessID":
				m.AccessID = vals[0]
			}
		}
	}
	return nil
}

// DeleteBranchRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteBranchRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// DeleteClient_Request implement urlenc.URLValuesUnmarshaler.
func (m *DeleteClient_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clientID":
				m.ClientID = vals[0]
			}
		}
	}
	return nil
}

// DeleteSLAReq implement urlenc.URLValuesUnmarshaler.
func (m *DeleteSLAReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			case "slaID":
				m.SlaID = vals[0]
			}
		}
	}
	return nil
}

// DownloadSpecTextReq implement urlenc.URLValuesUnmarshaler.
func (m *DownloadSpecTextReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "versionID":
				m.VersionID = vals[0]
			}
		}
	}
	return nil
}

// ErrorResponse implement urlenc.URLValuesUnmarshaler.
func (m *ErrorResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "code":
				m.Code = vals[0]
			case "msg":
				m.Msg = vals[0]
			case "ctx":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Ctx = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Ctx = val
					} else {
						m.Ctx = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ExportProjectPackageRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExportProjectPackageRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectPackageRequest":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ProjectPackageRequest = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ProjectPackageRequest = val
					} else {
						m.ProjectPackageRequest = structpb.NewStringValue(vals[0])
					}
				}
			case "orgID":
				m.OrgID = vals[0]
			case "projectID":
				m.ProjectID = vals[0]
			}
		}
	}
	return nil
}

// ExportProjectTemplateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExportProjectTemplateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "projectDisplayName":
				m.ProjectDisplayName = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// FileTreeDeleteNode_Request implement urlenc.URLValuesUnmarshaler.
func (m *FileTreeDeleteNode_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "treeName":
				m.TreeName = vals[0]
			case "inode":
				m.Inode = vals[0]
			}
		}
	}
	return nil
}

// FileTreeGetNode_Request implement urlenc.URLValuesUnmarshaler.
func (m *FileTreeGetNode_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "treeName":
				m.TreeName = vals[0]
			case "inode":
				m.Inode = vals[0]
			}
		}
	}
	return nil
}

// FileTreeListNodes_Request implement urlenc.URLValuesUnmarshaler.
func (m *FileTreeListNodes_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "treeName":
				m.TreeName = vals[0]
			}
		}
	}
	return nil
}

// FileTreeMvCpNode_Request implement urlenc.URLValuesUnmarshaler.
func (m *FileTreeMvCpNode_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "treeName":
				m.TreeName = vals[0]
			case "inode":
				m.Inode = vals[0]
			case "action":
				m.Action = vals[0]
			}
		}
	}
	return nil
}

// FileTreeUpdateNode_Request implement urlenc.URLValuesUnmarshaler.
func (m *FileTreeUpdateNode_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "treeName":
				m.TreeName = vals[0]
			case "inode":
				m.Inode = vals[0]
			}
		}
	}
	return nil
}

// GetAPIAssetReq implement urlenc.URLValuesUnmarshaler.
func (m *GetAPIAssetReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			}
		}
	}
	return nil
}

// GetAPIAssetVersionReq implement urlenc.URLValuesUnmarshaler.
func (m *GetAPIAssetVersionReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "versionID":
				m.VersionID = vals[0]
			}
		}
	}
	return nil
}

// GetAccess_Request implement urlenc.URLValuesUnmarshaler.
func (m *GetAccess_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "accessID":
				m.AccessID = vals[0]
			}
		}
	}
	return nil
}

// GetAddonInstanceDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAddonInstanceDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GetAssetVersionRsp implement urlenc.URLValuesUnmarshaler.
func (m *GetAssetVersionRsp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "asset":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Asset = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Asset = val
					} else {
						m.Asset = structpb.NewStringValue(vals[0])
					}
				}
			case "version":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Version = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Version = val
					} else {
						m.Version = structpb.NewStringValue(vals[0])
					}
				}
			case "spec":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Spec = val
					} else {
						m.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "hasInstantiation":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.HasInstantiation = val
			case "hasAccess":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.HasAccess = val
			case "access":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Access = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Access = val
					} else {
						m.Access = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GetClientReq implement urlenc.URLValuesUnmarshaler.
func (m *GetClientReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "clientID":
				m.ClientID = vals[0]
			}
		}
	}
	return nil
}

// GetContractReq implement urlenc.URLValuesUnmarshaler.
func (m *GetContractReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "clientID":
				m.ClientID = vals[0]
			case "contractID":
				m.ContractID = vals[0]
			}
		}
	}
	return nil
}

// GetInstantiationsReq implement urlenc.URLValuesUnmarshaler.
func (m *GetInstantiationsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			case "minor":
				m.Minor = vals[0]
			}
		}
	}
	return nil
}

// GetOperationReq implement urlenc.URLValuesUnmarshaler.
func (m *GetOperationReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// GetOperationURIParameters implement urlenc.URLValuesUnmarshaler.
func (m *GetOperationURIParameters) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			}
		}
	}
	return nil
}

// GetSLAReq implement urlenc.URLValuesUnmarshaler.
func (m *GetSLAReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			}
		}
	}
	return nil
}

// GetSLARsp implement urlenc.URLValuesUnmarshaler.
func (m *GetSLARsp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "sLAModel":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.SLAModel = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.SLAModel = val
					} else {
						m.SLAModel = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "assetName":
				m.AssetName = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			case "userTo":
				m.UserTo = vals[0]
			case "default":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Default = val
			case "clientCount":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ClientCount = val
			}
		}
	}
	return nil
}

// GetTestFileRecordResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetTestFileRecordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// Header implement urlenc.URLValuesUnmarshaler.
func (m *Header) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "success":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Success = val
			case "error":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Error = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Error = val
					} else {
						m.Error = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// IOSCertificateDTO implement urlenc.URLValuesUnmarshaler.
func (m *IOSCertificateDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "debugProvisionFile":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.DebugProvisionFile = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.DebugProvisionFile = val
					} else {
						m.DebugProvisionFile = structpb.NewStringValue(vals[0])
					}
				}
			case "releaseProvisionFile":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ReleaseProvisionFile = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ReleaseProvisionFile = val
					} else {
						m.ReleaseProvisionFile = structpb.NewStringValue(vals[0])
					}
				}
			case "keyChainP12":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.KeyChainP12 = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.KeyChainP12 = val
					} else {
						m.KeyChainP12 = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// IOSCertificateKeyChainP12DTO implement urlenc.URLValuesUnmarshaler.
func (m *IOSCertificateKeyChainP12DTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "certificateFileDTO":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.CertificateFileDTO = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.CertificateFileDTO = val
					} else {
						m.CertificateFileDTO = structpb.NewStringValue(vals[0])
					}
				}
			case "password":
				m.Password = vals[0]
			}
		}
	}
	return nil
}

// IOSCertificateKeyDTO implement urlenc.URLValuesUnmarshaler.
func (m *IOSCertificateKeyDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "keyChainP12File":
				m.KeyChainP12File = vals[0]
			case "keyChainP12Password":
				m.KeyChainP12Password = vals[0]
			case "debugMobileProvision":
				m.DebugMobileProvision = vals[0]
			case "releaseMobileProvision":
				m.ReleaseMobileProvision = vals[0]
			}
		}
	}
	return nil
}

// IRComment implement urlenc.URLValuesUnmarshaler.
func (m *IRComment) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "iterationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "issueID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "issueTitle":
				m.IssueTitle = vals[0]
			case "issueType":
				m.IssueType = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// ISummary implement urlenc.URLValuesUnmarshaler.
func (m *ISummary) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "requirement":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Requirement = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Requirement = val
					} else {
						m.Requirement = structpb.NewStringValue(vals[0])
					}
				}
			case "task":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Task = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Task = val
					} else {
						m.Task = structpb.NewStringValue(vals[0])
					}
				}
			case "bug":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Bug = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Bug = val
					} else {
						m.Bug = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ISummaryState implement urlenc.URLValuesUnmarshaler.
func (m *ISummaryState) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "done":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Done = val
			case "unDone":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UnDone = val
			}
		}
	}
	return nil
}

// ImportProjectPackageRequest implement urlenc.URLValuesUnmarshaler.
func (m *ImportProjectPackageRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectPackageRequest":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ProjectPackageRequest = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ProjectPackageRequest = val
					} else {
						m.ProjectPackageRequest = structpb.NewStringValue(vals[0])
					}
				}
			case "orgID":
				m.OrgID = vals[0]
			case "projectID":
				m.ProjectID = vals[0]
			}
		}
	}
	return nil
}

// ImportProjectTemplateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ImportProjectTemplateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "projectDisplayName":
				m.ProjectDisplayName = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// InstanceDetailRes implement urlenc.URLValuesUnmarshaler.
func (m *InstanceDetailRes) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "instanceName":
				m.InstanceName = vals[0]
			case "addonName":
				m.AddonName = vals[0]
			case "projectName":
				m.ProjectName = vals[0]
			case "logoURL":
				m.LogoURL = vals[0]
			case "status":
				m.Status = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "env":
				m.Env = vals[0]
			case "envCn":
				m.EnvCn = vals[0]
			case "version":
				m.Version = vals[0]
			case "attachCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AttachCount = val
			case "planCnName":
				m.PlanCnName = vals[0]
			case "createAt":
				m.CreateAt = vals[0]
			case "platform":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Platform = val
			case "projectID":
				m.ProjectID = vals[0]
			case "canDel":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CanDel = val
			}
		}
	}
	return nil
}

// InstanceReferenceRes implement urlenc.URLValuesUnmarshaler.
func (m *InstanceReferenceRes) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				m.OrgID = vals[0]
			case "projectID":
				m.ProjectID = vals[0]
			case "projectName":
				m.ProjectName = vals[0]
			case "applicationID":
				m.ApplicationID = vals[0]
			case "applicationName":
				m.ApplicationName = vals[0]
			case "runtimeID":
				m.RuntimeID = vals[0]
			case "runtimeName":
				m.RuntimeName = vals[0]
			}
		}
	}
	return nil
}

// Iteration implement urlenc.URLValuesUnmarshaler.
func (m *Iteration) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "startedAt":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
			case "startedAt.seconds":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartedAt.Seconds = val
			case "startedAt.nanos":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.StartedAt.Nanos = int32(val)
			case "finishedAt":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
			case "finishedAt.seconds":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FinishedAt.Seconds = val
			case "finishedAt.nanos":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.FinishedAt.Nanos = int32(val)
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "state":
				m.State = vals[0]
			case "issueSummary":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IssueSummary = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IssueSummary = val
					} else {
						m.IssueSummary = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// IterationCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *IterationCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "startedAt":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
			case "startedAt.seconds":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartedAt.Seconds = val
			case "startedAt.nanos":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.StartedAt.Nanos = int32(val)
			case "finishedAt":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
			case "finishedAt.seconds":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FinishedAt.Seconds = val
			case "finishedAt.nanos":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.FinishedAt.Nanos = int32(val)
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			}
		}
	}
	return nil
}

// IterationCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *IterationCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// IterationGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *IterationGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// IterationPagingRequest implement urlenc.URLValuesUnmarshaler.
func (m *IterationPagingRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "deadline":
				m.Deadline = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "state":
				m.State = vals[0]
			case "withoutIssueSummary":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.WithoutIssueSummary = val
			case "IDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IDs = list
			}
		}
	}
	return nil
}

// IterationPagingResponse implement urlenc.URLValuesUnmarshaler.
func (m *IterationPagingResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// IterationUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *IterationUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "startedAt":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
			case "startedAt.seconds":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartedAt.Seconds = val
			case "startedAt.nanos":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.StartedAt.Nanos = int32(val)
			case "finishedAt":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
			case "finishedAt.seconds":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FinishedAt.Seconds = val
			case "finishedAt.nanos":
				if m.FinishedAt == nil {
					m.FinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.FinishedAt.Nanos = int32(val)
			case "state":
				m.State = vals[0]
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// IterationUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *IterationUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// LibReference implement urlenc.URLValuesUnmarshaler.
func (m *LibReference) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "libID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.LibID = val
			case "libName":
				m.LibName = vals[0]
			case "libDesc":
				m.LibDesc = vals[0]
			case "approvalID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApprovalID = val
			case "approvalStatus":
				m.ApprovalStatus = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// LibReferenceCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *LibReferenceCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "appName":
				m.AppName = vals[0]
			case "libID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.LibID = val
			case "libName":
				m.LibName = vals[0]
			case "libDesc":
				m.LibDesc = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// LibReferenceCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *LibReferenceCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// LibReferenceListRequest implement urlenc.URLValuesUnmarshaler.
func (m *LibReferenceListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "libID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.LibID = val
			case "approvalStatus":
				m.ApprovalStatus = vals[0]
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// LibReferenceListResponse implement urlenc.URLValuesUnmarshaler.
func (m *LibReferenceListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// LibReferenceListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *LibReferenceListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ListAPIGatewayRespData implement urlenc.URLValuesUnmarshaler.
func (m *ListAPIGatewayRespData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ListAPIGatewaysReq implement urlenc.URLValuesUnmarshaler.
func (m *ListAPIGatewaysReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			}
		}
	}
	return nil
}

// ListAPIGatewaysResp implement urlenc.URLValuesUnmarshaler.
func (m *ListAPIGatewaysResp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ListAccessReq implement urlenc.URLValuesUnmarshaler.
func (m *ListAccessReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ListAccessRsp implement urlenc.URLValuesUnmarshaler.
func (m *ListAccessRsp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ListContractRecordsReq implement urlenc.URLValuesUnmarshaler.
func (m *ListContractRecordsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "clientID":
				m.ClientID = vals[0]
			case "contractID":
				m.ContractID = vals[0]
			}
		}
	}
	return nil
}

// ListContractRecordsRsp implement urlenc.URLValuesUnmarshaler.
func (m *ListContractRecordsRsp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ListContractsReq implement urlenc.URLValuesUnmarshaler.
func (m *ListContractsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			case "clientID":
				m.ClientID = vals[0]
			}
		}
	}
	return nil
}

// ListContractsRsp implement urlenc.URLValuesUnmarshaler.
func (m *ListContractsRsp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ListInstantiations_Request implement urlenc.URLValuesUnmarshaler.
func (m *ListInstantiations_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ListMyClientsReq implement urlenc.URLValuesUnmarshaler.
func (m *ListMyClientsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ListProjectAPIGatewaysReq implement urlenc.URLValuesUnmarshaler.
func (m *ListProjectAPIGatewaysReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "projectID":
				m.ProjectID = vals[0]
			}
		}
	}
	return nil
}

// ListRuntimeServices_Request implement urlenc.URLValuesUnmarshaler.
func (m *ListRuntimeServices_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				m.AppID = vals[0]
			}
		}
	}
	return nil
}

// ListSLAsReq implement urlenc.URLValuesUnmarshaler.
func (m *ListSLAsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			case "slaID":
				m.SlaID = vals[0]
			}
		}
	}
	return nil
}

// ListSLAsRsp implement urlenc.URLValuesUnmarshaler.
func (m *ListSLAsRsp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ListSwaggerVersionClientsReq implement urlenc.URLValuesUnmarshaler.
func (m *ListSwaggerVersionClientsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			}
		}
	}
	return nil
}

// ListSwaggerVersionRsp implement urlenc.URLValuesUnmarshaler.
func (m *ListSwaggerVersionRsp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ListSwaggerVersionsReq implement urlenc.URLValuesUnmarshaler.
func (m *ListSwaggerVersionsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			}
		}
	}
	return nil
}

// ListTestFileRecordsRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListTestFileRecordsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "projectIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ProjectIDs = list
			case "projectName":
				m.ProjectName = vals[0]
			case "projectDisplayName":
				m.ProjectDisplayName = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "spaceID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SpaceID = val
			case "types":
				m.Types = vals
			case "locale":
				m.Locale = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "asc":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Asc = val
			}
		}
	}
	return nil
}

// ListTestFileRecordsResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListTestFileRecordsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// MemberRoleListResponse implement urlenc.URLValuesUnmarshaler.
func (m *MemberRoleListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// MessageCertificateKeyDTO implement urlenc.URLValuesUnmarshaler.
func (m *MessageCertificateKeyDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "key":
				m.Key = vals[0]
			}
		}
	}
	return nil
}

// MonitorKeys implement urlenc.URLValuesUnmarshaler.
func (m *MonitorKeys) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "aK":
				m.AK = vals[0]
			case "aI":
				m.AI = vals[0]
			case "env":
				m.Env = vals[0]
			case "appID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			}
		}
	}
	return nil
}

// OrgCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *OrgCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "logo":
				m.Logo = vals[0]
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "locale":
				m.Locale = vals[0]
			case "admins":
				m.Admins = vals
			case "publisherName":
				m.PublisherName = vals[0]
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "type":
				m.Type = vals[0]
			}
		}
	}
	return nil
}

// OrgCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *OrgCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// OrgDTO implement urlenc.URLValuesUnmarshaler.
func (m *OrgDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "creator":
				m.Creator = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "locale":
				m.Locale = vals[0]
			case "config":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config = val
					} else {
						m.Config = structpb.NewStringValue(vals[0])
					}
				}
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "blockoutConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.BlockoutConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.BlockoutConfig = val
					} else {
						m.BlockoutConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "enableReleaseCrossCluster":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.EnableReleaseCrossCluster = val
			case "selected":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Selected = val
			case "operation":
				m.Operation = vals[0]
			case "status":
				m.Status = vals[0]
			case "type":
				m.Type = vals[0]
			case "publisherID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublisherID = val
			case "domain":
				m.Domain = vals[0]
			case "openFdp":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.OpenFdp = val
			case "version":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Version = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "auditMessage":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AuditMessage = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AuditMessage = val
					} else {
						m.AuditMessage = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// OrgFetchRequest implement urlenc.URLValuesUnmarshaler.
func (m *OrgFetchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "IDOrName":
				m.IDOrName = vals[0]
			case "orgID":
				m.OrgID = vals[0]
			}
		}
	}
	return nil
}

// OrgGetByDomainRequest implement urlenc.URLValuesUnmarshaler.
func (m *OrgGetByDomainRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "domain":
				m.Domain = vals[0]
			case "orgName":
				m.OrgName = vals[0]
			}
		}
	}
	return nil
}

// OrgGetByDomainResponse implement urlenc.URLValuesUnmarshaler.
func (m *OrgGetByDomainResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// OrgNexusGetRequest implement urlenc.URLValuesUnmarshaler.
func (m *OrgNexusGetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "formats":
				m.Formats = vals
			case "types":
				m.Types = vals
			case "orgID":
				m.OrgID = vals[0]
			}
		}
	}
	return nil
}

// OrgNexusGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *OrgNexusGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// OrgNexusShowPasswordRequest implement urlenc.URLValuesUnmarshaler.
func (m *OrgNexusShowPasswordRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "nexusUserIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.NexusUserIDs = list
			}
		}
	}
	return nil
}

// OrgNexusShowPasswordResponse implement urlenc.URLValuesUnmarshaler.
func (m *OrgNexusShowPasswordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// OrgResourceInfo implement urlenc.URLValuesUnmarshaler.
func (m *OrgResourceInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "totalCpu":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.TotalCpu = val
			case "totalMem":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.TotalMem = val
			case "availableCpu":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.AvailableCpu = val
			case "availableMem":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.AvailableMem = val
			}
		}
	}
	return nil
}

// OrgSearchRequest implement urlenc.URLValuesUnmarshaler.
func (m *OrgSearchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "q":
				m.Q = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "org":
				m.Org = vals[0]
			}
		}
	}
	return nil
}

// OrgSearchResponse implement urlenc.URLValuesUnmarshaler.
func (m *OrgSearchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// OrgUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *OrgUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// OrgUpdateRequestBody implement urlenc.URLValuesUnmarshaler.
func (m *OrgUpdateRequestBody) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "logo":
				m.Logo = vals[0]
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "locale":
				m.Locale = vals[0]
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "publisherName":
				m.PublisherName = vals[0]
			case "config":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config = val
					} else {
						m.Config = structpb.NewStringValue(vals[0])
					}
				}
			case "blockoutConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.BlockoutConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.BlockoutConfig = val
					} else {
						m.BlockoutConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_CERTIFICATION_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_CERTIFICATION_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_ERR_EFFACTS_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_ERR_EFFACTS_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_ERR_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_ERR_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_ERR_RATE_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_ERR_RATE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_ERR_TREND_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_ERR_TREND_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_METIRCS_COMMON_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_METIRCS_COMMON_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			case "metricName":
				m.MetricName = vals[0]
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_METIRCS_HISTOGRAM_COMMON_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			case "metricName":
				m.MetricName = vals[0]
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_STATISTICS_TREND_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_STATISTICS_TREND_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			}
		}
	}
	return nil
}

// PUBLISH_ITEM_USERS_Request implement urlenc.URLValuesUnmarshaler.
func (m *PUBLISH_ITEM_USERS_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				m.PublishItemId = vals[0]
			}
		}
	}
	return nil
}

// PagingAPIAssetsReq implement urlenc.URLValuesUnmarshaler.
func (m *PagingAPIAssetsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PagingAppCertificateDTO implement urlenc.URLValuesUnmarshaler.
func (m *PagingAppCertificateDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// PagingCertificateDTO implement urlenc.URLValuesUnmarshaler.
func (m *PagingCertificateDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// PagingOrgDTO implement urlenc.URLValuesUnmarshaler.
func (m *PagingOrgDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// PagingProjectDTO implement urlenc.URLValuesUnmarshaler.
func (m *PagingProjectDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// PagingPublisherDTO implement urlenc.URLValuesUnmarshaler.
func (m *PagingPublisherDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// PipelineAppAllValidBranchWorkspaceResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineAppAllValidBranchWorkspaceResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineCancelResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCancelResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineConfigNamespacesFetchResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineConfigNamespacesFetchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branch":
				m.Branch = vals[0]
			case "source":
				m.Source = vals[0]
			case "pipelineYmlSource":
				m.PipelineYmlSource = vals[0]
			case "pipelineYmlName":
				m.PipelineYmlName = vals[0]
			case "pipelineYmlContent":
				m.PipelineYmlContent = vals[0]
			case "autoRun":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AutoRun = val
			case "callbackURLs":
				m.CallbackURLs = vals
			case "userID":
				m.UserID = vals[0]
			case "isCronTriggered":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsCronTriggered = val
			}
		}
	}
	return nil
}

// PipelineCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineCronDTO implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCronDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "timeCreated":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
			case "timeCreated.seconds":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeCreated.Seconds = val
			case "timeCreated.nanos":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeCreated.Nanos = int32(val)
			case "timeUpdated":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "timeUpdated.seconds":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeUpdated.Seconds = val
			case "timeUpdated.nanos":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeUpdated.Nanos = int32(val)
			case "applicationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "branch":
				m.Branch = vals[0]
			case "cronExpr":
				m.CronExpr = vals[0]
			case "cronStartTime":
				if m.CronStartTime == nil {
					m.CronStartTime = &timestamppb.Timestamp{}
				}
			case "cronStartTime.seconds":
				if m.CronStartTime == nil {
					m.CronStartTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CronStartTime.Seconds = val
			case "cronStartTime.nanos":
				if m.CronStartTime == nil {
					m.CronStartTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CronStartTime.Nanos = int32(val)
			case "pipelineYmlName":
				m.PipelineYmlName = vals[0]
			case "basePipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BasePipelineID = val
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = &val
			case "pipelineYml":
				m.PipelineYml = vals[0]
			case "configManageNamespaces":
				m.ConfigManageNamespaces = vals
			case "userID":
				m.UserID = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "pipelineDefinitionID":
				m.PipelineDefinitionID = vals[0]
			case "pipelineSource":
				m.PipelineSource = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			}
		}
	}
	return nil
}

// PipelineCronListResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCronListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineCronStartResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCronStartResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineCronStopResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCronStopResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineGetBranchRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineGetBranchRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineInvokedCombo implement urlenc.URLValuesUnmarshaler.
func (m *PipelineInvokedCombo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "branch":
				m.Branch = vals[0]
			case "source":
				m.Source = vals[0]
			case "ymlName":
				m.YmlName = vals[0]
			case "pagingYmlNames":
				m.PagingYmlNames = vals
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			case "commit":
				m.Commit = vals[0]
			case "status":
				m.Status = vals[0]
			case "timeCreated":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
			case "timeCreated.seconds":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeCreated.Seconds = val
			case "timeCreated.nanos":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeCreated.Nanos = int32(val)
			case "cancelUser":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.CancelUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.CancelUser = val
					} else {
						m.CancelUser = structpb.NewStringValue(vals[0])
					}
				}
			case "triggerMode":
				m.TriggerMode = vals[0]
			case "workspace":
				m.Workspace = vals[0]
			}
		}
	}
	return nil
}

// PipelineInvokedComboRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineInvokedComboRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branches":
				m.Branches = vals[0]
			case "sources":
				m.Sources = vals[0]
			case "ymlNames":
				m.YmlNames = vals[0]
			}
		}
	}
	return nil
}

// PipelineInvokedComboResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineInvokedComboResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineOperateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineOperateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				m.PipelineID = vals[0]
			}
		}
	}
	return nil
}

// PipelineOperateResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineOperateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelinePageListRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelinePageListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "commaBranches":
				m.CommaBranches = vals[0]
			case "commaSources":
				m.CommaSources = vals[0]
			case "commaYmlNames":
				m.CommaYmlNames = vals[0]
			case "commaStatuses":
				m.CommaStatuses = vals[0]
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branches":
				m.Branches = vals
			case "sources":
				m.Sources = vals
			case "allSources":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AllSources = val
			case "ymlNames":
				m.YmlNames = vals
			case "statuses":
				m.Statuses = vals
			case "notStatuses":
				m.NotStatuses = vals
			case "triggerModes":
				m.TriggerModes = vals
			case "clusterNames":
				m.ClusterNames = vals
			case "includeSnippet":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IncludeSnippet = val
			case "startTimeBegin":
				if m.StartTimeBegin == nil {
					m.StartTimeBegin = &timestamppb.Timestamp{}
				}
			case "startTimeBegin.seconds":
				if m.StartTimeBegin == nil {
					m.StartTimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTimeBegin.Seconds = val
			case "startTimeBegin.nanos":
				if m.StartTimeBegin == nil {
					m.StartTimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.StartTimeBegin.Nanos = int32(val)
			case "startTimeBeginTimestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTimeBeginTimestamp = val
			case "startTimeBeginCST":
				m.StartTimeBeginCST = vals[0]
			case "endTimeBegin":
				if m.EndTimeBegin == nil {
					m.EndTimeBegin = &timestamppb.Timestamp{}
				}
			case "endTimeBegin.seconds":
				if m.EndTimeBegin == nil {
					m.EndTimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTimeBegin.Seconds = val
			case "endTimeBegin.nanos":
				if m.EndTimeBegin == nil {
					m.EndTimeBegin = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.EndTimeBegin.Nanos = int32(val)
			case "endTimeBeginTimestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTimeBeginTimestamp = val
			case "endTimeBeginCST":
				m.EndTimeBeginCST = vals[0]
			case "startTimeCreated":
				if m.StartTimeCreated == nil {
					m.StartTimeCreated = &timestamppb.Timestamp{}
				}
			case "startTimeCreated.seconds":
				if m.StartTimeCreated == nil {
					m.StartTimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTimeCreated.Seconds = val
			case "startTimeCreated.nanos":
				if m.StartTimeCreated == nil {
					m.StartTimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.StartTimeCreated.Nanos = int32(val)
			case "startTimeCreatedTimestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTimeCreatedTimestamp = val
			case "endTimeCreated":
				if m.EndTimeCreated == nil {
					m.EndTimeCreated = &timestamppb.Timestamp{}
				}
			case "endTimeCreated.seconds":
				if m.EndTimeCreated == nil {
					m.EndTimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTimeCreated.Seconds = val
			case "endTimeCreated.nanos":
				if m.EndTimeCreated == nil {
					m.EndTimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.EndTimeCreated.Nanos = int32(val)
			case "endTimeCreatedTimestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTimeCreatedTimestamp = val
			case "mustMatchLabelsJSON":
				m.MustMatchLabelsJSON = vals[0]
			case "mustMatchLabelsQueryParams":
				m.MustMatchLabelsQueryParams = vals
			case "anyMatchLabelsJSON":
				m.AnyMatchLabelsJSON = vals[0]
			case "anyMatchLabelsQueryParams":
				m.AnyMatchLabelsQueryParams = vals
			case "pageNum":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNum = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "largePageSize":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.LargePageSize = val
			case "countOnly":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CountOnly = val
			case "selectCols":
				m.SelectCols = vals
			case "ascCols":
				m.AscCols = vals
			case "descCols":
				m.DescCols = vals
			case "startIDGt":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartIDGt = val
			case "endIDLt":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndIDLt = val
			case "pipelineDefinitionRequest":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.PipelineDefinitionRequest = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.PipelineDefinitionRequest = val
					} else {
						m.PipelineDefinitionRequest = structpb.NewStringValue(vals[0])
					}
				}
			case "pipelineDefinitionRequestJSONBase64":
				m.PipelineDefinitionRequestJSONBase64 = vals[0]
			}
		}
	}
	return nil
}

// PipelinePageListResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelinePageListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineRerunFailedResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRerunFailedResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			case "pipelineID":
				m.PipelineID = vals[0]
			}
		}
	}
	return nil
}

// PipelineRerunResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRerunResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineRunResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRunResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineTaskOperateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTaskOperateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "taskID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TaskID = val
			case "taskAlias":
				m.TaskAlias = vals[0]
			case "disable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Disable = &val
			case "pause":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Pause = &val
			}
		}
	}
	return nil
}

// ProjectCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "ddHook":
				m.DdHook = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "clusterID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ClusterID = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "resourceConfigs":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ResourceConfigs = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ResourceConfigs = val
					} else {
						m.ResourceConfigs = structpb.NewStringValue(vals[0])
					}
				}
			case "cpuQuota":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuQuota = val
			case "memQuota":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemQuota = val
			case "template":
				m.Template = vals[0]
			}
		}
	}
	return nil
}

// ProjectCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// ProjectDTO implement urlenc.URLValuesUnmarshaler.
func (m *ProjectDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "dDHook":
				m.DDHook = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "creator":
				m.Creator = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "owners":
				m.Owners = vals
			case "activeTime":
				m.ActiveTime = vals[0]
			case "joined":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Joined = val
			case "canUnblock":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CanUnblock = &val
			case "blockStatus":
				m.BlockStatus = vals[0]
			case "canManage":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CanManage = val
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "stats":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Stats = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Stats = val
					} else {
						m.Stats = structpb.NewStringValue(vals[0])
					}
				}
			case "projectResourceUsage":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ProjectResourceUsage = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ProjectResourceUsage = val
					} else {
						m.ProjectResourceUsage = structpb.NewStringValue(vals[0])
					}
				}
			case "resourceConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ResourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ResourceConfig = val
					} else {
						m.ResourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "cpuQuota":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuQuota = val
			case "memQuota":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemQuota = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "type":
				m.Type = vals[0]
			}
		}
	}
	return nil
}

// ProjectDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// ProjectDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectDetailRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectDetailRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectIDOrName":
				m.ProjectIDOrName = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "orgName":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgName = val
			}
		}
	}
	return nil
}

// ProjectDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "query":
				m.Query = vals[0]
			case "name":
				m.Name = vals[0]
			case "orderBy":
				m.OrderBy = vals[0]
			case "asc":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Asc = val
			case "joined":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Joined = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "projectIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ProjectIDs = list
			case "keepMsp":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.KeepMsp = val
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			}
		}
	}
	return nil
}

// ProjectListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectPackageParse_Request implement urlenc.URLValuesUnmarshaler.
func (m *ProjectPackageParse_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ProjectPackageRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectPackageRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "projectDisplayName":
				m.ProjectDisplayName = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "orgName":
				m.OrgName = vals[0]
			}
		}
	}
	return nil
}

// ProjectResourceUsage implement urlenc.URLValuesUnmarshaler.
func (m *ProjectResourceUsage) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "cpuServiceUsed":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuServiceUsed = val
			case "memServiceUsed":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemServiceUsed = val
			case "cpuAddonUsed":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuAddonUsed = val
			case "memAddonUsed":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemAddonUsed = val
			}
		}
	}
	return nil
}

// ProjectStats implement urlenc.URLValuesUnmarshaler.
func (m *ProjectStats) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "countApplications":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CountApplications = val
			case "countMembers":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CountMembers = val
			case "totalApplicationsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalApplicationsCount = val
			case "totalMembersCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalMembersCount = val
			case "totalIterationsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalIterationsCount = val
			case "runningIterationsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RunningIterationsCount = val
			case "planningIterationsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanningIterationsCount = val
			case "totalManHourCount":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.TotalManHourCount = val
			case "usedManHourCount":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.UsedManHourCount = val
			case "planningManHourCount":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.PlanningManHourCount = val
			case "doneBugCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DoneBugCount = val
			case "totalBugCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalBugCount = val
			case "doneBugPercent":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.DoneBugPercent = val
			}
		}
	}
	return nil
}

// ProxyMetrics_Request implement urlenc.URLValuesUnmarshaler.
func (m *ProxyMetrics_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PublishItemStatisticsDetailData implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsDetailData) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PublishItemStatisticsDetailRequest implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsDetailRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "endTime":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTime = val
			case "publishItemId":
				m.PublishItemId = vals[0]
			}
		}
	}
	return nil
}

// PublishItemStatisticsDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "key":
				m.Key = vals[0]
			case "totalUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalUsers = val
			case "totalUsersGrowth":
				m.TotalUsersGrowth = vals[0]
			case "newUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NewUsers = val
			case "activeUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ActiveUsers = val
			case "activeUsersGrowth":
				m.ActiveUsersGrowth = vals[0]
			case "launches":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Launches = val
			case "upgradeUser":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpgradeUser = val
			}
		}
	}
	return nil
}

// PublishItemStatisticsErrListData implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsErrListData) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PublishItemStatisticsErrListResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsErrListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "errSummary":
				m.ErrSummary = vals[0]
			case "appVersion":
				m.AppVersion = vals[0]
			case "timeOfFirst":
				if m.TimeOfFirst == nil {
					m.TimeOfFirst = &timestamppb.Timestamp{}
				}
			case "timeOfFirst.seconds":
				if m.TimeOfFirst == nil {
					m.TimeOfFirst = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeOfFirst.Seconds = val
			case "timeOfFirst.nanos":
				if m.TimeOfFirst == nil {
					m.TimeOfFirst = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeOfFirst.Nanos = int32(val)
			case "timeOfRecent":
				if m.TimeOfRecent == nil {
					m.TimeOfRecent = &timestamppb.Timestamp{}
				}
			case "timeOfRecent.seconds":
				if m.TimeOfRecent == nil {
					m.TimeOfRecent = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeOfRecent.Seconds = val
			case "timeOfRecent.nanos":
				if m.TimeOfRecent == nil {
					m.TimeOfRecent = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeOfRecent.Nanos = int32(val)
			case "totalErr":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalErr = val
			case "affectUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AffectUsers = val
			}
		}
	}
	return nil
}

// PublishItemStatisticsErrTrendData implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsErrTrendData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PublishItemStatisticsErrTrendResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsErrTrendResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "crashTimes":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CrashTimes = val
			case "crashRate":
				m.CrashRate = vals[0]
			case "crashRateGrowth":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CrashRateGrowth = val
			case "affectUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AffectUsers = val
			case "affectUsersProportion":
				m.AffectUsersProportion = vals[0]
			case "affectUsersProportionGrowth":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.AffectUsersProportionGrowth = val
			}
		}
	}
	return nil
}

// PublishItemStatisticsTrendData implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsTrendData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PublishItemStatisticsTrendResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemStatisticsTrendResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "sevenDayAvgNewUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SevenDayAvgNewUsers = val
			case "sevenDayAvgNewUsersGrowth":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.SevenDayAvgNewUsersGrowth = val
			case "sevenDayAvgActiveUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SevenDayAvgActiveUsers = val
			case "sevenDayAvgActiveUsersGrowth":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.SevenDayAvgActiveUsersGrowth = val
			case "sevenDayAvgNewUsersRetention":
				m.SevenDayAvgNewUsersRetention = vals[0]
			case "sevenDayAvgNewUsersRetentionGrowth":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.SevenDayAvgNewUsersRetentionGrowth = val
			case "sevenDayAvgDuration":
				m.SevenDayAvgDuration = vals[0]
			case "sevenDayAvgDurationGrowth":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.SevenDayAvgDurationGrowth = val
			case "sevenDayTotalActiveUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SevenDayTotalActiveUsers = val
			case "sevenDayTotalActiveUsersGrowth":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.SevenDayTotalActiveUsersGrowth = val
			case "monthTotalActiveUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MonthTotalActiveUsers = val
			case "monthTotalActiveUsersGrowth":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MonthTotalActiveUsersGrowth = val
			case "totalUsers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalUsers = val
			case "totalCrashRate":
				m.TotalCrashRate = vals[0]
			}
		}
	}
	return nil
}

// PublisherCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PublisherCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "publisherType":
				m.PublisherType = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// PublisherCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublisherCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// PublisherDTO implement urlenc.URLValuesUnmarshaler.
func (m *PublisherDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "publisherType":
				m.PublisherType = vals[0]
			case "publisherKey":
				m.PublisherKey = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "creator":
				m.Creator = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "joined":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Joined = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "pipelineCmNamespaces":
				m.PipelineCmNamespaces = vals
			}
		}
	}
	return nil
}

// PublisherDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublisherDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// PublisherDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublisherDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PublisherListRequest implement urlenc.URLValuesUnmarshaler.
func (m *PublisherListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "joined":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Joined = val
			case "query":
				m.Query = vals[0]
			case "name":
				m.Name = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// PublisherListResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublisherListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PublisherUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PublisherUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			}
		}
	}
	return nil
}

// PublisherUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublisherUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PushCertificateConfigs implement urlenc.URLValuesUnmarshaler.
func (m *PushCertificateConfigs) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "envs":
				m.Envs = vals
			case "certificateType":
				m.CertificateType = vals[0]
			case "iOSKey":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IOSKey = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IOSKey = val
					} else {
						m.IOSKey = structpb.NewStringValue(vals[0])
					}
				}
			case "androidKey":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AndroidKey = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AndroidKey = val
					} else {
						m.AndroidKey = structpb.NewStringValue(vals[0])
					}
				}
			case "messageKey":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MessageKey = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MessageKey = val
					} else {
						m.MessageKey = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PushCertificateConfigsRequest implement urlenc.URLValuesUnmarshaler.
func (m *PushCertificateConfigsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "certificateID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CertificateID = val
			case "certificateType":
				m.CertificateType = vals[0]
			case "envs":
				m.Envs = vals
			case "iOSKey":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IOSKey = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IOSKey = val
					} else {
						m.IOSKey = structpb.NewStringValue(vals[0])
					}
				}
			case "androidKey":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AndroidKey = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AndroidKey = val
					} else {
						m.AndroidKey = structpb.NewStringValue(vals[0])
					}
				}
			case "messageKey":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MessageKey = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MessageKey = val
					} else {
						m.MessageKey = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QA_APITESTS_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_APITESTS_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// QA_AUTOTEST_SPACE_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_AUTOTEST_SPACE_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// QA_PIPELINE_TASK_LOGS_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_PIPELINE_TASK_LOGS_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				m.PipelineID = vals[0]
			case "taskID":
				m.TaskID = vals[0]
			}
		}
	}
	return nil
}

// QA_RECORDS_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_RECORDS_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// QA_SONAR_GET_CREDENTIAL_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_SONAR_GET_CREDENTIAL_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QA_SONAR_ISSUES_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_SONAR_ISSUES_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QA_SONAR_METRIC_RULES_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_SONAR_METRIC_RULES_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// QA_TESTENV_CREATE_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_TESTENV_CREATE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QA_TESTENV_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_TESTENV_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// QA_TESTENV_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_TESTENV_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// QA_TESTENV_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_TESTENV_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QA_TESTPLAN_PIPELINE_DETAIL_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_TESTPLAN_PIPELINE_DETAIL_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineId":
				m.PipelineId = vals[0]
			}
		}
	}
	return nil
}

// QueryAppPublishItemRelationResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryAppPublishItemRelationResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryBranchRuleRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryBranchRuleRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "appID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			}
		}
	}
	return nil
}

// QueryBranchRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryBranchRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// RoleInfo implement urlenc.URLValuesUnmarshaler.
func (m *RoleInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "role":
				m.Role = vals[0]
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// RoleList implement urlenc.URLValuesUnmarshaler.
func (m *RoleList) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// SLAModel implement urlenc.URLValuesUnmarshaler.
func (m *SLAModel) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "baseModel":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.BaseModel = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.BaseModel = val
					} else {
						m.BaseModel = structpb.NewStringValue(vals[0])
					}
				}
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "approval":
				m.Approval = vals[0]
			case "accessID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AccessID = val
			case "source":
				m.Source = vals[0]
			}
		}
	}
	return nil
}

// SPOT_APITESTS_LOGS_DOWNLOAD_Request implement urlenc.URLValuesUnmarshaler.
func (m *SPOT_APITESTS_LOGS_DOWNLOAD_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// SPOT_APITESTS_LOGS_Request implement urlenc.URLValuesUnmarshaler.
func (m *SPOT_APITESTS_LOGS_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// SearchOperationQueryParameters implement urlenc.URLValuesUnmarshaler.
func (m *SearchOperationQueryParameters) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "keyword":
				m.Keyword = vals[0]
			}
		}
	}
	return nil
}

// SearchOperationsReq implement urlenc.URLValuesUnmarshaler.
func (m *SearchOperationsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// SonarCredentialGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *SonarCredentialGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// SonarIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *SonarIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// SonarMetricRuleDto implement urlenc.URLValuesUnmarshaler.
func (m *SonarMetricRuleDto) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "description":
				m.Description = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "metricKey":
				m.MetricKey = vals[0]
			case "metricKeyID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MetricKeyID = val
			case "operational":
				m.Operational = vals[0]
			case "metricValue":
				m.MetricValue = vals[0]
			case "metricKeyDesc":
				m.MetricKeyDesc = vals[0]
			case "decimalScale":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DecimalScale = val
			case "valueType":
				m.ValueType = vals[0]
			}
		}
	}
	return nil
}

// SonarMetricRulesBatchDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *SonarMetricRulesBatchDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "IDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IDs = list
			}
		}
	}
	return nil
}

// SonarMetricRulesBatchInsertRequest implement urlenc.URLValuesUnmarshaler.
func (m *SonarMetricRulesBatchInsertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// SonarMetricRulesDefinitionListRequest implement urlenc.URLValuesUnmarshaler.
func (m *SonarMetricRulesDefinitionListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// SonarMetricRulesDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *SonarMetricRulesDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// SonarMetricRulesListRequest implement urlenc.URLValuesUnmarshaler.
func (m *SonarMetricRulesListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// SonarMetricRulesPagingRequest implement urlenc.URLValuesUnmarshaler.
func (m *SonarMetricRulesPagingRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// SonarMetricRulesUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *SonarMetricRulesUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "description":
				m.Description = vals[0]
			case "metricValue":
				m.MetricValue = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// SonarStoreRequest implement urlenc.URLValuesUnmarshaler.
func (m *SonarStoreRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "buildID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BuildID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "applicationName":
				m.ApplicationName = vals[0]
			case "branch":
				m.Branch = vals[0]
			case "gitRepo":
				m.GitRepo = vals[0]
			case "commitID":
				m.CommitID = vals[0]
			case "projectName":
				m.ProjectName = vals[0]
			case "operatorID":
				m.OperatorID = vals[0]
			case "logID":
				m.LogID = vals[0]
			case "key":
				m.Key = vals[0]
			case "issuesStatistics":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IssuesStatistics = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IssuesStatistics = val
					} else {
						m.IssuesStatistics = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// SonarStoreResponse implement urlenc.URLValuesUnmarshaler.
func (m *SonarStoreResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// TestFileRecord implement urlenc.URLValuesUnmarshaler.
func (m *TestFileRecord) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "fileName":
				m.FileName = vals[0]
			case "description":
				m.Description = vals[0]
			case "projectName":
				m.ProjectName = vals[0]
			case "projectDisplayName":
				m.ProjectDisplayName = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "testSetID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TestSetID = val
			case "apiFileUUID":
				m.ApiFileUUID = vals[0]
			case "spaceID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SpaceID = val
			case "type":
				m.Type = vals[0]
			case "state":
				m.State = vals[0]
			case "errorInfo":
				m.ErrorInfo = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "operatorID":
				m.OperatorID = vals[0]
			}
		}
	}
	return nil
}

// TestIssuesStatistics implement urlenc.URLValuesUnmarshaler.
func (m *TestIssuesStatistics) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "bugs":
				m.Bugs = vals[0]
			case "coverage":
				m.Coverage = vals[0]
			case "vulnerabilities":
				m.Vulnerabilities = vals[0]
			case "codeSmells":
				m.CodeSmells = vals[0]
			case "duplications":
				m.Duplications = vals[0]
			case "rating":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Rating = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Rating = val
					} else {
						m.Rating = structpb.NewStringValue(vals[0])
					}
				}
			case "sonarKey":
				m.SonarKey = vals[0]
			case "path":
				m.Path = vals[0]
			case "uT":
				m.UT = vals[0]
			case "commitID":
				m.CommitID = vals[0]
			case "branch":
				m.Branch = vals[0]
			case "time":
				if m.Time == nil {
					m.Time = &timestamppb.Timestamp{}
				}
			case "time.seconds":
				if m.Time == nil {
					m.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Time.Seconds = val
			case "time.nanos":
				if m.Time == nil {
					m.Time = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Time.Nanos = int32(val)
			}
		}
	}
	return nil
}

// Ticket implement urlenc.URLValuesUnmarshaler.
func (m *Ticket) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "type":
				m.Type = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "status":
				m.Status = vals[0]
			case "key":
				m.Key = vals[0]
			case "orgID":
				m.OrgID = vals[0]
			case "metric":
				m.Metric = vals[0]
			case "metricID":
				m.MetricID = vals[0]
			case "count":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Count = val
			case "creator":
				m.Creator = vals[0]
			case "lastOperator":
				m.LastOperator = vals[0]
			case "targetType":
				m.TargetType = vals[0]
			case "lastComment":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.LastComment = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.LastComment = val
					} else {
						m.LastComment = structpb.NewStringValue(vals[0])
					}
				}
			case "targetID":
				m.TargetID = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "closedAt":
				if m.ClosedAt == nil {
					m.ClosedAt = &timestamppb.Timestamp{}
				}
			case "closedAt.seconds":
				if m.ClosedAt == nil {
					m.ClosedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ClosedAt.Seconds = val
			case "closedAt.nanos":
				if m.ClosedAt == nil {
					m.ClosedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ClosedAt.Nanos = int32(val)
			case "triggeredAt":
				if m.TriggeredAt == nil {
					m.TriggeredAt = &timestamppb.Timestamp{}
				}
			case "triggeredAt.seconds":
				if m.TriggeredAt == nil {
					m.TriggeredAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TriggeredAt.Seconds = val
			case "triggeredAt.nanos":
				if m.TriggeredAt == nil {
					m.TriggeredAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TriggeredAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// TicketCloseRequest implement urlenc.URLValuesUnmarshaler.
func (m *TicketCloseRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			}
		}
	}
	return nil
}

// TicketCloseResponse implement urlenc.URLValuesUnmarshaler.
func (m *TicketCloseResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// TicketCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *TicketCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "type":
				m.Type = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "key":
				m.Key = vals[0]
			case "orgID":
				m.OrgID = vals[0]
			case "metric":
				m.Metric = vals[0]
			case "metricID":
				m.MetricID = vals[0]
			case "userID":
				m.UserID = vals[0]
			case "targetType":
				m.TargetType = vals[0]
			case "targetID":
				m.TargetID = vals[0]
			case "triggeredAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TriggeredAt = val
			case "closedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ClosedAt = val
			}
		}
	}
	return nil
}

// TicketCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *TicketCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// TicketDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *TicketDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			}
		}
	}
	return nil
}

// TicketDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *TicketDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// TicketFetchRequest implement urlenc.URLValuesUnmarshaler.
func (m *TicketFetchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			}
		}
	}
	return nil
}

// TicketFetchResponse implement urlenc.URLValuesUnmarshaler.
func (m *TicketFetchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// TicketListRequest implement urlenc.URLValuesUnmarshaler.
func (m *TicketListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals
			case "priority":
				m.Priority = vals[0]
			case "status":
				m.Status = vals[0]
			case "targetType":
				m.TargetType = vals[0]
			case "targetID":
				m.TargetID = vals[0]
			case "key":
				m.Key = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "metric":
				m.Metric = vals[0]
			case "metricID":
				m.MetricID = vals
			case "startTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTime = val
			case "endTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTime = val
			case "comment":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Comment = val
			case "q":
				m.Q = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// TicketListResponse implement urlenc.URLValuesUnmarshaler.
func (m *TicketListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// TicketListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *TicketListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// TicketReopenRequest implement urlenc.URLValuesUnmarshaler.
func (m *TicketReopenRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			}
		}
	}
	return nil
}

// TicketReopenResponse implement urlenc.URLValuesUnmarshaler.
func (m *TicketReopenResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// TicketUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *TicketUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ticketID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TicketID = val
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// TicketUpdateRequestBody implement urlenc.URLValuesUnmarshaler.
func (m *TicketUpdateRequestBody) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "type":
				m.Type = vals[0]
			case "priority":
				m.Priority = vals[0]
			}
		}
	}
	return nil
}

// TicketUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *TicketUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "pinode":
				m.Pinode = vals[0]
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeFindAncestorsRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeFindAncestorsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeFuzzySearchRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeFuzzySearchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "fromPinode":
				m.FromPinode = vals[0]
			case "recursive":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Recursive = val
			case "prefixFuzzy":
				m.PrefixFuzzy = vals[0]
			case "suffixFuzzy":
				m.SuffixFuzzy = vals[0]
			case "fuzzy":
				m.Fuzzy = vals[0]
			case "creatorID":
				m.CreatorID = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeGetRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeGetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeListRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "pinode":
				m.Pinode = vals[0]
			case "pipelineCategoryKey":
				m.PipelineCategoryKey = vals[0]
			}
		}
	}
	return nil
}

// UpdateAPIAssetReq implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAPIAssetReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			}
		}
	}
	return nil
}

// UpdateAccess_Request implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAccess_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "accessID":
				m.AccessID = vals[0]
			}
		}
	}
	return nil
}

// UpdateAppPublishItemRelationRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAppPublishItemRelationRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "userID":
				m.UserID = vals[0]
			case "prodItemID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProdItemID = val
			case "sTAGINGItemID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.STAGINGItemID = val
			case "tESTItemID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TESTItemID = val
			case "dEVItemID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DEVItemID = val
			case "application":
				m.Application = vals[0]
			}
		}
	}
	return nil
}

// UpdateAppPublishItemRelationResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAppPublishItemRelationResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateAssetVersionReq implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAssetVersionReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "versionID":
				m.VersionID = vals[0]
			}
		}
	}
	return nil
}

// UpdateBranchRuleRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateBranchRuleRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "rule":
				m.Rule = vals[0]
			case "isProtect":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsProtect = val
			case "needApproval":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NeedApproval = val
			case "isTriggerPipeline":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsTriggerPipeline = val
			case "desc":
				m.Desc = vals[0]
			case "workspace":
				m.Workspace = vals[0]
			case "artifactWorkspace":
				m.ArtifactWorkspace = vals[0]
			}
		}
	}
	return nil
}

// UpdateBranchRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateBranchRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UpdateClientReq implement urlenc.URLValuesUnmarshaler.
func (m *UpdateClientReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "queryParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.QueryParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.QueryParams = val
					} else {
						m.QueryParams = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			case "clientID":
				m.ClientID = vals[0]
			}
		}
	}
	return nil
}

// UpdateContract_Request implement urlenc.URLValuesUnmarshaler.
func (m *UpdateContract_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clientID":
				m.ClientID = vals[0]
			case "contractID":
				m.ContractID = vals[0]
			}
		}
	}
	return nil
}

// UpdateInstantiationReq implement urlenc.URLValuesUnmarshaler.
func (m *UpdateInstantiationReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			case "minor":
				m.Minor = vals[0]
			case "instantiationID":
				m.InstantiationID = vals[0]
			}
		}
	}
	return nil
}

// UpdateSLAReq implement urlenc.URLValuesUnmarshaler.
func (m *UpdateSLAReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identity":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Identity = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Identity = val
					} else {
						m.Identity = structpb.NewStringValue(vals[0])
					}
				}
			case "uRIParams":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.URIParams = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.URIParams = val
					} else {
						m.URIParams = structpb.NewStringValue(vals[0])
					}
				}
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			case "assetID":
				m.AssetID = vals[0]
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			case "slaID":
				m.SlaID = vals[0]
			}
		}
	}
	return nil
}

// ValidBranch implement urlenc.URLValuesUnmarshaler.
func (m *ValidBranch) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "isProtect":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsProtect = val
			case "needApproval":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NeedApproval = val
			case "isTriggerPipeline":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsTriggerPipeline = val
			case "workspace":
				m.Workspace = vals[0]
			case "artifactWorkspace":
				m.ArtifactWorkspace = vals[0]
			}
		}
	}
	return nil
}

// ValidateSwagger_Request implement urlenc.URLValuesUnmarshaler.
func (m *ValidateSwagger_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}
