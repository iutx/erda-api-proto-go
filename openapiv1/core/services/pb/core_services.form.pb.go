// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: core_services.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*ApplicationDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationFetchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationFetchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationStats)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApplicationWorkspace)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApproveCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApproveCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApproveDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AuditListCleanCronRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AuditListCleanCronResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AuditSetCleanCronRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AuditSetCleanCronResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_APPLICATION_PIN_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_APPLICATION_UNPIN_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_APP_LIST_TEMPLATES_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_IMAGE_FETCH_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_IMAGE_UPLOAD_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_LABEL_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_LICENSE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_MANUAL_REVIEW_ADD_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_MBOX_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_MBOX_READ_ALL_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_MBOX_STATS_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_MEMBER_LABEL_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_NOTIFY_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_NOTIFY_DISABLE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_NOTIFY_ENABLE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_NOTIFY_FUZZY_QUERY_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_NOTIFY_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_PERMISSION_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_PROJECT_FUNCTIONS_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_PROJECT_GET_NSINFO_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_PROJECT_METRICS_HISTOGRAM_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CMDB_PROJECT_WORKSPACE_ABILITIES_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateNotifyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateNotifyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateReviewUser)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteNotifyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DereferenceClusterRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DereferenceClusterResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*EVENTBOX_WEBSOCKET_INFO_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*EVENTBOX_WEBSOCKET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ErrorLog)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ErrorLogCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ErrorLogCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAuthorityByUserIdRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAuthorityByUserIdResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetReviewByTaskIdIdRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetReviewByTaskIdIdResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetReviewsBySponsorIdRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetReviewsBySponsorIdResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetReviewsByUserIdRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetReviewsByUserIdResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LicenseResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListMemberRolesByUserRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListMemberRolesByUserResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Member)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberAddByInviteCodeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberAddByInviteCodeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberAddOptions)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberAddRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberAddResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberLabelInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberLabelList)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberLabelListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberList)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberRemoveRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MemberRemoveResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NotifySource)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NotifyTarget)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingProjectDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PermissionCheckRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PermissionCheckResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PermissionCheckResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PermissionList)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PermissionListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectFunctionSetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectFunctionSetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectLabelCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectLabelCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectLabelListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectLabelListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectLabelUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectNameSpaceInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectNameSpaceInfoResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectResourceUsage)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectStats)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectUpdateBody)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectWorkSpaceAbility)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectWorkSpaceAbilityResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QUOTA_GET_PROJECT_NAMESPACES_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QUOTA_GET_PROJECT_QUOTA_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryMBoxData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryMBoxRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryMBoxResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyHistoryData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyHistoryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyHistoryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyItemData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyItemRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyItemResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryNotifyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Scope)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ScopeResource)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ScopeRole)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ScopeRoleAccessRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ScopeRoleList)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ScopeRoleListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Target)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateApproval)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateNotifyItemRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateNotifyItemResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateNotifyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateNotifyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UserRoleListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UserScopeRole)(nil)

// ApplicationDTO implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "mode":
				m.Mode = vals[0]
			case "pined":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Pined = val
			case "desc":
				m.Desc = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "creator":
				m.Creator = vals[0]
			case "unBlockStart":
				if m.UnBlockStart == nil {
					m.UnBlockStart = &timestamppb.Timestamp{}
				}
			case "unBlockStart.seconds":
				if m.UnBlockStart == nil {
					m.UnBlockStart = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UnBlockStart.Seconds = val
			case "unBlockStart.nanos":
				if m.UnBlockStart == nil {
					m.UnBlockStart = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UnBlockStart.Nanos = int32(val)
			case "unBlockEnd":
				if m.UnBlockEnd == nil {
					m.UnBlockEnd = &timestamppb.Timestamp{}
				}
			case "unBlockEnd.seconds":
				if m.UnBlockEnd == nil {
					m.UnBlockEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UnBlockEnd.Seconds = val
			case "unBlockEnd.nanos":
				if m.UnBlockEnd == nil {
					m.UnBlockEnd = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UnBlockEnd.Nanos = int32(val)
			case "blockStatus":
				m.BlockStatus = vals[0]
			case "stats":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Stats = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Stats = val
					} else {
						m.Stats = structpb.NewStringValue(vals[0])
					}
				}
			case "gitRepo":
				m.GitRepo = vals[0]
			case "gitRepoAbbrev":
				m.GitRepoAbbrev = vals[0]
			case "gitRepoNew":
				m.GitRepoNew = vals[0]
			case "token":
				m.Token = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "orgName":
				m.OrgName = vals[0]
			case "orgDisplayName":
				m.OrgDisplayName = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "projectDisplayName":
				m.ProjectDisplayName = vals[0]
			case "isExternalRepo":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsExternalRepo = val
			case "repoConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.RepoConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.RepoConfig = val
					} else {
						m.RepoConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "sonarConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.SonarConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.SonarConfig = val
					} else {
						m.SonarConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "memberRoles":
				m.MemberRoles = vals
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "extra":
				m.Extra = vals[0]
			}
		}
	}
	return nil
}

// ApplicationFetchRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationFetchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "applicationIDOrName":
				m.ApplicationIDOrName = vals[0]
			case "projectID":
				m.ProjectID = vals[0]
			}
		}
	}
	return nil
}

// ApplicationFetchResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationFetchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApplicationListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "mode":
				m.Mode = vals[0]
			case "query":
				m.Query = vals[0]
			case "name":
				m.Name = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "public":
				m.Public = vals[0]
			case "orderBy":
				m.OrderBy = vals[0]
			case "applicationID":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ApplicationID = list
			case "isSimple":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsSimple = val
			}
		}
	}
	return nil
}

// ApplicationListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApplicationListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ApplicationStats implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationStats) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "countRuntimes":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CountRuntimes = val
			case "countMembers":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CountMembers = val
			case "timeLastModified":
				m.TimeLastModified = vals[0]
			}
		}
	}
	return nil
}

// ApplicationWorkspace implement urlenc.URLValuesUnmarshaler.
func (m *ApplicationWorkspace) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			case "workspace":
				m.Workspace = vals[0]
			case "configNamespace":
				m.ConfigNamespace = vals[0]
			}
		}
	}
	return nil
}

// ApproveCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApproveCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "targetID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TargetID = val
			case "entityID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EntityID = val
			case "targetName":
				m.TargetName = vals[0]
			case "type":
				m.Type = vals[0]
			case "title":
				m.Title = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "desc":
				m.Desc = vals[0]
			}
		}
	}
	return nil
}

// ApproveCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApproveCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApproveDTO implement urlenc.URLValuesUnmarshaler.
func (m *ApproveDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "entityID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EntityID = val
			case "targetID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TargetID = val
			case "targetName":
				m.TargetName = vals[0]
			case "type":
				m.Type = vals[0]
			case "title":
				m.Title = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "status":
				m.Status = vals[0]
			case "submitter":
				m.Submitter = vals[0]
			case "approver":
				m.Approver = vals[0]
			case "approvalTime":
				if m.ApprovalTime == nil {
					m.ApprovalTime = &timestamppb.Timestamp{}
				}
			case "approvalTime.seconds":
				if m.ApprovalTime == nil {
					m.ApprovalTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApprovalTime.Seconds = val
			case "approvalTime.nanos":
				if m.ApprovalTime == nil {
					m.ApprovalTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ApprovalTime.Nanos = int32(val)
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// AuditListCleanCronRequest implement urlenc.URLValuesUnmarshaler.
func (m *AuditListCleanCronRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// AuditListCleanCronResponse implement urlenc.URLValuesUnmarshaler.
func (m *AuditListCleanCronResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AuditSetCleanCronRequest implement urlenc.URLValuesUnmarshaler.
func (m *AuditSetCleanCronRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "interval":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Interval = val
			}
		}
	}
	return nil
}

// AuditSetCleanCronResponse implement urlenc.URLValuesUnmarshaler.
func (m *AuditSetCleanCronResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// CMDB_APPLICATION_PIN_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_APPLICATION_PIN_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "applicationId":
				m.ApplicationId = vals[0]
			}
		}
	}
	return nil
}

// CMDB_APPLICATION_UNPIN_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_APPLICATION_UNPIN_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "applicationId":
				m.ApplicationId = vals[0]
			}
		}
	}
	return nil
}

// CMDB_APP_LIST_TEMPLATES_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_APP_LIST_TEMPLATES_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_IMAGE_FETCH_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_IMAGE_FETCH_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "imageName":
				m.ImageName = vals[0]
			}
		}
	}
	return nil
}

// CMDB_IMAGE_UPLOAD_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_IMAGE_UPLOAD_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_LABEL_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_LABEL_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// CMDB_LICENSE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_LICENSE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_MANUAL_REVIEW_ADD_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_MANUAL_REVIEW_ADD_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_MBOX_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_MBOX_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "mboxID":
				m.MboxID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_MBOX_READ_ALL_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_MBOX_READ_ALL_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_MBOX_STATS_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_MBOX_STATS_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_MEMBER_LABEL_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_MEMBER_LABEL_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_NOTIFY_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_NOTIFY_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "notifyID":
				m.NotifyID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_NOTIFY_DISABLE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_NOTIFY_DISABLE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "notifyID":
				m.NotifyID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_NOTIFY_ENABLE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_NOTIFY_ENABLE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "notifyID":
				m.NotifyID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_NOTIFY_FUZZY_QUERY_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_NOTIFY_FUZZY_QUERY_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_NOTIFY_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_NOTIFY_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "notifyID":
				m.NotifyID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_PERMISSION_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_PERMISSION_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_PROJECT_FUNCTIONS_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_PROJECT_FUNCTIONS_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_PROJECT_GET_NSINFO_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_PROJECT_GET_NSINFO_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				m.ProjectID = vals[0]
			}
		}
	}
	return nil
}

// CMDB_PROJECT_METRICS_HISTOGRAM_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_PROJECT_METRICS_HISTOGRAM_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "resourceType":
				m.ResourceType = vals[0]
			}
		}
	}
	return nil
}

// CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CMDB_PROJECT_WORKSPACE_ABILITIES_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *CMDB_PROJECT_WORKSPACE_ABILITIES_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				m.ProjectID = vals[0]
			case "workspace":
				m.Workspace = vals[0]
			}
		}
	}
	return nil
}

// CreateNotifyRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateNotifyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "enabled":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enabled = val
			case "channels":
				m.Channels = vals[0]
			case "notifyGroupID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NotifyGroupID = val
			case "notifyItemIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.NotifyItemIDs = list
			case "withGroup":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.WithGroup = val
			case "label":
				m.Label = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "workSpace":
				m.WorkSpace = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// CreateNotifyResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateNotifyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CreateReviewUser implement urlenc.URLValuesUnmarshaler.
func (m *CreateReviewUser) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgId = val
			case "operator":
				m.Operator = vals[0]
			case "taskId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TaskId = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// DeleteNotifyResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteNotifyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// DereferenceClusterRequest implement urlenc.URLValuesUnmarshaler.
func (m *DereferenceClusterRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "cluster":
				m.Cluster = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// DereferenceClusterResponse implement urlenc.URLValuesUnmarshaler.
func (m *DereferenceClusterResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// EVENTBOX_WEBSOCKET_INFO_Request implement urlenc.URLValuesUnmarshaler.
func (m *EVENTBOX_WEBSOCKET_INFO_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// EVENTBOX_WEBSOCKET_Request implement urlenc.URLValuesUnmarshaler.
func (m *EVENTBOX_WEBSOCKET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "a":
				m.A = vals[0]
			case "b":
				m.B = vals[0]
			}
		}
	}
	return nil
}

// ErrorLog implement urlenc.URLValuesUnmarshaler.
func (m *ErrorLog) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "level":
				m.Level = vals[0]
			case "resourceType":
				m.ResourceType = vals[0]
			case "resourceID":
				m.ResourceID = vals[0]
			case "occurrenceTime":
				m.OccurrenceTime = vals[0]
			case "humanLog":
				m.HumanLog = vals[0]
			case "primevalLog":
				m.PrimevalLog = vals[0]
			case "dedupID":
				m.DedupID = vals[0]
			}
		}
	}
	return nil
}

// ErrorLogCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ErrorLogCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "errorLog":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ErrorLog = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ErrorLog = val
					} else {
						m.ErrorLog = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ErrorLogCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ErrorLogCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// GetAuthorityByUserIdRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAuthorityByUserIdRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "operator":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Operator = val
			case "orgId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgId = val
			case "taskId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TaskId = val
			}
		}
	}
	return nil
}

// GetAuthorityByUserIdResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAuthorityByUserIdResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "authority":
				m.Authority = vals[0]
			}
		}
	}
	return nil
}

// GetReviewByTaskIdIdRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetReviewByTaskIdIdRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "taskId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TaskId = val
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// GetReviewByTaskIdIdResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetReviewByTaskIdIdResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			case "approvalStatus":
				m.ApprovalStatus = vals[0]
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetReviewsBySponsorIdRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetReviewsBySponsorIdRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "sponsorId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SponsorId = val
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "projectId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			case "approvalStatus":
				m.ApprovalStatus = vals[0]
			case "orgId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgId = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// GetReviewsBySponsorIdResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetReviewsBySponsorIdResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "projectId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			case "projectName":
				m.ProjectName = vals[0]
			case "applicationId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationId = val
			case "applicationName":
				m.ApplicationName = vals[0]
			case "buildId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BuildId = val
			case "branchName":
				m.BranchName = vals[0]
			case "commitId":
				m.CommitId = vals[0]
			case "commitMessage":
				m.CommitMessage = vals[0]
			case "approver":
				m.Approver = vals
			case "approvalContent":
				m.ApprovalContent = vals[0]
			case "approvalReason":
				m.ApprovalReason = vals[0]
			}
		}
	}
	return nil
}

// GetReviewsByUserIdRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetReviewsByUserIdRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "userId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UserId = val
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "projectId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			case "operator":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Operator = val
			case "approvalStatus":
				m.ApprovalStatus = vals[0]
			case "orgId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgId = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// GetReviewsByUserIdResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetReviewsByUserIdResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "projectName":
				m.ProjectName = vals[0]
			case "applicationName":
				m.ApplicationName = vals[0]
			case "projectId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			case "applicationId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationId = val
			case "buildId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BuildId = val
			case "branchName":
				m.BranchName = vals[0]
			case "commitId":
				m.CommitId = vals[0]
			case "commitMessage":
				m.CommitMessage = vals[0]
			case "operator":
				m.Operator = vals[0]
			case "approvalStatus":
				m.ApprovalStatus = vals[0]
			case "approvalContent":
				m.ApprovalContent = vals[0]
			case "approvalReason":
				m.ApprovalReason = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// LicenseResponse implement urlenc.URLValuesUnmarshaler.
func (m *LicenseResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "valid":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Valid = val
			case "message":
				m.Message = vals[0]
			case "currentHostCount":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CurrentHostCount = val
			case "license":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.License = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.License = val
					} else {
						m.License = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ListMemberRolesByUserRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListMemberRolesByUserRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "userID":
				m.UserID = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			case "parentID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ParentID = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// ListMemberRolesByUserResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListMemberRolesByUserResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// Member implement urlenc.URLValuesUnmarshaler.
func (m *Member) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "userID":
				m.UserID = vals[0]
			case "email":
				m.Email = vals[0]
			case "mobile":
				m.Mobile = vals[0]
			case "name":
				m.Name = vals[0]
			case "nick":
				m.Nick = vals[0]
			case "avatar":
				m.Avatar = vals[0]
			case "status":
				m.Status = vals[0]
			case "scope":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Scope = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Scope = val
					} else {
						m.Scope = structpb.NewStringValue(vals[0])
					}
				}
			case "roles":
				m.Roles = vals
			case "labels":
				m.Labels = vals
			case "removed":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Removed = val
			case "deleted":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Deleted = val
			case "token":
				m.Token = vals[0]
			}
		}
	}
	return nil
}

// MemberAddByInviteCodeRequest implement urlenc.URLValuesUnmarshaler.
func (m *MemberAddByInviteCodeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "verifyCode":
				m.VerifyCode = vals[0]
			case "userIDs":
				m.UserIDs = vals
			case "orgID":
				m.OrgID = vals[0]
			}
		}
	}
	return nil
}

// MemberAddByInviteCodeResponse implement urlenc.URLValuesUnmarshaler.
func (m *MemberAddByInviteCodeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// MemberAddOptions implement urlenc.URLValuesUnmarshaler.
func (m *MemberAddOptions) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "rewrite":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Rewrite = val
			}
		}
	}
	return nil
}

// MemberAddRequest implement urlenc.URLValuesUnmarshaler.
func (m *MemberAddRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Scope = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Scope = val
					} else {
						m.Scope = structpb.NewStringValue(vals[0])
					}
				}
			case "targetScopeType":
				m.TargetScopeType = vals[0]
			case "targetScopeIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.TargetScopeIDs = list
			case "roles":
				m.Roles = vals
			case "userIDs":
				m.UserIDs = vals
			case "options":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Options = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Options = val
					} else {
						m.Options = structpb.NewStringValue(vals[0])
					}
				}
			case "labels":
				m.Labels = vals
			case "verifyCode":
				m.VerifyCode = vals[0]
			}
		}
	}
	return nil
}

// MemberAddResponse implement urlenc.URLValuesUnmarshaler.
func (m *MemberAddResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// MemberLabelInfo implement urlenc.URLValuesUnmarshaler.
func (m *MemberLabelInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "label":
				m.Label = vals[0]
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// MemberLabelList implement urlenc.URLValuesUnmarshaler.
func (m *MemberLabelList) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// MemberLabelListResponse implement urlenc.URLValuesUnmarshaler.
func (m *MemberLabelListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// MemberList implement urlenc.URLValuesUnmarshaler.
func (m *MemberList) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// MemberListRequest implement urlenc.URLValuesUnmarshaler.
func (m *MemberListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScopeID = val
			case "roles":
				m.Roles = vals
			case "labels":
				m.Labels = vals
			case "q":
				m.Q = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// MemberListResponse implement urlenc.URLValuesUnmarshaler.
func (m *MemberListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// MemberRemoveRequest implement urlenc.URLValuesUnmarshaler.
func (m *MemberRemoveRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Scope = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Scope = val
					} else {
						m.Scope = structpb.NewStringValue(vals[0])
					}
				}
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// MemberRemoveResponse implement urlenc.URLValuesUnmarshaler.
func (m *MemberRemoveResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// NotifySource implement urlenc.URLValuesUnmarshaler.
func (m *NotifySource) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "sourceType":
				m.SourceType = vals[0]
			case "sourceID":
				m.SourceID = vals[0]
			case "params":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Params = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Params = val
					} else {
						m.Params = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// NotifyTarget implement urlenc.URLValuesUnmarshaler.
func (m *NotifyTarget) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			}
		}
	}
	return nil
}

// PagingProjectDTO implement urlenc.URLValuesUnmarshaler.
func (m *PagingProjectDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// PermissionCheckRequest implement urlenc.URLValuesUnmarshaler.
func (m *PermissionCheckRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "userID":
				m.UserID = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScopeID = val
			case "resource":
				m.Resource = vals[0]
			case "action":
				m.Action = vals[0]
			case "resourceRole":
				m.ResourceRole = vals[0]
			}
		}
	}
	return nil
}

// PermissionCheckResponse implement urlenc.URLValuesUnmarshaler.
func (m *PermissionCheckResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PermissionCheckResponseData implement urlenc.URLValuesUnmarshaler.
func (m *PermissionCheckResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "access":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Access = val
			}
		}
	}
	return nil
}

// PermissionList implement urlenc.URLValuesUnmarshaler.
func (m *PermissionList) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "access":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Access = val
			case "roles":
				m.Roles = vals
			case "exist":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Exist = val
			case "contactsWhenNoPermission":
				m.ContactsWhenNoPermission = vals
			case "scopeInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ScopeInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ScopeInfo = val
					} else {
						m.ScopeInfo = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PermissionListResponse implement urlenc.URLValuesUnmarshaler.
func (m *PermissionListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectDTO implement urlenc.URLValuesUnmarshaler.
func (m *ProjectDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "dDHook":
				m.DDHook = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "creator":
				m.Creator = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "owners":
				m.Owners = vals
			case "activeTime":
				m.ActiveTime = vals[0]
			case "joined":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Joined = val
			case "canUnblock":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CanUnblock = &val
			case "blockStatus":
				m.BlockStatus = vals[0]
			case "canManage":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CanManage = val
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "stats":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Stats = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Stats = val
					} else {
						m.Stats = structpb.NewStringValue(vals[0])
					}
				}
			case "projectResourceUsage":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ProjectResourceUsage = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ProjectResourceUsage = val
					} else {
						m.ProjectResourceUsage = structpb.NewStringValue(vals[0])
					}
				}
			case "resourceConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ResourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ResourceConfig = val
					} else {
						m.ResourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "cpuQuota":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuQuota = val
			case "memQuota":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemQuota = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "type":
				m.Type = vals[0]
			}
		}
	}
	return nil
}

// ProjectFunctionSetRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectFunctionSetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// ProjectFunctionSetResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectFunctionSetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// ProjectLabelCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectLabelCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "type":
				m.Type = vals[0]
			case "color":
				m.Color = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// ProjectLabelCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectLabelCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// ProjectLabelListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectLabelListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "key":
				m.Key = vals[0]
			case "type":
				m.Type = vals[0]
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// ProjectLabelListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectLabelListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectLabelUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectLabelUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "color":
				m.Color = vals[0]
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			}
		}
	}
	return nil
}

// ProjectListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "query":
				m.Query = vals[0]
			case "name":
				m.Name = vals[0]
			case "orderBy":
				m.OrderBy = vals[0]
			case "asc":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Asc = val
			case "joined":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Joined = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "projectIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ProjectIDs = list
			case "keepMsp":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.KeepMsp = val
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			}
		}
	}
	return nil
}

// ProjectListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectNameSpaceInfo implement urlenc.URLValuesUnmarshaler.
func (m *ProjectNameSpaceInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "enabled":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enabled = val
			}
		}
	}
	return nil
}

// ProjectNameSpaceInfoResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectNameSpaceInfoResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectResourceUsage implement urlenc.URLValuesUnmarshaler.
func (m *ProjectResourceUsage) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "cpuServiceUsed":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuServiceUsed = val
			case "memServiceUsed":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemServiceUsed = val
			case "cpuAddonUsed":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuAddonUsed = val
			case "memAddonUsed":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemAddonUsed = val
			}
		}
	}
	return nil
}

// ProjectStats implement urlenc.URLValuesUnmarshaler.
func (m *ProjectStats) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "countApplications":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CountApplications = val
			case "countMembers":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CountMembers = val
			case "totalApplicationsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalApplicationsCount = val
			case "totalMembersCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalMembersCount = val
			case "totalIterationsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalIterationsCount = val
			case "runningIterationsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RunningIterationsCount = val
			case "planningIterationsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanningIterationsCount = val
			case "totalManHourCount":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.TotalManHourCount = val
			case "usedManHourCount":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.UsedManHourCount = val
			case "planningManHourCount":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.PlanningManHourCount = val
			case "doneBugCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DoneBugCount = val
			case "totalBugCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalBugCount = val
			case "doneBugPercent":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.DoneBugPercent = val
			}
		}
	}
	return nil
}

// ProjectUpdateBody implement urlenc.URLValuesUnmarshaler.
func (m *ProjectUpdateBody) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "ddHook":
				m.DdHook = vals[0]
			case "resourceConfigs":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ResourceConfigs = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ResourceConfigs = val
					} else {
						m.ResourceConfigs = structpb.NewStringValue(vals[0])
					}
				}
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "cpuQuota":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuQuota = val
			case "memQuota":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemQuota = val
			}
		}
	}
	return nil
}

// ProjectUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ProjectUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ProjectWorkSpaceAbility implement urlenc.URLValuesUnmarshaler.
func (m *ProjectWorkSpaceAbility) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "orgName":
				m.OrgName = vals[0]
			case "workspace":
				m.Workspace = vals[0]
			case "abilities":
				m.Abilities = vals[0]
			}
		}
	}
	return nil
}

// ProjectWorkSpaceAbilityResponse implement urlenc.URLValuesUnmarshaler.
func (m *ProjectWorkSpaceAbilityResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QUOTA_GET_PROJECT_NAMESPACES_Request implement urlenc.URLValuesUnmarshaler.
func (m *QUOTA_GET_PROJECT_NAMESPACES_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QUOTA_GET_PROJECT_QUOTA_Request implement urlenc.URLValuesUnmarshaler.
func (m *QUOTA_GET_PROJECT_QUOTA_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryMBoxData implement urlenc.URLValuesUnmarshaler.
func (m *QueryMBoxData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			case "unRead":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UnRead = val
			}
		}
	}
	return nil
}

// QueryMBoxRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryMBoxRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "label":
				m.Label = vals[0]
			case "status":
				m.Status = vals[0]
			case "type":
				m.Type = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "userID":
				m.UserID = vals[0]
			}
		}
	}
	return nil
}

// QueryMBoxResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryMBoxResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QueryNotifyData implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// QueryNotifyHistoryData implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyHistoryData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// QueryNotifyHistoryRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyHistoryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "notifyName":
				m.NotifyName = vals[0]
			case "startTime":
				m.StartTime = vals[0]
			case "endTime":
				m.EndTime = vals[0]
			case "channel":
				m.Channel = vals[0]
			case "label":
				m.Label = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// QueryNotifyHistoryResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyHistoryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QueryNotifyItemData implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyItemData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// QueryNotifyItemRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyItemRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "category":
				m.Category = vals[0]
			case "label":
				m.Label = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			}
		}
	}
	return nil
}

// QueryNotifyItemResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyItemResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QueryNotifyRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "groupDetail":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.GroupDetail = val
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "label":
				m.Label = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// QueryNotifyResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryNotifyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// Scope implement urlenc.URLValuesUnmarshaler.
func (m *Scope) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "ID":
				m.ID = vals[0]
			}
		}
	}
	return nil
}

// ScopeResource implement urlenc.URLValuesUnmarshaler.
func (m *ScopeResource) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "resource":
				m.Resource = vals[0]
			case "action":
				m.Action = vals[0]
			case "resourceRole":
				m.ResourceRole = vals[0]
			}
		}
	}
	return nil
}

// ScopeRole implement urlenc.URLValuesUnmarshaler.
func (m *ScopeRole) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Scope = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Scope = val
					} else {
						m.Scope = structpb.NewStringValue(vals[0])
					}
				}
			case "access":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Access = val
			case "roles":
				m.Roles = vals
			}
		}
	}
	return nil
}

// ScopeRoleAccessRequest implement urlenc.URLValuesUnmarshaler.
func (m *ScopeRoleAccessRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Scope = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Scope = val
					} else {
						m.Scope = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ScopeRoleList implement urlenc.URLValuesUnmarshaler.
func (m *ScopeRoleList) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ScopeRoleListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ScopeRoleListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// Target implement urlenc.URLValuesUnmarshaler.
func (m *Target) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "receiver":
				m.Receiver = vals[0]
			case "secret":
				m.Secret = vals[0]
			}
		}
	}
	return nil
}

// UpdateApproval implement urlenc.URLValuesUnmarshaler.
func (m *UpdateApproval) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "orgId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgId = val
			case "reject":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Reject = val
			case "reason":
				m.Reason = vals[0]
			}
		}
	}
	return nil
}

// UpdateNotifyItemRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateNotifyItemRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "mobileTemplate":
				m.MobileTemplate = vals[0]
			case "notifyItemID":
				m.NotifyItemID = vals[0]
			}
		}
	}
	return nil
}

// UpdateNotifyItemResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateNotifyItemResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateNotifyRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateNotifyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "channels":
				m.Channels = vals[0]
			case "notifyGroupID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NotifyGroupID = val
			case "notifyItemIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.NotifyItemIDs = list
			case "withGroup":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.WithGroup = val
			case "groupName":
				m.GroupName = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "notifyID":
				m.NotifyID = vals[0]
			}
		}
	}
	return nil
}

// UpdateNotifyResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateNotifyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UserRoleListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *UserRoleListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// UserScopeRole implement urlenc.URLValuesUnmarshaler.
func (m *UserScopeRole) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScopeID = val
			case "scopeName":
				m.ScopeName = vals[0]
			case "roles":
				m.Roles = vals
			}
		}
	}
	return nil
}
