// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: core_services.proto

package pb

import (
	context "context"
	http1 "net/http"
	strconv "strconv"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// CoreServicesHandler is the server API for CoreServices service.
type CoreServicesHandler interface {
	// GET /api/applications
	CMDB_APPLICATIONS_LIST(context.Context, *ApplicationListRequest) (*ApplicationListResponse, error)
	// GET /api/applications/{applicationIDOrName}
	CMDB_APPLICATION_FETCH(context.Context, *ApplicationFetchRequest) (*ApplicationFetchResponse, error)
	// PUT /api/applications/{applicationId}/actions/pin
	CMDB_APPLICATION_PIN(context.Context, *CMDB_APPLICATION_PIN_Request) (*emptypb.Empty, error)
	// PUT /api/applications/{applicationId}/actions/unpin
	CMDB_APPLICATION_UNPIN(context.Context, *CMDB_APPLICATION_UNPIN_Request) (*emptypb.Empty, error)
	// POST /api/approves
	CMDB_APPROVE_CREATE(context.Context, *ApproveCreateRequest) (*ApproveCreateResponse, error)
	// GET /api/applications/actions/list-templates
	CMDB_APP_LIST_TEMPLATES(context.Context, *CMDB_APP_LIST_TEMPLATES_Request) (*emptypb.Empty, error)
	// GET /api/audits/actions/setting
	CMDB_AUDITS_LIST_SET(context.Context, *AuditListCleanCronRequest) (*AuditListCleanCronResponse, error)
	// PUT /api/audits/actions/setting
	CMDB_AUDITS_SET(context.Context, *AuditSetCleanCronRequest) (*AuditSetCleanCronResponse, error)
	// PUT /api/clusters/actions/dereference
	CMDB_CLUSTER_DEREFERENCE(context.Context, *DereferenceClusterRequest) (*DereferenceClusterResponse, error)
	// POST /api/task-error/actions/create
	CMDB_ERRORLOG_CREATE(context.Context, *ErrorLogCreateRequest) (*ErrorLogCreateResponse, error)
	// GET /api/images/{imageName}
	CMDB_IMAGE_FETCH(context.Context, *CMDB_IMAGE_FETCH_Request) (*emptypb.Empty, error)
	// POST /api/images/actions/upload
	CMDB_IMAGE_UPLOAD(context.Context, *CMDB_IMAGE_UPLOAD_Request) (*emptypb.Empty, error)
	// POST /api/labels
	CMDB_LABEL_CREATE(context.Context, *ProjectLabelCreateRequest) (*ProjectLabelCreateResponse, error)
	// DELETE /api/labels/{id}
	CMDB_LABEL_DELETE(context.Context, *CMDB_LABEL_DELETE_Request) (*emptypb.Empty, error)
	// GET /api/labels
	CMDB_LABEL_LIST(context.Context, *ProjectLabelListRequest) (*ProjectLabelListResponse, error)
	// PUT /api/labels/{ID}
	CMDB_LABEL_UPDATE(context.Context, *ProjectLabelUpdateRequest) (*emptypb.Empty, error)
	// GET /api/license
	CMDB_LICENSE(context.Context, *CMDB_LICENSE_Request) (*LicenseResponse, error)
	// POST /api/reviews/actions/review/approve
	CMDB_MANUAL_REVIEW_ADD(context.Context, *CMDB_MANUAL_REVIEW_ADD_Request) (*emptypb.Empty, error)
	// POST /api/reviews/actions/user/create
	CMDB_MANUAL_REVIEW_ADDUSER(context.Context, *CreateReviewUser) (*emptypb.Empty, error)
	// GET /api/reviews/actions/authority
	CMDB_MANUAL_REVIEW_AUTHORITY(context.Context, *GetAuthorityByUserIdRequest) (*GetAuthorityByUserIdResponse, error)
	// GET /api/reviews/actions/{id}
	CMDB_MANUAL_REVIEW_GET(context.Context, *GetReviewByTaskIdIdRequest) (*GetReviewByTaskIdIdResponse, error)
	// GET /api/reviews/actions/list-launched-approval
	CMDB_MANUAL_REVIEW_LISTBYSPONSORID(context.Context, *GetReviewsBySponsorIdRequest) (*GetReviewsBySponsorIdResponse, error)
	// GET /api/reviews/actions/list-approved
	CMDB_MANUAL_REVIEW_LISTBYUserID(context.Context, *GetReviewsByUserIdRequest) (*GetReviewsByUserIdResponse, error)
	// PUT /api/reviews/actions/updateReview
	CMDB_MANUAL_REVIEW_UPDATE(context.Context, *UpdateApproval) (*emptypb.Empty, error)
	// GET /api/mboxs/{mboxID}
	CMDB_MBOX_GET(context.Context, *CMDB_MBOX_GET_Request) (*emptypb.Empty, error)
	// GET /api/mboxs
	CMDB_MBOX_LIST(context.Context, *QueryMBoxRequest) (*QueryMBoxResponse, error)
	// POST /api/mboxs/actions/read-all
	CMDB_MBOX_READ_ALL(context.Context, *CMDB_MBOX_READ_ALL_Request) (*emptypb.Empty, error)
	// GET /api/mboxs/actions/stats
	CMDB_MBOX_STATS(context.Context, *CMDB_MBOX_STATS_Request) (*emptypb.Empty, error)
	// POST /api/members
	CMDB_MEMBER_ADD(context.Context, *MemberAddRequest) (*MemberAddResponse, error)
	// POST /api/members/actions/create-by-invitecode
	CMDB_MEMBER_ADD_BY_INVITECODE(context.Context, *MemberAddByInviteCodeRequest) (*MemberAddByInviteCodeResponse, error)
	// GET /api/members/actions/list-labels
	CMDB_MEMBER_LABEL_LIST(context.Context, *CMDB_MEMBER_LABEL_LIST_Request) (*MemberLabelListResponse, error)
	// GET /api/members
	CMDB_MEMBER_LIST(context.Context, *MemberListRequest) (*MemberListResponse, error)
	// POST /api/members/actions/remove
	CMDB_MEMBER_REMOVE(context.Context, *MemberRemoveRequest) (*MemberRemoveResponse, error)
	// GET /api/applications/actions/list-my-applications
	CMDB_MY_APPLICATIONS_LIST(context.Context, *ApplicationListRequest) (*ApplicationListResponse, error)
	// GET /api/projects/actions/list-my-projects
	CMDB_MY_PROJECTS_LIST(context.Context, *ProjectListRequest) (*ProjectListResponse, error)
	// GET /api/notify-items
	CMDB_NOTIFYITEM_QUERY(context.Context, *QueryNotifyItemRequest) (*QueryNotifyItemResponse, error)
	// PUT /api/notify-items/{notifyItemID}
	CMDB_NOTIFYITEM_UPDATE(context.Context, *UpdateNotifyItemRequest) (*UpdateNotifyItemResponse, error)
	// POST /api/notifies
	CMDB_NOTIFY_CREATE(context.Context, *CreateNotifyRequest) (*CreateNotifyResponse, error)
	// DELETE /api/notifies/{notifyID}
	CMDB_NOTIFY_DELETE(context.Context, *CMDB_NOTIFY_DELETE_Request) (*DeleteNotifyResponse, error)
	// PUT /api/notifies/{notifyID}/actions/disable
	CMDB_NOTIFY_DISABLE(context.Context, *CMDB_NOTIFY_DISABLE_Request) (*emptypb.Empty, error)
	// PUT /api/notifies/{notifyID}/actions/enable
	CMDB_NOTIFY_ENABLE(context.Context, *CMDB_NOTIFY_ENABLE_Request) (*emptypb.Empty, error)
	// GET /api/notifies/actions/fuzzy-query-by-source
	CMDB_NOTIFY_FUZZY_QUERY(context.Context, *CMDB_NOTIFY_FUZZY_QUERY_Request) (*emptypb.Empty, error)
	// GET /api/notifies/{notifyID}
	CMDB_NOTIFY_GET(context.Context, *CMDB_NOTIFY_GET_Request) (*emptypb.Empty, error)
	// GET /api/notify-histories
	CMDB_NOTIFY_HISTORIES(context.Context, *QueryNotifyHistoryRequest) (*QueryNotifyHistoryResponse, error)
	// GET /api/notifies
	CMDB_NOTIFY_QUERY(context.Context, *QueryNotifyRequest) (*QueryNotifyResponse, error)
	// PUT /api/notifies/{notifyID}
	CMDB_NOTIFY_UPDATE(context.Context, *UpdateNotifyRequest) (*UpdateNotifyResponse, error)
	// POST /api/permissions/actions/access
	CMDB_PERMISSION_ACCESS(context.Context, *ScopeRoleAccessRequest) (*PermissionListResponse, error)
	// POST /api/permissions/actions/check
	CMDB_PERMISSION_CHECK(context.Context, *PermissionCheckRequest) (*PermissionCheckResponse, error)
	// GET /api/permissions
	CMDB_PERMISSION_LIST(context.Context, *CMDB_PERMISSION_LIST_Request) (*ScopeRoleListResponse, error)
	// GET /api/projects/actions/get-project-functions
	CMDB_PROJECT_FUNCTIONS_GET(context.Context, *CMDB_PROJECT_FUNCTIONS_GET_Request) (*emptypb.Empty, error)
	// POST /api/projects/actions/set-project-functions
	CMDB_PROJECT_FUNCTIONS_SET(context.Context, *ProjectFunctionSetRequest) (*ProjectFunctionSetResponse, error)
	// GET /api/projects/{projectID}/actions/get-ns-info
	CMDB_PROJECT_GET_NSINFO(context.Context, *CMDB_PROJECT_GET_NSINFO_Request) (*ProjectNameSpaceInfoResponse, error)
	// GET /api/projects/resource/{resourceType}/actions/list-usage-histogram
	CMDB_PROJECT_METRICS_HISTOGRAM(context.Context, *CMDB_PROJECT_METRICS_HISTOGRAM_Request) (*emptypb.Empty, error)
	// PUT /api/projects/{projectID}
	CMDB_PROJECT_UPDATE(context.Context, *ProjectUpdateRequest) (*ProjectUpdateResponse, error)
	// POST /api/project-workspace-abilities
	CMDB_PROJECT_WORKSPACE_ABILITIES_CREATE(context.Context, *ProjectWorkSpaceAbility) (*emptypb.Empty, error)
	// DELETE /api/project-workspace-abilities
	CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE(context.Context, *CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_Request) (*emptypb.Empty, error)
	// GET /api/project-workspace-abilities/{projectID}/{workspace}
	CMDB_PROJECT_WORKSPACE_ABILITIES_GET(context.Context, *CMDB_PROJECT_WORKSPACE_ABILITIES_GET_Request) (*ProjectWorkSpaceAbilityResponse, error)
	// PUT /api/project-workspace-abilities
	CMDB_PROJECT_WORKSPACE_ABILITIES_UPDATE(context.Context, *ProjectWorkSpaceAbility) (*emptypb.Empty, error)
	// GET /api/members/actions/list-user-roles
	CMDB_ROLES_LIST_BY_USER(context.Context, *ListMemberRolesByUserRequest) (*ListMemberRolesByUserResponse, error)
	// GET /api/websocket/{a}/{b}/websocket
	EVENTBOX_WEBSOCKET(context.Context, *EVENTBOX_WEBSOCKET_Request) (*emptypb.Empty, error)
	// GET /api/websocket/info
	EVENTBOX_WEBSOCKET_INFO(context.Context, *EVENTBOX_WEBSOCKET_INFO_Request) (*emptypb.Empty, error)
	// GET /api/projects-namespaces
	QUOTA_GET_PROJECT_NAMESPACES(context.Context, *QUOTA_GET_PROJECT_NAMESPACES_Request) (*emptypb.Empty, error)
	// GET /api/projects-quota
	QUOTA_GET_PROJECT_QUOTA(context.Context, *QUOTA_GET_PROJECT_QUOTA_Request) (*emptypb.Empty, error)
}

// RegisterCoreServicesHandler register CoreServicesHandler to http.Router.
func RegisterCoreServicesHandler(r http.Router, srv CoreServicesHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_CMDB_APPLICATIONS_LIST := func(method, path string, fn func(context.Context, *ApplicationListRequest) (*ApplicationListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplicationListRequest))
		}
		var CMDB_APPLICATIONS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPLICATIONS_LIST_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_APPLICATIONS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPLICATIONS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ApplicationListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPLICATION_FETCH := func(method, path string, fn func(context.Context, *ApplicationFetchRequest) (*ApplicationFetchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplicationFetchRequest))
		}
		var CMDB_APPLICATION_FETCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPLICATION_FETCH_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_APPLICATION_FETCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPLICATION_FETCH_info)
				}
				r = r.WithContext(ctx)
				var in ApplicationFetchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "applicationIDOrName":
							in.ApplicationIDOrName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPLICATION_PIN := func(method, path string, fn func(context.Context, *CMDB_APPLICATION_PIN_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_APPLICATION_PIN_Request))
		}
		var CMDB_APPLICATION_PIN_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPLICATION_PIN_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_APPLICATION_PIN", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPLICATION_PIN_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_APPLICATION_PIN_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "applicationId":
							in.ApplicationId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPLICATION_UNPIN := func(method, path string, fn func(context.Context, *CMDB_APPLICATION_UNPIN_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_APPLICATION_UNPIN_Request))
		}
		var CMDB_APPLICATION_UNPIN_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPLICATION_UNPIN_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_APPLICATION_UNPIN", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPLICATION_UNPIN_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_APPLICATION_UNPIN_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "applicationId":
							in.ApplicationId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPROVE_CREATE := func(method, path string, fn func(context.Context, *ApproveCreateRequest) (*ApproveCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApproveCreateRequest))
		}
		var CMDB_APPROVE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APPROVE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_APPROVE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APPROVE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ApproveCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APP_LIST_TEMPLATES := func(method, path string, fn func(context.Context, *CMDB_APP_LIST_TEMPLATES_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_APP_LIST_TEMPLATES_Request))
		}
		var CMDB_APP_LIST_TEMPLATES_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_APP_LIST_TEMPLATES_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_APP_LIST_TEMPLATES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_APP_LIST_TEMPLATES_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_APP_LIST_TEMPLATES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_AUDITS_LIST_SET := func(method, path string, fn func(context.Context, *AuditListCleanCronRequest) (*AuditListCleanCronResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AuditListCleanCronRequest))
		}
		var CMDB_AUDITS_LIST_SET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_AUDITS_LIST_SET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_AUDITS_LIST_SET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_AUDITS_LIST_SET_info)
				}
				r = r.WithContext(ctx)
				var in AuditListCleanCronRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_AUDITS_SET := func(method, path string, fn func(context.Context, *AuditSetCleanCronRequest) (*AuditSetCleanCronResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AuditSetCleanCronRequest))
		}
		var CMDB_AUDITS_SET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_AUDITS_SET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_AUDITS_SET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_AUDITS_SET_info)
				}
				r = r.WithContext(ctx)
				var in AuditSetCleanCronRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_CLUSTER_DEREFERENCE := func(method, path string, fn func(context.Context, *DereferenceClusterRequest) (*DereferenceClusterResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DereferenceClusterRequest))
		}
		var CMDB_CLUSTER_DEREFERENCE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_CLUSTER_DEREFERENCE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_CLUSTER_DEREFERENCE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_CLUSTER_DEREFERENCE_info)
				}
				r = r.WithContext(ctx)
				var in DereferenceClusterRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ERRORLOG_CREATE := func(method, path string, fn func(context.Context, *ErrorLogCreateRequest) (*ErrorLogCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ErrorLogCreateRequest))
		}
		var CMDB_ERRORLOG_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ERRORLOG_CREATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_ERRORLOG_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ERRORLOG_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ErrorLogCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_IMAGE_FETCH := func(method, path string, fn func(context.Context, *CMDB_IMAGE_FETCH_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_IMAGE_FETCH_Request))
		}
		var CMDB_IMAGE_FETCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_IMAGE_FETCH_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_IMAGE_FETCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_IMAGE_FETCH_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_IMAGE_FETCH_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "imageName":
							in.ImageName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_IMAGE_UPLOAD := func(method, path string, fn func(context.Context, *CMDB_IMAGE_UPLOAD_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_IMAGE_UPLOAD_Request))
		}
		var CMDB_IMAGE_UPLOAD_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_IMAGE_UPLOAD_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_IMAGE_UPLOAD", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_IMAGE_UPLOAD_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_IMAGE_UPLOAD_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LABEL_CREATE := func(method, path string, fn func(context.Context, *ProjectLabelCreateRequest) (*ProjectLabelCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectLabelCreateRequest))
		}
		var CMDB_LABEL_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LABEL_CREATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_LABEL_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LABEL_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ProjectLabelCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LABEL_DELETE := func(method, path string, fn func(context.Context, *CMDB_LABEL_DELETE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_LABEL_DELETE_Request))
		}
		var CMDB_LABEL_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LABEL_DELETE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_LABEL_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LABEL_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_LABEL_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LABEL_LIST := func(method, path string, fn func(context.Context, *ProjectLabelListRequest) (*ProjectLabelListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectLabelListRequest))
		}
		var CMDB_LABEL_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LABEL_LIST_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_LABEL_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LABEL_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ProjectLabelListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LABEL_UPDATE := func(method, path string, fn func(context.Context, *ProjectLabelUpdateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectLabelUpdateRequest))
		}
		var CMDB_LABEL_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LABEL_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_LABEL_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LABEL_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in ProjectLabelUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ID":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_LICENSE := func(method, path string, fn func(context.Context, *CMDB_LICENSE_Request) (*LicenseResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_LICENSE_Request))
		}
		var CMDB_LICENSE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_LICENSE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_LICENSE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_LICENSE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_LICENSE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MANUAL_REVIEW_ADD := func(method, path string, fn func(context.Context, *CMDB_MANUAL_REVIEW_ADD_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_MANUAL_REVIEW_ADD_Request))
		}
		var CMDB_MANUAL_REVIEW_ADD_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MANUAL_REVIEW_ADD_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MANUAL_REVIEW_ADD", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MANUAL_REVIEW_ADD_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_MANUAL_REVIEW_ADD_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MANUAL_REVIEW_ADDUSER := func(method, path string, fn func(context.Context, *CreateReviewUser) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateReviewUser))
		}
		var CMDB_MANUAL_REVIEW_ADDUSER_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MANUAL_REVIEW_ADDUSER_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MANUAL_REVIEW_ADDUSER", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MANUAL_REVIEW_ADDUSER_info)
				}
				r = r.WithContext(ctx)
				var in CreateReviewUser
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MANUAL_REVIEW_AUTHORITY := func(method, path string, fn func(context.Context, *GetAuthorityByUserIdRequest) (*GetAuthorityByUserIdResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAuthorityByUserIdRequest))
		}
		var CMDB_MANUAL_REVIEW_AUTHORITY_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MANUAL_REVIEW_AUTHORITY_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MANUAL_REVIEW_AUTHORITY", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MANUAL_REVIEW_AUTHORITY_info)
				}
				r = r.WithContext(ctx)
				var in GetAuthorityByUserIdRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MANUAL_REVIEW_GET := func(method, path string, fn func(context.Context, *GetReviewByTaskIdIdRequest) (*GetReviewByTaskIdIdResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetReviewByTaskIdIdRequest))
		}
		var CMDB_MANUAL_REVIEW_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MANUAL_REVIEW_GET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MANUAL_REVIEW_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MANUAL_REVIEW_GET_info)
				}
				r = r.WithContext(ctx)
				var in GetReviewByTaskIdIdRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MANUAL_REVIEW_LISTBYSPONSORID := func(method, path string, fn func(context.Context, *GetReviewsBySponsorIdRequest) (*GetReviewsBySponsorIdResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetReviewsBySponsorIdRequest))
		}
		var CMDB_MANUAL_REVIEW_LISTBYSPONSORID_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MANUAL_REVIEW_LISTBYSPONSORID_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MANUAL_REVIEW_LISTBYSPONSORID", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MANUAL_REVIEW_LISTBYSPONSORID_info)
				}
				r = r.WithContext(ctx)
				var in GetReviewsBySponsorIdRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MANUAL_REVIEW_LISTBYUserID := func(method, path string, fn func(context.Context, *GetReviewsByUserIdRequest) (*GetReviewsByUserIdResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetReviewsByUserIdRequest))
		}
		var CMDB_MANUAL_REVIEW_LISTBYUserID_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MANUAL_REVIEW_LISTBYUserID_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MANUAL_REVIEW_LISTBYUserID", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MANUAL_REVIEW_LISTBYUserID_info)
				}
				r = r.WithContext(ctx)
				var in GetReviewsByUserIdRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MANUAL_REVIEW_UPDATE := func(method, path string, fn func(context.Context, *UpdateApproval) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateApproval))
		}
		var CMDB_MANUAL_REVIEW_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MANUAL_REVIEW_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MANUAL_REVIEW_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MANUAL_REVIEW_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in UpdateApproval
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MBOX_GET := func(method, path string, fn func(context.Context, *CMDB_MBOX_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_MBOX_GET_Request))
		}
		var CMDB_MBOX_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MBOX_GET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MBOX_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MBOX_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_MBOX_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "mboxID":
							in.MboxID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MBOX_LIST := func(method, path string, fn func(context.Context, *QueryMBoxRequest) (*QueryMBoxResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryMBoxRequest))
		}
		var CMDB_MBOX_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MBOX_LIST_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MBOX_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MBOX_LIST_info)
				}
				r = r.WithContext(ctx)
				var in QueryMBoxRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MBOX_READ_ALL := func(method, path string, fn func(context.Context, *CMDB_MBOX_READ_ALL_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_MBOX_READ_ALL_Request))
		}
		var CMDB_MBOX_READ_ALL_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MBOX_READ_ALL_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MBOX_READ_ALL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MBOX_READ_ALL_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_MBOX_READ_ALL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MBOX_STATS := func(method, path string, fn func(context.Context, *CMDB_MBOX_STATS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_MBOX_STATS_Request))
		}
		var CMDB_MBOX_STATS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MBOX_STATS_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MBOX_STATS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MBOX_STATS_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_MBOX_STATS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MEMBER_ADD := func(method, path string, fn func(context.Context, *MemberAddRequest) (*MemberAddResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*MemberAddRequest))
		}
		var CMDB_MEMBER_ADD_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MEMBER_ADD_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MEMBER_ADD", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MEMBER_ADD_info)
				}
				r = r.WithContext(ctx)
				var in MemberAddRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MEMBER_ADD_BY_INVITECODE := func(method, path string, fn func(context.Context, *MemberAddByInviteCodeRequest) (*MemberAddByInviteCodeResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*MemberAddByInviteCodeRequest))
		}
		var CMDB_MEMBER_ADD_BY_INVITECODE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MEMBER_ADD_BY_INVITECODE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MEMBER_ADD_BY_INVITECODE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MEMBER_ADD_BY_INVITECODE_info)
				}
				r = r.WithContext(ctx)
				var in MemberAddByInviteCodeRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MEMBER_LABEL_LIST := func(method, path string, fn func(context.Context, *CMDB_MEMBER_LABEL_LIST_Request) (*MemberLabelListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_MEMBER_LABEL_LIST_Request))
		}
		var CMDB_MEMBER_LABEL_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MEMBER_LABEL_LIST_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MEMBER_LABEL_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MEMBER_LABEL_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_MEMBER_LABEL_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MEMBER_LIST := func(method, path string, fn func(context.Context, *MemberListRequest) (*MemberListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*MemberListRequest))
		}
		var CMDB_MEMBER_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MEMBER_LIST_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MEMBER_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MEMBER_LIST_info)
				}
				r = r.WithContext(ctx)
				var in MemberListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MEMBER_REMOVE := func(method, path string, fn func(context.Context, *MemberRemoveRequest) (*MemberRemoveResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*MemberRemoveRequest))
		}
		var CMDB_MEMBER_REMOVE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MEMBER_REMOVE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MEMBER_REMOVE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MEMBER_REMOVE_info)
				}
				r = r.WithContext(ctx)
				var in MemberRemoveRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MY_APPLICATIONS_LIST := func(method, path string, fn func(context.Context, *ApplicationListRequest) (*ApplicationListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ApplicationListRequest))
		}
		var CMDB_MY_APPLICATIONS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MY_APPLICATIONS_LIST_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MY_APPLICATIONS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MY_APPLICATIONS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ApplicationListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_MY_PROJECTS_LIST := func(method, path string, fn func(context.Context, *ProjectListRequest) (*ProjectListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectListRequest))
		}
		var CMDB_MY_PROJECTS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_MY_PROJECTS_LIST_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_MY_PROJECTS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_MY_PROJECTS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ProjectListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFYITEM_QUERY := func(method, path string, fn func(context.Context, *QueryNotifyItemRequest) (*QueryNotifyItemResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryNotifyItemRequest))
		}
		var CMDB_NOTIFYITEM_QUERY_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFYITEM_QUERY_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFYITEM_QUERY", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFYITEM_QUERY_info)
				}
				r = r.WithContext(ctx)
				var in QueryNotifyItemRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFYITEM_UPDATE := func(method, path string, fn func(context.Context, *UpdateNotifyItemRequest) (*UpdateNotifyItemResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateNotifyItemRequest))
		}
		var CMDB_NOTIFYITEM_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFYITEM_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFYITEM_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFYITEM_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in UpdateNotifyItemRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "notifyItemID":
							in.NotifyItemID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_CREATE := func(method, path string, fn func(context.Context, *CreateNotifyRequest) (*CreateNotifyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateNotifyRequest))
		}
		var CMDB_NOTIFY_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_CREATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateNotifyRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_DELETE := func(method, path string, fn func(context.Context, *CMDB_NOTIFY_DELETE_Request) (*DeleteNotifyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_NOTIFY_DELETE_Request))
		}
		var CMDB_NOTIFY_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_DELETE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_NOTIFY_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "notifyID":
							in.NotifyID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_DISABLE := func(method, path string, fn func(context.Context, *CMDB_NOTIFY_DISABLE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_NOTIFY_DISABLE_Request))
		}
		var CMDB_NOTIFY_DISABLE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_DISABLE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_DISABLE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_DISABLE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_NOTIFY_DISABLE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "notifyID":
							in.NotifyID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_ENABLE := func(method, path string, fn func(context.Context, *CMDB_NOTIFY_ENABLE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_NOTIFY_ENABLE_Request))
		}
		var CMDB_NOTIFY_ENABLE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_ENABLE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_ENABLE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_ENABLE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_NOTIFY_ENABLE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "notifyID":
							in.NotifyID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_FUZZY_QUERY := func(method, path string, fn func(context.Context, *CMDB_NOTIFY_FUZZY_QUERY_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_NOTIFY_FUZZY_QUERY_Request))
		}
		var CMDB_NOTIFY_FUZZY_QUERY_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_FUZZY_QUERY_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_FUZZY_QUERY", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_FUZZY_QUERY_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_NOTIFY_FUZZY_QUERY_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_GET := func(method, path string, fn func(context.Context, *CMDB_NOTIFY_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_NOTIFY_GET_Request))
		}
		var CMDB_NOTIFY_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_GET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_NOTIFY_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "notifyID":
							in.NotifyID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_HISTORIES := func(method, path string, fn func(context.Context, *QueryNotifyHistoryRequest) (*QueryNotifyHistoryResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryNotifyHistoryRequest))
		}
		var CMDB_NOTIFY_HISTORIES_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_HISTORIES_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_HISTORIES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_HISTORIES_info)
				}
				r = r.WithContext(ctx)
				var in QueryNotifyHistoryRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_QUERY := func(method, path string, fn func(context.Context, *QueryNotifyRequest) (*QueryNotifyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryNotifyRequest))
		}
		var CMDB_NOTIFY_QUERY_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_QUERY_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_QUERY", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_QUERY_info)
				}
				r = r.WithContext(ctx)
				var in QueryNotifyRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_NOTIFY_UPDATE := func(method, path string, fn func(context.Context, *UpdateNotifyRequest) (*UpdateNotifyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateNotifyRequest))
		}
		var CMDB_NOTIFY_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_NOTIFY_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_NOTIFY_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_NOTIFY_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in UpdateNotifyRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "notifyID":
							in.NotifyID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PERMISSION_ACCESS := func(method, path string, fn func(context.Context, *ScopeRoleAccessRequest) (*PermissionListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ScopeRoleAccessRequest))
		}
		var CMDB_PERMISSION_ACCESS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PERMISSION_ACCESS_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PERMISSION_ACCESS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PERMISSION_ACCESS_info)
				}
				r = r.WithContext(ctx)
				var in ScopeRoleAccessRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PERMISSION_CHECK := func(method, path string, fn func(context.Context, *PermissionCheckRequest) (*PermissionCheckResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PermissionCheckRequest))
		}
		var CMDB_PERMISSION_CHECK_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PERMISSION_CHECK_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PERMISSION_CHECK", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PERMISSION_CHECK_info)
				}
				r = r.WithContext(ctx)
				var in PermissionCheckRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PERMISSION_LIST := func(method, path string, fn func(context.Context, *CMDB_PERMISSION_LIST_Request) (*ScopeRoleListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_PERMISSION_LIST_Request))
		}
		var CMDB_PERMISSION_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PERMISSION_LIST_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PERMISSION_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PERMISSION_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_PERMISSION_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_FUNCTIONS_GET := func(method, path string, fn func(context.Context, *CMDB_PROJECT_FUNCTIONS_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_PROJECT_FUNCTIONS_GET_Request))
		}
		var CMDB_PROJECT_FUNCTIONS_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_FUNCTIONS_GET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_FUNCTIONS_GET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_FUNCTIONS_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_PROJECT_FUNCTIONS_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_FUNCTIONS_SET := func(method, path string, fn func(context.Context, *ProjectFunctionSetRequest) (*ProjectFunctionSetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectFunctionSetRequest))
		}
		var CMDB_PROJECT_FUNCTIONS_SET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_FUNCTIONS_SET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_FUNCTIONS_SET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_FUNCTIONS_SET_info)
				}
				r = r.WithContext(ctx)
				var in ProjectFunctionSetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_GET_NSINFO := func(method, path string, fn func(context.Context, *CMDB_PROJECT_GET_NSINFO_Request) (*ProjectNameSpaceInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_PROJECT_GET_NSINFO_Request))
		}
		var CMDB_PROJECT_GET_NSINFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_GET_NSINFO_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_GET_NSINFO", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_GET_NSINFO_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_PROJECT_GET_NSINFO_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_METRICS_HISTOGRAM := func(method, path string, fn func(context.Context, *CMDB_PROJECT_METRICS_HISTOGRAM_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_PROJECT_METRICS_HISTOGRAM_Request))
		}
		var CMDB_PROJECT_METRICS_HISTOGRAM_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_METRICS_HISTOGRAM_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_METRICS_HISTOGRAM", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_METRICS_HISTOGRAM_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_PROJECT_METRICS_HISTOGRAM_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "resourceType":
							in.ResourceType = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_UPDATE := func(method, path string, fn func(context.Context, *ProjectUpdateRequest) (*ProjectUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectUpdateRequest))
		}
		var CMDB_PROJECT_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in ProjectUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_WORKSPACE_ABILITIES_CREATE := func(method, path string, fn func(context.Context, *ProjectWorkSpaceAbility) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectWorkSpaceAbility))
		}
		var CMDB_PROJECT_WORKSPACE_ABILITIES_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_WORKSPACE_ABILITIES_CREATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_WORKSPACE_ABILITIES_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_WORKSPACE_ABILITIES_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ProjectWorkSpaceAbility
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE := func(method, path string, fn func(context.Context, *CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_Request))
		}
		var CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_WORKSPACE_ABILITIES_GET := func(method, path string, fn func(context.Context, *CMDB_PROJECT_WORKSPACE_ABILITIES_GET_Request) (*ProjectWorkSpaceAbilityResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMDB_PROJECT_WORKSPACE_ABILITIES_GET_Request))
		}
		var CMDB_PROJECT_WORKSPACE_ABILITIES_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_WORKSPACE_ABILITIES_GET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_WORKSPACE_ABILITIES_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_WORKSPACE_ABILITIES_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMDB_PROJECT_WORKSPACE_ABILITIES_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "workspace":
							in.Workspace = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_PROJECT_WORKSPACE_ABILITIES_UPDATE := func(method, path string, fn func(context.Context, *ProjectWorkSpaceAbility) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ProjectWorkSpaceAbility))
		}
		var CMDB_PROJECT_WORKSPACE_ABILITIES_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_PROJECT_WORKSPACE_ABILITIES_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_PROJECT_WORKSPACE_ABILITIES_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_PROJECT_WORKSPACE_ABILITIES_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in ProjectWorkSpaceAbility
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_ROLES_LIST_BY_USER := func(method, path string, fn func(context.Context, *ListMemberRolesByUserRequest) (*ListMemberRolesByUserResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListMemberRolesByUserRequest))
		}
		var CMDB_ROLES_LIST_BY_USER_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMDB_ROLES_LIST_BY_USER_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "CMDB_ROLES_LIST_BY_USER", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMDB_ROLES_LIST_BY_USER_info)
				}
				r = r.WithContext(ctx)
				var in ListMemberRolesByUserRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_EVENTBOX_WEBSOCKET := func(method, path string, fn func(context.Context, *EVENTBOX_WEBSOCKET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*EVENTBOX_WEBSOCKET_Request))
		}
		var EVENTBOX_WEBSOCKET_info transport.ServiceInfo
		if h.Interceptor != nil {
			EVENTBOX_WEBSOCKET_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "EVENTBOX_WEBSOCKET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, EVENTBOX_WEBSOCKET_info)
				}
				r = r.WithContext(ctx)
				var in EVENTBOX_WEBSOCKET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "a":
							in.A = val
						case "b":
							in.B = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_EVENTBOX_WEBSOCKET_INFO := func(method, path string, fn func(context.Context, *EVENTBOX_WEBSOCKET_INFO_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*EVENTBOX_WEBSOCKET_INFO_Request))
		}
		var EVENTBOX_WEBSOCKET_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			EVENTBOX_WEBSOCKET_INFO_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "EVENTBOX_WEBSOCKET_INFO", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, EVENTBOX_WEBSOCKET_INFO_info)
				}
				r = r.WithContext(ctx)
				var in EVENTBOX_WEBSOCKET_INFO_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QUOTA_GET_PROJECT_NAMESPACES := func(method, path string, fn func(context.Context, *QUOTA_GET_PROJECT_NAMESPACES_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QUOTA_GET_PROJECT_NAMESPACES_Request))
		}
		var QUOTA_GET_PROJECT_NAMESPACES_info transport.ServiceInfo
		if h.Interceptor != nil {
			QUOTA_GET_PROJECT_NAMESPACES_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "QUOTA_GET_PROJECT_NAMESPACES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QUOTA_GET_PROJECT_NAMESPACES_info)
				}
				r = r.WithContext(ctx)
				var in QUOTA_GET_PROJECT_NAMESPACES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QUOTA_GET_PROJECT_QUOTA := func(method, path string, fn func(context.Context, *QUOTA_GET_PROJECT_QUOTA_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QUOTA_GET_PROJECT_QUOTA_Request))
		}
		var QUOTA_GET_PROJECT_QUOTA_info transport.ServiceInfo
		if h.Interceptor != nil {
			QUOTA_GET_PROJECT_QUOTA_info = transport.NewServiceInfo("erda.openapiv1.core.core_services", "QUOTA_GET_PROJECT_QUOTA", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QUOTA_GET_PROJECT_QUOTA_info)
				}
				r = r.WithContext(ctx)
				var in QUOTA_GET_PROJECT_QUOTA_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMDB_APPLICATIONS_LIST("GET", "/api/applications", srv.CMDB_APPLICATIONS_LIST)
	add_CMDB_APPLICATION_FETCH("GET", "/api/applications/{applicationIDOrName}", srv.CMDB_APPLICATION_FETCH)
	add_CMDB_APPLICATION_PIN("PUT", "/api/applications/{applicationId}/actions/pin", srv.CMDB_APPLICATION_PIN)
	add_CMDB_APPLICATION_UNPIN("PUT", "/api/applications/{applicationId}/actions/unpin", srv.CMDB_APPLICATION_UNPIN)
	add_CMDB_APPROVE_CREATE("POST", "/api/approves", srv.CMDB_APPROVE_CREATE)
	add_CMDB_APP_LIST_TEMPLATES("GET", "/api/applications/actions/list-templates", srv.CMDB_APP_LIST_TEMPLATES)
	add_CMDB_AUDITS_LIST_SET("GET", "/api/audits/actions/setting", srv.CMDB_AUDITS_LIST_SET)
	add_CMDB_AUDITS_SET("PUT", "/api/audits/actions/setting", srv.CMDB_AUDITS_SET)
	add_CMDB_CLUSTER_DEREFERENCE("PUT", "/api/clusters/actions/dereference", srv.CMDB_CLUSTER_DEREFERENCE)
	add_CMDB_ERRORLOG_CREATE("POST", "/api/task-error/actions/create", srv.CMDB_ERRORLOG_CREATE)
	add_CMDB_IMAGE_FETCH("GET", "/api/images/{imageName}", srv.CMDB_IMAGE_FETCH)
	add_CMDB_IMAGE_UPLOAD("POST", "/api/images/actions/upload", srv.CMDB_IMAGE_UPLOAD)
	add_CMDB_LABEL_CREATE("POST", "/api/labels", srv.CMDB_LABEL_CREATE)
	add_CMDB_LABEL_DELETE("DELETE", "/api/labels/{id}", srv.CMDB_LABEL_DELETE)
	add_CMDB_LABEL_LIST("GET", "/api/labels", srv.CMDB_LABEL_LIST)
	add_CMDB_LABEL_UPDATE("PUT", "/api/labels/{ID}", srv.CMDB_LABEL_UPDATE)
	add_CMDB_LICENSE("GET", "/api/license", srv.CMDB_LICENSE)
	add_CMDB_MANUAL_REVIEW_ADD("POST", "/api/reviews/actions/review/approve", srv.CMDB_MANUAL_REVIEW_ADD)
	add_CMDB_MANUAL_REVIEW_ADDUSER("POST", "/api/reviews/actions/user/create", srv.CMDB_MANUAL_REVIEW_ADDUSER)
	add_CMDB_MANUAL_REVIEW_AUTHORITY("GET", "/api/reviews/actions/authority", srv.CMDB_MANUAL_REVIEW_AUTHORITY)
	add_CMDB_MANUAL_REVIEW_GET("GET", "/api/reviews/actions/{id}", srv.CMDB_MANUAL_REVIEW_GET)
	add_CMDB_MANUAL_REVIEW_LISTBYSPONSORID("GET", "/api/reviews/actions/list-launched-approval", srv.CMDB_MANUAL_REVIEW_LISTBYSPONSORID)
	add_CMDB_MANUAL_REVIEW_LISTBYUserID("GET", "/api/reviews/actions/list-approved", srv.CMDB_MANUAL_REVIEW_LISTBYUserID)
	add_CMDB_MANUAL_REVIEW_UPDATE("PUT", "/api/reviews/actions/updateReview", srv.CMDB_MANUAL_REVIEW_UPDATE)
	add_CMDB_MBOX_GET("GET", "/api/mboxs/{mboxID}", srv.CMDB_MBOX_GET)
	add_CMDB_MBOX_LIST("GET", "/api/mboxs", srv.CMDB_MBOX_LIST)
	add_CMDB_MBOX_READ_ALL("POST", "/api/mboxs/actions/read-all", srv.CMDB_MBOX_READ_ALL)
	add_CMDB_MBOX_STATS("GET", "/api/mboxs/actions/stats", srv.CMDB_MBOX_STATS)
	add_CMDB_MEMBER_ADD("POST", "/api/members", srv.CMDB_MEMBER_ADD)
	add_CMDB_MEMBER_ADD_BY_INVITECODE("POST", "/api/members/actions/create-by-invitecode", srv.CMDB_MEMBER_ADD_BY_INVITECODE)
	add_CMDB_MEMBER_LABEL_LIST("GET", "/api/members/actions/list-labels", srv.CMDB_MEMBER_LABEL_LIST)
	add_CMDB_MEMBER_LIST("GET", "/api/members", srv.CMDB_MEMBER_LIST)
	add_CMDB_MEMBER_REMOVE("POST", "/api/members/actions/remove", srv.CMDB_MEMBER_REMOVE)
	add_CMDB_MY_APPLICATIONS_LIST("GET", "/api/applications/actions/list-my-applications", srv.CMDB_MY_APPLICATIONS_LIST)
	add_CMDB_MY_PROJECTS_LIST("GET", "/api/projects/actions/list-my-projects", srv.CMDB_MY_PROJECTS_LIST)
	add_CMDB_NOTIFYITEM_QUERY("GET", "/api/notify-items", srv.CMDB_NOTIFYITEM_QUERY)
	add_CMDB_NOTIFYITEM_UPDATE("PUT", "/api/notify-items/{notifyItemID}", srv.CMDB_NOTIFYITEM_UPDATE)
	add_CMDB_NOTIFY_CREATE("POST", "/api/notifies", srv.CMDB_NOTIFY_CREATE)
	add_CMDB_NOTIFY_DELETE("DELETE", "/api/notifies/{notifyID}", srv.CMDB_NOTIFY_DELETE)
	add_CMDB_NOTIFY_DISABLE("PUT", "/api/notifies/{notifyID}/actions/disable", srv.CMDB_NOTIFY_DISABLE)
	add_CMDB_NOTIFY_ENABLE("PUT", "/api/notifies/{notifyID}/actions/enable", srv.CMDB_NOTIFY_ENABLE)
	add_CMDB_NOTIFY_FUZZY_QUERY("GET", "/api/notifies/actions/fuzzy-query-by-source", srv.CMDB_NOTIFY_FUZZY_QUERY)
	add_CMDB_NOTIFY_GET("GET", "/api/notifies/{notifyID}", srv.CMDB_NOTIFY_GET)
	add_CMDB_NOTIFY_HISTORIES("GET", "/api/notify-histories", srv.CMDB_NOTIFY_HISTORIES)
	add_CMDB_NOTIFY_QUERY("GET", "/api/notifies", srv.CMDB_NOTIFY_QUERY)
	add_CMDB_NOTIFY_UPDATE("PUT", "/api/notifies/{notifyID}", srv.CMDB_NOTIFY_UPDATE)
	add_CMDB_PERMISSION_ACCESS("POST", "/api/permissions/actions/access", srv.CMDB_PERMISSION_ACCESS)
	add_CMDB_PERMISSION_CHECK("POST", "/api/permissions/actions/check", srv.CMDB_PERMISSION_CHECK)
	add_CMDB_PERMISSION_LIST("GET", "/api/permissions", srv.CMDB_PERMISSION_LIST)
	add_CMDB_PROJECT_FUNCTIONS_GET("GET", "/api/projects/actions/get-project-functions", srv.CMDB_PROJECT_FUNCTIONS_GET)
	add_CMDB_PROJECT_FUNCTIONS_SET("POST", "/api/projects/actions/set-project-functions", srv.CMDB_PROJECT_FUNCTIONS_SET)
	add_CMDB_PROJECT_GET_NSINFO("GET", "/api/projects/{projectID}/actions/get-ns-info", srv.CMDB_PROJECT_GET_NSINFO)
	add_CMDB_PROJECT_METRICS_HISTOGRAM("GET", "/api/projects/resource/{resourceType}/actions/list-usage-histogram", srv.CMDB_PROJECT_METRICS_HISTOGRAM)
	add_CMDB_PROJECT_UPDATE("PUT", "/api/projects/{projectID}", srv.CMDB_PROJECT_UPDATE)
	add_CMDB_PROJECT_WORKSPACE_ABILITIES_CREATE("POST", "/api/project-workspace-abilities", srv.CMDB_PROJECT_WORKSPACE_ABILITIES_CREATE)
	add_CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE("DELETE", "/api/project-workspace-abilities", srv.CMDB_PROJECT_WORKSPACE_ABILITIES_DELETE)
	add_CMDB_PROJECT_WORKSPACE_ABILITIES_GET("GET", "/api/project-workspace-abilities/{projectID}/{workspace}", srv.CMDB_PROJECT_WORKSPACE_ABILITIES_GET)
	add_CMDB_PROJECT_WORKSPACE_ABILITIES_UPDATE("PUT", "/api/project-workspace-abilities", srv.CMDB_PROJECT_WORKSPACE_ABILITIES_UPDATE)
	add_CMDB_ROLES_LIST_BY_USER("GET", "/api/members/actions/list-user-roles", srv.CMDB_ROLES_LIST_BY_USER)
	add_EVENTBOX_WEBSOCKET("GET", "/api/websocket/{a}/{b}/websocket", srv.EVENTBOX_WEBSOCKET)
	add_EVENTBOX_WEBSOCKET_INFO("GET", "/api/websocket/info", srv.EVENTBOX_WEBSOCKET_INFO)
	add_QUOTA_GET_PROJECT_NAMESPACES("GET", "/api/projects-namespaces", srv.QUOTA_GET_PROJECT_NAMESPACES)
	add_QUOTA_GET_PROJECT_QUOTA("GET", "/api/projects-quota", srv.QUOTA_GET_PROJECT_QUOTA)
}
