// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: dicehub.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*CreateBranchRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateUpdateDeleteReleaseRuleRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DICEHUB_RELEASES_DOWNLOAD_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*H5VersionInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RELEASE_RULE_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RELEASE_RULE_UPDATE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RELEASE_RULEDelete_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseGetDiceYmlRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseResource)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseTag)(nil)
var _ urlenc.URLValuesUnmarshaler = (*VersionInfo)(nil)

// CreateBranchRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateBranchRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CreateUpdateDeleteReleaseRuleRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateUpdateDeleteReleaseRuleRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "userID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UserID = val
			case "ruleID":
				m.RuleID = vals[0]
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// DICEHUB_RELEASES_DOWNLOAD_Request implement urlenc.URLValuesUnmarshaler.
func (m *DICEHUB_RELEASES_DOWNLOAD_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseId":
				m.ReleaseId = vals[0]
			}
		}
	}
	return nil
}

// H5VersionInfo implement urlenc.URLValuesUnmarshaler.
func (m *H5VersionInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "versionInfo":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.VersionInfo = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.VersionInfo = val
					} else {
						m.VersionInfo = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// RELEASE_RULE_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *RELEASE_RULE_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// RELEASE_RULE_UPDATE_Request implement urlenc.URLValuesUnmarshaler.
func (m *RELEASE_RULE_UPDATE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// RELEASE_RULEDelete_Request implement urlenc.URLValuesUnmarshaler.
func (m *RELEASE_RULEDelete_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// ReleaseData implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			case "releaseName":
				m.ReleaseName = vals[0]
			case "diceyml":
				m.Diceyml = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "addon":
				m.Addon = vals[0]
			case "changelog":
				m.Changelog = vals[0]
			case "isStable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsStable = val
			case "isFormal":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsFormal = val
			case "isProjectRelease":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsProjectRelease = val
			case "applicationReleaseList":
				m.ApplicationReleaseList = vals[0]
			case "images":
				m.Images = vals
			case "version":
				m.Version = vals[0]
			case "crossCluster":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CrossCluster = val
			case "reference":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Reference = val
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "applicationName":
				m.ApplicationName = vals[0]
			case "userID":
				m.UserID = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "isLatest":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsLatest = val
			}
		}
	}
	return nil
}

// ReleaseGetDiceYmlRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseGetDiceYmlRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			}
		}
	}
	return nil
}

// ReleaseListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "query":
				m.Query = vals[0]
			case "releaseID":
				m.ReleaseID = vals[0]
			case "releaseName":
				m.ReleaseName = vals[0]
			case "cluster":
				m.Cluster = vals[0]
			case "branch":
				m.Branch = vals[0]
			case "latest":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Latest = val
			case "isStable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsStable = &val
			case "isFormal":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsFormal = &val
			case "isProjectRelease":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsProjectRelease = &val
			case "userID":
				m.UserID = vals
			case "version":
				m.Version = vals[0]
			case "commitID":
				m.CommitID = vals[0]
			case "tags":
				m.Tags = vals[0]
			case "isVersion":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsVersion = val
			case "crossCluster":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CrossCluster = &val
			case "crossClusterOrSpecifyCluster":
				m.CrossClusterOrSpecifyCluster = &vals[0]
			case "applicationID":
				m.ApplicationID = vals
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "startTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTime = val
			case "endTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTime = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "pageNum":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNum = val
			case "orderBy":
				m.OrderBy = vals[0]
			case "order":
				m.Order = vals[0]
			}
		}
	}
	return nil
}

// ReleaseListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ReleaseListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ReleaseResource implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseResource) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "name":
				m.Name = vals[0]
			case "uRL":
				m.URL = vals[0]
			}
		}
	}
	return nil
}

// ReleaseTag implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseTag) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "creator":
				m.Creator = vals[0]
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "color":
				m.Color = vals[0]
			case "name":
				m.Name = vals[0]
			case "type":
				m.Type = vals[0]
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// VersionInfo implement urlenc.URLValuesUnmarshaler.
func (m *VersionInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageName":
				m.PackageName = vals[0]
			case "version":
				m.Version = vals[0]
			case "buildID":
				m.BuildID = vals[0]
			}
		}
	}
	return nil
}
