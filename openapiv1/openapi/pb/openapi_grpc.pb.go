// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// Source: openapi.proto

package pb

import (
	context "context"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	grpc1 "github.com/erda-project/erda-infra/pkg/transport/grpc"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion5

// OpenapiClient is the client API for Openapi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OpenapiClient interface {
	DICE_METADATA(ctx context.Context, in *DICE_METADATA_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DOC_JSON(ctx context.Context, in *DOC_JSON_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	OPENAPI_DOC(ctx context.Context, in *OPENAPI_DOC_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	OPENAPI_EVENT_DOC(ctx context.Context, in *OPENAPI_EVENT_DOC_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	OPENAPI_GEN_CLIENT_TOKEN(ctx context.Context, in *OPENAPI_GEN_CLIENT_TOKEN_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	OPENAPI_LIST_CLIENT(ctx context.Context, in *OPENAPI_LIST_CLIENT_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	OPENAPI_METRICS(ctx context.Context, in *OPENAPI_METRICS_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	OPENAPI_NEW_CLIENT(ctx context.Context, in *OPENAPI_NEW_CLIENT_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	OPENAPI_STAT(ctx context.Context, in *OPENAPI_STAT_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	OPENAPI_VERSION(ctx context.Context, in *OPENAPI_VERSION_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type openapiClient struct {
	cc grpc1.ClientConnInterface
}

func NewOpenapiClient(cc grpc1.ClientConnInterface) OpenapiClient {
	return &openapiClient{cc}
}

func (c *openapiClient) DICE_METADATA(ctx context.Context, in *DICE_METADATA_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/DICE_METADATA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) DOC_JSON(ctx context.Context, in *DOC_JSON_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/DOC_JSON", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) OPENAPI_DOC(ctx context.Context, in *OPENAPI_DOC_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/OPENAPI_DOC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) OPENAPI_EVENT_DOC(ctx context.Context, in *OPENAPI_EVENT_DOC_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/OPENAPI_EVENT_DOC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) OPENAPI_GEN_CLIENT_TOKEN(ctx context.Context, in *OPENAPI_GEN_CLIENT_TOKEN_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/OPENAPI_GEN_CLIENT_TOKEN", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) OPENAPI_LIST_CLIENT(ctx context.Context, in *OPENAPI_LIST_CLIENT_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/OPENAPI_LIST_CLIENT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) OPENAPI_METRICS(ctx context.Context, in *OPENAPI_METRICS_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/OPENAPI_METRICS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) OPENAPI_NEW_CLIENT(ctx context.Context, in *OPENAPI_NEW_CLIENT_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/OPENAPI_NEW_CLIENT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) OPENAPI_STAT(ctx context.Context, in *OPENAPI_STAT_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/OPENAPI_STAT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openapiClient) OPENAPI_VERSION(ctx context.Context, in *OPENAPI_VERSION_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.openapi.openapi/OPENAPI_VERSION", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OpenapiServer is the server API for Openapi service.
// All implementations should embed UnimplementedOpenapiServer
// for forward compatibility
type OpenapiServer interface {
	DICE_METADATA(context.Context, *DICE_METADATA_Request) (*emptypb.Empty, error)
	DOC_JSON(context.Context, *DOC_JSON_Request) (*emptypb.Empty, error)
	OPENAPI_DOC(context.Context, *OPENAPI_DOC_Request) (*emptypb.Empty, error)
	OPENAPI_EVENT_DOC(context.Context, *OPENAPI_EVENT_DOC_Request) (*emptypb.Empty, error)
	OPENAPI_GEN_CLIENT_TOKEN(context.Context, *OPENAPI_GEN_CLIENT_TOKEN_Request) (*emptypb.Empty, error)
	OPENAPI_LIST_CLIENT(context.Context, *OPENAPI_LIST_CLIENT_Request) (*emptypb.Empty, error)
	OPENAPI_METRICS(context.Context, *OPENAPI_METRICS_Request) (*emptypb.Empty, error)
	OPENAPI_NEW_CLIENT(context.Context, *OPENAPI_NEW_CLIENT_Request) (*emptypb.Empty, error)
	OPENAPI_STAT(context.Context, *OPENAPI_STAT_Request) (*emptypb.Empty, error)
	OPENAPI_VERSION(context.Context, *OPENAPI_VERSION_Request) (*emptypb.Empty, error)
}

// UnimplementedOpenapiServer should be embedded to have forward compatible implementations.
type UnimplementedOpenapiServer struct {
}

func (*UnimplementedOpenapiServer) DICE_METADATA(context.Context, *DICE_METADATA_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DICE_METADATA not implemented")
}
func (*UnimplementedOpenapiServer) DOC_JSON(context.Context, *DOC_JSON_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DOC_JSON not implemented")
}
func (*UnimplementedOpenapiServer) OPENAPI_DOC(context.Context, *OPENAPI_DOC_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OPENAPI_DOC not implemented")
}
func (*UnimplementedOpenapiServer) OPENAPI_EVENT_DOC(context.Context, *OPENAPI_EVENT_DOC_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OPENAPI_EVENT_DOC not implemented")
}
func (*UnimplementedOpenapiServer) OPENAPI_GEN_CLIENT_TOKEN(context.Context, *OPENAPI_GEN_CLIENT_TOKEN_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OPENAPI_GEN_CLIENT_TOKEN not implemented")
}
func (*UnimplementedOpenapiServer) OPENAPI_LIST_CLIENT(context.Context, *OPENAPI_LIST_CLIENT_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OPENAPI_LIST_CLIENT not implemented")
}
func (*UnimplementedOpenapiServer) OPENAPI_METRICS(context.Context, *OPENAPI_METRICS_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OPENAPI_METRICS not implemented")
}
func (*UnimplementedOpenapiServer) OPENAPI_NEW_CLIENT(context.Context, *OPENAPI_NEW_CLIENT_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OPENAPI_NEW_CLIENT not implemented")
}
func (*UnimplementedOpenapiServer) OPENAPI_STAT(context.Context, *OPENAPI_STAT_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OPENAPI_STAT not implemented")
}
func (*UnimplementedOpenapiServer) OPENAPI_VERSION(context.Context, *OPENAPI_VERSION_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OPENAPI_VERSION not implemented")
}

func RegisterOpenapiServer(s grpc1.ServiceRegistrar, srv OpenapiServer, opts ...grpc1.HandleOption) {
	s.RegisterService(_get_Openapi_serviceDesc(srv, opts...), srv)
}

var _Openapi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "erda.openapiv1.openapi.openapi",
	HandlerType: (*OpenapiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "openapi.proto",
}

func _get_Openapi_serviceDesc(srv OpenapiServer, opts ...grpc1.HandleOption) *grpc.ServiceDesc {
	h := grpc1.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}

	_Openapi_DICE_METADATA_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.DICE_METADATA(ctx, req.(*DICE_METADATA_Request))
	}
	var _Openapi_DICE_METADATA_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_DICE_METADATA_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "DICE_METADATA", srv)
		_Openapi_DICE_METADATA_Handler = h.Interceptor(_Openapi_DICE_METADATA_Handler)
	}

	_Openapi_DOC_JSON_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.DOC_JSON(ctx, req.(*DOC_JSON_Request))
	}
	var _Openapi_DOC_JSON_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_DOC_JSON_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "DOC_JSON", srv)
		_Openapi_DOC_JSON_Handler = h.Interceptor(_Openapi_DOC_JSON_Handler)
	}

	_Openapi_OPENAPI_DOC_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.OPENAPI_DOC(ctx, req.(*OPENAPI_DOC_Request))
	}
	var _Openapi_OPENAPI_DOC_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_OPENAPI_DOC_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "OPENAPI_DOC", srv)
		_Openapi_OPENAPI_DOC_Handler = h.Interceptor(_Openapi_OPENAPI_DOC_Handler)
	}

	_Openapi_OPENAPI_EVENT_DOC_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.OPENAPI_EVENT_DOC(ctx, req.(*OPENAPI_EVENT_DOC_Request))
	}
	var _Openapi_OPENAPI_EVENT_DOC_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_OPENAPI_EVENT_DOC_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "OPENAPI_EVENT_DOC", srv)
		_Openapi_OPENAPI_EVENT_DOC_Handler = h.Interceptor(_Openapi_OPENAPI_EVENT_DOC_Handler)
	}

	_Openapi_OPENAPI_GEN_CLIENT_TOKEN_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.OPENAPI_GEN_CLIENT_TOKEN(ctx, req.(*OPENAPI_GEN_CLIENT_TOKEN_Request))
	}
	var _Openapi_OPENAPI_GEN_CLIENT_TOKEN_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_OPENAPI_GEN_CLIENT_TOKEN_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "OPENAPI_GEN_CLIENT_TOKEN", srv)
		_Openapi_OPENAPI_GEN_CLIENT_TOKEN_Handler = h.Interceptor(_Openapi_OPENAPI_GEN_CLIENT_TOKEN_Handler)
	}

	_Openapi_OPENAPI_LIST_CLIENT_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.OPENAPI_LIST_CLIENT(ctx, req.(*OPENAPI_LIST_CLIENT_Request))
	}
	var _Openapi_OPENAPI_LIST_CLIENT_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_OPENAPI_LIST_CLIENT_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "OPENAPI_LIST_CLIENT", srv)
		_Openapi_OPENAPI_LIST_CLIENT_Handler = h.Interceptor(_Openapi_OPENAPI_LIST_CLIENT_Handler)
	}

	_Openapi_OPENAPI_METRICS_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.OPENAPI_METRICS(ctx, req.(*OPENAPI_METRICS_Request))
	}
	var _Openapi_OPENAPI_METRICS_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_OPENAPI_METRICS_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "OPENAPI_METRICS", srv)
		_Openapi_OPENAPI_METRICS_Handler = h.Interceptor(_Openapi_OPENAPI_METRICS_Handler)
	}

	_Openapi_OPENAPI_NEW_CLIENT_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.OPENAPI_NEW_CLIENT(ctx, req.(*OPENAPI_NEW_CLIENT_Request))
	}
	var _Openapi_OPENAPI_NEW_CLIENT_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_OPENAPI_NEW_CLIENT_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "OPENAPI_NEW_CLIENT", srv)
		_Openapi_OPENAPI_NEW_CLIENT_Handler = h.Interceptor(_Openapi_OPENAPI_NEW_CLIENT_Handler)
	}

	_Openapi_OPENAPI_STAT_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.OPENAPI_STAT(ctx, req.(*OPENAPI_STAT_Request))
	}
	var _Openapi_OPENAPI_STAT_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_OPENAPI_STAT_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "OPENAPI_STAT", srv)
		_Openapi_OPENAPI_STAT_Handler = h.Interceptor(_Openapi_OPENAPI_STAT_Handler)
	}

	_Openapi_OPENAPI_VERSION_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.OPENAPI_VERSION(ctx, req.(*OPENAPI_VERSION_Request))
	}
	var _Openapi_OPENAPI_VERSION_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Openapi_OPENAPI_VERSION_info = transport.NewServiceInfo("erda.openapiv1.openapi.openapi", "OPENAPI_VERSION", srv)
		_Openapi_OPENAPI_VERSION_Handler = h.Interceptor(_Openapi_OPENAPI_VERSION_Handler)
	}

	var serviceDesc = _Openapi_serviceDesc
	serviceDesc.Methods = []grpc.MethodDesc{
		{
			MethodName: "DICE_METADATA",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(DICE_METADATA_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).DICE_METADATA(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_DICE_METADATA_info)
				}
				if interceptor == nil {
					return _Openapi_DICE_METADATA_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/DICE_METADATA",
				}
				return interceptor(ctx, in, info, _Openapi_DICE_METADATA_Handler)
			},
		},
		{
			MethodName: "DOC_JSON",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(DOC_JSON_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).DOC_JSON(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_DOC_JSON_info)
				}
				if interceptor == nil {
					return _Openapi_DOC_JSON_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/DOC_JSON",
				}
				return interceptor(ctx, in, info, _Openapi_DOC_JSON_Handler)
			},
		},
		{
			MethodName: "OPENAPI_DOC",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(OPENAPI_DOC_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).OPENAPI_DOC(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_OPENAPI_DOC_info)
				}
				if interceptor == nil {
					return _Openapi_OPENAPI_DOC_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/OPENAPI_DOC",
				}
				return interceptor(ctx, in, info, _Openapi_OPENAPI_DOC_Handler)
			},
		},
		{
			MethodName: "OPENAPI_EVENT_DOC",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(OPENAPI_EVENT_DOC_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).OPENAPI_EVENT_DOC(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_OPENAPI_EVENT_DOC_info)
				}
				if interceptor == nil {
					return _Openapi_OPENAPI_EVENT_DOC_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/OPENAPI_EVENT_DOC",
				}
				return interceptor(ctx, in, info, _Openapi_OPENAPI_EVENT_DOC_Handler)
			},
		},
		{
			MethodName: "OPENAPI_GEN_CLIENT_TOKEN",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(OPENAPI_GEN_CLIENT_TOKEN_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).OPENAPI_GEN_CLIENT_TOKEN(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_OPENAPI_GEN_CLIENT_TOKEN_info)
				}
				if interceptor == nil {
					return _Openapi_OPENAPI_GEN_CLIENT_TOKEN_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/OPENAPI_GEN_CLIENT_TOKEN",
				}
				return interceptor(ctx, in, info, _Openapi_OPENAPI_GEN_CLIENT_TOKEN_Handler)
			},
		},
		{
			MethodName: "OPENAPI_LIST_CLIENT",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(OPENAPI_LIST_CLIENT_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).OPENAPI_LIST_CLIENT(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_OPENAPI_LIST_CLIENT_info)
				}
				if interceptor == nil {
					return _Openapi_OPENAPI_LIST_CLIENT_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/OPENAPI_LIST_CLIENT",
				}
				return interceptor(ctx, in, info, _Openapi_OPENAPI_LIST_CLIENT_Handler)
			},
		},
		{
			MethodName: "OPENAPI_METRICS",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(OPENAPI_METRICS_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).OPENAPI_METRICS(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_OPENAPI_METRICS_info)
				}
				if interceptor == nil {
					return _Openapi_OPENAPI_METRICS_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/OPENAPI_METRICS",
				}
				return interceptor(ctx, in, info, _Openapi_OPENAPI_METRICS_Handler)
			},
		},
		{
			MethodName: "OPENAPI_NEW_CLIENT",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(OPENAPI_NEW_CLIENT_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).OPENAPI_NEW_CLIENT(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_OPENAPI_NEW_CLIENT_info)
				}
				if interceptor == nil {
					return _Openapi_OPENAPI_NEW_CLIENT_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/OPENAPI_NEW_CLIENT",
				}
				return interceptor(ctx, in, info, _Openapi_OPENAPI_NEW_CLIENT_Handler)
			},
		},
		{
			MethodName: "OPENAPI_STAT",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(OPENAPI_STAT_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).OPENAPI_STAT(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_OPENAPI_STAT_info)
				}
				if interceptor == nil {
					return _Openapi_OPENAPI_STAT_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/OPENAPI_STAT",
				}
				return interceptor(ctx, in, info, _Openapi_OPENAPI_STAT_Handler)
			},
		},
		{
			MethodName: "OPENAPI_VERSION",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(OPENAPI_VERSION_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(OpenapiServer).OPENAPI_VERSION(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Openapi_OPENAPI_VERSION_info)
				}
				if interceptor == nil {
					return _Openapi_OPENAPI_VERSION_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.openapi.openapi/OPENAPI_VERSION",
				}
				return interceptor(ctx, in, info, _Openapi_OPENAPI_VERSION_Handler)
			},
		},
	}
	return &serviceDesc
}
