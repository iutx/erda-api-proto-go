// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: cmp.proto

package pb

import (
	context "context"
	http1 "net/http"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// CmpHandler is the server API for Cmp service.
type CmpHandler interface {
	// GET /api/addons/actions/config
	CMP_ADDON_CONFIG(context.Context, *AddonConfigRequest) (*AddonConfigResponse, error)
	// POST /api/addons/actions/config
	CMP_ADDON_CONFIG_UPDATE(context.Context, *AddonConfigUpdateRequest) (*AddonConfigUpdateResponse, error)
	// POST /api/addons/actions/scale
	CMP_ADDON_SCALE(context.Context, *AddonScaleRequest) (*AddonScaleResponse, error)
	// GET /api/addons/status
	CMP_ADDON_STATUS(context.Context, *OpsAddonStatusQueryRequest) (*OpsAddonStatusResponse, error)
	// GET /api/cmp/alerts/conditions
	CMP_ALERT_CONDITIONS(context.Context, *CMP_ALERT_CONDITIONS_Request) (*emptypb.Empty, error)
	// POST /api/cmp/alerts/conditions/value
	CMP_ALERT_CONDITIONS_VALUE(context.Context, *CMP_ALERT_CONDITIONS_VALUE_Request) (*emptypb.Empty, error)
	// POST /api/cloud-clusters
	CMP_CLOUD_CLUSTERS(context.Context, *CloudClusterRequest) (*CloudClusterResponse, error)
	// POST /api/ops/cloud-nodes
	CMP_CLOUD_NODES(context.Context, *CloudNodesRequest) (*CloudNodesResponse, error)
	// GET /api/ops/cloud-resource
	CMP_CLOUD_RESOURCE(context.Context, *CMP_CLOUD_RESOURCE_Request) (*emptypb.Empty, error)
	// POST /api/cloud-account
	CMP_CLOUD_RESOURCE_ACCOUNT_CREATE(context.Context, *CreateCloudAccountRequest) (*CreateCloudAccountResponse, error)
	// DELETE /api/cloud-account
	CMP_CLOUD_RESOURCE_ACCOUNT_DELETE(context.Context, *DeleteCloudAccountRequest) (*DeleteCloudAccountResponse, error)
	// GET /api/cloud-account
	CMP_CLOUD_RESOURCE_ACCOUNT_LIST(context.Context, *CMP_CLOUD_RESOURCE_ACCOUNT_LIST_Request) (*ListCloudAccountResponse, error)
	// POST /api/cloud-ecs/actions/config-renew-attribute
	CMP_CLOUD_RESOURCE_ECS_AUTO_RENEW(context.Context, *AutoRenewCloudResourceEcsRequest) (*HandleCloudResourceECSResponse, error)
	// GET /api/cloud-ecs
	CMP_CLOUD_RESOURCE_ECS_LIST(context.Context, *ListCloudResourceECSRequest) (*ListCloudResourceECSResponse, error)
	// POST /api/cloud-ecs/actions/restart
	CMP_CLOUD_RESOURCE_ECS_RESTART(context.Context, *HandleCloudResourceEcsRequest) (*HandleCloudResourceECSResponse, error)
	// POST /api/cloud-ecs/actions/start
	CMP_CLOUD_RESOURCE_ECS_START(context.Context, *HandleCloudResourceEcsRequest) (*HandleCloudResourceECSResponse, error)
	// POST /api/cloud-ecs/actions/stop
	CMP_CLOUD_RESOURCE_ECS_STOP(context.Context, *HandleCloudResourceEcsRequest) (*HandleCloudResourceECSResponse, error)
	// GET /api/ecs-trending
	CMP_CLOUD_RESOURCE_ECS_TREND(context.Context, *CMP_CLOUD_RESOURCE_ECS_TREND_Request) (*GetCloudResourceECSTrendResponse, error)
	// GET /api/cloud-gateway
	CMP_CLOUD_RESOURCE_GATEWAY_LIST(context.Context, *ListCloudResourceGatewayRequest) (*ListCloudResourceGatewayResponse, error)
	// GET /api/ops/cloud-resource-list
	CMP_CLOUD_RESOURCE_LIST(context.Context, *CMP_CLOUD_RESOURCE_LIST_Request) (*emptypb.Empty, error)
	// POST /api/cloud-mysql/actions/create-account
	CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_CREATE(context.Context, *CreateCloudResourceMysqlAccountRequest) (*CreateCloudResourceMysqlAccountResponse, error)
	// GET /api/cloud-mysql/{instanceID}/accounts
	CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_INFO(context.Context, *CloudResourceMysqlListAccountRequest) (*CloudResourceMysqlListAccountResponse, error)
	// POST /api/cloud-mysql/actions/reset-password
	CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PASSWORD_RESET(context.Context, *CreateCloudResourceMysqlAccountRequest) (*CreateCloudResourceMysqlAccountResponse, error)
	// POST /api/cloud-mysql/actions/grant-privilege
	CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PRIVILEGE_GRANT(context.Context, *GrantMysqlAccountPrivilegeRequest) (*GrantMysqlAccountPrivilegeResponse, error)
	// POST /api/cloud-mysql
	CMP_CLOUD_RESOURCE_MYSQL_CREATE(context.Context, *CreateCloudResourceMysqlRequest) (*CreateCloudResourceMysqlResponse, error)
	// GET /api/cloud-mysql/{instanceID}/databases
	CMP_CLOUD_RESOURCE_MYSQL_DATABASE_INFO(context.Context, *CloudResourceMysqlDBRequest) (*CloudResourceMysqlDBResponse, error)
	// POST /api/cloud-mysql/actions/create-db
	CMP_CLOUD_RESOURCE_MYSQL_DB_CREATE(context.Context, *CreateCloudResourceMysqlDBRequest) (*CreateCloudResourceMysqlDBResponse, error)
	// DELETE /api/cloud-mysql/actions/delete-db
	CMP_CLOUD_RESOURCE_MYSQL_DB_DELETE(context.Context, *DeleteCloudResourceMysqlDBRequest) (*CloudAddonResourceDeleteRespnse, error)
	// DELETE /api/cloud-mysql
	CMP_CLOUD_RESOURCE_MYSQL_DELETE(context.Context, *DeleteCloudResourceMysqlRequest) (*CloudAddonResourceDeleteRespnse, error)
	// GET /api/cloud-mysql/{idorname}
	CMP_CLOUD_RESOURCE_MYSQL_DETAIL_INFO(context.Context, *CloudResourceMysqlDetailInfoRequest) (*CloudResourceMysqlDetailInfoResponse, error)
	// GET /api/cloud-mysql
	CMP_CLOUD_RESOURCE_MYSQL_LIST(context.Context, *ListCloudResourceMysqlRequest) (*ListCloudResourceMysqlResponse, error)
	// POST /api/cloud-ons
	CMP_CLOUD_RESOURCE_ONS_CREATE(context.Context, *CreateCloudResourceOnsRequest) (*CreateCloudResourceOnsResponse, error)
	// DELETE /api/cloud-ons
	CMP_CLOUD_RESOURCE_ONS_DELETE(context.Context, *DeleteCloudResourceOnsRequest) (*CloudAddonResourceDeleteRespnse, error)
	// GET /api/cloud-ons/{instanceID}
	CMP_CLOUD_RESOURCE_ONS_DETAIL_INFO(context.Context, *CloudResourceOnsDetailInfoRequest) (*CloudResourceOnsDetailInfoResponse, error)
	// POST /api/cloud-ons/actions/create-group
	CMP_CLOUD_RESOURCE_ONS_GROUP_CREATE(context.Context, *CreateCloudResourceOnsGroupRequest) (*CreateCloudResourceOnsGroupResponse, error)
	// GET /api/cloud-ons/actions/list-group
	CMP_CLOUD_RESOURCE_ONS_GROUP_INFO(context.Context, *CloudResourceOnsGroupInfoRequest) (*CloudResourceOnsGroupInfoResponse, error)
	// GET /api/cloud-ons
	CMP_CLOUD_RESOURCE_ONS_LIST(context.Context, *ListCloudResourceOnsRequest) (*ListCloudResourceOnsResponse, error)
	// POST /api/cloud-ons/actions/create-topic
	CMP_CLOUD_RESOURCE_ONS_TOPIC_CREATE(context.Context, *CreateCloudResourceOnsTopicRequest) (*CreateCloudResourceOnsTopicResponse, error)
	// DELETE /api/cloud-ons/actions/delete-topic
	CMP_CLOUD_RESOURCE_ONS_TOPIC_DELETE(context.Context, *DeleteCloudResourceOnsRequest) (*CloudAddonResourceDeleteRespnse, error)
	// GET /api/cloud-ons/actions/list-topic
	CMP_CLOUD_RESOURCE_ONS_TOPIC_INFO(context.Context, *CloudResourceOnsTopicInfoRequest) (*CloudResourceOnsTopicInfoResponse, error)
	// POST /api/cloud-oss
	CMP_CLOUD_RESOURCE_OSS_CREATE(context.Context, *CreateCloudResourceOssRequest) (*CreateCloudResourceOssResponse, error)
	// DELETE /api/cloud-oss
	CMP_CLOUD_RESOURCE_OSS_DELETE(context.Context, *DeleteCloudResourceOssRequest) (*CloudAddonResourceDeleteRespnse, error)
	// GET /api/cloud-oss/{bucketname}
	CMP_CLOUD_RESOURCE_OSS_DETAIL_INFO(context.Context, *CloudResourceOssDetailInfoRequest) (*CloudResourceOssDetailInfoResponse, error)
	// GET /api/cloud-oss
	CMP_CLOUD_RESOURCE_OSS_LIST(context.Context, *ListCloudResourceOssRequest) (*ListCloudResourceOssResponse, error)
	// GET /api/cloud-resource-overview
	CMP_CLOUD_RESOURCE_OVERVIEW(context.Context, *CloudResourceOverviewRequest) (*CloudResourceOverviewResponse, error)
	// POST /api/cloud-redis
	CMP_CLOUD_RESOURCE_REDIS_CREATE(context.Context, *CreateCloudResourceRedisRequest) (*CreateCloudResourceRedisResponse, error)
	// DELETE /api/cloud-redis
	CMP_CLOUD_RESOURCE_REDIS_DELETE(context.Context, *DeleteCloudResourceRedisRequest) (*CloudAddonResourceDeleteRespnse, error)
	// GET /api/cloud-redis/{instanceID}
	CMP_CLOUD_RESOURCE_REDIS_DETAIL_INFO(context.Context, *CloudResourceRedisDetailInfoRequest) (*CloudResourceRedisDetailInfoResponse, error)
	// GET /api/cloud-region
	CMP_CLOUD_RESOURCE_REGION_LIST(context.Context, *ListCloudResourceRegionRequest) (*ListCloudResourceRegionResponse, error)
	// GET /api/cloud-redis
	CMP_CLOUD_RESOURCE_Redis_LIST(context.Context, *ListCloudResourceRedisRequest) (*ListCloudResourceRedisResponse, error)
	// POST /api/cloud-resource/set-tag
	CMP_CLOUD_RESOURCE_SET_TAG(context.Context, *CloudResourceSetTagRequest) (*CloudResourceSetTagResponse, error)
	// POST /api/cloud-vpc
	CMP_CLOUD_RESOURCE_VPC_CREATE(context.Context, *CreateCloudResourceVPCRequest) (*CreateCloudResourceVPCResponse, error)
	// GET /api/cloud-vpc
	CMP_CLOUD_RESOURCE_VPC_LIST(context.Context, *ListCloudResourceVPCRequest) (*ListCloudResourceVPCResponse, error)
	// POST /api/cloud-vsw
	CMP_CLOUD_RESOURCE_VSW_CREATE(context.Context, *CreateCloudResourceVSWRequest) (*CreateCloudResourceVSWResponse, error)
	// GET /api/cloud-vsw
	CMP_CLOUD_RESOURCE_VSW_LIST(context.Context, *ListCloudResourceVSWRequest) (*ListCloudResourceVSWResponse, error)
	// GET /api/cloud-zone
	CMP_CLOUD_RESOURCE_ZONE_LIST(context.Context, *ListCloudResourceZoneRequest) (*ListCloudResourceZoneResponse, error)
	// POST /api/cluster/actions/batch-upgrade
	CMP_CLUSTER_BATCH_UPGRADE(context.Context, *BatchUpgradeEdgeClusterRequest) (*BatchUpgradeEdgeClusterResponse, error)
	// POST /api/clusters
	CMP_CLUSTER_IMPORT(context.Context, *CMP_CLUSTER_IMPORT_Request) (*emptypb.Empty, error)
	// GET /api/cluster
	CMP_CLUSTER_INFO(context.Context, *CMP_CLUSTER_INFO_Request) (*emptypb.Empty, error)
	// GET /api/cluster/init-command
	CMP_CLUSTER_INIT_COMMAND(context.Context, *CMP_CLUSTER_INIT_COMMAND_Request) (*emptypb.Empty, error)
	// POST /api/cluster/actions/init-retry
	CMP_CLUSTER_INIT_RETRY(context.Context, *CMP_CLUSTER_INIT_RETRY_Request) (*emptypb.Empty, error)
	// DELETE /api/cluster
	CMP_CLUSTER_OFFLINE(context.Context, *OfflineEdgeClusterRequest) (*OfflineEdgeClusterResponse, error)
	// POST /api/cluster-preview
	CMP_CLUSTER_PREVIEW(context.Context, *CMP_CLUSTER_PREVIEW_Request) (*emptypb.Empty, error)
	// PUT /api/clusters
	CMP_CLUSTER_UPDATE(context.Context, *ClusterUpdateRequest) (*ClusterUpdateResponse, error)
	// POST /api/cluster/actions/upgrade
	CMP_CLUSTER_UPGRADE(context.Context, *UpgradeEdgeClusterRequest) (*UpgradeEdgeClusterResponse, error)
	// POST /api/cluster/credential/access-keys
	CMP_CREDENTIAL_ACCESSKEY_CREATE(context.Context, *CMP_CREDENTIAL_ACCESSKEY_CREATE_Request) (*emptypb.Empty, error)
	// GET /api/cluster/credential/access-keys
	CMP_CREDENTIAL_ACCESSKEY_GET(context.Context, *CMP_CREDENTIAL_ACCESSKEY_GET_Request) (*emptypb.Empty, error)
	// POST /api/cluster/credential/access-keys/actions/reset
	CMP_CREDENTIAL_ACCESSKEY_RESET(context.Context, *CMP_CREDENTIAL_ACCESSKEY_RESET_Request) (*emptypb.Empty, error)
	// DELETE /api/edge/site/offline/{ID}
	CMP_EDGE_HOST_OFFLINE(context.Context, *EdgeHostOffline) (*emptypb.Empty, error)
	// GET /api/k8s/clusters
	CMP_K8S_CLUSTERS(context.Context, *CMP_K8S_CLUSTERS_Request) (*K8SClusters, error)
	// POST /api/nodes
	CMP_NODES(context.Context, *AddNodesRequest) (*AddNodesResponse, error)
	// DELETE /api/nodes
	CMP_NODES_REMOVE(context.Context, *RmNodesRequest) (*RmNodesResponse, error)
	// GET /api/node-labels
	CMP_NODE_LABELS_LIST(context.Context, *CMP_NODE_LABELS_LIST_Request) (*emptypb.Empty, error)
	// POST /api/node-labels
	CMP_NODE_LABELS_UPDATE(context.Context, *UpdateLabelsRequest) (*UpdateLabelsResponse, error)
	// GET /api/node-logs
	CMP_NODE_LOGS(context.Context, *CMP_NODE_LOGS_Request) (*emptypb.Empty, error)
	// GET /api/org-cluster-info
	CMP_ORG_CLUSTER_INFO(context.Context, *OrgClusterInfoRequest) (*OrgClusterInfoResponse, error)
	// GET /api/records
	CMP_RECORDS(context.Context, *CMP_RECORDS_Request) (*emptypb.Empty, error)
	// GET /api/recordtypes
	CMP_RECORDTYPES(context.Context, *CMP_RECORDTYPES_Request) (*emptypb.Empty, error)
	// GET /api/resource-overview/class
	CMP_RESOURCE_OVERVIEW_CLASS(context.Context, *CMP_RESOURCE_OVERVIEW_CLASS_Request) (*emptypb.Empty, error)
	// GET /api/resource-overview/cluster-trend
	CMP_RESOURCE_OVERVIEW_CLUSTER_TREND(context.Context, *CMP_RESOURCE_OVERVIEW_CLUSTER_TREND_Request) (*emptypb.Empty, error)
	// GET /api/resource-overview/gauge
	CMP_RESOURCE_OVERVIEW_GAUGE(context.Context, *CMP_RESOURCE_OVERVIEW_GAUGE_Request) (*emptypb.Empty, error)
	// GET /api/resource-overview/project-trend
	CMP_RESOURCE_OVERVIEW_PROJECT_TREND(context.Context, *CMP_RESOURCE_OVERVIEW_PROJECT_TREND_Request) (*emptypb.Empty, error)
	// GET /api/resource-overview/report-table
	CMP_RESOURCE_OVERVIEW_REPORT(context.Context, *CMP_RESOURCE_OVERVIEW_REPORT_Request) (*emptypb.Empty, error)
	// GET /api/org/actions/list-running-tasks
	CMP_RUNNING_TASKS_LIST(context.Context, *OrgRunningTasksListRequest) (*OrgRunningTasksListResponse, error)
	// POST /api/k8s/clusters/**
	CMP_STEVE_CREATE(context.Context, *CMP_STEVE_CREATE_Request) (*emptypb.Empty, error)
	// DELETE /api/k8s/clusters/**
	CMP_STEVE_DELETE(context.Context, *CMP_STEVE_DELETE_Request) (*emptypb.Empty, error)
	// GET /api/k8s/clusters/**
	CMP_STEVE_GET(context.Context, *CMP_STEVE_GET_Request) (*emptypb.Empty, error)
	// PATCH /api/k8s/clusters/**
	CMP_STEVE_PATCH(context.Context, *CMP_STEVE_PATCH_Request) (*emptypb.Empty, error)
	// PUT /api/k8s/clusters/**
	CMP_STEVE_UPDATE(context.Context, *CMP_STEVE_UPDATE_Request) (*emptypb.Empty, error)
	// GET /api/websocket/k8s/clusters/**
	CMP_STEVE_WS(context.Context, *CMP_STEVE_WS_Request) (*emptypb.Empty, error)
}

// RegisterCmpHandler register CmpHandler to http.Router.
func RegisterCmpHandler(r http.Router, srv CmpHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_CMP_ADDON_CONFIG := func(method, path string, fn func(context.Context, *AddonConfigRequest) (*AddonConfigResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddonConfigRequest))
		}
		var CMP_ADDON_CONFIG_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_ADDON_CONFIG_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_ADDON_CONFIG", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_ADDON_CONFIG_info)
				}
				r = r.WithContext(ctx)
				var in AddonConfigRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_ADDON_CONFIG_UPDATE := func(method, path string, fn func(context.Context, *AddonConfigUpdateRequest) (*AddonConfigUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddonConfigUpdateRequest))
		}
		var CMP_ADDON_CONFIG_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_ADDON_CONFIG_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_ADDON_CONFIG_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_ADDON_CONFIG_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in AddonConfigUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_ADDON_SCALE := func(method, path string, fn func(context.Context, *AddonScaleRequest) (*AddonScaleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddonScaleRequest))
		}
		var CMP_ADDON_SCALE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_ADDON_SCALE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_ADDON_SCALE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_ADDON_SCALE_info)
				}
				r = r.WithContext(ctx)
				var in AddonScaleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_ADDON_STATUS := func(method, path string, fn func(context.Context, *OpsAddonStatusQueryRequest) (*OpsAddonStatusResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OpsAddonStatusQueryRequest))
		}
		var CMP_ADDON_STATUS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_ADDON_STATUS_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_ADDON_STATUS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_ADDON_STATUS_info)
				}
				r = r.WithContext(ctx)
				var in OpsAddonStatusQueryRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_ALERT_CONDITIONS := func(method, path string, fn func(context.Context, *CMP_ALERT_CONDITIONS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_ALERT_CONDITIONS_Request))
		}
		var CMP_ALERT_CONDITIONS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_ALERT_CONDITIONS_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_ALERT_CONDITIONS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_ALERT_CONDITIONS_info)
				}
				r = r.WithContext(ctx)
				var in CMP_ALERT_CONDITIONS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_ALERT_CONDITIONS_VALUE := func(method, path string, fn func(context.Context, *CMP_ALERT_CONDITIONS_VALUE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_ALERT_CONDITIONS_VALUE_Request))
		}
		var CMP_ALERT_CONDITIONS_VALUE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_ALERT_CONDITIONS_VALUE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_ALERT_CONDITIONS_VALUE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_ALERT_CONDITIONS_VALUE_info)
				}
				r = r.WithContext(ctx)
				var in CMP_ALERT_CONDITIONS_VALUE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_CLUSTERS := func(method, path string, fn func(context.Context, *CloudClusterRequest) (*CloudClusterResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudClusterRequest))
		}
		var CMP_CLOUD_CLUSTERS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_CLUSTERS_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_CLUSTERS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_CLUSTERS_info)
				}
				r = r.WithContext(ctx)
				var in CloudClusterRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_NODES := func(method, path string, fn func(context.Context, *CloudNodesRequest) (*CloudNodesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudNodesRequest))
		}
		var CMP_CLOUD_NODES_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_NODES_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_NODES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_NODES_info)
				}
				r = r.WithContext(ctx)
				var in CloudNodesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE := func(method, path string, fn func(context.Context, *CMP_CLOUD_RESOURCE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLOUD_RESOURCE_Request))
		}
		var CMP_CLOUD_RESOURCE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLOUD_RESOURCE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ACCOUNT_CREATE := func(method, path string, fn func(context.Context, *CreateCloudAccountRequest) (*CreateCloudAccountResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudAccountRequest))
		}
		var CMP_CLOUD_RESOURCE_ACCOUNT_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ACCOUNT_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ACCOUNT_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ACCOUNT_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudAccountRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ACCOUNT_DELETE := func(method, path string, fn func(context.Context, *DeleteCloudAccountRequest) (*DeleteCloudAccountResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCloudAccountRequest))
		}
		var CMP_CLOUD_RESOURCE_ACCOUNT_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ACCOUNT_DELETE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ACCOUNT_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ACCOUNT_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCloudAccountRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ACCOUNT_LIST := func(method, path string, fn func(context.Context, *CMP_CLOUD_RESOURCE_ACCOUNT_LIST_Request) (*ListCloudAccountResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLOUD_RESOURCE_ACCOUNT_LIST_Request))
		}
		var CMP_CLOUD_RESOURCE_ACCOUNT_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ACCOUNT_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ACCOUNT_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ACCOUNT_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLOUD_RESOURCE_ACCOUNT_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ECS_AUTO_RENEW := func(method, path string, fn func(context.Context, *AutoRenewCloudResourceEcsRequest) (*HandleCloudResourceECSResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoRenewCloudResourceEcsRequest))
		}
		var CMP_CLOUD_RESOURCE_ECS_AUTO_RENEW_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ECS_AUTO_RENEW_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ECS_AUTO_RENEW", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ECS_AUTO_RENEW_info)
				}
				r = r.WithContext(ctx)
				var in AutoRenewCloudResourceEcsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ECS_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceECSRequest) (*ListCloudResourceECSResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceECSRequest))
		}
		var CMP_CLOUD_RESOURCE_ECS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ECS_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ECS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ECS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceECSRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ECS_RESTART := func(method, path string, fn func(context.Context, *HandleCloudResourceEcsRequest) (*HandleCloudResourceECSResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*HandleCloudResourceEcsRequest))
		}
		var CMP_CLOUD_RESOURCE_ECS_RESTART_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ECS_RESTART_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ECS_RESTART", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ECS_RESTART_info)
				}
				r = r.WithContext(ctx)
				var in HandleCloudResourceEcsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ECS_START := func(method, path string, fn func(context.Context, *HandleCloudResourceEcsRequest) (*HandleCloudResourceECSResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*HandleCloudResourceEcsRequest))
		}
		var CMP_CLOUD_RESOURCE_ECS_START_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ECS_START_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ECS_START", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ECS_START_info)
				}
				r = r.WithContext(ctx)
				var in HandleCloudResourceEcsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ECS_STOP := func(method, path string, fn func(context.Context, *HandleCloudResourceEcsRequest) (*HandleCloudResourceECSResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*HandleCloudResourceEcsRequest))
		}
		var CMP_CLOUD_RESOURCE_ECS_STOP_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ECS_STOP_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ECS_STOP", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ECS_STOP_info)
				}
				r = r.WithContext(ctx)
				var in HandleCloudResourceEcsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ECS_TREND := func(method, path string, fn func(context.Context, *CMP_CLOUD_RESOURCE_ECS_TREND_Request) (*GetCloudResourceECSTrendResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLOUD_RESOURCE_ECS_TREND_Request))
		}
		var CMP_CLOUD_RESOURCE_ECS_TREND_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ECS_TREND_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ECS_TREND", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ECS_TREND_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLOUD_RESOURCE_ECS_TREND_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_GATEWAY_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceGatewayRequest) (*ListCloudResourceGatewayResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceGatewayRequest))
		}
		var CMP_CLOUD_RESOURCE_GATEWAY_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_GATEWAY_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_GATEWAY_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_GATEWAY_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceGatewayRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_LIST := func(method, path string, fn func(context.Context, *CMP_CLOUD_RESOURCE_LIST_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLOUD_RESOURCE_LIST_Request))
		}
		var CMP_CLOUD_RESOURCE_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLOUD_RESOURCE_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceMysqlAccountRequest) (*CreateCloudResourceMysqlAccountResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceMysqlAccountRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceMysqlAccountRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_INFO := func(method, path string, fn func(context.Context, *CloudResourceMysqlListAccountRequest) (*CloudResourceMysqlListAccountResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceMysqlListAccountRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_INFO", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceMysqlListAccountRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "instanceID":
							in.InstanceID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PASSWORD_RESET := func(method, path string, fn func(context.Context, *CreateCloudResourceMysqlAccountRequest) (*CreateCloudResourceMysqlAccountResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceMysqlAccountRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PASSWORD_RESET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PASSWORD_RESET_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PASSWORD_RESET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PASSWORD_RESET_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceMysqlAccountRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PRIVILEGE_GRANT := func(method, path string, fn func(context.Context, *GrantMysqlAccountPrivilegeRequest) (*GrantMysqlAccountPrivilegeResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GrantMysqlAccountPrivilegeRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PRIVILEGE_GRANT_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PRIVILEGE_GRANT_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PRIVILEGE_GRANT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PRIVILEGE_GRANT_info)
				}
				r = r.WithContext(ctx)
				var in GrantMysqlAccountPrivilegeRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceMysqlRequest) (*CreateCloudResourceMysqlResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceMysqlRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceMysqlRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_DATABASE_INFO := func(method, path string, fn func(context.Context, *CloudResourceMysqlDBRequest) (*CloudResourceMysqlDBResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceMysqlDBRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_DATABASE_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_DATABASE_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_DATABASE_INFO", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_DATABASE_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceMysqlDBRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "instanceID":
							in.InstanceID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_DB_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceMysqlDBRequest) (*CreateCloudResourceMysqlDBResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceMysqlDBRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_DB_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_DB_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_DB_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_DB_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceMysqlDBRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_DB_DELETE := func(method, path string, fn func(context.Context, *DeleteCloudResourceMysqlDBRequest) (*CloudAddonResourceDeleteRespnse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCloudResourceMysqlDBRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_DB_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_DB_DELETE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_DB_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_DB_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCloudResourceMysqlDBRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_DELETE := func(method, path string, fn func(context.Context, *DeleteCloudResourceMysqlRequest) (*CloudAddonResourceDeleteRespnse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCloudResourceMysqlRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_DELETE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCloudResourceMysqlRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_DETAIL_INFO := func(method, path string, fn func(context.Context, *CloudResourceMysqlDetailInfoRequest) (*CloudResourceMysqlDetailInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceMysqlDetailInfoRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_DETAIL_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_DETAIL_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_DETAIL_INFO", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_DETAIL_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceMysqlDetailInfoRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "idorname":
							in.Idorname = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_MYSQL_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceMysqlRequest) (*ListCloudResourceMysqlResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceMysqlRequest))
		}
		var CMP_CLOUD_RESOURCE_MYSQL_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_MYSQL_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_MYSQL_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_MYSQL_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceMysqlRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceOnsRequest) (*CreateCloudResourceOnsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceOnsRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceOnsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_DELETE := func(method, path string, fn func(context.Context, *DeleteCloudResourceOnsRequest) (*CloudAddonResourceDeleteRespnse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCloudResourceOnsRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_DELETE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCloudResourceOnsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_DETAIL_INFO := func(method, path string, fn func(context.Context, *CloudResourceOnsDetailInfoRequest) (*CloudResourceOnsDetailInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceOnsDetailInfoRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_DETAIL_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_DETAIL_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_DETAIL_INFO", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_DETAIL_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceOnsDetailInfoRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "instanceID":
							in.InstanceID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_GROUP_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceOnsGroupRequest) (*CreateCloudResourceOnsGroupResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceOnsGroupRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_GROUP_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_GROUP_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_GROUP_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_GROUP_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceOnsGroupRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_GROUP_INFO := func(method, path string, fn func(context.Context, *CloudResourceOnsGroupInfoRequest) (*CloudResourceOnsGroupInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceOnsGroupInfoRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_GROUP_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_GROUP_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_GROUP_INFO", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_GROUP_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceOnsGroupInfoRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceOnsRequest) (*ListCloudResourceOnsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceOnsRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceOnsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_TOPIC_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceOnsTopicRequest) (*CreateCloudResourceOnsTopicResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceOnsTopicRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_TOPIC_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_TOPIC_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_TOPIC_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_TOPIC_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceOnsTopicRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_TOPIC_DELETE := func(method, path string, fn func(context.Context, *DeleteCloudResourceOnsRequest) (*CloudAddonResourceDeleteRespnse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCloudResourceOnsRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_TOPIC_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_TOPIC_DELETE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_TOPIC_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_TOPIC_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCloudResourceOnsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ONS_TOPIC_INFO := func(method, path string, fn func(context.Context, *CloudResourceOnsTopicInfoRequest) (*CloudResourceOnsTopicInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceOnsTopicInfoRequest))
		}
		var CMP_CLOUD_RESOURCE_ONS_TOPIC_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ONS_TOPIC_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ONS_TOPIC_INFO", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ONS_TOPIC_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceOnsTopicInfoRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_OSS_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceOssRequest) (*CreateCloudResourceOssResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceOssRequest))
		}
		var CMP_CLOUD_RESOURCE_OSS_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_OSS_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_OSS_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_OSS_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceOssRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_OSS_DELETE := func(method, path string, fn func(context.Context, *DeleteCloudResourceOssRequest) (*CloudAddonResourceDeleteRespnse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCloudResourceOssRequest))
		}
		var CMP_CLOUD_RESOURCE_OSS_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_OSS_DELETE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_OSS_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_OSS_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCloudResourceOssRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_OSS_DETAIL_INFO := func(method, path string, fn func(context.Context, *CloudResourceOssDetailInfoRequest) (*CloudResourceOssDetailInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceOssDetailInfoRequest))
		}
		var CMP_CLOUD_RESOURCE_OSS_DETAIL_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_OSS_DETAIL_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_OSS_DETAIL_INFO", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_OSS_DETAIL_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceOssDetailInfoRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "bucketname":
							in.Bucketname = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_OSS_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceOssRequest) (*ListCloudResourceOssResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceOssRequest))
		}
		var CMP_CLOUD_RESOURCE_OSS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_OSS_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_OSS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_OSS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceOssRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_OVERVIEW := func(method, path string, fn func(context.Context, *CloudResourceOverviewRequest) (*CloudResourceOverviewResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceOverviewRequest))
		}
		var CMP_CLOUD_RESOURCE_OVERVIEW_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_OVERVIEW_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_OVERVIEW", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_OVERVIEW_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceOverviewRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_REDIS_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceRedisRequest) (*CreateCloudResourceRedisResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceRedisRequest))
		}
		var CMP_CLOUD_RESOURCE_REDIS_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_REDIS_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_REDIS_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_REDIS_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceRedisRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_REDIS_DELETE := func(method, path string, fn func(context.Context, *DeleteCloudResourceRedisRequest) (*CloudAddonResourceDeleteRespnse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCloudResourceRedisRequest))
		}
		var CMP_CLOUD_RESOURCE_REDIS_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_REDIS_DELETE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_REDIS_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_REDIS_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCloudResourceRedisRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_REDIS_DETAIL_INFO := func(method, path string, fn func(context.Context, *CloudResourceRedisDetailInfoRequest) (*CloudResourceRedisDetailInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceRedisDetailInfoRequest))
		}
		var CMP_CLOUD_RESOURCE_REDIS_DETAIL_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_REDIS_DETAIL_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_REDIS_DETAIL_INFO", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_REDIS_DETAIL_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceRedisDetailInfoRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "instanceID":
							in.InstanceID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_REGION_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceRegionRequest) (*ListCloudResourceRegionResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceRegionRequest))
		}
		var CMP_CLOUD_RESOURCE_REGION_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_REGION_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_REGION_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_REGION_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceRegionRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_Redis_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceRedisRequest) (*ListCloudResourceRedisResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceRedisRequest))
		}
		var CMP_CLOUD_RESOURCE_Redis_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_Redis_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_Redis_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_Redis_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceRedisRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_SET_TAG := func(method, path string, fn func(context.Context, *CloudResourceSetTagRequest) (*CloudResourceSetTagResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CloudResourceSetTagRequest))
		}
		var CMP_CLOUD_RESOURCE_SET_TAG_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_SET_TAG_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_SET_TAG", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_SET_TAG_info)
				}
				r = r.WithContext(ctx)
				var in CloudResourceSetTagRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_VPC_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceVPCRequest) (*CreateCloudResourceVPCResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceVPCRequest))
		}
		var CMP_CLOUD_RESOURCE_VPC_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_VPC_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_VPC_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_VPC_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceVPCRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_VPC_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceVPCRequest) (*ListCloudResourceVPCResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceVPCRequest))
		}
		var CMP_CLOUD_RESOURCE_VPC_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_VPC_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_VPC_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_VPC_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceVPCRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_VSW_CREATE := func(method, path string, fn func(context.Context, *CreateCloudResourceVSWRequest) (*CreateCloudResourceVSWResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCloudResourceVSWRequest))
		}
		var CMP_CLOUD_RESOURCE_VSW_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_VSW_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_VSW_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_VSW_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CreateCloudResourceVSWRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_VSW_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceVSWRequest) (*ListCloudResourceVSWResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceVSWRequest))
		}
		var CMP_CLOUD_RESOURCE_VSW_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_VSW_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_VSW_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_VSW_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceVSWRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLOUD_RESOURCE_ZONE_LIST := func(method, path string, fn func(context.Context, *ListCloudResourceZoneRequest) (*ListCloudResourceZoneResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListCloudResourceZoneRequest))
		}
		var CMP_CLOUD_RESOURCE_ZONE_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLOUD_RESOURCE_ZONE_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLOUD_RESOURCE_ZONE_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLOUD_RESOURCE_ZONE_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ListCloudResourceZoneRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_BATCH_UPGRADE := func(method, path string, fn func(context.Context, *BatchUpgradeEdgeClusterRequest) (*BatchUpgradeEdgeClusterResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*BatchUpgradeEdgeClusterRequest))
		}
		var CMP_CLUSTER_BATCH_UPGRADE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_BATCH_UPGRADE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_BATCH_UPGRADE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_BATCH_UPGRADE_info)
				}
				r = r.WithContext(ctx)
				var in BatchUpgradeEdgeClusterRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_IMPORT := func(method, path string, fn func(context.Context, *CMP_CLUSTER_IMPORT_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLUSTER_IMPORT_Request))
		}
		var CMP_CLUSTER_IMPORT_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_IMPORT_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_IMPORT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_IMPORT_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLUSTER_IMPORT_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_INFO := func(method, path string, fn func(context.Context, *CMP_CLUSTER_INFO_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLUSTER_INFO_Request))
		}
		var CMP_CLUSTER_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_INFO", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_INFO_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLUSTER_INFO_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_INIT_COMMAND := func(method, path string, fn func(context.Context, *CMP_CLUSTER_INIT_COMMAND_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLUSTER_INIT_COMMAND_Request))
		}
		var CMP_CLUSTER_INIT_COMMAND_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_INIT_COMMAND_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_INIT_COMMAND", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_INIT_COMMAND_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLUSTER_INIT_COMMAND_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_INIT_RETRY := func(method, path string, fn func(context.Context, *CMP_CLUSTER_INIT_RETRY_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLUSTER_INIT_RETRY_Request))
		}
		var CMP_CLUSTER_INIT_RETRY_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_INIT_RETRY_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_INIT_RETRY", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_INIT_RETRY_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLUSTER_INIT_RETRY_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_OFFLINE := func(method, path string, fn func(context.Context, *OfflineEdgeClusterRequest) (*OfflineEdgeClusterResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OfflineEdgeClusterRequest))
		}
		var CMP_CLUSTER_OFFLINE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_OFFLINE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_OFFLINE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_OFFLINE_info)
				}
				r = r.WithContext(ctx)
				var in OfflineEdgeClusterRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_PREVIEW := func(method, path string, fn func(context.Context, *CMP_CLUSTER_PREVIEW_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CLUSTER_PREVIEW_Request))
		}
		var CMP_CLUSTER_PREVIEW_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_PREVIEW_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_PREVIEW", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_PREVIEW_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CLUSTER_PREVIEW_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_UPDATE := func(method, path string, fn func(context.Context, *ClusterUpdateRequest) (*ClusterUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ClusterUpdateRequest))
		}
		var CMP_CLUSTER_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in ClusterUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CLUSTER_UPGRADE := func(method, path string, fn func(context.Context, *UpgradeEdgeClusterRequest) (*UpgradeEdgeClusterResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpgradeEdgeClusterRequest))
		}
		var CMP_CLUSTER_UPGRADE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CLUSTER_UPGRADE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CLUSTER_UPGRADE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CLUSTER_UPGRADE_info)
				}
				r = r.WithContext(ctx)
				var in UpgradeEdgeClusterRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CREDENTIAL_ACCESSKEY_CREATE := func(method, path string, fn func(context.Context, *CMP_CREDENTIAL_ACCESSKEY_CREATE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CREDENTIAL_ACCESSKEY_CREATE_Request))
		}
		var CMP_CREDENTIAL_ACCESSKEY_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CREDENTIAL_ACCESSKEY_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CREDENTIAL_ACCESSKEY_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CREDENTIAL_ACCESSKEY_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CREDENTIAL_ACCESSKEY_CREATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CREDENTIAL_ACCESSKEY_GET := func(method, path string, fn func(context.Context, *CMP_CREDENTIAL_ACCESSKEY_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CREDENTIAL_ACCESSKEY_GET_Request))
		}
		var CMP_CREDENTIAL_ACCESSKEY_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CREDENTIAL_ACCESSKEY_GET_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CREDENTIAL_ACCESSKEY_GET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CREDENTIAL_ACCESSKEY_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CREDENTIAL_ACCESSKEY_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_CREDENTIAL_ACCESSKEY_RESET := func(method, path string, fn func(context.Context, *CMP_CREDENTIAL_ACCESSKEY_RESET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_CREDENTIAL_ACCESSKEY_RESET_Request))
		}
		var CMP_CREDENTIAL_ACCESSKEY_RESET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_CREDENTIAL_ACCESSKEY_RESET_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_CREDENTIAL_ACCESSKEY_RESET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_CREDENTIAL_ACCESSKEY_RESET_info)
				}
				r = r.WithContext(ctx)
				var in CMP_CREDENTIAL_ACCESSKEY_RESET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_EDGE_HOST_OFFLINE := func(method, path string, fn func(context.Context, *EdgeHostOffline) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*EdgeHostOffline))
		}
		var CMP_EDGE_HOST_OFFLINE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_EDGE_HOST_OFFLINE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_EDGE_HOST_OFFLINE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_EDGE_HOST_OFFLINE_info)
				}
				r = r.WithContext(ctx)
				var in EdgeHostOffline
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ID":
							in.ID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_K8S_CLUSTERS := func(method, path string, fn func(context.Context, *CMP_K8S_CLUSTERS_Request) (*K8SClusters, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_K8S_CLUSTERS_Request))
		}
		var CMP_K8S_CLUSTERS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_K8S_CLUSTERS_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_K8S_CLUSTERS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_K8S_CLUSTERS_info)
				}
				r = r.WithContext(ctx)
				var in CMP_K8S_CLUSTERS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_NODES := func(method, path string, fn func(context.Context, *AddNodesRequest) (*AddNodesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddNodesRequest))
		}
		var CMP_NODES_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_NODES_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_NODES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_NODES_info)
				}
				r = r.WithContext(ctx)
				var in AddNodesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_NODES_REMOVE := func(method, path string, fn func(context.Context, *RmNodesRequest) (*RmNodesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*RmNodesRequest))
		}
		var CMP_NODES_REMOVE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_NODES_REMOVE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_NODES_REMOVE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_NODES_REMOVE_info)
				}
				r = r.WithContext(ctx)
				var in RmNodesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_NODE_LABELS_LIST := func(method, path string, fn func(context.Context, *CMP_NODE_LABELS_LIST_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_NODE_LABELS_LIST_Request))
		}
		var CMP_NODE_LABELS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_NODE_LABELS_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_NODE_LABELS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_NODE_LABELS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in CMP_NODE_LABELS_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_NODE_LABELS_UPDATE := func(method, path string, fn func(context.Context, *UpdateLabelsRequest) (*UpdateLabelsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateLabelsRequest))
		}
		var CMP_NODE_LABELS_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_NODE_LABELS_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_NODE_LABELS_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_NODE_LABELS_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in UpdateLabelsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_NODE_LOGS := func(method, path string, fn func(context.Context, *CMP_NODE_LOGS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_NODE_LOGS_Request))
		}
		var CMP_NODE_LOGS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_NODE_LOGS_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_NODE_LOGS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_NODE_LOGS_info)
				}
				r = r.WithContext(ctx)
				var in CMP_NODE_LOGS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_ORG_CLUSTER_INFO := func(method, path string, fn func(context.Context, *OrgClusterInfoRequest) (*OrgClusterInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgClusterInfoRequest))
		}
		var CMP_ORG_CLUSTER_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_ORG_CLUSTER_INFO_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_ORG_CLUSTER_INFO", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_ORG_CLUSTER_INFO_info)
				}
				r = r.WithContext(ctx)
				var in OrgClusterInfoRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_RECORDS := func(method, path string, fn func(context.Context, *CMP_RECORDS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_RECORDS_Request))
		}
		var CMP_RECORDS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_RECORDS_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_RECORDS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_RECORDS_info)
				}
				r = r.WithContext(ctx)
				var in CMP_RECORDS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_RECORDTYPES := func(method, path string, fn func(context.Context, *CMP_RECORDTYPES_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_RECORDTYPES_Request))
		}
		var CMP_RECORDTYPES_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_RECORDTYPES_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_RECORDTYPES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_RECORDTYPES_info)
				}
				r = r.WithContext(ctx)
				var in CMP_RECORDTYPES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_RESOURCE_OVERVIEW_CLASS := func(method, path string, fn func(context.Context, *CMP_RESOURCE_OVERVIEW_CLASS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_RESOURCE_OVERVIEW_CLASS_Request))
		}
		var CMP_RESOURCE_OVERVIEW_CLASS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_RESOURCE_OVERVIEW_CLASS_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_RESOURCE_OVERVIEW_CLASS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_RESOURCE_OVERVIEW_CLASS_info)
				}
				r = r.WithContext(ctx)
				var in CMP_RESOURCE_OVERVIEW_CLASS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_RESOURCE_OVERVIEW_CLUSTER_TREND := func(method, path string, fn func(context.Context, *CMP_RESOURCE_OVERVIEW_CLUSTER_TREND_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_RESOURCE_OVERVIEW_CLUSTER_TREND_Request))
		}
		var CMP_RESOURCE_OVERVIEW_CLUSTER_TREND_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_RESOURCE_OVERVIEW_CLUSTER_TREND_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_RESOURCE_OVERVIEW_CLUSTER_TREND", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_RESOURCE_OVERVIEW_CLUSTER_TREND_info)
				}
				r = r.WithContext(ctx)
				var in CMP_RESOURCE_OVERVIEW_CLUSTER_TREND_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_RESOURCE_OVERVIEW_GAUGE := func(method, path string, fn func(context.Context, *CMP_RESOURCE_OVERVIEW_GAUGE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_RESOURCE_OVERVIEW_GAUGE_Request))
		}
		var CMP_RESOURCE_OVERVIEW_GAUGE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_RESOURCE_OVERVIEW_GAUGE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_RESOURCE_OVERVIEW_GAUGE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_RESOURCE_OVERVIEW_GAUGE_info)
				}
				r = r.WithContext(ctx)
				var in CMP_RESOURCE_OVERVIEW_GAUGE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_RESOURCE_OVERVIEW_PROJECT_TREND := func(method, path string, fn func(context.Context, *CMP_RESOURCE_OVERVIEW_PROJECT_TREND_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_RESOURCE_OVERVIEW_PROJECT_TREND_Request))
		}
		var CMP_RESOURCE_OVERVIEW_PROJECT_TREND_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_RESOURCE_OVERVIEW_PROJECT_TREND_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_RESOURCE_OVERVIEW_PROJECT_TREND", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_RESOURCE_OVERVIEW_PROJECT_TREND_info)
				}
				r = r.WithContext(ctx)
				var in CMP_RESOURCE_OVERVIEW_PROJECT_TREND_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_RESOURCE_OVERVIEW_REPORT := func(method, path string, fn func(context.Context, *CMP_RESOURCE_OVERVIEW_REPORT_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_RESOURCE_OVERVIEW_REPORT_Request))
		}
		var CMP_RESOURCE_OVERVIEW_REPORT_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_RESOURCE_OVERVIEW_REPORT_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_RESOURCE_OVERVIEW_REPORT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_RESOURCE_OVERVIEW_REPORT_info)
				}
				r = r.WithContext(ctx)
				var in CMP_RESOURCE_OVERVIEW_REPORT_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_RUNNING_TASKS_LIST := func(method, path string, fn func(context.Context, *OrgRunningTasksListRequest) (*OrgRunningTasksListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*OrgRunningTasksListRequest))
		}
		var CMP_RUNNING_TASKS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_RUNNING_TASKS_LIST_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_RUNNING_TASKS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_RUNNING_TASKS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in OrgRunningTasksListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_STEVE_CREATE := func(method, path string, fn func(context.Context, *CMP_STEVE_CREATE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_STEVE_CREATE_Request))
		}
		var CMP_STEVE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_STEVE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_STEVE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_STEVE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CMP_STEVE_CREATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_STEVE_DELETE := func(method, path string, fn func(context.Context, *CMP_STEVE_DELETE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_STEVE_DELETE_Request))
		}
		var CMP_STEVE_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_STEVE_DELETE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_STEVE_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_STEVE_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in CMP_STEVE_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_STEVE_GET := func(method, path string, fn func(context.Context, *CMP_STEVE_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_STEVE_GET_Request))
		}
		var CMP_STEVE_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_STEVE_GET_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_STEVE_GET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_STEVE_GET_info)
				}
				r = r.WithContext(ctx)
				var in CMP_STEVE_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_STEVE_PATCH := func(method, path string, fn func(context.Context, *CMP_STEVE_PATCH_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_STEVE_PATCH_Request))
		}
		var CMP_STEVE_PATCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_STEVE_PATCH_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_STEVE_PATCH", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_STEVE_PATCH_info)
				}
				r = r.WithContext(ctx)
				var in CMP_STEVE_PATCH_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_STEVE_UPDATE := func(method, path string, fn func(context.Context, *CMP_STEVE_UPDATE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_STEVE_UPDATE_Request))
		}
		var CMP_STEVE_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_STEVE_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_STEVE_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_STEVE_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in CMP_STEVE_UPDATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_STEVE_WS := func(method, path string, fn func(context.Context, *CMP_STEVE_WS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CMP_STEVE_WS_Request))
		}
		var CMP_STEVE_WS_info transport.ServiceInfo
		if h.Interceptor != nil {
			CMP_STEVE_WS_info = transport.NewServiceInfo("erda.openapiv1.cmp.cmp", "CMP_STEVE_WS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CMP_STEVE_WS_info)
				}
				r = r.WithContext(ctx)
				var in CMP_STEVE_WS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CMP_ADDON_CONFIG("GET", "/api/addons/actions/config", srv.CMP_ADDON_CONFIG)
	add_CMP_ADDON_CONFIG_UPDATE("POST", "/api/addons/actions/config", srv.CMP_ADDON_CONFIG_UPDATE)
	add_CMP_ADDON_SCALE("POST", "/api/addons/actions/scale", srv.CMP_ADDON_SCALE)
	add_CMP_ADDON_STATUS("GET", "/api/addons/status", srv.CMP_ADDON_STATUS)
	add_CMP_ALERT_CONDITIONS("GET", "/api/cmp/alerts/conditions", srv.CMP_ALERT_CONDITIONS)
	add_CMP_ALERT_CONDITIONS_VALUE("POST", "/api/cmp/alerts/conditions/value", srv.CMP_ALERT_CONDITIONS_VALUE)
	add_CMP_CLOUD_CLUSTERS("POST", "/api/cloud-clusters", srv.CMP_CLOUD_CLUSTERS)
	add_CMP_CLOUD_NODES("POST", "/api/ops/cloud-nodes", srv.CMP_CLOUD_NODES)
	add_CMP_CLOUD_RESOURCE("GET", "/api/ops/cloud-resource", srv.CMP_CLOUD_RESOURCE)
	add_CMP_CLOUD_RESOURCE_ACCOUNT_CREATE("POST", "/api/cloud-account", srv.CMP_CLOUD_RESOURCE_ACCOUNT_CREATE)
	add_CMP_CLOUD_RESOURCE_ACCOUNT_DELETE("DELETE", "/api/cloud-account", srv.CMP_CLOUD_RESOURCE_ACCOUNT_DELETE)
	add_CMP_CLOUD_RESOURCE_ACCOUNT_LIST("GET", "/api/cloud-account", srv.CMP_CLOUD_RESOURCE_ACCOUNT_LIST)
	add_CMP_CLOUD_RESOURCE_ECS_AUTO_RENEW("POST", "/api/cloud-ecs/actions/config-renew-attribute", srv.CMP_CLOUD_RESOURCE_ECS_AUTO_RENEW)
	add_CMP_CLOUD_RESOURCE_ECS_LIST("GET", "/api/cloud-ecs", srv.CMP_CLOUD_RESOURCE_ECS_LIST)
	add_CMP_CLOUD_RESOURCE_ECS_RESTART("POST", "/api/cloud-ecs/actions/restart", srv.CMP_CLOUD_RESOURCE_ECS_RESTART)
	add_CMP_CLOUD_RESOURCE_ECS_START("POST", "/api/cloud-ecs/actions/start", srv.CMP_CLOUD_RESOURCE_ECS_START)
	add_CMP_CLOUD_RESOURCE_ECS_STOP("POST", "/api/cloud-ecs/actions/stop", srv.CMP_CLOUD_RESOURCE_ECS_STOP)
	add_CMP_CLOUD_RESOURCE_ECS_TREND("GET", "/api/ecs-trending", srv.CMP_CLOUD_RESOURCE_ECS_TREND)
	add_CMP_CLOUD_RESOURCE_GATEWAY_LIST("GET", "/api/cloud-gateway", srv.CMP_CLOUD_RESOURCE_GATEWAY_LIST)
	add_CMP_CLOUD_RESOURCE_LIST("GET", "/api/ops/cloud-resource-list", srv.CMP_CLOUD_RESOURCE_LIST)
	add_CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_CREATE("POST", "/api/cloud-mysql/actions/create-account", srv.CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_CREATE)
	add_CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_INFO("GET", "/api/cloud-mysql/{instanceID}/accounts", srv.CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_INFO)
	add_CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PASSWORD_RESET("POST", "/api/cloud-mysql/actions/reset-password", srv.CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PASSWORD_RESET)
	add_CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PRIVILEGE_GRANT("POST", "/api/cloud-mysql/actions/grant-privilege", srv.CMP_CLOUD_RESOURCE_MYSQL_ACCOUNT_PRIVILEGE_GRANT)
	add_CMP_CLOUD_RESOURCE_MYSQL_CREATE("POST", "/api/cloud-mysql", srv.CMP_CLOUD_RESOURCE_MYSQL_CREATE)
	add_CMP_CLOUD_RESOURCE_MYSQL_DATABASE_INFO("GET", "/api/cloud-mysql/{instanceID}/databases", srv.CMP_CLOUD_RESOURCE_MYSQL_DATABASE_INFO)
	add_CMP_CLOUD_RESOURCE_MYSQL_DB_CREATE("POST", "/api/cloud-mysql/actions/create-db", srv.CMP_CLOUD_RESOURCE_MYSQL_DB_CREATE)
	add_CMP_CLOUD_RESOURCE_MYSQL_DB_DELETE("DELETE", "/api/cloud-mysql/actions/delete-db", srv.CMP_CLOUD_RESOURCE_MYSQL_DB_DELETE)
	add_CMP_CLOUD_RESOURCE_MYSQL_DELETE("DELETE", "/api/cloud-mysql", srv.CMP_CLOUD_RESOURCE_MYSQL_DELETE)
	add_CMP_CLOUD_RESOURCE_MYSQL_DETAIL_INFO("GET", "/api/cloud-mysql/{idorname}", srv.CMP_CLOUD_RESOURCE_MYSQL_DETAIL_INFO)
	add_CMP_CLOUD_RESOURCE_MYSQL_LIST("GET", "/api/cloud-mysql", srv.CMP_CLOUD_RESOURCE_MYSQL_LIST)
	add_CMP_CLOUD_RESOURCE_ONS_CREATE("POST", "/api/cloud-ons", srv.CMP_CLOUD_RESOURCE_ONS_CREATE)
	add_CMP_CLOUD_RESOURCE_ONS_DELETE("DELETE", "/api/cloud-ons", srv.CMP_CLOUD_RESOURCE_ONS_DELETE)
	add_CMP_CLOUD_RESOURCE_ONS_DETAIL_INFO("GET", "/api/cloud-ons/{instanceID}", srv.CMP_CLOUD_RESOURCE_ONS_DETAIL_INFO)
	add_CMP_CLOUD_RESOURCE_ONS_GROUP_CREATE("POST", "/api/cloud-ons/actions/create-group", srv.CMP_CLOUD_RESOURCE_ONS_GROUP_CREATE)
	add_CMP_CLOUD_RESOURCE_ONS_GROUP_INFO("GET", "/api/cloud-ons/actions/list-group", srv.CMP_CLOUD_RESOURCE_ONS_GROUP_INFO)
	add_CMP_CLOUD_RESOURCE_ONS_LIST("GET", "/api/cloud-ons", srv.CMP_CLOUD_RESOURCE_ONS_LIST)
	add_CMP_CLOUD_RESOURCE_ONS_TOPIC_CREATE("POST", "/api/cloud-ons/actions/create-topic", srv.CMP_CLOUD_RESOURCE_ONS_TOPIC_CREATE)
	add_CMP_CLOUD_RESOURCE_ONS_TOPIC_DELETE("DELETE", "/api/cloud-ons/actions/delete-topic", srv.CMP_CLOUD_RESOURCE_ONS_TOPIC_DELETE)
	add_CMP_CLOUD_RESOURCE_ONS_TOPIC_INFO("GET", "/api/cloud-ons/actions/list-topic", srv.CMP_CLOUD_RESOURCE_ONS_TOPIC_INFO)
	add_CMP_CLOUD_RESOURCE_OSS_CREATE("POST", "/api/cloud-oss", srv.CMP_CLOUD_RESOURCE_OSS_CREATE)
	add_CMP_CLOUD_RESOURCE_OSS_DELETE("DELETE", "/api/cloud-oss", srv.CMP_CLOUD_RESOURCE_OSS_DELETE)
	add_CMP_CLOUD_RESOURCE_OSS_DETAIL_INFO("GET", "/api/cloud-oss/{bucketname}", srv.CMP_CLOUD_RESOURCE_OSS_DETAIL_INFO)
	add_CMP_CLOUD_RESOURCE_OSS_LIST("GET", "/api/cloud-oss", srv.CMP_CLOUD_RESOURCE_OSS_LIST)
	add_CMP_CLOUD_RESOURCE_OVERVIEW("GET", "/api/cloud-resource-overview", srv.CMP_CLOUD_RESOURCE_OVERVIEW)
	add_CMP_CLOUD_RESOURCE_REDIS_CREATE("POST", "/api/cloud-redis", srv.CMP_CLOUD_RESOURCE_REDIS_CREATE)
	add_CMP_CLOUD_RESOURCE_REDIS_DELETE("DELETE", "/api/cloud-redis", srv.CMP_CLOUD_RESOURCE_REDIS_DELETE)
	add_CMP_CLOUD_RESOURCE_REDIS_DETAIL_INFO("GET", "/api/cloud-redis/{instanceID}", srv.CMP_CLOUD_RESOURCE_REDIS_DETAIL_INFO)
	add_CMP_CLOUD_RESOURCE_REGION_LIST("GET", "/api/cloud-region", srv.CMP_CLOUD_RESOURCE_REGION_LIST)
	add_CMP_CLOUD_RESOURCE_Redis_LIST("GET", "/api/cloud-redis", srv.CMP_CLOUD_RESOURCE_Redis_LIST)
	add_CMP_CLOUD_RESOURCE_SET_TAG("POST", "/api/cloud-resource/set-tag", srv.CMP_CLOUD_RESOURCE_SET_TAG)
	add_CMP_CLOUD_RESOURCE_VPC_CREATE("POST", "/api/cloud-vpc", srv.CMP_CLOUD_RESOURCE_VPC_CREATE)
	add_CMP_CLOUD_RESOURCE_VPC_LIST("GET", "/api/cloud-vpc", srv.CMP_CLOUD_RESOURCE_VPC_LIST)
	add_CMP_CLOUD_RESOURCE_VSW_CREATE("POST", "/api/cloud-vsw", srv.CMP_CLOUD_RESOURCE_VSW_CREATE)
	add_CMP_CLOUD_RESOURCE_VSW_LIST("GET", "/api/cloud-vsw", srv.CMP_CLOUD_RESOURCE_VSW_LIST)
	add_CMP_CLOUD_RESOURCE_ZONE_LIST("GET", "/api/cloud-zone", srv.CMP_CLOUD_RESOURCE_ZONE_LIST)
	add_CMP_CLUSTER_BATCH_UPGRADE("POST", "/api/cluster/actions/batch-upgrade", srv.CMP_CLUSTER_BATCH_UPGRADE)
	add_CMP_CLUSTER_IMPORT("POST", "/api/clusters", srv.CMP_CLUSTER_IMPORT)
	add_CMP_CLUSTER_INFO("GET", "/api/cluster", srv.CMP_CLUSTER_INFO)
	add_CMP_CLUSTER_INIT_COMMAND("GET", "/api/cluster/init-command", srv.CMP_CLUSTER_INIT_COMMAND)
	add_CMP_CLUSTER_INIT_RETRY("POST", "/api/cluster/actions/init-retry", srv.CMP_CLUSTER_INIT_RETRY)
	add_CMP_CLUSTER_OFFLINE("DELETE", "/api/cluster", srv.CMP_CLUSTER_OFFLINE)
	add_CMP_CLUSTER_PREVIEW("POST", "/api/cluster-preview", srv.CMP_CLUSTER_PREVIEW)
	add_CMP_CLUSTER_UPDATE("PUT", "/api/clusters", srv.CMP_CLUSTER_UPDATE)
	add_CMP_CLUSTER_UPGRADE("POST", "/api/cluster/actions/upgrade", srv.CMP_CLUSTER_UPGRADE)
	add_CMP_CREDENTIAL_ACCESSKEY_CREATE("POST", "/api/cluster/credential/access-keys", srv.CMP_CREDENTIAL_ACCESSKEY_CREATE)
	add_CMP_CREDENTIAL_ACCESSKEY_GET("GET", "/api/cluster/credential/access-keys", srv.CMP_CREDENTIAL_ACCESSKEY_GET)
	add_CMP_CREDENTIAL_ACCESSKEY_RESET("POST", "/api/cluster/credential/access-keys/actions/reset", srv.CMP_CREDENTIAL_ACCESSKEY_RESET)
	add_CMP_EDGE_HOST_OFFLINE("DELETE", "/api/edge/site/offline/{ID}", srv.CMP_EDGE_HOST_OFFLINE)
	add_CMP_K8S_CLUSTERS("GET", "/api/k8s/clusters", srv.CMP_K8S_CLUSTERS)
	add_CMP_NODES("POST", "/api/nodes", srv.CMP_NODES)
	add_CMP_NODES_REMOVE("DELETE", "/api/nodes", srv.CMP_NODES_REMOVE)
	add_CMP_NODE_LABELS_LIST("GET", "/api/node-labels", srv.CMP_NODE_LABELS_LIST)
	add_CMP_NODE_LABELS_UPDATE("POST", "/api/node-labels", srv.CMP_NODE_LABELS_UPDATE)
	add_CMP_NODE_LOGS("GET", "/api/node-logs", srv.CMP_NODE_LOGS)
	add_CMP_ORG_CLUSTER_INFO("GET", "/api/org-cluster-info", srv.CMP_ORG_CLUSTER_INFO)
	add_CMP_RECORDS("GET", "/api/records", srv.CMP_RECORDS)
	add_CMP_RECORDTYPES("GET", "/api/recordtypes", srv.CMP_RECORDTYPES)
	add_CMP_RESOURCE_OVERVIEW_CLASS("GET", "/api/resource-overview/class", srv.CMP_RESOURCE_OVERVIEW_CLASS)
	add_CMP_RESOURCE_OVERVIEW_CLUSTER_TREND("GET", "/api/resource-overview/cluster-trend", srv.CMP_RESOURCE_OVERVIEW_CLUSTER_TREND)
	add_CMP_RESOURCE_OVERVIEW_GAUGE("GET", "/api/resource-overview/gauge", srv.CMP_RESOURCE_OVERVIEW_GAUGE)
	add_CMP_RESOURCE_OVERVIEW_PROJECT_TREND("GET", "/api/resource-overview/project-trend", srv.CMP_RESOURCE_OVERVIEW_PROJECT_TREND)
	add_CMP_RESOURCE_OVERVIEW_REPORT("GET", "/api/resource-overview/report-table", srv.CMP_RESOURCE_OVERVIEW_REPORT)
	add_CMP_RUNNING_TASKS_LIST("GET", "/api/org/actions/list-running-tasks", srv.CMP_RUNNING_TASKS_LIST)
	add_CMP_STEVE_CREATE("POST", "/api/k8s/clusters/**", srv.CMP_STEVE_CREATE)
	add_CMP_STEVE_DELETE("DELETE", "/api/k8s/clusters/**", srv.CMP_STEVE_DELETE)
	add_CMP_STEVE_GET("GET", "/api/k8s/clusters/**", srv.CMP_STEVE_GET)
	add_CMP_STEVE_PATCH("PATCH", "/api/k8s/clusters/**", srv.CMP_STEVE_PATCH)
	add_CMP_STEVE_UPDATE("PUT", "/api/k8s/clusters/**", srv.CMP_STEVE_UPDATE)
	add_CMP_STEVE_WS("GET", "/api/websocket/k8s/clusters/**", srv.CMP_STEVE_WS)
}
