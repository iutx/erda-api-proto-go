// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: orchestrator.proto

package pb

import (
	context "context"
	http1 "net/http"
	strconv "strconv"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// OrchestratorHandler is the server API for Orchestrator service.
type OrchestratorHandler interface {
	// GET /api/addon/metrics/charts/{scope}/histogram
	ADDON_METRICS_HISTOGRAM(context.Context, *ADDON_METRICS_HISTOGRAM_Request) (*emptypb.Empty, error)
	// POST /api/addons
	ORCHESTRATOR_ADDONS_SCALE(context.Context, *ORCHESTRATOR_ADDONS_SCALE_Request) (*emptypb.Empty, error)
	// GET /api/addons/actions/list-available
	ORCHESTRATOR_ADDON_AVAILABLE(context.Context, *AddonAvailableRequest) (*AddonAvailableResponse, error)
	// POST /api/addons/actions/create-addon
	ORCHESTRATOR_ADDON_CREATE(context.Context, *AddonDirectCreateRequest) (*emptypb.Empty, error)
	// POST /api/addons/actions/create-custom
	ORCHESTRATOR_ADDON_CREATE_CUSTOM(context.Context, *CustomAddonCreateRequest) (*emptypb.Empty, error)
	// GET /api/addons/actions/list-customs
	ORCHESTRATOR_ADDON_CUSTOM(context.Context, *ORCHESTRATOR_ADDON_CUSTOM_Request) (*emptypb.Empty, error)
	// DELETE /api/addons/{addonId}
	ORCHESTRATOR_ADDON_DELETE(context.Context, *ORCHESTRATOR_ADDON_DELETE_Request) (*AddonFetchResponse, error)
	// POST /api/addon/action/yml-export
	ORCHESTRATOR_ADDON_EXPORT(context.Context, *ORCHESTRATOR_ADDON_EXPORT_Request) (*emptypb.Empty, error)
	// GET /api/addons/actions/list-extension
	ORCHESTRATOR_ADDON_EXTENSION(context.Context, *ORCHESTRATOR_ADDON_EXTENSION_Request) (*AddonExtensionResponse, error)
	// GET /api/addons/{addonId}
	ORCHESTRATOR_ADDON_FETCH(context.Context, *ORCHESTRATOR_ADDON_FETCH_Request) (*AddonFetchResponse, error)
	// POST /api/addon/action/yml-import
	ORCHESTRATOR_ADDON_IMPORT(context.Context, *ORCHESTRATOR_ADDON_IMPORT_Request) (*emptypb.Empty, error)
	// GET /api/addons
	ORCHESTRATOR_ADDON_LIST(context.Context, *AddonListRequest) (*AddonListResponse, error)
	// GET /api/addons/{instanceId}/logs
	ORCHESTRATOR_ADDON_LOGS(context.Context, *ORCHESTRATOR_ADDON_LOGS_Request) (*emptypb.Empty, error)
	// GET /api/addons/actions/menu
	ORCHESTRATOR_ADDON_MENU(context.Context, *ORCHESTRATOR_ADDON_MENU_Request) (*emptypb.Empty, error)
	// GET /api/addons/{addonID}/actions/references
	ORCHESTRATOR_ADDON_REFERENCES(context.Context, *ORCHESTRATOR_ADDON_REFERENCES_Request) (*AddonReferencesResponse, error)
	// POST /api/addons/actions/create-tenant
	ORCHESTRATOR_ADDON_TENANT_CREATE(context.Context, *AddonTenantCreateRequest) (*emptypb.Empty, error)
	// PUT /api/addons/{addonId}/actions/update-custom
	ORCHESTRATOR_ADDON_UPDATE_CUSTOM(context.Context, *CustomAddonUpdateRequest) (*emptypb.Empty, error)
	// GET /api/cmdb/clusters/{cluster}/instances-usage
	ORCHESTRATOR_CLUSTER_INSTANCES_USAGE(context.Context, *ORCHESTRATOR_CLUSTER_INSTANCES_USAGE_Request) (*emptypb.Empty, error)
	// POST /api/deployments/{deploymentID}/actions/deploy-addons
	ORCHESTRATOR_DEPLOYMENT_ADDONS(context.Context, *ORCHESTRATOR_DEPLOYMENT_ADDONS_Request) (*emptypb.Empty, error)
	// POST /api/deployments/actions/approve
	ORCHESTRATOR_DEPLOYMENT_APPROVE(context.Context, *DeploymentApproveRequest) (*DeploymentApproveResponse, error)
	// POST /api/deployments/{deploymentId}/actions/cancel
	ORCHESTRATOR_DEPLOYMENT_CANCEL(context.Context, *DeploymentCancelRequest) (*DeploymentCancelResponse, error)
	// POST /api/deployments/{deploymentID}/actions/deploy-domains
	ORCHESTRATOR_DEPLOYMENT_DOMAINS(context.Context, *ORCHESTRATOR_DEPLOYMENT_DOMAINS_Request) (*emptypb.Empty, error)
	// GET /api/deployments
	ORCHESTRATOR_DEPLOYMENT_LIST(context.Context, *DeploymentListRequest) (*DeploymentListResponse, error)
	// GET /api/deployments/actions/list-approved
	ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED(context.Context, *ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED_Request) (*DeploymentDetailListResponse, error)
	// GET /api/deployments/actions/list-launched-approval
	ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL(context.Context, *ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL_Request) (*DeploymentDetailListResponse, error)
	// GET /api/deployments/actions/list-pending-approval
	ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL(context.Context, *ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL_Request) (*DeploymentDetailListResponse, error)
	// POST /api/deployment-orders/{deploymentOrderID}/actions/cancel
	ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL_Request) (*emptypb.Empty, error)
	// POST /api/deployment-orders
	ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE_Request) (*emptypb.Empty, error)
	// POST /api/deployment-orders/{deploymentOrderID}/actions/deploy
	ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY_Request) (*emptypb.Empty, error)
	// GET /api/deployment-orders/{deploymentOrderID}
	ORCHESTRATOR_DEPLOYMENT_ORDER_GET(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_GET_Request) (*emptypb.Empty, error)
	// GET /api/deployment-orders
	ORCHESTRATOR_DEPLOYMENT_ORDER_LIST(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_LIST_Request) (*emptypb.Empty, error)
	// GET /api/deployment-orders/actions/render-detail
	ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL_Request) (*emptypb.Empty, error)
	// GET /api/deployments/{deploymentId}/status
	ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS(context.Context, *ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS_Request) (*emptypb.Empty, error)
	// POST /api/deployments/{deploymentID}/actions/deploy-services
	ORCHESTRATOR_DEPLOYMENT_SERVICES(context.Context, *ORCHESTRATOR_DEPLOYMENT_SERVICES_Request) (*emptypb.Empty, error)
	// GET /api/runtimes/actions/get-app-workspace-releases
	ORCHESTRATOR_GET_APP_WORKSPACE_RELEASES(context.Context, *AppWorkspaceReleasesGetRequest) (*AppWorkspaceReleasesGetResponse, error)
	// GET /api/instances-usage
	ORCHESTRATOR_INSTANCES_USAGE(context.Context, *ORCHESTRATOR_INSTANCES_USAGE_Request) (*emptypb.Empty, error)
	// GET /api/microservice/project/{projectID}/menus
	ORCHESTRATOR_MICRO_SERVICE_MENUS(context.Context, *ORCHESTRATOR_MICRO_SERVICE_MENUS_Request) (*MicroServiceMenuResponseData, error)
	// GET /api/microservice/projects
	ORCHESTRATOR_MICRO_SERVICE_PROJECTS(context.Context, *ORCHESTRATOR_MICRO_SERVICE_PROJECTS_Request) (*MicroServiceProjectResponse, error)
	// GET /api/middlewares/resource/classification
	ORCHESTRATOR_MIDDLEWARE_ADDON_CLASSIFICATION(context.Context, *MiddlewareListRequest) (*emptypb.Empty, error)
	// GET /api/middlewares/resource/daily
	ORCHESTRATOR_MIDDLEWARE_DAILY(context.Context, *MiddlewareListRequest) (*emptypb.Empty, error)
	// GET /api/middlewares/{addonId}
	ORCHESTRATOR_MIDDLEWARE_FETCH(context.Context, *ORCHESTRATOR_MIDDLEWARE_FETCH_Request) (*MiddlewareFetchResponse, error)
	// GET /api/middlewares/{addonId}/actions/get-resource
	ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE(context.Context, *ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE_Request) (*MiddlewareResourceFetchResponse, error)
	// GET /api/middlewares
	ORCHESTRATOR_MIDDLEWARE_LIST(context.Context, *MiddlewareListRequest) (*MiddlewareListResponse, error)
	// GET /api/migration/{migrationId}/logs
	ORCHESTRATOR_MIGRATION_LOG(context.Context, *ORCHESTRATOR_MIGRATION_LOG_Request) (*emptypb.Empty, error)
	// GET /api/nodelabels
	ORCHESTRATOR_NODELABEL_LIST(context.Context, *ScheduleLabelListRequest) (*ScheduleLabelListResponse, error)
	// POST /api/nodelabels
	ORCHESTRATOR_NODELABEL_SET(context.Context, *ScheduleLabelSetRequest) (*ScheduleLabelSetResponse, error)
	// GET /api/orgCenter/job/logs
	ORCHESTRATOR_ORG_JOB_LOG(context.Context, *ORCHESTRATOR_ORG_JOB_LOG_Request) (*emptypb.Empty, error)
	// GET /api/countProjectRuntime
	ORCHESTRATOR_PROJECT_RUNTIME_COUNT(context.Context, *ORCHESTRATOR_PROJECT_RUNTIME_COUNT_Request) (*emptypb.Empty, error)
	// PUT /api/runtimes/actions/batch-update-pre-overlay
	ORCHESTRATOR_RUNTIMES_BATCH_SCALE(context.Context, *ORCHESTRATOR_RUNTIMES_BATCH_SCALE_Request) (*emptypb.Empty, error)
	// GET /api/runtimesServices
	ORCHESTRATOR_RUNTIME_BATCH_SERVICES(context.Context, *ORCHESTRATOR_RUNTIME_BATCH_SERVICES_Request) (*emptypb.Empty, error)
	// GET /api/runtimes/actions/bulk-get-status
	ORCHESTRATOR_RUNTIME_BULK_GET_STATUS(context.Context, *ORCHESTRATOR_RUNTIME_BULK_GET_STATUS_Request) (*emptypb.Empty, error)
	// POST /api/runtimes
	ORCHESTRATOR_RUNTIME_CREATE(context.Context, *ORCHESTRATOR_RUNTIME_CREATE_Request) (*emptypb.Empty, error)
	// DELETE /api/runtimes/{runtimeId}
	ORCHESTRATOR_RUNTIME_DELETE(context.Context, *ORCHESTRATOR_RUNTIME_DELETE_Request) (*RuntimeDeleteResponse, error)
	// GET /api/runtimes/deploy/logs
	ORCHESTRATOR_RUNTIME_DEPLOY_LOG(context.Context, *ORCHESTRATOR_RUNTIME_DEPLOY_LOG_Request) (*emptypb.Empty, error)
	// GET /api/runtimes/{runtimeID}/domains
	ORCHESTRATOR_RUNTIME_DOMAIN_GET(context.Context, *DomainListRequest) (*DomainListResponse, error)
	// PUT /api/runtimes/{runtimeID}/domains
	ORCHESTRATOR_RUNTIME_DOMAIN_UPDATE(context.Context, *DomainUpdateRequest) (*DomainUpdateResponse, error)
	// GET /api/runtimes/actions/group-by-apps
	ORCHESTRATOR_RUNTIME_GROUP_BY_APPS(context.Context, *ORCHESTRATOR_RUNTIME_GROUP_BY_APPS_Request) (*emptypb.Empty, error)
	// GET /api/runtimes/{IDOrName}
	ORCHESTRATOR_RUNTIME_INSPECT(context.Context, *RuntimeInspectRequest) (*RuntimeInspectResponse, error)
	// GET /api/runtimes/{runtimeId}/configuration
	ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP(context.Context, *ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP_Request) (*emptypb.Empty, error)
	// POST /api/runtimes/actions/killpod
	ORCHESTRATOR_RUNTIME_KILLPOD(context.Context, *RuntimeKillPodRequest) (*emptypb.Empty, error)
	// GET /api/runtimes/actions/list-my-runtimes
	ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES(context.Context, *ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES_Request) (*emptypb.Empty, error)
	// POST /api/runtimes/{runtimeId}/actions/redeploy
	ORCHESTRATOR_RUNTIME_REDEPLOY(context.Context, *ORCHESTRATOR_RUNTIME_REDEPLOY_Request) (*emptypb.Empty, error)
	// POST /api/runtimes/{runtimeId}/actions/redeploy-action
	ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION(context.Context, *ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION_Request) (*emptypb.Empty, error)
	// POST /api/runtimes/actions/deploy-release
	ORCHESTRATOR_RUNTIME_RELEASE_CREATE(context.Context, *RuntimeReleaseCreateRequest) (*RuntimeReleaseCreatePipelineResponse, error)
	// POST /api/runtimes/actions/deploy-release-action
	ORCHESTRATOR_RUNTIME_RELEASE_CREATE_ACTION(context.Context, *RuntimeReleaseCreateRequest) (*RuntimeCreateResponse, error)
	// POST /api/runtimes/{runtimeId}/actions/rollback
	ORCHESTRATOR_RUNTIME_ROLLBACK(context.Context, *ORCHESTRATOR_RUNTIME_ROLLBACK_Request) (*emptypb.Empty, error)
	// POST /api/runtimes/{runtimeId}/actions/rollback-action
	ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION(context.Context, *ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION_Request) (*emptypb.Empty, error)
	// GET /api/runtimes
	ORCHESTRATOR_RUNTIME_SEARCH(context.Context, *ORCHESTRATOR_RUNTIME_SEARCH_Request) (*emptypb.Empty, error)
	// GET /api/instances/actions/get-service
	ORCHESTRATOR_SERVICE_INSTANCE_LIST(context.Context, *ContainerListRequest) (*ContainerListResponse, error)
	// GET /api/instances/actions/get-service-pods
	ORCHESTRATOR_SERVICE_POD_LIST(context.Context, *PodListRequest) (*PodListResponse, error)
	// GET /api/terminal
	ORCHESTRATOR_TERMINAL(context.Context, *ORCHESTRATOR_TERMINAL_Request) (*emptypb.Empty, error)
}

// RegisterOrchestratorHandler register OrchestratorHandler to http.Router.
func RegisterOrchestratorHandler(r http.Router, srv OrchestratorHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_ADDON_METRICS_HISTOGRAM := func(method, path string, fn func(context.Context, *ADDON_METRICS_HISTOGRAM_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ADDON_METRICS_HISTOGRAM_Request))
		}
		var ADDON_METRICS_HISTOGRAM_info transport.ServiceInfo
		if h.Interceptor != nil {
			ADDON_METRICS_HISTOGRAM_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ADDON_METRICS_HISTOGRAM", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ADDON_METRICS_HISTOGRAM_info)
				}
				r = r.WithContext(ctx)
				var in ADDON_METRICS_HISTOGRAM_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "scope":
							in.Scope = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDONS_SCALE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDONS_SCALE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDONS_SCALE_Request))
		}
		var ORCHESTRATOR_ADDONS_SCALE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDONS_SCALE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDONS_SCALE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDONS_SCALE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDONS_SCALE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_AVAILABLE := func(method, path string, fn func(context.Context, *AddonAvailableRequest) (*AddonAvailableResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddonAvailableRequest))
		}
		var ORCHESTRATOR_ADDON_AVAILABLE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_AVAILABLE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_AVAILABLE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_AVAILABLE_info)
				}
				r = r.WithContext(ctx)
				var in AddonAvailableRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_CREATE := func(method, path string, fn func(context.Context, *AddonDirectCreateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddonDirectCreateRequest))
		}
		var ORCHESTRATOR_ADDON_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_CREATE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in AddonDirectCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_CREATE_CUSTOM := func(method, path string, fn func(context.Context, *CustomAddonCreateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CustomAddonCreateRequest))
		}
		var ORCHESTRATOR_ADDON_CREATE_CUSTOM_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_CREATE_CUSTOM_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_CREATE_CUSTOM", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_CREATE_CUSTOM_info)
				}
				r = r.WithContext(ctx)
				var in CustomAddonCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_CUSTOM := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_CUSTOM_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_CUSTOM_Request))
		}
		var ORCHESTRATOR_ADDON_CUSTOM_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_CUSTOM_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_CUSTOM", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_CUSTOM_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_CUSTOM_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_DELETE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_DELETE_Request) (*AddonFetchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_DELETE_Request))
		}
		var ORCHESTRATOR_ADDON_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_DELETE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "addonId":
							in.AddonId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_EXPORT := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_EXPORT_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_EXPORT_Request))
		}
		var ORCHESTRATOR_ADDON_EXPORT_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_EXPORT_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_EXPORT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_EXPORT_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_EXPORT_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_EXTENSION := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_EXTENSION_Request) (*AddonExtensionResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_EXTENSION_Request))
		}
		var ORCHESTRATOR_ADDON_EXTENSION_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_EXTENSION_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_EXTENSION", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_EXTENSION_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_EXTENSION_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_FETCH := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_FETCH_Request) (*AddonFetchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_FETCH_Request))
		}
		var ORCHESTRATOR_ADDON_FETCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_FETCH_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_FETCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_FETCH_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_FETCH_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "addonId":
							in.AddonId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_IMPORT := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_IMPORT_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_IMPORT_Request))
		}
		var ORCHESTRATOR_ADDON_IMPORT_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_IMPORT_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_IMPORT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_IMPORT_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_IMPORT_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_LIST := func(method, path string, fn func(context.Context, *AddonListRequest) (*AddonListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddonListRequest))
		}
		var ORCHESTRATOR_ADDON_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_LIST_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_LIST_info)
				}
				r = r.WithContext(ctx)
				var in AddonListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_LOGS := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_LOGS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_LOGS_Request))
		}
		var ORCHESTRATOR_ADDON_LOGS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_LOGS_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_LOGS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_LOGS_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_LOGS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "instanceId":
							in.InstanceId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_MENU := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_MENU_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_MENU_Request))
		}
		var ORCHESTRATOR_ADDON_MENU_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_MENU_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_MENU", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_MENU_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_MENU_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_REFERENCES := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ADDON_REFERENCES_Request) (*AddonReferencesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ADDON_REFERENCES_Request))
		}
		var ORCHESTRATOR_ADDON_REFERENCES_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_REFERENCES_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_REFERENCES", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_REFERENCES_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ADDON_REFERENCES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "addonID":
							in.AddonID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_TENANT_CREATE := func(method, path string, fn func(context.Context, *AddonTenantCreateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddonTenantCreateRequest))
		}
		var ORCHESTRATOR_ADDON_TENANT_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_TENANT_CREATE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_TENANT_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_TENANT_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in AddonTenantCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ADDON_UPDATE_CUSTOM := func(method, path string, fn func(context.Context, *CustomAddonUpdateRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CustomAddonUpdateRequest))
		}
		var ORCHESTRATOR_ADDON_UPDATE_CUSTOM_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ADDON_UPDATE_CUSTOM_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ADDON_UPDATE_CUSTOM", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ADDON_UPDATE_CUSTOM_info)
				}
				r = r.WithContext(ctx)
				var in CustomAddonUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "addonId":
							in.AddonId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_CLUSTER_INSTANCES_USAGE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_CLUSTER_INSTANCES_USAGE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_CLUSTER_INSTANCES_USAGE_Request))
		}
		var ORCHESTRATOR_CLUSTER_INSTANCES_USAGE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_CLUSTER_INSTANCES_USAGE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_CLUSTER_INSTANCES_USAGE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_CLUSTER_INSTANCES_USAGE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_CLUSTER_INSTANCES_USAGE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "cluster":
							in.Cluster = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_ADDONS := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_ADDONS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_ADDONS_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_ADDONS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_ADDONS_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_ADDONS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_ADDONS_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_ADDONS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "deploymentID":
							in.DeploymentID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_APPROVE := func(method, path string, fn func(context.Context, *DeploymentApproveRequest) (*DeploymentApproveResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeploymentApproveRequest))
		}
		var ORCHESTRATOR_DEPLOYMENT_APPROVE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_APPROVE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_APPROVE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_APPROVE_info)
				}
				r = r.WithContext(ctx)
				var in DeploymentApproveRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_CANCEL := func(method, path string, fn func(context.Context, *DeploymentCancelRequest) (*DeploymentCancelResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeploymentCancelRequest))
		}
		var ORCHESTRATOR_DEPLOYMENT_CANCEL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_CANCEL_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_CANCEL", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_CANCEL_info)
				}
				r = r.WithContext(ctx)
				var in DeploymentCancelRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "deploymentId":
							in.DeploymentId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_DOMAINS := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_DOMAINS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_DOMAINS_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_DOMAINS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_DOMAINS_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_DOMAINS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_DOMAINS_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_DOMAINS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "deploymentID":
							in.DeploymentID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_LIST := func(method, path string, fn func(context.Context, *DeploymentListRequest) (*DeploymentListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeploymentListRequest))
		}
		var ORCHESTRATOR_DEPLOYMENT_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_LIST_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_LIST_info)
				}
				r = r.WithContext(ctx)
				var in DeploymentListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED_Request) (*DeploymentDetailListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL_Request) (*DeploymentDetailListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL_Request) (*DeploymentDetailListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "deploymentOrderID":
							in.DeploymentOrderID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "deploymentOrderID":
							in.DeploymentOrderID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_ORDER_GET := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_ORDER_GET_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_ORDER_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_ORDER_GET_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_ORDER_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_ORDER_GET_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_ORDER_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "deploymentOrderID":
							in.DeploymentOrderID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_ORDER_LIST := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_LIST_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_ORDER_LIST_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_ORDER_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_ORDER_LIST_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_ORDER_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_ORDER_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_ORDER_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "deploymentId":
							in.DeploymentId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_DEPLOYMENT_SERVICES := func(method, path string, fn func(context.Context, *ORCHESTRATOR_DEPLOYMENT_SERVICES_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_DEPLOYMENT_SERVICES_Request))
		}
		var ORCHESTRATOR_DEPLOYMENT_SERVICES_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_DEPLOYMENT_SERVICES_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_DEPLOYMENT_SERVICES", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_DEPLOYMENT_SERVICES_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_DEPLOYMENT_SERVICES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "deploymentID":
							in.DeploymentID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_GET_APP_WORKSPACE_RELEASES := func(method, path string, fn func(context.Context, *AppWorkspaceReleasesGetRequest) (*AppWorkspaceReleasesGetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AppWorkspaceReleasesGetRequest))
		}
		var ORCHESTRATOR_GET_APP_WORKSPACE_RELEASES_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_GET_APP_WORKSPACE_RELEASES_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_GET_APP_WORKSPACE_RELEASES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_GET_APP_WORKSPACE_RELEASES_info)
				}
				r = r.WithContext(ctx)
				var in AppWorkspaceReleasesGetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_INSTANCES_USAGE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_INSTANCES_USAGE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_INSTANCES_USAGE_Request))
		}
		var ORCHESTRATOR_INSTANCES_USAGE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_INSTANCES_USAGE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_INSTANCES_USAGE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_INSTANCES_USAGE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_INSTANCES_USAGE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_MICRO_SERVICE_MENUS := func(method, path string, fn func(context.Context, *ORCHESTRATOR_MICRO_SERVICE_MENUS_Request) (*MicroServiceMenuResponseData, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_MICRO_SERVICE_MENUS_Request))
		}
		var ORCHESTRATOR_MICRO_SERVICE_MENUS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_MICRO_SERVICE_MENUS_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_MICRO_SERVICE_MENUS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_MICRO_SERVICE_MENUS_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_MICRO_SERVICE_MENUS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_MICRO_SERVICE_PROJECTS := func(method, path string, fn func(context.Context, *ORCHESTRATOR_MICRO_SERVICE_PROJECTS_Request) (*MicroServiceProjectResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_MICRO_SERVICE_PROJECTS_Request))
		}
		var ORCHESTRATOR_MICRO_SERVICE_PROJECTS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_MICRO_SERVICE_PROJECTS_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_MICRO_SERVICE_PROJECTS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_MICRO_SERVICE_PROJECTS_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_MICRO_SERVICE_PROJECTS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_MIDDLEWARE_ADDON_CLASSIFICATION := func(method, path string, fn func(context.Context, *MiddlewareListRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*MiddlewareListRequest))
		}
		var ORCHESTRATOR_MIDDLEWARE_ADDON_CLASSIFICATION_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_MIDDLEWARE_ADDON_CLASSIFICATION_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_MIDDLEWARE_ADDON_CLASSIFICATION", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_MIDDLEWARE_ADDON_CLASSIFICATION_info)
				}
				r = r.WithContext(ctx)
				var in MiddlewareListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_MIDDLEWARE_DAILY := func(method, path string, fn func(context.Context, *MiddlewareListRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*MiddlewareListRequest))
		}
		var ORCHESTRATOR_MIDDLEWARE_DAILY_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_MIDDLEWARE_DAILY_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_MIDDLEWARE_DAILY", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_MIDDLEWARE_DAILY_info)
				}
				r = r.WithContext(ctx)
				var in MiddlewareListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_MIDDLEWARE_FETCH := func(method, path string, fn func(context.Context, *ORCHESTRATOR_MIDDLEWARE_FETCH_Request) (*MiddlewareFetchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_MIDDLEWARE_FETCH_Request))
		}
		var ORCHESTRATOR_MIDDLEWARE_FETCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_MIDDLEWARE_FETCH_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_MIDDLEWARE_FETCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_MIDDLEWARE_FETCH_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_MIDDLEWARE_FETCH_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "addonId":
							in.AddonId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE_Request) (*MiddlewareResourceFetchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE_Request))
		}
		var ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "addonId":
							in.AddonId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_MIDDLEWARE_LIST := func(method, path string, fn func(context.Context, *MiddlewareListRequest) (*MiddlewareListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*MiddlewareListRequest))
		}
		var ORCHESTRATOR_MIDDLEWARE_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_MIDDLEWARE_LIST_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_MIDDLEWARE_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_MIDDLEWARE_LIST_info)
				}
				r = r.WithContext(ctx)
				var in MiddlewareListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_MIGRATION_LOG := func(method, path string, fn func(context.Context, *ORCHESTRATOR_MIGRATION_LOG_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_MIGRATION_LOG_Request))
		}
		var ORCHESTRATOR_MIGRATION_LOG_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_MIGRATION_LOG_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_MIGRATION_LOG", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_MIGRATION_LOG_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_MIGRATION_LOG_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "migrationId":
							in.MigrationId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_NODELABEL_LIST := func(method, path string, fn func(context.Context, *ScheduleLabelListRequest) (*ScheduleLabelListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ScheduleLabelListRequest))
		}
		var ORCHESTRATOR_NODELABEL_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_NODELABEL_LIST_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_NODELABEL_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_NODELABEL_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ScheduleLabelListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_NODELABEL_SET := func(method, path string, fn func(context.Context, *ScheduleLabelSetRequest) (*ScheduleLabelSetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ScheduleLabelSetRequest))
		}
		var ORCHESTRATOR_NODELABEL_SET_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_NODELABEL_SET_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_NODELABEL_SET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_NODELABEL_SET_info)
				}
				r = r.WithContext(ctx)
				var in ScheduleLabelSetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_ORG_JOB_LOG := func(method, path string, fn func(context.Context, *ORCHESTRATOR_ORG_JOB_LOG_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_ORG_JOB_LOG_Request))
		}
		var ORCHESTRATOR_ORG_JOB_LOG_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_ORG_JOB_LOG_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_ORG_JOB_LOG", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_ORG_JOB_LOG_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_ORG_JOB_LOG_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_PROJECT_RUNTIME_COUNT := func(method, path string, fn func(context.Context, *ORCHESTRATOR_PROJECT_RUNTIME_COUNT_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_PROJECT_RUNTIME_COUNT_Request))
		}
		var ORCHESTRATOR_PROJECT_RUNTIME_COUNT_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_PROJECT_RUNTIME_COUNT_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_PROJECT_RUNTIME_COUNT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_PROJECT_RUNTIME_COUNT_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_PROJECT_RUNTIME_COUNT_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIMES_BATCH_SCALE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIMES_BATCH_SCALE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIMES_BATCH_SCALE_Request))
		}
		var ORCHESTRATOR_RUNTIMES_BATCH_SCALE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIMES_BATCH_SCALE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIMES_BATCH_SCALE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIMES_BATCH_SCALE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIMES_BATCH_SCALE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_BATCH_SERVICES := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_BATCH_SERVICES_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_BATCH_SERVICES_Request))
		}
		var ORCHESTRATOR_RUNTIME_BATCH_SERVICES_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_BATCH_SERVICES_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_BATCH_SERVICES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_BATCH_SERVICES_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_BATCH_SERVICES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_BULK_GET_STATUS := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_BULK_GET_STATUS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_BULK_GET_STATUS_Request))
		}
		var ORCHESTRATOR_RUNTIME_BULK_GET_STATUS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_BULK_GET_STATUS_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_BULK_GET_STATUS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_BULK_GET_STATUS_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_BULK_GET_STATUS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_CREATE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_CREATE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_CREATE_Request))
		}
		var ORCHESTRATOR_RUNTIME_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_CREATE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_CREATE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_DELETE := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_DELETE_Request) (*RuntimeDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_DELETE_Request))
		}
		var ORCHESTRATOR_RUNTIME_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_DELETE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeId":
							in.RuntimeId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_DEPLOY_LOG := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_DEPLOY_LOG_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_DEPLOY_LOG_Request))
		}
		var ORCHESTRATOR_RUNTIME_DEPLOY_LOG_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_DEPLOY_LOG_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_DEPLOY_LOG", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_DEPLOY_LOG_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_DEPLOY_LOG_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_DOMAIN_GET := func(method, path string, fn func(context.Context, *DomainListRequest) (*DomainListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DomainListRequest))
		}
		var ORCHESTRATOR_RUNTIME_DOMAIN_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_DOMAIN_GET_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_DOMAIN_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_DOMAIN_GET_info)
				}
				r = r.WithContext(ctx)
				var in DomainListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.RuntimeID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_DOMAIN_UPDATE := func(method, path string, fn func(context.Context, *DomainUpdateRequest) (*DomainUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DomainUpdateRequest))
		}
		var ORCHESTRATOR_RUNTIME_DOMAIN_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_DOMAIN_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_DOMAIN_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_DOMAIN_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in DomainUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.RuntimeID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_GROUP_BY_APPS := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_GROUP_BY_APPS_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_GROUP_BY_APPS_Request))
		}
		var ORCHESTRATOR_RUNTIME_GROUP_BY_APPS_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_GROUP_BY_APPS_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_GROUP_BY_APPS", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_GROUP_BY_APPS_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_GROUP_BY_APPS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_INSPECT := func(method, path string, fn func(context.Context, *RuntimeInspectRequest) (*RuntimeInspectResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*RuntimeInspectRequest))
		}
		var ORCHESTRATOR_RUNTIME_INSPECT_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_INSPECT_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_INSPECT", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_INSPECT_info)
				}
				r = r.WithContext(ctx)
				var in RuntimeInspectRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "IDOrName":
							in.IDOrName = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP_Request))
		}
		var ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeId":
							in.RuntimeId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_KILLPOD := func(method, path string, fn func(context.Context, *RuntimeKillPodRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*RuntimeKillPodRequest))
		}
		var ORCHESTRATOR_RUNTIME_KILLPOD_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_KILLPOD_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_KILLPOD", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_KILLPOD_info)
				}
				r = r.WithContext(ctx)
				var in RuntimeKillPodRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES_Request))
		}
		var ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_REDEPLOY := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_REDEPLOY_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_REDEPLOY_Request))
		}
		var ORCHESTRATOR_RUNTIME_REDEPLOY_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_REDEPLOY_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_REDEPLOY", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_REDEPLOY_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_REDEPLOY_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeId":
							in.RuntimeId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION_Request))
		}
		var ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeId":
							in.RuntimeId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_RELEASE_CREATE := func(method, path string, fn func(context.Context, *RuntimeReleaseCreateRequest) (*RuntimeReleaseCreatePipelineResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*RuntimeReleaseCreateRequest))
		}
		var ORCHESTRATOR_RUNTIME_RELEASE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_RELEASE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_RELEASE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_RELEASE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in RuntimeReleaseCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_RELEASE_CREATE_ACTION := func(method, path string, fn func(context.Context, *RuntimeReleaseCreateRequest) (*RuntimeCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*RuntimeReleaseCreateRequest))
		}
		var ORCHESTRATOR_RUNTIME_RELEASE_CREATE_ACTION_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_RELEASE_CREATE_ACTION_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_RELEASE_CREATE_ACTION", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_RELEASE_CREATE_ACTION_info)
				}
				r = r.WithContext(ctx)
				var in RuntimeReleaseCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_ROLLBACK := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_ROLLBACK_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_ROLLBACK_Request))
		}
		var ORCHESTRATOR_RUNTIME_ROLLBACK_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_ROLLBACK_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_ROLLBACK", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_ROLLBACK_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_ROLLBACK_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeId":
							in.RuntimeId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION_Request))
		}
		var ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "runtimeId":
							in.RuntimeId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_RUNTIME_SEARCH := func(method, path string, fn func(context.Context, *ORCHESTRATOR_RUNTIME_SEARCH_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_RUNTIME_SEARCH_Request))
		}
		var ORCHESTRATOR_RUNTIME_SEARCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_RUNTIME_SEARCH_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_RUNTIME_SEARCH", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_RUNTIME_SEARCH_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_RUNTIME_SEARCH_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_SERVICE_INSTANCE_LIST := func(method, path string, fn func(context.Context, *ContainerListRequest) (*ContainerListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ContainerListRequest))
		}
		var ORCHESTRATOR_SERVICE_INSTANCE_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_SERVICE_INSTANCE_LIST_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_SERVICE_INSTANCE_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_SERVICE_INSTANCE_LIST_info)
				}
				r = r.WithContext(ctx)
				var in ContainerListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_SERVICE_POD_LIST := func(method, path string, fn func(context.Context, *PodListRequest) (*PodListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PodListRequest))
		}
		var ORCHESTRATOR_SERVICE_POD_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_SERVICE_POD_LIST_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_SERVICE_POD_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_SERVICE_POD_LIST_info)
				}
				r = r.WithContext(ctx)
				var in PodListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ORCHESTRATOR_TERMINAL := func(method, path string, fn func(context.Context, *ORCHESTRATOR_TERMINAL_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ORCHESTRATOR_TERMINAL_Request))
		}
		var ORCHESTRATOR_TERMINAL_info transport.ServiceInfo
		if h.Interceptor != nil {
			ORCHESTRATOR_TERMINAL_info = transport.NewServiceInfo("erda.openapiv1.orchestrator.orchestrator", "ORCHESTRATOR_TERMINAL", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ORCHESTRATOR_TERMINAL_info)
				}
				r = r.WithContext(ctx)
				var in ORCHESTRATOR_TERMINAL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ADDON_METRICS_HISTOGRAM("GET", "/api/addon/metrics/charts/{scope}/histogram", srv.ADDON_METRICS_HISTOGRAM)
	add_ORCHESTRATOR_ADDONS_SCALE("POST", "/api/addons", srv.ORCHESTRATOR_ADDONS_SCALE)
	add_ORCHESTRATOR_ADDON_AVAILABLE("GET", "/api/addons/actions/list-available", srv.ORCHESTRATOR_ADDON_AVAILABLE)
	add_ORCHESTRATOR_ADDON_CREATE("POST", "/api/addons/actions/create-addon", srv.ORCHESTRATOR_ADDON_CREATE)
	add_ORCHESTRATOR_ADDON_CREATE_CUSTOM("POST", "/api/addons/actions/create-custom", srv.ORCHESTRATOR_ADDON_CREATE_CUSTOM)
	add_ORCHESTRATOR_ADDON_CUSTOM("GET", "/api/addons/actions/list-customs", srv.ORCHESTRATOR_ADDON_CUSTOM)
	add_ORCHESTRATOR_ADDON_DELETE("DELETE", "/api/addons/{addonId}", srv.ORCHESTRATOR_ADDON_DELETE)
	add_ORCHESTRATOR_ADDON_EXPORT("POST", "/api/addon/action/yml-export", srv.ORCHESTRATOR_ADDON_EXPORT)
	add_ORCHESTRATOR_ADDON_EXTENSION("GET", "/api/addons/actions/list-extension", srv.ORCHESTRATOR_ADDON_EXTENSION)
	add_ORCHESTRATOR_ADDON_FETCH("GET", "/api/addons/{addonId}", srv.ORCHESTRATOR_ADDON_FETCH)
	add_ORCHESTRATOR_ADDON_IMPORT("POST", "/api/addon/action/yml-import", srv.ORCHESTRATOR_ADDON_IMPORT)
	add_ORCHESTRATOR_ADDON_LIST("GET", "/api/addons", srv.ORCHESTRATOR_ADDON_LIST)
	add_ORCHESTRATOR_ADDON_LOGS("GET", "/api/addons/{instanceId}/logs", srv.ORCHESTRATOR_ADDON_LOGS)
	add_ORCHESTRATOR_ADDON_MENU("GET", "/api/addons/actions/menu", srv.ORCHESTRATOR_ADDON_MENU)
	add_ORCHESTRATOR_ADDON_REFERENCES("GET", "/api/addons/{addonID}/actions/references", srv.ORCHESTRATOR_ADDON_REFERENCES)
	add_ORCHESTRATOR_ADDON_TENANT_CREATE("POST", "/api/addons/actions/create-tenant", srv.ORCHESTRATOR_ADDON_TENANT_CREATE)
	add_ORCHESTRATOR_ADDON_UPDATE_CUSTOM("PUT", "/api/addons/{addonId}/actions/update-custom", srv.ORCHESTRATOR_ADDON_UPDATE_CUSTOM)
	add_ORCHESTRATOR_CLUSTER_INSTANCES_USAGE("GET", "/api/cmdb/clusters/{cluster}/instances-usage", srv.ORCHESTRATOR_CLUSTER_INSTANCES_USAGE)
	add_ORCHESTRATOR_DEPLOYMENT_ADDONS("POST", "/api/deployments/{deploymentID}/actions/deploy-addons", srv.ORCHESTRATOR_DEPLOYMENT_ADDONS)
	add_ORCHESTRATOR_DEPLOYMENT_APPROVE("POST", "/api/deployments/actions/approve", srv.ORCHESTRATOR_DEPLOYMENT_APPROVE)
	add_ORCHESTRATOR_DEPLOYMENT_CANCEL("POST", "/api/deployments/{deploymentId}/actions/cancel", srv.ORCHESTRATOR_DEPLOYMENT_CANCEL)
	add_ORCHESTRATOR_DEPLOYMENT_DOMAINS("POST", "/api/deployments/{deploymentID}/actions/deploy-domains", srv.ORCHESTRATOR_DEPLOYMENT_DOMAINS)
	add_ORCHESTRATOR_DEPLOYMENT_LIST("GET", "/api/deployments", srv.ORCHESTRATOR_DEPLOYMENT_LIST)
	add_ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED("GET", "/api/deployments/actions/list-approved", srv.ORCHESTRATOR_DEPLOYMENT_LIST_APPROVED)
	add_ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL("GET", "/api/deployments/actions/list-launched-approval", srv.ORCHESTRATOR_DEPLOYMENT_LIST_LAUNCHED_APPROVAL)
	add_ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL("GET", "/api/deployments/actions/list-pending-approval", srv.ORCHESTRATOR_DEPLOYMENT_LIST_PENDING_APPROVAL)
	add_ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL("POST", "/api/deployment-orders/{deploymentOrderID}/actions/cancel", srv.ORCHESTRATOR_DEPLOYMENT_ORDER_CANCEL)
	add_ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE("POST", "/api/deployment-orders", srv.ORCHESTRATOR_DEPLOYMENT_ORDER_CREATE)
	add_ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY("POST", "/api/deployment-orders/{deploymentOrderID}/actions/deploy", srv.ORCHESTRATOR_DEPLOYMENT_ORDER_DEPLOY)
	add_ORCHESTRATOR_DEPLOYMENT_ORDER_GET("GET", "/api/deployment-orders/{deploymentOrderID}", srv.ORCHESTRATOR_DEPLOYMENT_ORDER_GET)
	add_ORCHESTRATOR_DEPLOYMENT_ORDER_LIST("GET", "/api/deployment-orders", srv.ORCHESTRATOR_DEPLOYMENT_ORDER_LIST)
	add_ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL("GET", "/api/deployment-orders/actions/render-detail", srv.ORCHESTRATOR_DEPLOYMENT_ORDER_RENDER_DETAIL)
	add_ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS("GET", "/api/deployments/{deploymentId}/status", srv.ORCHESTRATOR_DEPLOYMENT_QUERY_STATUS)
	add_ORCHESTRATOR_DEPLOYMENT_SERVICES("POST", "/api/deployments/{deploymentID}/actions/deploy-services", srv.ORCHESTRATOR_DEPLOYMENT_SERVICES)
	add_ORCHESTRATOR_GET_APP_WORKSPACE_RELEASES("GET", "/api/runtimes/actions/get-app-workspace-releases", srv.ORCHESTRATOR_GET_APP_WORKSPACE_RELEASES)
	add_ORCHESTRATOR_INSTANCES_USAGE("GET", "/api/instances-usage", srv.ORCHESTRATOR_INSTANCES_USAGE)
	add_ORCHESTRATOR_MICRO_SERVICE_MENUS("GET", "/api/microservice/project/{projectID}/menus", srv.ORCHESTRATOR_MICRO_SERVICE_MENUS)
	add_ORCHESTRATOR_MICRO_SERVICE_PROJECTS("GET", "/api/microservice/projects", srv.ORCHESTRATOR_MICRO_SERVICE_PROJECTS)
	add_ORCHESTRATOR_MIDDLEWARE_ADDON_CLASSIFICATION("GET", "/api/middlewares/resource/classification", srv.ORCHESTRATOR_MIDDLEWARE_ADDON_CLASSIFICATION)
	add_ORCHESTRATOR_MIDDLEWARE_DAILY("GET", "/api/middlewares/resource/daily", srv.ORCHESTRATOR_MIDDLEWARE_DAILY)
	add_ORCHESTRATOR_MIDDLEWARE_FETCH("GET", "/api/middlewares/{addonId}", srv.ORCHESTRATOR_MIDDLEWARE_FETCH)
	add_ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE("GET", "/api/middlewares/{addonId}/actions/get-resource", srv.ORCHESTRATOR_MIDDLEWARE_FETCH_RESOURCE)
	add_ORCHESTRATOR_MIDDLEWARE_LIST("GET", "/api/middlewares", srv.ORCHESTRATOR_MIDDLEWARE_LIST)
	add_ORCHESTRATOR_MIGRATION_LOG("GET", "/api/migration/{migrationId}/logs", srv.ORCHESTRATOR_MIGRATION_LOG)
	add_ORCHESTRATOR_NODELABEL_LIST("GET", "/api/nodelabels", srv.ORCHESTRATOR_NODELABEL_LIST)
	add_ORCHESTRATOR_NODELABEL_SET("POST", "/api/nodelabels", srv.ORCHESTRATOR_NODELABEL_SET)
	add_ORCHESTRATOR_ORG_JOB_LOG("GET", "/api/orgCenter/job/logs", srv.ORCHESTRATOR_ORG_JOB_LOG)
	add_ORCHESTRATOR_PROJECT_RUNTIME_COUNT("GET", "/api/countProjectRuntime", srv.ORCHESTRATOR_PROJECT_RUNTIME_COUNT)
	add_ORCHESTRATOR_RUNTIMES_BATCH_SCALE("PUT", "/api/runtimes/actions/batch-update-pre-overlay", srv.ORCHESTRATOR_RUNTIMES_BATCH_SCALE)
	add_ORCHESTRATOR_RUNTIME_BATCH_SERVICES("GET", "/api/runtimesServices", srv.ORCHESTRATOR_RUNTIME_BATCH_SERVICES)
	add_ORCHESTRATOR_RUNTIME_BULK_GET_STATUS("GET", "/api/runtimes/actions/bulk-get-status", srv.ORCHESTRATOR_RUNTIME_BULK_GET_STATUS)
	add_ORCHESTRATOR_RUNTIME_CREATE("POST", "/api/runtimes", srv.ORCHESTRATOR_RUNTIME_CREATE)
	add_ORCHESTRATOR_RUNTIME_DELETE("DELETE", "/api/runtimes/{runtimeId}", srv.ORCHESTRATOR_RUNTIME_DELETE)
	add_ORCHESTRATOR_RUNTIME_DEPLOY_LOG("GET", "/api/runtimes/deploy/logs", srv.ORCHESTRATOR_RUNTIME_DEPLOY_LOG)
	add_ORCHESTRATOR_RUNTIME_DOMAIN_GET("GET", "/api/runtimes/{runtimeID}/domains", srv.ORCHESTRATOR_RUNTIME_DOMAIN_GET)
	add_ORCHESTRATOR_RUNTIME_DOMAIN_UPDATE("PUT", "/api/runtimes/{runtimeID}/domains", srv.ORCHESTRATOR_RUNTIME_DOMAIN_UPDATE)
	add_ORCHESTRATOR_RUNTIME_GROUP_BY_APPS("GET", "/api/runtimes/actions/group-by-apps", srv.ORCHESTRATOR_RUNTIME_GROUP_BY_APPS)
	add_ORCHESTRATOR_RUNTIME_INSPECT("GET", "/api/runtimes/{IDOrName}", srv.ORCHESTRATOR_RUNTIME_INSPECT)
	add_ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP("GET", "/api/runtimes/{runtimeId}/configuration", srv.ORCHESTRATOR_RUNTIME_INSPECT_SERVICEGROUP)
	add_ORCHESTRATOR_RUNTIME_KILLPOD("POST", "/api/runtimes/actions/killpod", srv.ORCHESTRATOR_RUNTIME_KILLPOD)
	add_ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES("GET", "/api/runtimes/actions/list-my-runtimes", srv.ORCHESTRATOR_RUNTIME_LIST_MY_RUNTIMES)
	add_ORCHESTRATOR_RUNTIME_REDEPLOY("POST", "/api/runtimes/{runtimeId}/actions/redeploy", srv.ORCHESTRATOR_RUNTIME_REDEPLOY)
	add_ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION("POST", "/api/runtimes/{runtimeId}/actions/redeploy-action", srv.ORCHESTRATOR_RUNTIME_REDEPLOY_ACTION)
	add_ORCHESTRATOR_RUNTIME_RELEASE_CREATE("POST", "/api/runtimes/actions/deploy-release", srv.ORCHESTRATOR_RUNTIME_RELEASE_CREATE)
	add_ORCHESTRATOR_RUNTIME_RELEASE_CREATE_ACTION("POST", "/api/runtimes/actions/deploy-release-action", srv.ORCHESTRATOR_RUNTIME_RELEASE_CREATE_ACTION)
	add_ORCHESTRATOR_RUNTIME_ROLLBACK("POST", "/api/runtimes/{runtimeId}/actions/rollback", srv.ORCHESTRATOR_RUNTIME_ROLLBACK)
	add_ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION("POST", "/api/runtimes/{runtimeId}/actions/rollback-action", srv.ORCHESTRATOR_RUNTIME_ROLLBACK_ACTION)
	add_ORCHESTRATOR_RUNTIME_SEARCH("GET", "/api/runtimes", srv.ORCHESTRATOR_RUNTIME_SEARCH)
	add_ORCHESTRATOR_SERVICE_INSTANCE_LIST("GET", "/api/instances/actions/get-service", srv.ORCHESTRATOR_SERVICE_INSTANCE_LIST)
	add_ORCHESTRATOR_SERVICE_POD_LIST("GET", "/api/instances/actions/get-service-pods", srv.ORCHESTRATOR_SERVICE_POD_LIST)
	add_ORCHESTRATOR_TERMINAL("GET", "/api/terminal", srv.ORCHESTRATOR_TERMINAL)
}
