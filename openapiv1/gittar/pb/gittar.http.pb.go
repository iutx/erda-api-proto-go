// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: gittar.proto

package pb

import (
	context "context"
	http1 "net/http"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// GittarHandler is the server API for Gittar service.
type GittarHandler interface {
	// GET /api/gittar/{org}/{repo}/archive/**
	GITTAR_ARCHIVE(context.Context, *GITTAR_ARCHIVE_Request) (*emptypb.Empty, error)
	// GET /api/gittar/{org}/{repo}/blame/**
	GITTAR_BLAME(context.Context, *GITTAR_BLAME_Request) (*GittarBlameResponse, error)
	// GET /api/gittar/{org}/{repo}/blob/**
	GITTAR_BLOB(context.Context, *GITTAR_BLOB_Request) (*GittarBlobResponse, error)
	// GET /api/gittar/{org}/{repo}/branches
	GITTAR_BRANCH(context.Context, *GITTAR_BRANCH_Request) (*GittarBranchesResponse, error)
	// POST /api/gittar/{org}/{repo}/branches
	GITTAR_BRANCH_CREATE(context.Context, *GittarCreateBranchRequest) (*GittarCreateBranchResponse, error)
	// DELETE /api/gittar/{org}/{repo}/branches/**
	GITTAR_BRANCH_DELETE(context.Context, *GITTAR_BRANCH_DELETE_Request) (*GittarDeleteBranchResponse, error)
	// POST /api/gittar/{org}/{repo}/check-runs
	GITTAR_CHECK_RUN_CREATE(context.Context, *CheckRun) (*CreateCheckRunResponse, error)
	// GET /api/gittar/{org}/{repo}/check-runs
	GITTAR_CHECK_RUN_QUERY(context.Context, *CheckRun) (*CreateCheckRunResponse, error)
	// GET /api/gittar/{org}/{repo}/commit/**
	GITTAR_COMMIT(context.Context, *GITTAR_COMMIT_Request) (*GittarCommitResponse, error)
	// GET /api/gittar/{org}/{repo}/commits/**
	GITTAR_COMMITS(context.Context, *GittarCommitsRequest) (*GittarCommitsResponse, error)
	// POST /api/gittar/{org}/{repo}/commits
	GITTAR_COMMITS_CREATE(context.Context, *GittarCreateCommitRequest) (*GittarCreateCommitResponse, error)
	// GET /api/gittar/{org}/{repo}/compare/**
	GITTAR_COMPARE(context.Context, *GITTAR_COMPARE_Request) (*GittarCompareResponse, error)
	// POST /api/gittar/{org}/{repo}/merge-requests/{id}/{action}
	GITTAR_MERGE_ACTION_POST(context.Context, *GITTAR_MERGE_ACTION_POST_Request) (*emptypb.Empty, error)
	// GET /api/gittar/{org}/{repo}/merge-requests/{id}/{action}
	GITTAR_MERGE_ACTION_QUERY(context.Context, *GITTAR_MERGE_ACTION_QUERY_Request) (*emptypb.Empty, error)
	// POST /api/gittar/{org}/{repo}/merge-requests
	GITTAR_MERGE_CREATE(context.Context, *GittarCreateMergeRequest) (*GittarCreateMergeResponse, error)
	// GET /api/gittar/{org}/{repo}/merge-requests/{id}
	GITTAR_MERGE_GET(context.Context, *GITTAR_MERGE_GET_Request) (*GittarQueryMrDetailResponse, error)
	// GET /api/gittar/{org}/{repo}/merge-requests
	GITTAR_MERGE_QUERY(context.Context, *GittarQueryMrRequest) (*GittarQueryMrResponse, error)
	// GET /api/gittar/{org}/{repo}/merge-stats
	GITTAR_MERGE_STATS(context.Context, *GittarMergeStatusRequest) (*GittarMergeStatusResponse, error)
	// GET /api/gittar/{org}/{repo}/merge-templates
	GITTAR_MR_TEMPLATES(context.Context, *GITTAR_MR_TEMPLATES_Request) (*GittarMergeTemplatesResponse, error)
	// GET /api/gittar/{org}/{repo}/raw/**
	GITTAR_RAW(context.Context, *GITTAR_RAW_Request) (*emptypb.Empty, error)
	// GET /api/gittar/{org}/{repo}/stats/**
	GITTAR_REPO_STATS(context.Context, *GITTAR_REPO_STATS_Request) (*GittarStatsResponse, error)
	// GET /api/gittar/{org}/{repo}/stats
	GITTAR_REPO_STATS_DEFAULT(context.Context, *GITTAR_REPO_STATS_DEFAULT_Request) (*GittarStatsResponse, error)
	// GET /api/gittar/{org}/{repo}/tags
	GITTAR_TAG(context.Context, *GITTAR_TAG_Request) (*GittarTagsResponse, error)
	// POST /api/gittar/{org}/{repo}/tags
	GITTAR_TAG_CREATE(context.Context, *GittarCreateTagRequest) (*GittarCreateTagResponse, error)
	// DELETE /api/gittar/{org}/{repo}/tags/**
	GITTAR_TAG_DELETE(context.Context, *GITTAR_TAG_DELETE_Request) (*GittarDeleteResponse, error)
	// GET /api/gittar/{org}/{repo}/tree/**
	GITTAR_TREE(context.Context, *GITTAR_TREE_Request) (*emptypb.Empty, error)
	// GET /api/gittar/{org}/{repo}/tree-search
	GITTAR_TREE_SEARCH(context.Context, *GittarTreeSearchRequest) (*GittarTreeSearchResponse, error)
	// DELETE /api/repo/**
	REPO_DELETE(context.Context, *REPO_DELETE_Request) (*emptypb.Empty, error)
	// GET /api/repo/**
	REPO_GET(context.Context, *REPO_GET_Request) (*emptypb.Empty, error)
	// POST /api/repo/**
	REPO_POST(context.Context, *REPO_POST_Request) (*emptypb.Empty, error)
	// PUT /api/repo/**
	REPO_PUT(context.Context, *REPO_PUT_Request) (*emptypb.Empty, error)
}

// RegisterGittarHandler register GittarHandler to http.Router.
func RegisterGittarHandler(r http.Router, srv GittarHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_GITTAR_ARCHIVE := func(method, path string, fn func(context.Context, *GITTAR_ARCHIVE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_ARCHIVE_Request))
		}
		var GITTAR_ARCHIVE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_ARCHIVE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_ARCHIVE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_ARCHIVE_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_ARCHIVE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_BLAME := func(method, path string, fn func(context.Context, *GITTAR_BLAME_Request) (*GittarBlameResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_BLAME_Request))
		}
		var GITTAR_BLAME_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_BLAME_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BLAME", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_BLAME_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_BLAME_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_BLOB := func(method, path string, fn func(context.Context, *GITTAR_BLOB_Request) (*GittarBlobResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_BLOB_Request))
		}
		var GITTAR_BLOB_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_BLOB_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BLOB", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_BLOB_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_BLOB_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_BRANCH := func(method, path string, fn func(context.Context, *GITTAR_BRANCH_Request) (*GittarBranchesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_BRANCH_Request))
		}
		var GITTAR_BRANCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_BRANCH_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BRANCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_BRANCH_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_BRANCH_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_BRANCH_CREATE := func(method, path string, fn func(context.Context, *GittarCreateBranchRequest) (*GittarCreateBranchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GittarCreateBranchRequest))
		}
		var GITTAR_BRANCH_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_BRANCH_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BRANCH_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_BRANCH_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in GittarCreateBranchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_BRANCH_DELETE := func(method, path string, fn func(context.Context, *GITTAR_BRANCH_DELETE_Request) (*GittarDeleteBranchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_BRANCH_DELETE_Request))
		}
		var GITTAR_BRANCH_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_BRANCH_DELETE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BRANCH_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_BRANCH_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_BRANCH_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_CHECK_RUN_CREATE := func(method, path string, fn func(context.Context, *CheckRun) (*CreateCheckRunResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CheckRun))
		}
		var GITTAR_CHECK_RUN_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_CHECK_RUN_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_CHECK_RUN_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_CHECK_RUN_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in CheckRun
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_CHECK_RUN_QUERY := func(method, path string, fn func(context.Context, *CheckRun) (*CreateCheckRunResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CheckRun))
		}
		var GITTAR_CHECK_RUN_QUERY_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_CHECK_RUN_QUERY_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_CHECK_RUN_QUERY", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_CHECK_RUN_QUERY_info)
				}
				r = r.WithContext(ctx)
				var in CheckRun
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_COMMIT := func(method, path string, fn func(context.Context, *GITTAR_COMMIT_Request) (*GittarCommitResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_COMMIT_Request))
		}
		var GITTAR_COMMIT_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_COMMIT_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_COMMIT", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_COMMIT_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_COMMIT_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_COMMITS := func(method, path string, fn func(context.Context, *GittarCommitsRequest) (*GittarCommitsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GittarCommitsRequest))
		}
		var GITTAR_COMMITS_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_COMMITS_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_COMMITS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_COMMITS_info)
				}
				r = r.WithContext(ctx)
				var in GittarCommitsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_COMMITS_CREATE := func(method, path string, fn func(context.Context, *GittarCreateCommitRequest) (*GittarCreateCommitResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GittarCreateCommitRequest))
		}
		var GITTAR_COMMITS_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_COMMITS_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_COMMITS_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_COMMITS_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in GittarCreateCommitRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_COMPARE := func(method, path string, fn func(context.Context, *GITTAR_COMPARE_Request) (*GittarCompareResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_COMPARE_Request))
		}
		var GITTAR_COMPARE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_COMPARE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_COMPARE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_COMPARE_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_COMPARE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_MERGE_ACTION_POST := func(method, path string, fn func(context.Context, *GITTAR_MERGE_ACTION_POST_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_MERGE_ACTION_POST_Request))
		}
		var GITTAR_MERGE_ACTION_POST_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_MERGE_ACTION_POST_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_ACTION_POST", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_MERGE_ACTION_POST_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_MERGE_ACTION_POST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						case "id":
							in.Id = val
						case "action":
							in.Action = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_MERGE_ACTION_QUERY := func(method, path string, fn func(context.Context, *GITTAR_MERGE_ACTION_QUERY_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_MERGE_ACTION_QUERY_Request))
		}
		var GITTAR_MERGE_ACTION_QUERY_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_MERGE_ACTION_QUERY_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_ACTION_QUERY", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_MERGE_ACTION_QUERY_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_MERGE_ACTION_QUERY_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						case "id":
							in.Id = val
						case "action":
							in.Action = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_MERGE_CREATE := func(method, path string, fn func(context.Context, *GittarCreateMergeRequest) (*GittarCreateMergeResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GittarCreateMergeRequest))
		}
		var GITTAR_MERGE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_MERGE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_MERGE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in GittarCreateMergeRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_MERGE_GET := func(method, path string, fn func(context.Context, *GITTAR_MERGE_GET_Request) (*GittarQueryMrDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_MERGE_GET_Request))
		}
		var GITTAR_MERGE_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_MERGE_GET_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_MERGE_GET_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_MERGE_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_MERGE_QUERY := func(method, path string, fn func(context.Context, *GittarQueryMrRequest) (*GittarQueryMrResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GittarQueryMrRequest))
		}
		var GITTAR_MERGE_QUERY_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_MERGE_QUERY_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_QUERY", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_MERGE_QUERY_info)
				}
				r = r.WithContext(ctx)
				var in GittarQueryMrRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_MERGE_STATS := func(method, path string, fn func(context.Context, *GittarMergeStatusRequest) (*GittarMergeStatusResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GittarMergeStatusRequest))
		}
		var GITTAR_MERGE_STATS_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_MERGE_STATS_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_STATS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_MERGE_STATS_info)
				}
				r = r.WithContext(ctx)
				var in GittarMergeStatusRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_MR_TEMPLATES := func(method, path string, fn func(context.Context, *GITTAR_MR_TEMPLATES_Request) (*GittarMergeTemplatesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_MR_TEMPLATES_Request))
		}
		var GITTAR_MR_TEMPLATES_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_MR_TEMPLATES_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MR_TEMPLATES", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_MR_TEMPLATES_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_MR_TEMPLATES_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_RAW := func(method, path string, fn func(context.Context, *GITTAR_RAW_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_RAW_Request))
		}
		var GITTAR_RAW_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_RAW_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_RAW", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_RAW_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_RAW_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_REPO_STATS := func(method, path string, fn func(context.Context, *GITTAR_REPO_STATS_Request) (*GittarStatsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_REPO_STATS_Request))
		}
		var GITTAR_REPO_STATS_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_REPO_STATS_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_REPO_STATS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_REPO_STATS_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_REPO_STATS_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_REPO_STATS_DEFAULT := func(method, path string, fn func(context.Context, *GITTAR_REPO_STATS_DEFAULT_Request) (*GittarStatsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_REPO_STATS_DEFAULT_Request))
		}
		var GITTAR_REPO_STATS_DEFAULT_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_REPO_STATS_DEFAULT_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_REPO_STATS_DEFAULT", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_REPO_STATS_DEFAULT_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_REPO_STATS_DEFAULT_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_TAG := func(method, path string, fn func(context.Context, *GITTAR_TAG_Request) (*GittarTagsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_TAG_Request))
		}
		var GITTAR_TAG_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_TAG_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TAG", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_TAG_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_TAG_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_TAG_CREATE := func(method, path string, fn func(context.Context, *GittarCreateTagRequest) (*GittarCreateTagResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GittarCreateTagRequest))
		}
		var GITTAR_TAG_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_TAG_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TAG_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_TAG_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in GittarCreateTagRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_TAG_DELETE := func(method, path string, fn func(context.Context, *GITTAR_TAG_DELETE_Request) (*GittarDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_TAG_DELETE_Request))
		}
		var GITTAR_TAG_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_TAG_DELETE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TAG_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_TAG_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_TAG_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_TREE := func(method, path string, fn func(context.Context, *GITTAR_TREE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GITTAR_TREE_Request))
		}
		var GITTAR_TREE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_TREE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TREE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_TREE_info)
				}
				r = r.WithContext(ctx)
				var in GITTAR_TREE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_TREE_SEARCH := func(method, path string, fn func(context.Context, *GittarTreeSearchRequest) (*GittarTreeSearchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GittarTreeSearchRequest))
		}
		var GITTAR_TREE_SEARCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			GITTAR_TREE_SEARCH_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TREE_SEARCH", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GITTAR_TREE_SEARCH_info)
				}
				r = r.WithContext(ctx)
				var in GittarTreeSearchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "org":
							in.Org = val
						case "repo":
							in.Repo = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_REPO_DELETE := func(method, path string, fn func(context.Context, *REPO_DELETE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*REPO_DELETE_Request))
		}
		var REPO_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			REPO_DELETE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "REPO_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, REPO_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in REPO_DELETE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_REPO_GET := func(method, path string, fn func(context.Context, *REPO_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*REPO_GET_Request))
		}
		var REPO_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			REPO_GET_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "REPO_GET", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, REPO_GET_info)
				}
				r = r.WithContext(ctx)
				var in REPO_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_REPO_POST := func(method, path string, fn func(context.Context, *REPO_POST_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*REPO_POST_Request))
		}
		var REPO_POST_info transport.ServiceInfo
		if h.Interceptor != nil {
			REPO_POST_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "REPO_POST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, REPO_POST_info)
				}
				r = r.WithContext(ctx)
				var in REPO_POST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_REPO_PUT := func(method, path string, fn func(context.Context, *REPO_PUT_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*REPO_PUT_Request))
		}
		var REPO_PUT_info transport.ServiceInfo
		if h.Interceptor != nil {
			REPO_PUT_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "REPO_PUT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, REPO_PUT_info)
				}
				r = r.WithContext(ctx)
				var in REPO_PUT_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GITTAR_ARCHIVE("GET", "/api/gittar/{org}/{repo}/archive/**", srv.GITTAR_ARCHIVE)
	add_GITTAR_BLAME("GET", "/api/gittar/{org}/{repo}/blame/**", srv.GITTAR_BLAME)
	add_GITTAR_BLOB("GET", "/api/gittar/{org}/{repo}/blob/**", srv.GITTAR_BLOB)
	add_GITTAR_BRANCH("GET", "/api/gittar/{org}/{repo}/branches", srv.GITTAR_BRANCH)
	add_GITTAR_BRANCH_CREATE("POST", "/api/gittar/{org}/{repo}/branches", srv.GITTAR_BRANCH_CREATE)
	add_GITTAR_BRANCH_DELETE("DELETE", "/api/gittar/{org}/{repo}/branches/**", srv.GITTAR_BRANCH_DELETE)
	add_GITTAR_CHECK_RUN_CREATE("POST", "/api/gittar/{org}/{repo}/check-runs", srv.GITTAR_CHECK_RUN_CREATE)
	add_GITTAR_CHECK_RUN_QUERY("GET", "/api/gittar/{org}/{repo}/check-runs", srv.GITTAR_CHECK_RUN_QUERY)
	add_GITTAR_COMMIT("GET", "/api/gittar/{org}/{repo}/commit/**", srv.GITTAR_COMMIT)
	add_GITTAR_COMMITS("GET", "/api/gittar/{org}/{repo}/commits/**", srv.GITTAR_COMMITS)
	add_GITTAR_COMMITS_CREATE("POST", "/api/gittar/{org}/{repo}/commits", srv.GITTAR_COMMITS_CREATE)
	add_GITTAR_COMPARE("GET", "/api/gittar/{org}/{repo}/compare/**", srv.GITTAR_COMPARE)
	add_GITTAR_MERGE_ACTION_POST("POST", "/api/gittar/{org}/{repo}/merge-requests/{id}/{action}", srv.GITTAR_MERGE_ACTION_POST)
	add_GITTAR_MERGE_ACTION_QUERY("GET", "/api/gittar/{org}/{repo}/merge-requests/{id}/{action}", srv.GITTAR_MERGE_ACTION_QUERY)
	add_GITTAR_MERGE_CREATE("POST", "/api/gittar/{org}/{repo}/merge-requests", srv.GITTAR_MERGE_CREATE)
	add_GITTAR_MERGE_GET("GET", "/api/gittar/{org}/{repo}/merge-requests/{id}", srv.GITTAR_MERGE_GET)
	add_GITTAR_MERGE_QUERY("GET", "/api/gittar/{org}/{repo}/merge-requests", srv.GITTAR_MERGE_QUERY)
	add_GITTAR_MERGE_STATS("GET", "/api/gittar/{org}/{repo}/merge-stats", srv.GITTAR_MERGE_STATS)
	add_GITTAR_MR_TEMPLATES("GET", "/api/gittar/{org}/{repo}/merge-templates", srv.GITTAR_MR_TEMPLATES)
	add_GITTAR_RAW("GET", "/api/gittar/{org}/{repo}/raw/**", srv.GITTAR_RAW)
	add_GITTAR_REPO_STATS("GET", "/api/gittar/{org}/{repo}/stats/**", srv.GITTAR_REPO_STATS)
	add_GITTAR_REPO_STATS_DEFAULT("GET", "/api/gittar/{org}/{repo}/stats", srv.GITTAR_REPO_STATS_DEFAULT)
	add_GITTAR_TAG("GET", "/api/gittar/{org}/{repo}/tags", srv.GITTAR_TAG)
	add_GITTAR_TAG_CREATE("POST", "/api/gittar/{org}/{repo}/tags", srv.GITTAR_TAG_CREATE)
	add_GITTAR_TAG_DELETE("DELETE", "/api/gittar/{org}/{repo}/tags/**", srv.GITTAR_TAG_DELETE)
	add_GITTAR_TREE("GET", "/api/gittar/{org}/{repo}/tree/**", srv.GITTAR_TREE)
	add_GITTAR_TREE_SEARCH("GET", "/api/gittar/{org}/{repo}/tree-search", srv.GITTAR_TREE_SEARCH)
	add_REPO_DELETE("DELETE", "/api/repo/**", srv.REPO_DELETE)
	add_REPO_GET("GET", "/api/repo/**", srv.REPO_GET)
	add_REPO_POST("POST", "/api/repo/**", srv.REPO_POST)
	add_REPO_PUT("PUT", "/api/repo/**", srv.REPO_PUT)
}
