// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: gittar.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*Branch)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CheckRun)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CheckRuns)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Commit)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateCheckRunResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteEvent)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Diff)(nil)
var _ urlenc.URLValuesUnmarshaler = (*EditActionItem)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_ARCHIVE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_BLAME_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_BLOB_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_BRANCH_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_BRANCH_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_COMMIT_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_COMPARE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_MERGE_ACTION_POST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_MERGE_ACTION_QUERY_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_MERGE_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_MR_TEMPLATES_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_RAW_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_REPO_STATS_DEFAULT_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_REPO_STATS_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_TAG_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_TAG_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GITTAR_TREE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarBlameResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarBlobData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarBlobResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarBranchesResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCommitResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCommitsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCommitsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCompareData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCompareResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCreateBranchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCreateBranchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCreateCommitRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCreateCommitResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCreateMergeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCreateMergeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCreateTagRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarCreateTagResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarDeleteBranchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarDiffData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarMergeStatusData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarMergeStatusRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarMergeStatusResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarMergeTemplatesResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarQueryMrDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarQueryMrRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarQueryMrResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarStatsData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarStatsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarTagsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarTreeSearchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarTreeSearchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MergeRequestInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MergeTemplatesResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryMergeRequestsData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*REPO_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*REPO_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*REPO_POST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*REPO_PUT_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Tag)(nil)

// Branch implement urlenc.URLValuesUnmarshaler.
func (m *Branch) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "name":
				m.Name = vals[0]
			case "commit":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Commit = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Commit = val
					} else {
						m.Commit = structpb.NewStringValue(vals[0])
					}
				}
			case "isDefault":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsDefault = val
			case "isProtect":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsProtect = val
			case "isMerged":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsMerged = val
			}
		}
	}
	return nil
}

// CheckRun implement urlenc.URLValuesUnmarshaler.
func (m *CheckRun) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "mrID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MrID = val
			case "type":
				m.Type = vals[0]
			case "externalID":
				m.ExternalID = vals[0]
			case "commit":
				m.Commit = vals[0]
			case "pipelineID":
				m.PipelineID = vals[0]
			case "status":
				m.Status = vals[0]
			case "result":
				m.Result = vals[0]
			case "output":
				m.Output = vals[0]
			case "completedAt":
				if m.CompletedAt == nil {
					m.CompletedAt = &timestamppb.Timestamp{}
				}
			case "completedAt.seconds":
				if m.CompletedAt == nil {
					m.CompletedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CompletedAt.Seconds = val
			case "completedAt.nanos":
				if m.CompletedAt == nil {
					m.CompletedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CompletedAt.Nanos = int32(val)
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "repoID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoID = val
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// CheckRuns implement urlenc.URLValuesUnmarshaler.
func (m *CheckRuns) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "result":
				m.Result = vals[0]
			case "mergable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Mergable = val
			}
		}
	}
	return nil
}

// Commit implement urlenc.URLValuesUnmarshaler.
func (m *Commit) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "author":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Author = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Author = val
					} else {
						m.Author = structpb.NewStringValue(vals[0])
					}
				}
			case "committer":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Committer = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Committer = val
					} else {
						m.Committer = structpb.NewStringValue(vals[0])
					}
				}
			case "commitMessage":
				m.CommitMessage = vals[0]
			case "parentSha":
				m.ParentSha = vals[0]
			}
		}
	}
	return nil
}

// CreateCheckRunResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateCheckRunResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// DeleteEvent implement urlenc.URLValuesUnmarshaler.
func (m *DeleteEvent) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "event":
				m.Event = vals[0]
			case "appName":
				m.AppName = vals[0]
			case "name":
				m.Name = vals[0]
			case "appID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// Diff implement urlenc.URLValuesUnmarshaler.
func (m *Diff) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "filesChanged":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FilesChanged = val
			case "totalAddition":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalAddition = val
			case "totalDeletion":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalDeletion = val
			case "isFinish":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsFinish = val
			}
		}
	}
	return nil
}

// EditActionItem implement urlenc.URLValuesUnmarshaler.
func (m *EditActionItem) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "action":
				m.Action = vals[0]
			case "content":
				m.Content = vals[0]
			case "path":
				m.Path = vals[0]
			case "pathType":
				m.PathType = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_ARCHIVE_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_ARCHIVE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_BLAME_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_BLAME_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_BLOB_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_BLOB_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_BRANCH_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_BRANCH_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_BRANCH_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_BRANCH_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_COMMIT_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_COMMIT_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_COMPARE_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_COMPARE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_MERGE_ACTION_POST_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_MERGE_ACTION_POST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			case "id":
				m.Id = vals[0]
			case "action":
				m.Action = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_MERGE_ACTION_QUERY_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_MERGE_ACTION_QUERY_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			case "id":
				m.Id = vals[0]
			case "action":
				m.Action = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_MERGE_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_MERGE_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_MR_TEMPLATES_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_MR_TEMPLATES_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_RAW_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_RAW_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_REPO_STATS_DEFAULT_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_REPO_STATS_DEFAULT_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_REPO_STATS_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_REPO_STATS_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_TAG_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_TAG_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_TAG_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_TAG_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GITTAR_TREE_Request implement urlenc.URLValuesUnmarshaler.
func (m *GITTAR_TREE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarBlameResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarBlameResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GittarBlobData implement urlenc.URLValuesUnmarshaler.
func (m *GittarBlobData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "binary":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Binary = val
			case "content":
				m.Content = vals[0]
			}
		}
	}
	return nil
}

// GittarBlobResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarBlobResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarBranchesResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarBranchesResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GittarCommitResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarCommitResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarCommitsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GittarCommitsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "search":
				m.Search = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarCommitsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarCommitsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GittarCompareData implement urlenc.URLValuesUnmarshaler.
func (m *GittarCompareData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "from":
				m.From = vals[0]
			case "to":
				m.To = vals[0]
			case "diff":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Diff = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Diff = val
					} else {
						m.Diff = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarCompareResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarCompareResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarCreateBranchRequest implement urlenc.URLValuesUnmarshaler.
func (m *GittarCreateBranchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "ref":
				m.Ref = vals[0]
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarCreateBranchResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarCreateBranchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GittarCreateCommitRequest implement urlenc.URLValuesUnmarshaler.
func (m *GittarCreateCommitRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "message":
				m.Message = vals[0]
			case "branch":
				m.Branch = vals[0]
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarCreateCommitResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarCreateCommitResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GittarCreateMergeRequest implement urlenc.URLValuesUnmarshaler.
func (m *GittarCreateMergeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "description":
				m.Description = vals[0]
			case "assigneeID":
				m.AssigneeID = vals[0]
			case "sourceBranch":
				m.SourceBranch = vals[0]
			case "targetBranch":
				m.TargetBranch = vals[0]
			case "removeSourceBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.RemoveSourceBranch = val
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarCreateMergeResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarCreateMergeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarCreateTagRequest implement urlenc.URLValuesUnmarshaler.
func (m *GittarCreateTagRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "message":
				m.Message = vals[0]
			case "ref":
				m.Ref = vals[0]
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarCreateTagResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarCreateTagResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GittarDeleteBranchResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarDeleteBranchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GittarDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarDiffData implement urlenc.URLValuesUnmarshaler.
func (m *GittarDiffData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "commit":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Commit = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Commit = val
					} else {
						m.Commit = structpb.NewStringValue(vals[0])
					}
				}
			case "diff":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Diff = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Diff = val
					} else {
						m.Diff = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarMergeStatusData implement urlenc.URLValuesUnmarshaler.
func (m *GittarMergeStatusData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "hasConflict":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.HasConflict = val
			case "isMerged":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsMerged = val
			case "hasError":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.HasError = val
			case "errorMsg":
				m.ErrorMsg = vals[0]
			}
		}
	}
	return nil
}

// GittarMergeStatusRequest implement urlenc.URLValuesUnmarshaler.
func (m *GittarMergeStatusRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "sourceBranch":
				m.SourceBranch = vals[0]
			case "targetBranch":
				m.TargetBranch = vals[0]
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarMergeStatusResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarMergeStatusResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarMergeTemplatesResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarMergeTemplatesResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarQueryMrDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarQueryMrDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarQueryMrRequest implement urlenc.URLValuesUnmarshaler.
func (m *GittarQueryMrRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "state":
				m.State = vals[0]
			case "query":
				m.Query = vals[0]
			case "authorId":
				m.AuthorId = vals[0]
			case "assigneeId":
				m.AssigneeId = vals[0]
			case "score":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Score = val
			case "page":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Page = val
			case "size":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Size = val
			case "targetBranch":
				m.TargetBranch = vals[0]
			case "sourceBranch":
				m.SourceBranch = vals[0]
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarQueryMrResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarQueryMrResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarStatsData implement urlenc.URLValuesUnmarshaler.
func (m *GittarStatsData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "commitsCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CommitsCount = val
			case "contributorCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ContributorCount = val
			case "tags":
				m.Tags = vals
			case "branches":
				m.Branches = vals
			case "defaultBranch":
				m.DefaultBranch = vals[0]
			case "empty":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Empty = val
			case "commitID":
				m.CommitID = vals[0]
			case "mergeRequestCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeRequestCount = val
			case "size":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Size = val
			case "readmeFile":
				m.ReadmeFile = vals[0]
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// GittarStatsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarStatsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GittarTagsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarTagsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GittarTreeSearchRequest implement urlenc.URLValuesUnmarshaler.
func (m *GittarTreeSearchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ref":
				m.Ref = vals[0]
			case "pattern":
				m.Pattern = vals[0]
			case "org":
				m.Org = vals[0]
			case "repo":
				m.Repo = vals[0]
			}
		}
	}
	return nil
}

// GittarTreeSearchResponse implement urlenc.URLValuesUnmarshaler.
func (m *GittarTreeSearchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// MergeRequestInfo implement urlenc.URLValuesUnmarshaler.
func (m *MergeRequestInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "repoMergeId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoMergeId = val
			case "appID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "repoID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoID = val
			case "title":
				m.Title = vals[0]
			case "authorId":
				m.AuthorId = vals[0]
			case "authorUser":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AuthorUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AuthorUser = val
					} else {
						m.AuthorUser = structpb.NewStringValue(vals[0])
					}
				}
			case "description":
				m.Description = vals[0]
			case "assigneeId":
				m.AssigneeId = vals[0]
			case "assigneeUser":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AssigneeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AssigneeUser = val
					} else {
						m.AssigneeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "mergeUserId":
				m.MergeUserId = vals[0]
			case "mergeUser":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.MergeUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.MergeUser = val
					} else {
						m.MergeUser = structpb.NewStringValue(vals[0])
					}
				}
			case "closeUserId":
				m.CloseUserId = vals[0]
			case "closeUser":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.CloseUser = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.CloseUser = val
					} else {
						m.CloseUser = structpb.NewStringValue(vals[0])
					}
				}
			case "sourceBranch":
				m.SourceBranch = vals[0]
			case "targetBranch":
				m.TargetBranch = vals[0]
			case "sourceSha":
				m.SourceSha = vals[0]
			case "targetSha":
				m.TargetSha = vals[0]
			case "removeSourceBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.RemoveSourceBranch = val
			case "state":
				m.State = vals[0]
			case "isCheckRunValid":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsCheckRunValid = val
			case "targetBranchRule":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.TargetBranchRule = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.TargetBranchRule = val
					} else {
						m.TargetBranchRule = structpb.NewStringValue(vals[0])
					}
				}
			case "defaultCommitMessage":
				m.DefaultCommitMessage = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "closeAt":
				if m.CloseAt == nil {
					m.CloseAt = &timestamppb.Timestamp{}
				}
			case "closeAt.seconds":
				if m.CloseAt == nil {
					m.CloseAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CloseAt.Seconds = val
			case "closeAt.nanos":
				if m.CloseAt == nil {
					m.CloseAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CloseAt.Nanos = int32(val)
			case "mergeAt":
				if m.MergeAt == nil {
					m.MergeAt = &timestamppb.Timestamp{}
				}
			case "mergeAt.seconds":
				if m.MergeAt == nil {
					m.MergeAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeAt.Seconds = val
			case "mergeAt.nanos":
				if m.MergeAt == nil {
					m.MergeAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.MergeAt.Nanos = int32(val)
			case "link":
				m.Link = vals[0]
			case "score":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Score = val
			case "scoreNum":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScoreNum = val
			case "rebaseBranch":
				m.RebaseBranch = vals[0]
			case "eventName":
				m.EventName = vals[0]
			case "checkRuns":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.CheckRuns = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.CheckRuns = val
					} else {
						m.CheckRuns = structpb.NewStringValue(vals[0])
					}
				}
			case "joinTempBranchStatus":
				m.JoinTempBranchStatus = vals[0]
			case "isJoinTempBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsJoinTempBranch = val
			}
		}
	}
	return nil
}

// MergeTemplatesResponseData implement urlenc.URLValuesUnmarshaler.
func (m *MergeTemplatesResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "branch":
				m.Branch = vals[0]
			case "path":
				m.Path = vals[0]
			case "names":
				m.Names = vals
			}
		}
	}
	return nil
}

// QueryMergeRequestsData implement urlenc.URLValuesUnmarshaler.
func (m *QueryMergeRequestsData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// REPO_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *REPO_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// REPO_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *REPO_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// REPO_POST_Request implement urlenc.URLValuesUnmarshaler.
func (m *REPO_POST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// REPO_PUT_Request implement urlenc.URLValuesUnmarshaler.
func (m *REPO_PUT_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// Tag implement urlenc.URLValuesUnmarshaler.
func (m *Tag) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "ID":
				m.ID = vals[0]
			case "object":
				m.Object = vals[0]
			case "tagger":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Tagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Tagger = val
					} else {
						m.Tagger = structpb.NewStringValue(vals[0])
					}
				}
			case "message":
				m.Message = vals[0]
			}
		}
	}
	return nil
}
