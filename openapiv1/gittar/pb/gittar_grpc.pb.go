// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// Source: gittar.proto

package pb

import (
	context "context"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	grpc1 "github.com/erda-project/erda-infra/pkg/transport/grpc"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion5

// GittarClient is the client API for Gittar service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GittarClient interface {
	GITTAR_ARCHIVE(ctx context.Context, in *GITTAR_ARCHIVE_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GITTAR_BLAME(ctx context.Context, in *GITTAR_BLAME_Request, opts ...grpc.CallOption) (*GittarBlameResponse, error)
	GITTAR_BLOB(ctx context.Context, in *GITTAR_BLOB_Request, opts ...grpc.CallOption) (*GittarBlobResponse, error)
	GITTAR_BRANCH(ctx context.Context, in *GITTAR_BRANCH_Request, opts ...grpc.CallOption) (*GittarBranchesResponse, error)
	GITTAR_BRANCH_CREATE(ctx context.Context, in *GittarCreateBranchRequest, opts ...grpc.CallOption) (*GittarCreateBranchResponse, error)
	GITTAR_BRANCH_DELETE(ctx context.Context, in *GITTAR_BRANCH_DELETE_Request, opts ...grpc.CallOption) (*GittarDeleteBranchResponse, error)
	GITTAR_CHECK_RUN_CREATE(ctx context.Context, in *CheckRun, opts ...grpc.CallOption) (*CreateCheckRunResponse, error)
	GITTAR_CHECK_RUN_QUERY(ctx context.Context, in *CheckRun, opts ...grpc.CallOption) (*CreateCheckRunResponse, error)
	GITTAR_COMMIT(ctx context.Context, in *GITTAR_COMMIT_Request, opts ...grpc.CallOption) (*GittarCommitResponse, error)
	GITTAR_COMMITS(ctx context.Context, in *GittarCommitsRequest, opts ...grpc.CallOption) (*GittarCommitsResponse, error)
	GITTAR_COMMITS_CREATE(ctx context.Context, in *GittarCreateCommitRequest, opts ...grpc.CallOption) (*GittarCreateCommitResponse, error)
	GITTAR_COMPARE(ctx context.Context, in *GITTAR_COMPARE_Request, opts ...grpc.CallOption) (*GittarCompareResponse, error)
	GITTAR_MERGE_ACTION_POST(ctx context.Context, in *GITTAR_MERGE_ACTION_POST_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GITTAR_MERGE_ACTION_QUERY(ctx context.Context, in *GITTAR_MERGE_ACTION_QUERY_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GITTAR_MERGE_CREATE(ctx context.Context, in *GittarCreateMergeRequest, opts ...grpc.CallOption) (*GittarCreateMergeResponse, error)
	GITTAR_MERGE_GET(ctx context.Context, in *GITTAR_MERGE_GET_Request, opts ...grpc.CallOption) (*GittarQueryMrDetailResponse, error)
	GITTAR_MERGE_QUERY(ctx context.Context, in *GittarQueryMrRequest, opts ...grpc.CallOption) (*GittarQueryMrResponse, error)
	GITTAR_MERGE_STATS(ctx context.Context, in *GittarMergeStatusRequest, opts ...grpc.CallOption) (*GittarMergeStatusResponse, error)
	GITTAR_MR_TEMPLATES(ctx context.Context, in *GITTAR_MR_TEMPLATES_Request, opts ...grpc.CallOption) (*GittarMergeTemplatesResponse, error)
	GITTAR_RAW(ctx context.Context, in *GITTAR_RAW_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GITTAR_REPO_STATS(ctx context.Context, in *GITTAR_REPO_STATS_Request, opts ...grpc.CallOption) (*GittarStatsResponse, error)
	GITTAR_REPO_STATS_DEFAULT(ctx context.Context, in *GITTAR_REPO_STATS_DEFAULT_Request, opts ...grpc.CallOption) (*GittarStatsResponse, error)
	GITTAR_TAG(ctx context.Context, in *GITTAR_TAG_Request, opts ...grpc.CallOption) (*GittarTagsResponse, error)
	GITTAR_TAG_CREATE(ctx context.Context, in *GittarCreateTagRequest, opts ...grpc.CallOption) (*GittarCreateTagResponse, error)
	GITTAR_TAG_DELETE(ctx context.Context, in *GITTAR_TAG_DELETE_Request, opts ...grpc.CallOption) (*GittarDeleteResponse, error)
	GITTAR_TREE(ctx context.Context, in *GITTAR_TREE_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GITTAR_TREE_SEARCH(ctx context.Context, in *GittarTreeSearchRequest, opts ...grpc.CallOption) (*GittarTreeSearchResponse, error)
	REPO_DELETE(ctx context.Context, in *REPO_DELETE_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	REPO_GET(ctx context.Context, in *REPO_GET_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	REPO_POST(ctx context.Context, in *REPO_POST_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
	REPO_PUT(ctx context.Context, in *REPO_PUT_Request, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type gittarClient struct {
	cc grpc1.ClientConnInterface
}

func NewGittarClient(cc grpc1.ClientConnInterface) GittarClient {
	return &gittarClient{cc}
}

func (c *gittarClient) GITTAR_ARCHIVE(ctx context.Context, in *GITTAR_ARCHIVE_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_ARCHIVE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_BLAME(ctx context.Context, in *GITTAR_BLAME_Request, opts ...grpc.CallOption) (*GittarBlameResponse, error) {
	out := new(GittarBlameResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_BLAME", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_BLOB(ctx context.Context, in *GITTAR_BLOB_Request, opts ...grpc.CallOption) (*GittarBlobResponse, error) {
	out := new(GittarBlobResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_BLOB", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_BRANCH(ctx context.Context, in *GITTAR_BRANCH_Request, opts ...grpc.CallOption) (*GittarBranchesResponse, error) {
	out := new(GittarBranchesResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_BRANCH", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_BRANCH_CREATE(ctx context.Context, in *GittarCreateBranchRequest, opts ...grpc.CallOption) (*GittarCreateBranchResponse, error) {
	out := new(GittarCreateBranchResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_BRANCH_CREATE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_BRANCH_DELETE(ctx context.Context, in *GITTAR_BRANCH_DELETE_Request, opts ...grpc.CallOption) (*GittarDeleteBranchResponse, error) {
	out := new(GittarDeleteBranchResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_BRANCH_DELETE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_CHECK_RUN_CREATE(ctx context.Context, in *CheckRun, opts ...grpc.CallOption) (*CreateCheckRunResponse, error) {
	out := new(CreateCheckRunResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_CHECK_RUN_CREATE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_CHECK_RUN_QUERY(ctx context.Context, in *CheckRun, opts ...grpc.CallOption) (*CreateCheckRunResponse, error) {
	out := new(CreateCheckRunResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_CHECK_RUN_QUERY", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_COMMIT(ctx context.Context, in *GITTAR_COMMIT_Request, opts ...grpc.CallOption) (*GittarCommitResponse, error) {
	out := new(GittarCommitResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_COMMIT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_COMMITS(ctx context.Context, in *GittarCommitsRequest, opts ...grpc.CallOption) (*GittarCommitsResponse, error) {
	out := new(GittarCommitsResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_COMMITS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_COMMITS_CREATE(ctx context.Context, in *GittarCreateCommitRequest, opts ...grpc.CallOption) (*GittarCreateCommitResponse, error) {
	out := new(GittarCreateCommitResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_COMMITS_CREATE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_COMPARE(ctx context.Context, in *GITTAR_COMPARE_Request, opts ...grpc.CallOption) (*GittarCompareResponse, error) {
	out := new(GittarCompareResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_COMPARE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_MERGE_ACTION_POST(ctx context.Context, in *GITTAR_MERGE_ACTION_POST_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_ACTION_POST", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_MERGE_ACTION_QUERY(ctx context.Context, in *GITTAR_MERGE_ACTION_QUERY_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_ACTION_QUERY", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_MERGE_CREATE(ctx context.Context, in *GittarCreateMergeRequest, opts ...grpc.CallOption) (*GittarCreateMergeResponse, error) {
	out := new(GittarCreateMergeResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_CREATE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_MERGE_GET(ctx context.Context, in *GITTAR_MERGE_GET_Request, opts ...grpc.CallOption) (*GittarQueryMrDetailResponse, error) {
	out := new(GittarQueryMrDetailResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_GET", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_MERGE_QUERY(ctx context.Context, in *GittarQueryMrRequest, opts ...grpc.CallOption) (*GittarQueryMrResponse, error) {
	out := new(GittarQueryMrResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_QUERY", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_MERGE_STATS(ctx context.Context, in *GittarMergeStatusRequest, opts ...grpc.CallOption) (*GittarMergeStatusResponse, error) {
	out := new(GittarMergeStatusResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_STATS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_MR_TEMPLATES(ctx context.Context, in *GITTAR_MR_TEMPLATES_Request, opts ...grpc.CallOption) (*GittarMergeTemplatesResponse, error) {
	out := new(GittarMergeTemplatesResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_MR_TEMPLATES", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_RAW(ctx context.Context, in *GITTAR_RAW_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_RAW", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_REPO_STATS(ctx context.Context, in *GITTAR_REPO_STATS_Request, opts ...grpc.CallOption) (*GittarStatsResponse, error) {
	out := new(GittarStatsResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_REPO_STATS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_REPO_STATS_DEFAULT(ctx context.Context, in *GITTAR_REPO_STATS_DEFAULT_Request, opts ...grpc.CallOption) (*GittarStatsResponse, error) {
	out := new(GittarStatsResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_REPO_STATS_DEFAULT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_TAG(ctx context.Context, in *GITTAR_TAG_Request, opts ...grpc.CallOption) (*GittarTagsResponse, error) {
	out := new(GittarTagsResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_TAG", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_TAG_CREATE(ctx context.Context, in *GittarCreateTagRequest, opts ...grpc.CallOption) (*GittarCreateTagResponse, error) {
	out := new(GittarCreateTagResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_TAG_CREATE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_TAG_DELETE(ctx context.Context, in *GITTAR_TAG_DELETE_Request, opts ...grpc.CallOption) (*GittarDeleteResponse, error) {
	out := new(GittarDeleteResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_TAG_DELETE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_TREE(ctx context.Context, in *GITTAR_TREE_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_TREE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) GITTAR_TREE_SEARCH(ctx context.Context, in *GittarTreeSearchRequest, opts ...grpc.CallOption) (*GittarTreeSearchResponse, error) {
	out := new(GittarTreeSearchResponse)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/GITTAR_TREE_SEARCH", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) REPO_DELETE(ctx context.Context, in *REPO_DELETE_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/REPO_DELETE", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) REPO_GET(ctx context.Context, in *REPO_GET_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/REPO_GET", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) REPO_POST(ctx context.Context, in *REPO_POST_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/REPO_POST", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gittarClient) REPO_PUT(ctx context.Context, in *REPO_PUT_Request, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/erda.openapiv1.gittar.gittar/REPO_PUT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GittarServer is the server API for Gittar service.
// All implementations should embed UnimplementedGittarServer
// for forward compatibility
type GittarServer interface {
	GITTAR_ARCHIVE(context.Context, *GITTAR_ARCHIVE_Request) (*emptypb.Empty, error)
	GITTAR_BLAME(context.Context, *GITTAR_BLAME_Request) (*GittarBlameResponse, error)
	GITTAR_BLOB(context.Context, *GITTAR_BLOB_Request) (*GittarBlobResponse, error)
	GITTAR_BRANCH(context.Context, *GITTAR_BRANCH_Request) (*GittarBranchesResponse, error)
	GITTAR_BRANCH_CREATE(context.Context, *GittarCreateBranchRequest) (*GittarCreateBranchResponse, error)
	GITTAR_BRANCH_DELETE(context.Context, *GITTAR_BRANCH_DELETE_Request) (*GittarDeleteBranchResponse, error)
	GITTAR_CHECK_RUN_CREATE(context.Context, *CheckRun) (*CreateCheckRunResponse, error)
	GITTAR_CHECK_RUN_QUERY(context.Context, *CheckRun) (*CreateCheckRunResponse, error)
	GITTAR_COMMIT(context.Context, *GITTAR_COMMIT_Request) (*GittarCommitResponse, error)
	GITTAR_COMMITS(context.Context, *GittarCommitsRequest) (*GittarCommitsResponse, error)
	GITTAR_COMMITS_CREATE(context.Context, *GittarCreateCommitRequest) (*GittarCreateCommitResponse, error)
	GITTAR_COMPARE(context.Context, *GITTAR_COMPARE_Request) (*GittarCompareResponse, error)
	GITTAR_MERGE_ACTION_POST(context.Context, *GITTAR_MERGE_ACTION_POST_Request) (*emptypb.Empty, error)
	GITTAR_MERGE_ACTION_QUERY(context.Context, *GITTAR_MERGE_ACTION_QUERY_Request) (*emptypb.Empty, error)
	GITTAR_MERGE_CREATE(context.Context, *GittarCreateMergeRequest) (*GittarCreateMergeResponse, error)
	GITTAR_MERGE_GET(context.Context, *GITTAR_MERGE_GET_Request) (*GittarQueryMrDetailResponse, error)
	GITTAR_MERGE_QUERY(context.Context, *GittarQueryMrRequest) (*GittarQueryMrResponse, error)
	GITTAR_MERGE_STATS(context.Context, *GittarMergeStatusRequest) (*GittarMergeStatusResponse, error)
	GITTAR_MR_TEMPLATES(context.Context, *GITTAR_MR_TEMPLATES_Request) (*GittarMergeTemplatesResponse, error)
	GITTAR_RAW(context.Context, *GITTAR_RAW_Request) (*emptypb.Empty, error)
	GITTAR_REPO_STATS(context.Context, *GITTAR_REPO_STATS_Request) (*GittarStatsResponse, error)
	GITTAR_REPO_STATS_DEFAULT(context.Context, *GITTAR_REPO_STATS_DEFAULT_Request) (*GittarStatsResponse, error)
	GITTAR_TAG(context.Context, *GITTAR_TAG_Request) (*GittarTagsResponse, error)
	GITTAR_TAG_CREATE(context.Context, *GittarCreateTagRequest) (*GittarCreateTagResponse, error)
	GITTAR_TAG_DELETE(context.Context, *GITTAR_TAG_DELETE_Request) (*GittarDeleteResponse, error)
	GITTAR_TREE(context.Context, *GITTAR_TREE_Request) (*emptypb.Empty, error)
	GITTAR_TREE_SEARCH(context.Context, *GittarTreeSearchRequest) (*GittarTreeSearchResponse, error)
	REPO_DELETE(context.Context, *REPO_DELETE_Request) (*emptypb.Empty, error)
	REPO_GET(context.Context, *REPO_GET_Request) (*emptypb.Empty, error)
	REPO_POST(context.Context, *REPO_POST_Request) (*emptypb.Empty, error)
	REPO_PUT(context.Context, *REPO_PUT_Request) (*emptypb.Empty, error)
}

// UnimplementedGittarServer should be embedded to have forward compatible implementations.
type UnimplementedGittarServer struct {
}

func (*UnimplementedGittarServer) GITTAR_ARCHIVE(context.Context, *GITTAR_ARCHIVE_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_ARCHIVE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_BLAME(context.Context, *GITTAR_BLAME_Request) (*GittarBlameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_BLAME not implemented")
}
func (*UnimplementedGittarServer) GITTAR_BLOB(context.Context, *GITTAR_BLOB_Request) (*GittarBlobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_BLOB not implemented")
}
func (*UnimplementedGittarServer) GITTAR_BRANCH(context.Context, *GITTAR_BRANCH_Request) (*GittarBranchesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_BRANCH not implemented")
}
func (*UnimplementedGittarServer) GITTAR_BRANCH_CREATE(context.Context, *GittarCreateBranchRequest) (*GittarCreateBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_BRANCH_CREATE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_BRANCH_DELETE(context.Context, *GITTAR_BRANCH_DELETE_Request) (*GittarDeleteBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_BRANCH_DELETE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_CHECK_RUN_CREATE(context.Context, *CheckRun) (*CreateCheckRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_CHECK_RUN_CREATE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_CHECK_RUN_QUERY(context.Context, *CheckRun) (*CreateCheckRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_CHECK_RUN_QUERY not implemented")
}
func (*UnimplementedGittarServer) GITTAR_COMMIT(context.Context, *GITTAR_COMMIT_Request) (*GittarCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_COMMIT not implemented")
}
func (*UnimplementedGittarServer) GITTAR_COMMITS(context.Context, *GittarCommitsRequest) (*GittarCommitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_COMMITS not implemented")
}
func (*UnimplementedGittarServer) GITTAR_COMMITS_CREATE(context.Context, *GittarCreateCommitRequest) (*GittarCreateCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_COMMITS_CREATE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_COMPARE(context.Context, *GITTAR_COMPARE_Request) (*GittarCompareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_COMPARE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_MERGE_ACTION_POST(context.Context, *GITTAR_MERGE_ACTION_POST_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_MERGE_ACTION_POST not implemented")
}
func (*UnimplementedGittarServer) GITTAR_MERGE_ACTION_QUERY(context.Context, *GITTAR_MERGE_ACTION_QUERY_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_MERGE_ACTION_QUERY not implemented")
}
func (*UnimplementedGittarServer) GITTAR_MERGE_CREATE(context.Context, *GittarCreateMergeRequest) (*GittarCreateMergeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_MERGE_CREATE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_MERGE_GET(context.Context, *GITTAR_MERGE_GET_Request) (*GittarQueryMrDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_MERGE_GET not implemented")
}
func (*UnimplementedGittarServer) GITTAR_MERGE_QUERY(context.Context, *GittarQueryMrRequest) (*GittarQueryMrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_MERGE_QUERY not implemented")
}
func (*UnimplementedGittarServer) GITTAR_MERGE_STATS(context.Context, *GittarMergeStatusRequest) (*GittarMergeStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_MERGE_STATS not implemented")
}
func (*UnimplementedGittarServer) GITTAR_MR_TEMPLATES(context.Context, *GITTAR_MR_TEMPLATES_Request) (*GittarMergeTemplatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_MR_TEMPLATES not implemented")
}
func (*UnimplementedGittarServer) GITTAR_RAW(context.Context, *GITTAR_RAW_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_RAW not implemented")
}
func (*UnimplementedGittarServer) GITTAR_REPO_STATS(context.Context, *GITTAR_REPO_STATS_Request) (*GittarStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_REPO_STATS not implemented")
}
func (*UnimplementedGittarServer) GITTAR_REPO_STATS_DEFAULT(context.Context, *GITTAR_REPO_STATS_DEFAULT_Request) (*GittarStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_REPO_STATS_DEFAULT not implemented")
}
func (*UnimplementedGittarServer) GITTAR_TAG(context.Context, *GITTAR_TAG_Request) (*GittarTagsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_TAG not implemented")
}
func (*UnimplementedGittarServer) GITTAR_TAG_CREATE(context.Context, *GittarCreateTagRequest) (*GittarCreateTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_TAG_CREATE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_TAG_DELETE(context.Context, *GITTAR_TAG_DELETE_Request) (*GittarDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_TAG_DELETE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_TREE(context.Context, *GITTAR_TREE_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_TREE not implemented")
}
func (*UnimplementedGittarServer) GITTAR_TREE_SEARCH(context.Context, *GittarTreeSearchRequest) (*GittarTreeSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GITTAR_TREE_SEARCH not implemented")
}
func (*UnimplementedGittarServer) REPO_DELETE(context.Context, *REPO_DELETE_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method REPO_DELETE not implemented")
}
func (*UnimplementedGittarServer) REPO_GET(context.Context, *REPO_GET_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method REPO_GET not implemented")
}
func (*UnimplementedGittarServer) REPO_POST(context.Context, *REPO_POST_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method REPO_POST not implemented")
}
func (*UnimplementedGittarServer) REPO_PUT(context.Context, *REPO_PUT_Request) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method REPO_PUT not implemented")
}

func RegisterGittarServer(s grpc1.ServiceRegistrar, srv GittarServer, opts ...grpc1.HandleOption) {
	s.RegisterService(_get_Gittar_serviceDesc(srv, opts...), srv)
}

var _Gittar_serviceDesc = grpc.ServiceDesc{
	ServiceName: "erda.openapiv1.gittar.gittar",
	HandlerType: (*GittarServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "gittar.proto",
}

func _get_Gittar_serviceDesc(srv GittarServer, opts ...grpc1.HandleOption) *grpc.ServiceDesc {
	h := grpc1.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}

	_Gittar_GITTAR_ARCHIVE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_ARCHIVE(ctx, req.(*GITTAR_ARCHIVE_Request))
	}
	var _Gittar_GITTAR_ARCHIVE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_ARCHIVE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_ARCHIVE", srv)
		_Gittar_GITTAR_ARCHIVE_Handler = h.Interceptor(_Gittar_GITTAR_ARCHIVE_Handler)
	}

	_Gittar_GITTAR_BLAME_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_BLAME(ctx, req.(*GITTAR_BLAME_Request))
	}
	var _Gittar_GITTAR_BLAME_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_BLAME_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BLAME", srv)
		_Gittar_GITTAR_BLAME_Handler = h.Interceptor(_Gittar_GITTAR_BLAME_Handler)
	}

	_Gittar_GITTAR_BLOB_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_BLOB(ctx, req.(*GITTAR_BLOB_Request))
	}
	var _Gittar_GITTAR_BLOB_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_BLOB_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BLOB", srv)
		_Gittar_GITTAR_BLOB_Handler = h.Interceptor(_Gittar_GITTAR_BLOB_Handler)
	}

	_Gittar_GITTAR_BRANCH_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_BRANCH(ctx, req.(*GITTAR_BRANCH_Request))
	}
	var _Gittar_GITTAR_BRANCH_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_BRANCH_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BRANCH", srv)
		_Gittar_GITTAR_BRANCH_Handler = h.Interceptor(_Gittar_GITTAR_BRANCH_Handler)
	}

	_Gittar_GITTAR_BRANCH_CREATE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_BRANCH_CREATE(ctx, req.(*GittarCreateBranchRequest))
	}
	var _Gittar_GITTAR_BRANCH_CREATE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_BRANCH_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BRANCH_CREATE", srv)
		_Gittar_GITTAR_BRANCH_CREATE_Handler = h.Interceptor(_Gittar_GITTAR_BRANCH_CREATE_Handler)
	}

	_Gittar_GITTAR_BRANCH_DELETE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_BRANCH_DELETE(ctx, req.(*GITTAR_BRANCH_DELETE_Request))
	}
	var _Gittar_GITTAR_BRANCH_DELETE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_BRANCH_DELETE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_BRANCH_DELETE", srv)
		_Gittar_GITTAR_BRANCH_DELETE_Handler = h.Interceptor(_Gittar_GITTAR_BRANCH_DELETE_Handler)
	}

	_Gittar_GITTAR_CHECK_RUN_CREATE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_CHECK_RUN_CREATE(ctx, req.(*CheckRun))
	}
	var _Gittar_GITTAR_CHECK_RUN_CREATE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_CHECK_RUN_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_CHECK_RUN_CREATE", srv)
		_Gittar_GITTAR_CHECK_RUN_CREATE_Handler = h.Interceptor(_Gittar_GITTAR_CHECK_RUN_CREATE_Handler)
	}

	_Gittar_GITTAR_CHECK_RUN_QUERY_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_CHECK_RUN_QUERY(ctx, req.(*CheckRun))
	}
	var _Gittar_GITTAR_CHECK_RUN_QUERY_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_CHECK_RUN_QUERY_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_CHECK_RUN_QUERY", srv)
		_Gittar_GITTAR_CHECK_RUN_QUERY_Handler = h.Interceptor(_Gittar_GITTAR_CHECK_RUN_QUERY_Handler)
	}

	_Gittar_GITTAR_COMMIT_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_COMMIT(ctx, req.(*GITTAR_COMMIT_Request))
	}
	var _Gittar_GITTAR_COMMIT_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_COMMIT_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_COMMIT", srv)
		_Gittar_GITTAR_COMMIT_Handler = h.Interceptor(_Gittar_GITTAR_COMMIT_Handler)
	}

	_Gittar_GITTAR_COMMITS_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_COMMITS(ctx, req.(*GittarCommitsRequest))
	}
	var _Gittar_GITTAR_COMMITS_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_COMMITS_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_COMMITS", srv)
		_Gittar_GITTAR_COMMITS_Handler = h.Interceptor(_Gittar_GITTAR_COMMITS_Handler)
	}

	_Gittar_GITTAR_COMMITS_CREATE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_COMMITS_CREATE(ctx, req.(*GittarCreateCommitRequest))
	}
	var _Gittar_GITTAR_COMMITS_CREATE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_COMMITS_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_COMMITS_CREATE", srv)
		_Gittar_GITTAR_COMMITS_CREATE_Handler = h.Interceptor(_Gittar_GITTAR_COMMITS_CREATE_Handler)
	}

	_Gittar_GITTAR_COMPARE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_COMPARE(ctx, req.(*GITTAR_COMPARE_Request))
	}
	var _Gittar_GITTAR_COMPARE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_COMPARE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_COMPARE", srv)
		_Gittar_GITTAR_COMPARE_Handler = h.Interceptor(_Gittar_GITTAR_COMPARE_Handler)
	}

	_Gittar_GITTAR_MERGE_ACTION_POST_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_MERGE_ACTION_POST(ctx, req.(*GITTAR_MERGE_ACTION_POST_Request))
	}
	var _Gittar_GITTAR_MERGE_ACTION_POST_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_MERGE_ACTION_POST_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_ACTION_POST", srv)
		_Gittar_GITTAR_MERGE_ACTION_POST_Handler = h.Interceptor(_Gittar_GITTAR_MERGE_ACTION_POST_Handler)
	}

	_Gittar_GITTAR_MERGE_ACTION_QUERY_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_MERGE_ACTION_QUERY(ctx, req.(*GITTAR_MERGE_ACTION_QUERY_Request))
	}
	var _Gittar_GITTAR_MERGE_ACTION_QUERY_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_MERGE_ACTION_QUERY_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_ACTION_QUERY", srv)
		_Gittar_GITTAR_MERGE_ACTION_QUERY_Handler = h.Interceptor(_Gittar_GITTAR_MERGE_ACTION_QUERY_Handler)
	}

	_Gittar_GITTAR_MERGE_CREATE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_MERGE_CREATE(ctx, req.(*GittarCreateMergeRequest))
	}
	var _Gittar_GITTAR_MERGE_CREATE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_MERGE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_CREATE", srv)
		_Gittar_GITTAR_MERGE_CREATE_Handler = h.Interceptor(_Gittar_GITTAR_MERGE_CREATE_Handler)
	}

	_Gittar_GITTAR_MERGE_GET_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_MERGE_GET(ctx, req.(*GITTAR_MERGE_GET_Request))
	}
	var _Gittar_GITTAR_MERGE_GET_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_MERGE_GET_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_GET", srv)
		_Gittar_GITTAR_MERGE_GET_Handler = h.Interceptor(_Gittar_GITTAR_MERGE_GET_Handler)
	}

	_Gittar_GITTAR_MERGE_QUERY_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_MERGE_QUERY(ctx, req.(*GittarQueryMrRequest))
	}
	var _Gittar_GITTAR_MERGE_QUERY_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_MERGE_QUERY_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_QUERY", srv)
		_Gittar_GITTAR_MERGE_QUERY_Handler = h.Interceptor(_Gittar_GITTAR_MERGE_QUERY_Handler)
	}

	_Gittar_GITTAR_MERGE_STATS_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_MERGE_STATS(ctx, req.(*GittarMergeStatusRequest))
	}
	var _Gittar_GITTAR_MERGE_STATS_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_MERGE_STATS_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MERGE_STATS", srv)
		_Gittar_GITTAR_MERGE_STATS_Handler = h.Interceptor(_Gittar_GITTAR_MERGE_STATS_Handler)
	}

	_Gittar_GITTAR_MR_TEMPLATES_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_MR_TEMPLATES(ctx, req.(*GITTAR_MR_TEMPLATES_Request))
	}
	var _Gittar_GITTAR_MR_TEMPLATES_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_MR_TEMPLATES_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_MR_TEMPLATES", srv)
		_Gittar_GITTAR_MR_TEMPLATES_Handler = h.Interceptor(_Gittar_GITTAR_MR_TEMPLATES_Handler)
	}

	_Gittar_GITTAR_RAW_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_RAW(ctx, req.(*GITTAR_RAW_Request))
	}
	var _Gittar_GITTAR_RAW_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_RAW_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_RAW", srv)
		_Gittar_GITTAR_RAW_Handler = h.Interceptor(_Gittar_GITTAR_RAW_Handler)
	}

	_Gittar_GITTAR_REPO_STATS_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_REPO_STATS(ctx, req.(*GITTAR_REPO_STATS_Request))
	}
	var _Gittar_GITTAR_REPO_STATS_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_REPO_STATS_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_REPO_STATS", srv)
		_Gittar_GITTAR_REPO_STATS_Handler = h.Interceptor(_Gittar_GITTAR_REPO_STATS_Handler)
	}

	_Gittar_GITTAR_REPO_STATS_DEFAULT_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_REPO_STATS_DEFAULT(ctx, req.(*GITTAR_REPO_STATS_DEFAULT_Request))
	}
	var _Gittar_GITTAR_REPO_STATS_DEFAULT_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_REPO_STATS_DEFAULT_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_REPO_STATS_DEFAULT", srv)
		_Gittar_GITTAR_REPO_STATS_DEFAULT_Handler = h.Interceptor(_Gittar_GITTAR_REPO_STATS_DEFAULT_Handler)
	}

	_Gittar_GITTAR_TAG_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_TAG(ctx, req.(*GITTAR_TAG_Request))
	}
	var _Gittar_GITTAR_TAG_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_TAG_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TAG", srv)
		_Gittar_GITTAR_TAG_Handler = h.Interceptor(_Gittar_GITTAR_TAG_Handler)
	}

	_Gittar_GITTAR_TAG_CREATE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_TAG_CREATE(ctx, req.(*GittarCreateTagRequest))
	}
	var _Gittar_GITTAR_TAG_CREATE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_TAG_CREATE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TAG_CREATE", srv)
		_Gittar_GITTAR_TAG_CREATE_Handler = h.Interceptor(_Gittar_GITTAR_TAG_CREATE_Handler)
	}

	_Gittar_GITTAR_TAG_DELETE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_TAG_DELETE(ctx, req.(*GITTAR_TAG_DELETE_Request))
	}
	var _Gittar_GITTAR_TAG_DELETE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_TAG_DELETE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TAG_DELETE", srv)
		_Gittar_GITTAR_TAG_DELETE_Handler = h.Interceptor(_Gittar_GITTAR_TAG_DELETE_Handler)
	}

	_Gittar_GITTAR_TREE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_TREE(ctx, req.(*GITTAR_TREE_Request))
	}
	var _Gittar_GITTAR_TREE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_TREE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TREE", srv)
		_Gittar_GITTAR_TREE_Handler = h.Interceptor(_Gittar_GITTAR_TREE_Handler)
	}

	_Gittar_GITTAR_TREE_SEARCH_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.GITTAR_TREE_SEARCH(ctx, req.(*GittarTreeSearchRequest))
	}
	var _Gittar_GITTAR_TREE_SEARCH_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_GITTAR_TREE_SEARCH_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "GITTAR_TREE_SEARCH", srv)
		_Gittar_GITTAR_TREE_SEARCH_Handler = h.Interceptor(_Gittar_GITTAR_TREE_SEARCH_Handler)
	}

	_Gittar_REPO_DELETE_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.REPO_DELETE(ctx, req.(*REPO_DELETE_Request))
	}
	var _Gittar_REPO_DELETE_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_REPO_DELETE_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "REPO_DELETE", srv)
		_Gittar_REPO_DELETE_Handler = h.Interceptor(_Gittar_REPO_DELETE_Handler)
	}

	_Gittar_REPO_GET_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.REPO_GET(ctx, req.(*REPO_GET_Request))
	}
	var _Gittar_REPO_GET_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_REPO_GET_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "REPO_GET", srv)
		_Gittar_REPO_GET_Handler = h.Interceptor(_Gittar_REPO_GET_Handler)
	}

	_Gittar_REPO_POST_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.REPO_POST(ctx, req.(*REPO_POST_Request))
	}
	var _Gittar_REPO_POST_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_REPO_POST_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "REPO_POST", srv)
		_Gittar_REPO_POST_Handler = h.Interceptor(_Gittar_REPO_POST_Handler)
	}

	_Gittar_REPO_PUT_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.REPO_PUT(ctx, req.(*REPO_PUT_Request))
	}
	var _Gittar_REPO_PUT_info transport.ServiceInfo
	if h.Interceptor != nil {
		_Gittar_REPO_PUT_info = transport.NewServiceInfo("erda.openapiv1.gittar.gittar", "REPO_PUT", srv)
		_Gittar_REPO_PUT_Handler = h.Interceptor(_Gittar_REPO_PUT_Handler)
	}

	var serviceDesc = _Gittar_serviceDesc
	serviceDesc.Methods = []grpc.MethodDesc{
		{
			MethodName: "GITTAR_ARCHIVE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_ARCHIVE_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_ARCHIVE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_ARCHIVE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_ARCHIVE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_ARCHIVE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_ARCHIVE_Handler)
			},
		},
		{
			MethodName: "GITTAR_BLAME",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_BLAME_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_BLAME(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_BLAME_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_BLAME_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_BLAME",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_BLAME_Handler)
			},
		},
		{
			MethodName: "GITTAR_BLOB",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_BLOB_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_BLOB(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_BLOB_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_BLOB_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_BLOB",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_BLOB_Handler)
			},
		},
		{
			MethodName: "GITTAR_BRANCH",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_BRANCH_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_BRANCH(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_BRANCH_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_BRANCH_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_BRANCH",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_BRANCH_Handler)
			},
		},
		{
			MethodName: "GITTAR_BRANCH_CREATE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GittarCreateBranchRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_BRANCH_CREATE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_BRANCH_CREATE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_BRANCH_CREATE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_BRANCH_CREATE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_BRANCH_CREATE_Handler)
			},
		},
		{
			MethodName: "GITTAR_BRANCH_DELETE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_BRANCH_DELETE_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_BRANCH_DELETE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_BRANCH_DELETE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_BRANCH_DELETE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_BRANCH_DELETE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_BRANCH_DELETE_Handler)
			},
		},
		{
			MethodName: "GITTAR_CHECK_RUN_CREATE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CheckRun)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_CHECK_RUN_CREATE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_CHECK_RUN_CREATE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_CHECK_RUN_CREATE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_CHECK_RUN_CREATE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_CHECK_RUN_CREATE_Handler)
			},
		},
		{
			MethodName: "GITTAR_CHECK_RUN_QUERY",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CheckRun)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_CHECK_RUN_QUERY(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_CHECK_RUN_QUERY_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_CHECK_RUN_QUERY_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_CHECK_RUN_QUERY",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_CHECK_RUN_QUERY_Handler)
			},
		},
		{
			MethodName: "GITTAR_COMMIT",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_COMMIT_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_COMMIT(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_COMMIT_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_COMMIT_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_COMMIT",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_COMMIT_Handler)
			},
		},
		{
			MethodName: "GITTAR_COMMITS",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GittarCommitsRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_COMMITS(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_COMMITS_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_COMMITS_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_COMMITS",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_COMMITS_Handler)
			},
		},
		{
			MethodName: "GITTAR_COMMITS_CREATE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GittarCreateCommitRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_COMMITS_CREATE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_COMMITS_CREATE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_COMMITS_CREATE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_COMMITS_CREATE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_COMMITS_CREATE_Handler)
			},
		},
		{
			MethodName: "GITTAR_COMPARE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_COMPARE_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_COMPARE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_COMPARE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_COMPARE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_COMPARE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_COMPARE_Handler)
			},
		},
		{
			MethodName: "GITTAR_MERGE_ACTION_POST",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_MERGE_ACTION_POST_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_MERGE_ACTION_POST(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_MERGE_ACTION_POST_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_MERGE_ACTION_POST_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_ACTION_POST",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_MERGE_ACTION_POST_Handler)
			},
		},
		{
			MethodName: "GITTAR_MERGE_ACTION_QUERY",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_MERGE_ACTION_QUERY_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_MERGE_ACTION_QUERY(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_MERGE_ACTION_QUERY_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_MERGE_ACTION_QUERY_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_ACTION_QUERY",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_MERGE_ACTION_QUERY_Handler)
			},
		},
		{
			MethodName: "GITTAR_MERGE_CREATE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GittarCreateMergeRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_MERGE_CREATE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_MERGE_CREATE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_MERGE_CREATE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_CREATE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_MERGE_CREATE_Handler)
			},
		},
		{
			MethodName: "GITTAR_MERGE_GET",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_MERGE_GET_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_MERGE_GET(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_MERGE_GET_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_MERGE_GET_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_GET",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_MERGE_GET_Handler)
			},
		},
		{
			MethodName: "GITTAR_MERGE_QUERY",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GittarQueryMrRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_MERGE_QUERY(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_MERGE_QUERY_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_MERGE_QUERY_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_QUERY",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_MERGE_QUERY_Handler)
			},
		},
		{
			MethodName: "GITTAR_MERGE_STATS",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GittarMergeStatusRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_MERGE_STATS(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_MERGE_STATS_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_MERGE_STATS_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_MERGE_STATS",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_MERGE_STATS_Handler)
			},
		},
		{
			MethodName: "GITTAR_MR_TEMPLATES",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_MR_TEMPLATES_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_MR_TEMPLATES(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_MR_TEMPLATES_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_MR_TEMPLATES_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_MR_TEMPLATES",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_MR_TEMPLATES_Handler)
			},
		},
		{
			MethodName: "GITTAR_RAW",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_RAW_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_RAW(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_RAW_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_RAW_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_RAW",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_RAW_Handler)
			},
		},
		{
			MethodName: "GITTAR_REPO_STATS",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_REPO_STATS_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_REPO_STATS(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_REPO_STATS_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_REPO_STATS_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_REPO_STATS",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_REPO_STATS_Handler)
			},
		},
		{
			MethodName: "GITTAR_REPO_STATS_DEFAULT",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_REPO_STATS_DEFAULT_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_REPO_STATS_DEFAULT(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_REPO_STATS_DEFAULT_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_REPO_STATS_DEFAULT_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_REPO_STATS_DEFAULT",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_REPO_STATS_DEFAULT_Handler)
			},
		},
		{
			MethodName: "GITTAR_TAG",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_TAG_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_TAG(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_TAG_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_TAG_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_TAG",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_TAG_Handler)
			},
		},
		{
			MethodName: "GITTAR_TAG_CREATE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GittarCreateTagRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_TAG_CREATE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_TAG_CREATE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_TAG_CREATE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_TAG_CREATE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_TAG_CREATE_Handler)
			},
		},
		{
			MethodName: "GITTAR_TAG_DELETE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_TAG_DELETE_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_TAG_DELETE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_TAG_DELETE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_TAG_DELETE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_TAG_DELETE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_TAG_DELETE_Handler)
			},
		},
		{
			MethodName: "GITTAR_TREE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GITTAR_TREE_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_TREE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_TREE_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_TREE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_TREE",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_TREE_Handler)
			},
		},
		{
			MethodName: "GITTAR_TREE_SEARCH",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(GittarTreeSearchRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).GITTAR_TREE_SEARCH(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_GITTAR_TREE_SEARCH_info)
				}
				if interceptor == nil {
					return _Gittar_GITTAR_TREE_SEARCH_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/GITTAR_TREE_SEARCH",
				}
				return interceptor(ctx, in, info, _Gittar_GITTAR_TREE_SEARCH_Handler)
			},
		},
		{
			MethodName: "REPO_DELETE",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(REPO_DELETE_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).REPO_DELETE(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_REPO_DELETE_info)
				}
				if interceptor == nil {
					return _Gittar_REPO_DELETE_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/REPO_DELETE",
				}
				return interceptor(ctx, in, info, _Gittar_REPO_DELETE_Handler)
			},
		},
		{
			MethodName: "REPO_GET",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(REPO_GET_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).REPO_GET(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_REPO_GET_info)
				}
				if interceptor == nil {
					return _Gittar_REPO_GET_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/REPO_GET",
				}
				return interceptor(ctx, in, info, _Gittar_REPO_GET_Handler)
			},
		},
		{
			MethodName: "REPO_POST",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(REPO_POST_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).REPO_POST(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_REPO_POST_info)
				}
				if interceptor == nil {
					return _Gittar_REPO_POST_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/REPO_POST",
				}
				return interceptor(ctx, in, info, _Gittar_REPO_POST_Handler)
			},
		},
		{
			MethodName: "REPO_PUT",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(REPO_PUT_Request)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(GittarServer).REPO_PUT(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _Gittar_REPO_PUT_info)
				}
				if interceptor == nil {
					return _Gittar_REPO_PUT_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.openapiv1.gittar.gittar/REPO_PUT",
				}
				return interceptor(ctx, in, info, _Gittar_REPO_PUT_Handler)
			},
		},
	}
	return &serviceDesc
}
