// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gittar.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Branch with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Branch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Branch with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BranchMultiError, or nil if none found.
func (m *Branch) ValidateAll() error {
	return m.validate(true)
}

func (m *Branch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for Name

	// no validation rules for IsDefault

	// no validation rules for IsProtect

	// no validation rules for IsMerged

	if m.Commit != nil {

		if all {
			switch v := interface{}(m.GetCommit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BranchValidationError{
						field:  "Commit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BranchValidationError{
						field:  "Commit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BranchValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BranchMultiError(errors)
	}

	return nil
}

// BranchMultiError is an error wrapping multiple validation errors returned by
// Branch.ValidateAll() if the designated constraints aren't met.
type BranchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BranchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BranchMultiError) AllErrors() []error { return m }

// BranchValidationError is the validation error returned by Branch.Validate if
// the designated constraints aren't met.
type BranchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BranchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BranchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BranchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BranchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BranchValidationError) ErrorName() string { return "BranchValidationError" }

// Error satisfies the builtin error interface
func (e BranchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBranch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BranchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BranchValidationError{}

// Validate checks the field values on CheckRun with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CheckRun) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckRun with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CheckRunMultiError, or nil
// if none found.
func (m *CheckRun) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckRun) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for Name

	// no validation rules for MrID

	// no validation rules for Type

	// no validation rules for ExternalID

	// no validation rules for Commit

	// no validation rules for PipelineID

	// no validation rules for Status

	// no validation rules for Result

	// no validation rules for Output

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckRunValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckRunValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckRunValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RepoID

	// no validation rules for Org

	// no validation rules for Repo

	if m.CompletedAt != nil {

		if all {
			switch v := interface{}(m.GetCompletedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CheckRunValidationError{
						field:  "CompletedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CheckRunValidationError{
						field:  "CompletedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCompletedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CheckRunValidationError{
					field:  "CompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CheckRunMultiError(errors)
	}

	return nil
}

// CheckRunMultiError is an error wrapping multiple validation errors returned
// by CheckRun.ValidateAll() if the designated constraints aren't met.
type CheckRunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckRunMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckRunMultiError) AllErrors() []error { return m }

// CheckRunValidationError is the validation error returned by
// CheckRun.Validate if the designated constraints aren't met.
type CheckRunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckRunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckRunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckRunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckRunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckRunValidationError) ErrorName() string { return "CheckRunValidationError" }

// Error satisfies the builtin error interface
func (e CheckRunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckRun.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckRunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckRunValidationError{}

// Validate checks the field values on CheckRuns with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CheckRuns) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckRuns with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CheckRunsMultiError, or nil
// if none found.
func (m *CheckRuns) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckRuns) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCheckRun() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CheckRunsValidationError{
						field:  fmt.Sprintf("CheckRun[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CheckRunsValidationError{
						field:  fmt.Sprintf("CheckRun[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CheckRunsValidationError{
					field:  fmt.Sprintf("CheckRun[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Result

	// no validation rules for Mergable

	if len(errors) > 0 {
		return CheckRunsMultiError(errors)
	}

	return nil
}

// CheckRunsMultiError is an error wrapping multiple validation errors returned
// by CheckRuns.ValidateAll() if the designated constraints aren't met.
type CheckRunsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckRunsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckRunsMultiError) AllErrors() []error { return m }

// CheckRunsValidationError is the validation error returned by
// CheckRuns.Validate if the designated constraints aren't met.
type CheckRunsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckRunsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckRunsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckRunsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckRunsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckRunsValidationError) ErrorName() string { return "CheckRunsValidationError" }

// Error satisfies the builtin error interface
func (e CheckRunsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckRuns.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckRunsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckRunsValidationError{}

// Validate checks the field values on Commit with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Commit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Commit with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CommitMultiError, or nil if none found.
func (m *Commit) ValidateAll() error {
	return m.validate(true)
}

func (m *Commit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for CommitMessage

	// no validation rules for ParentSha

	if m.Author != nil {

		if all {
			switch v := interface{}(m.GetAuthor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitValidationError{
						field:  "Author",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitValidationError{
						field:  "Author",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitValidationError{
					field:  "Author",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Committer != nil {

		if all {
			switch v := interface{}(m.GetCommitter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitValidationError{
						field:  "Committer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitValidationError{
						field:  "Committer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCommitter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitValidationError{
					field:  "Committer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CommitMultiError(errors)
	}

	return nil
}

// CommitMultiError is an error wrapping multiple validation errors returned by
// Commit.ValidateAll() if the designated constraints aren't met.
type CommitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitMultiError) AllErrors() []error { return m }

// CommitValidationError is the validation error returned by Commit.Validate if
// the designated constraints aren't met.
type CommitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitValidationError) ErrorName() string { return "CommitValidationError" }

// Error satisfies the builtin error interface
func (e CommitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitValidationError{}

// Validate checks the field values on CreateCheckRunResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateCheckRunResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateCheckRunResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateCheckRunResponseMultiError, or nil if none found.
func (m *CreateCheckRunResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateCheckRunResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateCheckRunResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateCheckRunResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateCheckRunResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateCheckRunResponseMultiError(errors)
	}

	return nil
}

// CreateCheckRunResponseMultiError is an error wrapping multiple validation
// errors returned by CreateCheckRunResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateCheckRunResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateCheckRunResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateCheckRunResponseMultiError) AllErrors() []error { return m }

// CreateCheckRunResponseValidationError is the validation error returned by
// CreateCheckRunResponse.Validate if the designated constraints aren't met.
type CreateCheckRunResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateCheckRunResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateCheckRunResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateCheckRunResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateCheckRunResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateCheckRunResponseValidationError) ErrorName() string {
	return "CreateCheckRunResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateCheckRunResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateCheckRunResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateCheckRunResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateCheckRunResponseValidationError{}

// Validate checks the field values on DeleteEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteEventMultiError, or
// nil if none found.
func (m *DeleteEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Event

	// no validation rules for AppName

	// no validation rules for Name

	// no validation rules for AppID

	// no validation rules for ProjectID

	if len(errors) > 0 {
		return DeleteEventMultiError(errors)
	}

	return nil
}

// DeleteEventMultiError is an error wrapping multiple validation errors
// returned by DeleteEvent.ValidateAll() if the designated constraints aren't met.
type DeleteEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteEventMultiError) AllErrors() []error { return m }

// DeleteEventValidationError is the validation error returned by
// DeleteEvent.Validate if the designated constraints aren't met.
type DeleteEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteEventValidationError) ErrorName() string { return "DeleteEventValidationError" }

// Error satisfies the builtin error interface
func (e DeleteEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteEventValidationError{}

// Validate checks the field values on Diff with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Diff) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Diff with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DiffMultiError, or nil if none found.
func (m *Diff) ValidateAll() error {
	return m.validate(true)
}

func (m *Diff) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FilesChanged

	// no validation rules for TotalAddition

	// no validation rules for TotalDeletion

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiffValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiffValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiffValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsFinish

	if len(errors) > 0 {
		return DiffMultiError(errors)
	}

	return nil
}

// DiffMultiError is an error wrapping multiple validation errors returned by
// Diff.ValidateAll() if the designated constraints aren't met.
type DiffMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiffMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiffMultiError) AllErrors() []error { return m }

// DiffValidationError is the validation error returned by Diff.Validate if the
// designated constraints aren't met.
type DiffValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiffValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiffValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiffValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiffValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiffValidationError) ErrorName() string { return "DiffValidationError" }

// Error satisfies the builtin error interface
func (e DiffValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiff.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiffValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiffValidationError{}

// Validate checks the field values on EditActionItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EditActionItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditActionItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EditActionItemMultiError,
// or nil if none found.
func (m *EditActionItem) ValidateAll() error {
	return m.validate(true)
}

func (m *EditActionItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Action

	// no validation rules for Content

	// no validation rules for Path

	// no validation rules for PathType

	if len(errors) > 0 {
		return EditActionItemMultiError(errors)
	}

	return nil
}

// EditActionItemMultiError is an error wrapping multiple validation errors
// returned by EditActionItem.ValidateAll() if the designated constraints
// aren't met.
type EditActionItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditActionItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditActionItemMultiError) AllErrors() []error { return m }

// EditActionItemValidationError is the validation error returned by
// EditActionItem.Validate if the designated constraints aren't met.
type EditActionItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditActionItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditActionItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditActionItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditActionItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditActionItemValidationError) ErrorName() string { return "EditActionItemValidationError" }

// Error satisfies the builtin error interface
func (e EditActionItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditActionItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditActionItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditActionItemValidationError{}

// Validate checks the field values on GITTAR_ARCHIVE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_ARCHIVE_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_ARCHIVE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_ARCHIVE_RequestMultiError, or nil if none found.
func (m *GITTAR_ARCHIVE_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_ARCHIVE_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_ARCHIVE_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_ARCHIVE_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_ARCHIVE_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_ARCHIVE_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_ARCHIVE_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_ARCHIVE_RequestMultiError) AllErrors() []error { return m }

// GITTAR_ARCHIVE_RequestValidationError is the validation error returned by
// GITTAR_ARCHIVE_Request.Validate if the designated constraints aren't met.
type GITTAR_ARCHIVE_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_ARCHIVE_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_ARCHIVE_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_ARCHIVE_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_ARCHIVE_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_ARCHIVE_RequestValidationError) ErrorName() string {
	return "GITTAR_ARCHIVE_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_ARCHIVE_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_ARCHIVE_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_ARCHIVE_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_ARCHIVE_RequestValidationError{}

// Validate checks the field values on GITTAR_BLAME_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_BLAME_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_BLAME_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_BLAME_RequestMultiError, or nil if none found.
func (m *GITTAR_BLAME_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_BLAME_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_BLAME_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_BLAME_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_BLAME_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_BLAME_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_BLAME_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_BLAME_RequestMultiError) AllErrors() []error { return m }

// GITTAR_BLAME_RequestValidationError is the validation error returned by
// GITTAR_BLAME_Request.Validate if the designated constraints aren't met.
type GITTAR_BLAME_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_BLAME_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_BLAME_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_BLAME_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_BLAME_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_BLAME_RequestValidationError) ErrorName() string {
	return "GITTAR_BLAME_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_BLAME_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_BLAME_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_BLAME_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_BLAME_RequestValidationError{}

// Validate checks the field values on GITTAR_BLOB_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_BLOB_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_BLOB_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_BLOB_RequestMultiError, or nil if none found.
func (m *GITTAR_BLOB_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_BLOB_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_BLOB_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_BLOB_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_BLOB_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_BLOB_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_BLOB_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_BLOB_RequestMultiError) AllErrors() []error { return m }

// GITTAR_BLOB_RequestValidationError is the validation error returned by
// GITTAR_BLOB_Request.Validate if the designated constraints aren't met.
type GITTAR_BLOB_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_BLOB_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_BLOB_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_BLOB_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_BLOB_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_BLOB_RequestValidationError) ErrorName() string {
	return "GITTAR_BLOB_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_BLOB_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_BLOB_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_BLOB_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_BLOB_RequestValidationError{}

// Validate checks the field values on GITTAR_BRANCH_DELETE_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_BRANCH_DELETE_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_BRANCH_DELETE_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_BRANCH_DELETE_RequestMultiError, or nil if none found.
func (m *GITTAR_BRANCH_DELETE_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_BRANCH_DELETE_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_BRANCH_DELETE_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_BRANCH_DELETE_RequestMultiError is an error wrapping multiple
// validation errors returned by GITTAR_BRANCH_DELETE_Request.ValidateAll() if
// the designated constraints aren't met.
type GITTAR_BRANCH_DELETE_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_BRANCH_DELETE_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_BRANCH_DELETE_RequestMultiError) AllErrors() []error { return m }

// GITTAR_BRANCH_DELETE_RequestValidationError is the validation error returned
// by GITTAR_BRANCH_DELETE_Request.Validate if the designated constraints
// aren't met.
type GITTAR_BRANCH_DELETE_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_BRANCH_DELETE_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_BRANCH_DELETE_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_BRANCH_DELETE_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_BRANCH_DELETE_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_BRANCH_DELETE_RequestValidationError) ErrorName() string {
	return "GITTAR_BRANCH_DELETE_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_BRANCH_DELETE_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_BRANCH_DELETE_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_BRANCH_DELETE_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_BRANCH_DELETE_RequestValidationError{}

// Validate checks the field values on GITTAR_BRANCH_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_BRANCH_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_BRANCH_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_BRANCH_RequestMultiError, or nil if none found.
func (m *GITTAR_BRANCH_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_BRANCH_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_BRANCH_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_BRANCH_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_BRANCH_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_BRANCH_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_BRANCH_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_BRANCH_RequestMultiError) AllErrors() []error { return m }

// GITTAR_BRANCH_RequestValidationError is the validation error returned by
// GITTAR_BRANCH_Request.Validate if the designated constraints aren't met.
type GITTAR_BRANCH_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_BRANCH_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_BRANCH_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_BRANCH_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_BRANCH_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_BRANCH_RequestValidationError) ErrorName() string {
	return "GITTAR_BRANCH_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_BRANCH_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_BRANCH_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_BRANCH_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_BRANCH_RequestValidationError{}

// Validate checks the field values on GITTAR_COMMIT_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_COMMIT_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_COMMIT_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_COMMIT_RequestMultiError, or nil if none found.
func (m *GITTAR_COMMIT_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_COMMIT_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_COMMIT_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_COMMIT_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_COMMIT_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_COMMIT_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_COMMIT_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_COMMIT_RequestMultiError) AllErrors() []error { return m }

// GITTAR_COMMIT_RequestValidationError is the validation error returned by
// GITTAR_COMMIT_Request.Validate if the designated constraints aren't met.
type GITTAR_COMMIT_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_COMMIT_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_COMMIT_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_COMMIT_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_COMMIT_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_COMMIT_RequestValidationError) ErrorName() string {
	return "GITTAR_COMMIT_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_COMMIT_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_COMMIT_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_COMMIT_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_COMMIT_RequestValidationError{}

// Validate checks the field values on GITTAR_COMPARE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_COMPARE_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_COMPARE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_COMPARE_RequestMultiError, or nil if none found.
func (m *GITTAR_COMPARE_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_COMPARE_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_COMPARE_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_COMPARE_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_COMPARE_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_COMPARE_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_COMPARE_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_COMPARE_RequestMultiError) AllErrors() []error { return m }

// GITTAR_COMPARE_RequestValidationError is the validation error returned by
// GITTAR_COMPARE_Request.Validate if the designated constraints aren't met.
type GITTAR_COMPARE_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_COMPARE_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_COMPARE_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_COMPARE_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_COMPARE_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_COMPARE_RequestValidationError) ErrorName() string {
	return "GITTAR_COMPARE_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_COMPARE_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_COMPARE_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_COMPARE_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_COMPARE_RequestValidationError{}

// Validate checks the field values on GITTAR_MERGE_ACTION_POST_Request with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GITTAR_MERGE_ACTION_POST_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_MERGE_ACTION_POST_Request with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GITTAR_MERGE_ACTION_POST_RequestMultiError, or nil if none found.
func (m *GITTAR_MERGE_ACTION_POST_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_MERGE_ACTION_POST_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	// no validation rules for Id

	// no validation rules for Action

	if len(errors) > 0 {
		return GITTAR_MERGE_ACTION_POST_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_MERGE_ACTION_POST_RequestMultiError is an error wrapping multiple
// validation errors returned by
// GITTAR_MERGE_ACTION_POST_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_MERGE_ACTION_POST_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_MERGE_ACTION_POST_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_MERGE_ACTION_POST_RequestMultiError) AllErrors() []error { return m }

// GITTAR_MERGE_ACTION_POST_RequestValidationError is the validation error
// returned by GITTAR_MERGE_ACTION_POST_Request.Validate if the designated
// constraints aren't met.
type GITTAR_MERGE_ACTION_POST_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_MERGE_ACTION_POST_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_MERGE_ACTION_POST_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_MERGE_ACTION_POST_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_MERGE_ACTION_POST_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_MERGE_ACTION_POST_RequestValidationError) ErrorName() string {
	return "GITTAR_MERGE_ACTION_POST_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_MERGE_ACTION_POST_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_MERGE_ACTION_POST_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_MERGE_ACTION_POST_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_MERGE_ACTION_POST_RequestValidationError{}

// Validate checks the field values on GITTAR_MERGE_ACTION_QUERY_Request with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GITTAR_MERGE_ACTION_QUERY_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_MERGE_ACTION_QUERY_Request
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GITTAR_MERGE_ACTION_QUERY_RequestMultiError, or nil if none found.
func (m *GITTAR_MERGE_ACTION_QUERY_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_MERGE_ACTION_QUERY_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	// no validation rules for Id

	// no validation rules for Action

	if len(errors) > 0 {
		return GITTAR_MERGE_ACTION_QUERY_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_MERGE_ACTION_QUERY_RequestMultiError is an error wrapping multiple
// validation errors returned by
// GITTAR_MERGE_ACTION_QUERY_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_MERGE_ACTION_QUERY_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_MERGE_ACTION_QUERY_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_MERGE_ACTION_QUERY_RequestMultiError) AllErrors() []error { return m }

// GITTAR_MERGE_ACTION_QUERY_RequestValidationError is the validation error
// returned by GITTAR_MERGE_ACTION_QUERY_Request.Validate if the designated
// constraints aren't met.
type GITTAR_MERGE_ACTION_QUERY_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_MERGE_ACTION_QUERY_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_MERGE_ACTION_QUERY_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_MERGE_ACTION_QUERY_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_MERGE_ACTION_QUERY_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_MERGE_ACTION_QUERY_RequestValidationError) ErrorName() string {
	return "GITTAR_MERGE_ACTION_QUERY_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_MERGE_ACTION_QUERY_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_MERGE_ACTION_QUERY_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_MERGE_ACTION_QUERY_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_MERGE_ACTION_QUERY_RequestValidationError{}

// Validate checks the field values on GITTAR_MERGE_GET_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_MERGE_GET_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_MERGE_GET_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_MERGE_GET_RequestMultiError, or nil if none found.
func (m *GITTAR_MERGE_GET_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_MERGE_GET_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	// no validation rules for Id

	if len(errors) > 0 {
		return GITTAR_MERGE_GET_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_MERGE_GET_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_MERGE_GET_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_MERGE_GET_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_MERGE_GET_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_MERGE_GET_RequestMultiError) AllErrors() []error { return m }

// GITTAR_MERGE_GET_RequestValidationError is the validation error returned by
// GITTAR_MERGE_GET_Request.Validate if the designated constraints aren't met.
type GITTAR_MERGE_GET_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_MERGE_GET_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_MERGE_GET_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_MERGE_GET_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_MERGE_GET_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_MERGE_GET_RequestValidationError) ErrorName() string {
	return "GITTAR_MERGE_GET_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_MERGE_GET_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_MERGE_GET_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_MERGE_GET_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_MERGE_GET_RequestValidationError{}

// Validate checks the field values on GITTAR_MR_TEMPLATES_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_MR_TEMPLATES_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_MR_TEMPLATES_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_MR_TEMPLATES_RequestMultiError, or nil if none found.
func (m *GITTAR_MR_TEMPLATES_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_MR_TEMPLATES_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_MR_TEMPLATES_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_MR_TEMPLATES_RequestMultiError is an error wrapping multiple
// validation errors returned by GITTAR_MR_TEMPLATES_Request.ValidateAll() if
// the designated constraints aren't met.
type GITTAR_MR_TEMPLATES_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_MR_TEMPLATES_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_MR_TEMPLATES_RequestMultiError) AllErrors() []error { return m }

// GITTAR_MR_TEMPLATES_RequestValidationError is the validation error returned
// by GITTAR_MR_TEMPLATES_Request.Validate if the designated constraints
// aren't met.
type GITTAR_MR_TEMPLATES_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_MR_TEMPLATES_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_MR_TEMPLATES_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_MR_TEMPLATES_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_MR_TEMPLATES_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_MR_TEMPLATES_RequestValidationError) ErrorName() string {
	return "GITTAR_MR_TEMPLATES_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_MR_TEMPLATES_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_MR_TEMPLATES_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_MR_TEMPLATES_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_MR_TEMPLATES_RequestValidationError{}

// Validate checks the field values on GITTAR_RAW_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_RAW_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_RAW_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_RAW_RequestMultiError, or nil if none found.
func (m *GITTAR_RAW_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_RAW_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_RAW_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_RAW_RequestMultiError is an error wrapping multiple validation errors
// returned by GITTAR_RAW_Request.ValidateAll() if the designated constraints
// aren't met.
type GITTAR_RAW_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_RAW_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_RAW_RequestMultiError) AllErrors() []error { return m }

// GITTAR_RAW_RequestValidationError is the validation error returned by
// GITTAR_RAW_Request.Validate if the designated constraints aren't met.
type GITTAR_RAW_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_RAW_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_RAW_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_RAW_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_RAW_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_RAW_RequestValidationError) ErrorName() string {
	return "GITTAR_RAW_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_RAW_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_RAW_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_RAW_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_RAW_RequestValidationError{}

// Validate checks the field values on GITTAR_REPO_STATS_DEFAULT_Request with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GITTAR_REPO_STATS_DEFAULT_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_REPO_STATS_DEFAULT_Request
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GITTAR_REPO_STATS_DEFAULT_RequestMultiError, or nil if none found.
func (m *GITTAR_REPO_STATS_DEFAULT_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_REPO_STATS_DEFAULT_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_REPO_STATS_DEFAULT_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_REPO_STATS_DEFAULT_RequestMultiError is an error wrapping multiple
// validation errors returned by
// GITTAR_REPO_STATS_DEFAULT_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_REPO_STATS_DEFAULT_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_REPO_STATS_DEFAULT_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_REPO_STATS_DEFAULT_RequestMultiError) AllErrors() []error { return m }

// GITTAR_REPO_STATS_DEFAULT_RequestValidationError is the validation error
// returned by GITTAR_REPO_STATS_DEFAULT_Request.Validate if the designated
// constraints aren't met.
type GITTAR_REPO_STATS_DEFAULT_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_REPO_STATS_DEFAULT_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_REPO_STATS_DEFAULT_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_REPO_STATS_DEFAULT_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_REPO_STATS_DEFAULT_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_REPO_STATS_DEFAULT_RequestValidationError) ErrorName() string {
	return "GITTAR_REPO_STATS_DEFAULT_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_REPO_STATS_DEFAULT_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_REPO_STATS_DEFAULT_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_REPO_STATS_DEFAULT_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_REPO_STATS_DEFAULT_RequestValidationError{}

// Validate checks the field values on GITTAR_REPO_STATS_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_REPO_STATS_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_REPO_STATS_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_REPO_STATS_RequestMultiError, or nil if none found.
func (m *GITTAR_REPO_STATS_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_REPO_STATS_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_REPO_STATS_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_REPO_STATS_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_REPO_STATS_Request.ValidateAll() if the
// designated constraints aren't met.
type GITTAR_REPO_STATS_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_REPO_STATS_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_REPO_STATS_RequestMultiError) AllErrors() []error { return m }

// GITTAR_REPO_STATS_RequestValidationError is the validation error returned by
// GITTAR_REPO_STATS_Request.Validate if the designated constraints aren't met.
type GITTAR_REPO_STATS_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_REPO_STATS_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_REPO_STATS_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_REPO_STATS_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_REPO_STATS_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_REPO_STATS_RequestValidationError) ErrorName() string {
	return "GITTAR_REPO_STATS_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_REPO_STATS_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_REPO_STATS_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_REPO_STATS_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_REPO_STATS_RequestValidationError{}

// Validate checks the field values on GITTAR_TAG_DELETE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_TAG_DELETE_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_TAG_DELETE_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_TAG_DELETE_RequestMultiError, or nil if none found.
func (m *GITTAR_TAG_DELETE_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_TAG_DELETE_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_TAG_DELETE_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_TAG_DELETE_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_TAG_DELETE_Request.ValidateAll() if the
// designated constraints aren't met.
type GITTAR_TAG_DELETE_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_TAG_DELETE_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_TAG_DELETE_RequestMultiError) AllErrors() []error { return m }

// GITTAR_TAG_DELETE_RequestValidationError is the validation error returned by
// GITTAR_TAG_DELETE_Request.Validate if the designated constraints aren't met.
type GITTAR_TAG_DELETE_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_TAG_DELETE_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_TAG_DELETE_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_TAG_DELETE_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_TAG_DELETE_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_TAG_DELETE_RequestValidationError) ErrorName() string {
	return "GITTAR_TAG_DELETE_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_TAG_DELETE_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_TAG_DELETE_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_TAG_DELETE_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_TAG_DELETE_RequestValidationError{}

// Validate checks the field values on GITTAR_TAG_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_TAG_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_TAG_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_TAG_RequestMultiError, or nil if none found.
func (m *GITTAR_TAG_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_TAG_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_TAG_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_TAG_RequestMultiError is an error wrapping multiple validation errors
// returned by GITTAR_TAG_Request.ValidateAll() if the designated constraints
// aren't met.
type GITTAR_TAG_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_TAG_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_TAG_RequestMultiError) AllErrors() []error { return m }

// GITTAR_TAG_RequestValidationError is the validation error returned by
// GITTAR_TAG_Request.Validate if the designated constraints aren't met.
type GITTAR_TAG_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_TAG_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_TAG_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_TAG_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_TAG_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_TAG_RequestValidationError) ErrorName() string {
	return "GITTAR_TAG_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_TAG_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_TAG_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_TAG_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_TAG_RequestValidationError{}

// Validate checks the field values on GITTAR_TREE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GITTAR_TREE_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GITTAR_TREE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GITTAR_TREE_RequestMultiError, or nil if none found.
func (m *GITTAR_TREE_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GITTAR_TREE_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GITTAR_TREE_RequestMultiError(errors)
	}

	return nil
}

// GITTAR_TREE_RequestMultiError is an error wrapping multiple validation
// errors returned by GITTAR_TREE_Request.ValidateAll() if the designated
// constraints aren't met.
type GITTAR_TREE_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GITTAR_TREE_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GITTAR_TREE_RequestMultiError) AllErrors() []error { return m }

// GITTAR_TREE_RequestValidationError is the validation error returned by
// GITTAR_TREE_Request.Validate if the designated constraints aren't met.
type GITTAR_TREE_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GITTAR_TREE_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GITTAR_TREE_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GITTAR_TREE_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GITTAR_TREE_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GITTAR_TREE_RequestValidationError) ErrorName() string {
	return "GITTAR_TREE_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e GITTAR_TREE_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGITTAR_TREE_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GITTAR_TREE_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GITTAR_TREE_RequestValidationError{}

// Validate checks the field values on GittarBlameResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarBlameResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarBlameResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarBlameResponseMultiError, or nil if none found.
func (m *GittarBlameResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarBlameResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GittarBlameResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GittarBlameResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GittarBlameResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GittarBlameResponseMultiError(errors)
	}

	return nil
}

// GittarBlameResponseMultiError is an error wrapping multiple validation
// errors returned by GittarBlameResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarBlameResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarBlameResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarBlameResponseMultiError) AllErrors() []error { return m }

// GittarBlameResponseValidationError is the validation error returned by
// GittarBlameResponse.Validate if the designated constraints aren't met.
type GittarBlameResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarBlameResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarBlameResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarBlameResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarBlameResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarBlameResponseValidationError) ErrorName() string {
	return "GittarBlameResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarBlameResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarBlameResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarBlameResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarBlameResponseValidationError{}

// Validate checks the field values on GittarBlobData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GittarBlobData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarBlobData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GittarBlobDataMultiError,
// or nil if none found.
func (m *GittarBlobData) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarBlobData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Binary

	// no validation rules for Content

	if len(errors) > 0 {
		return GittarBlobDataMultiError(errors)
	}

	return nil
}

// GittarBlobDataMultiError is an error wrapping multiple validation errors
// returned by GittarBlobData.ValidateAll() if the designated constraints
// aren't met.
type GittarBlobDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarBlobDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarBlobDataMultiError) AllErrors() []error { return m }

// GittarBlobDataValidationError is the validation error returned by
// GittarBlobData.Validate if the designated constraints aren't met.
type GittarBlobDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarBlobDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarBlobDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarBlobDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarBlobDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarBlobDataValidationError) ErrorName() string { return "GittarBlobDataValidationError" }

// Error satisfies the builtin error interface
func (e GittarBlobDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarBlobData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarBlobDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarBlobDataValidationError{}

// Validate checks the field values on GittarBlobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarBlobResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarBlobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarBlobResponseMultiError, or nil if none found.
func (m *GittarBlobResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarBlobResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarBlobResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarBlobResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarBlobResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarBlobResponseMultiError(errors)
	}

	return nil
}

// GittarBlobResponseMultiError is an error wrapping multiple validation errors
// returned by GittarBlobResponse.ValidateAll() if the designated constraints
// aren't met.
type GittarBlobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarBlobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarBlobResponseMultiError) AllErrors() []error { return m }

// GittarBlobResponseValidationError is the validation error returned by
// GittarBlobResponse.Validate if the designated constraints aren't met.
type GittarBlobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarBlobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarBlobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarBlobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarBlobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarBlobResponseValidationError) ErrorName() string {
	return "GittarBlobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarBlobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarBlobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarBlobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarBlobResponseValidationError{}

// Validate checks the field values on GittarBranchesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarBranchesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarBranchesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarBranchesResponseMultiError, or nil if none found.
func (m *GittarBranchesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarBranchesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GittarBranchesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GittarBranchesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GittarBranchesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GittarBranchesResponseMultiError(errors)
	}

	return nil
}

// GittarBranchesResponseMultiError is an error wrapping multiple validation
// errors returned by GittarBranchesResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarBranchesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarBranchesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarBranchesResponseMultiError) AllErrors() []error { return m }

// GittarBranchesResponseValidationError is the validation error returned by
// GittarBranchesResponse.Validate if the designated constraints aren't met.
type GittarBranchesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarBranchesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarBranchesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarBranchesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarBranchesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarBranchesResponseValidationError) ErrorName() string {
	return "GittarBranchesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarBranchesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarBranchesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarBranchesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarBranchesResponseValidationError{}

// Validate checks the field values on GittarCommitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCommitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCommitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCommitResponseMultiError, or nil if none found.
func (m *GittarCommitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCommitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarCommitResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarCommitResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarCommitResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarCommitResponseMultiError(errors)
	}

	return nil
}

// GittarCommitResponseMultiError is an error wrapping multiple validation
// errors returned by GittarCommitResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarCommitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCommitResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCommitResponseMultiError) AllErrors() []error { return m }

// GittarCommitResponseValidationError is the validation error returned by
// GittarCommitResponse.Validate if the designated constraints aren't met.
type GittarCommitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCommitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCommitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCommitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCommitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCommitResponseValidationError) ErrorName() string {
	return "GittarCommitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCommitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCommitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCommitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCommitResponseValidationError{}

// Validate checks the field values on GittarCommitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCommitsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCommitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCommitsRequestMultiError, or nil if none found.
func (m *GittarCommitsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCommitsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Search

	// no validation rules for PageNo

	// no validation rules for PageSize

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GittarCommitsRequestMultiError(errors)
	}

	return nil
}

// GittarCommitsRequestMultiError is an error wrapping multiple validation
// errors returned by GittarCommitsRequest.ValidateAll() if the designated
// constraints aren't met.
type GittarCommitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCommitsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCommitsRequestMultiError) AllErrors() []error { return m }

// GittarCommitsRequestValidationError is the validation error returned by
// GittarCommitsRequest.Validate if the designated constraints aren't met.
type GittarCommitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCommitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCommitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCommitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCommitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCommitsRequestValidationError) ErrorName() string {
	return "GittarCommitsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCommitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCommitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCommitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCommitsRequestValidationError{}

// Validate checks the field values on GittarCommitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCommitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCommitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCommitsResponseMultiError, or nil if none found.
func (m *GittarCommitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCommitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GittarCommitsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GittarCommitsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GittarCommitsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GittarCommitsResponseMultiError(errors)
	}

	return nil
}

// GittarCommitsResponseMultiError is an error wrapping multiple validation
// errors returned by GittarCommitsResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarCommitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCommitsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCommitsResponseMultiError) AllErrors() []error { return m }

// GittarCommitsResponseValidationError is the validation error returned by
// GittarCommitsResponse.Validate if the designated constraints aren't met.
type GittarCommitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCommitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCommitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCommitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCommitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCommitsResponseValidationError) ErrorName() string {
	return "GittarCommitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCommitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCommitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCommitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCommitsResponseValidationError{}

// Validate checks the field values on GittarCompareData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GittarCompareData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCompareData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCompareDataMultiError, or nil if none found.
func (m *GittarCompareData) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCompareData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	for idx, item := range m.GetCommits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GittarCompareDataValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GittarCompareDataValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GittarCompareDataValidationError{
					field:  fmt.Sprintf("Commits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDiff()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarCompareDataValidationError{
					field:  "Diff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarCompareDataValidationError{
					field:  "Diff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiff()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarCompareDataValidationError{
				field:  "Diff",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarCompareDataMultiError(errors)
	}

	return nil
}

// GittarCompareDataMultiError is an error wrapping multiple validation errors
// returned by GittarCompareData.ValidateAll() if the designated constraints
// aren't met.
type GittarCompareDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCompareDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCompareDataMultiError) AllErrors() []error { return m }

// GittarCompareDataValidationError is the validation error returned by
// GittarCompareData.Validate if the designated constraints aren't met.
type GittarCompareDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCompareDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCompareDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCompareDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCompareDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCompareDataValidationError) ErrorName() string {
	return "GittarCompareDataValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCompareDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCompareData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCompareDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCompareDataValidationError{}

// Validate checks the field values on GittarCompareResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCompareResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCompareResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCompareResponseMultiError, or nil if none found.
func (m *GittarCompareResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCompareResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarCompareResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarCompareResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarCompareResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarCompareResponseMultiError(errors)
	}

	return nil
}

// GittarCompareResponseMultiError is an error wrapping multiple validation
// errors returned by GittarCompareResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarCompareResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCompareResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCompareResponseMultiError) AllErrors() []error { return m }

// GittarCompareResponseValidationError is the validation error returned by
// GittarCompareResponse.Validate if the designated constraints aren't met.
type GittarCompareResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCompareResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCompareResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCompareResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCompareResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCompareResponseValidationError) ErrorName() string {
	return "GittarCompareResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCompareResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCompareResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCompareResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCompareResponseValidationError{}

// Validate checks the field values on GittarCreateBranchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCreateBranchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCreateBranchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCreateBranchRequestMultiError, or nil if none found.
func (m *GittarCreateBranchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCreateBranchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Ref

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GittarCreateBranchRequestMultiError(errors)
	}

	return nil
}

// GittarCreateBranchRequestMultiError is an error wrapping multiple validation
// errors returned by GittarCreateBranchRequest.ValidateAll() if the
// designated constraints aren't met.
type GittarCreateBranchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCreateBranchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCreateBranchRequestMultiError) AllErrors() []error { return m }

// GittarCreateBranchRequestValidationError is the validation error returned by
// GittarCreateBranchRequest.Validate if the designated constraints aren't met.
type GittarCreateBranchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCreateBranchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCreateBranchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCreateBranchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCreateBranchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCreateBranchRequestValidationError) ErrorName() string {
	return "GittarCreateBranchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCreateBranchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCreateBranchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCreateBranchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCreateBranchRequestValidationError{}

// Validate checks the field values on GittarCreateBranchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCreateBranchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCreateBranchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCreateBranchResponseMultiError, or nil if none found.
func (m *GittarCreateBranchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCreateBranchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GittarCreateBranchResponseMultiError(errors)
	}

	return nil
}

// GittarCreateBranchResponseMultiError is an error wrapping multiple
// validation errors returned by GittarCreateBranchResponse.ValidateAll() if
// the designated constraints aren't met.
type GittarCreateBranchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCreateBranchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCreateBranchResponseMultiError) AllErrors() []error { return m }

// GittarCreateBranchResponseValidationError is the validation error returned
// by GittarCreateBranchResponse.Validate if the designated constraints aren't met.
type GittarCreateBranchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCreateBranchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCreateBranchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCreateBranchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCreateBranchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCreateBranchResponseValidationError) ErrorName() string {
	return "GittarCreateBranchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCreateBranchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCreateBranchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCreateBranchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCreateBranchResponseValidationError{}

// Validate checks the field values on GittarCreateCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCreateCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCreateCommitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCreateCommitRequestMultiError, or nil if none found.
func (m *GittarCreateCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCreateCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GittarCreateCommitRequestValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GittarCreateCommitRequestValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GittarCreateCommitRequestValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Branch

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GittarCreateCommitRequestMultiError(errors)
	}

	return nil
}

// GittarCreateCommitRequestMultiError is an error wrapping multiple validation
// errors returned by GittarCreateCommitRequest.ValidateAll() if the
// designated constraints aren't met.
type GittarCreateCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCreateCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCreateCommitRequestMultiError) AllErrors() []error { return m }

// GittarCreateCommitRequestValidationError is the validation error returned by
// GittarCreateCommitRequest.Validate if the designated constraints aren't met.
type GittarCreateCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCreateCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCreateCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCreateCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCreateCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCreateCommitRequestValidationError) ErrorName() string {
	return "GittarCreateCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCreateCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCreateCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCreateCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCreateCommitRequestValidationError{}

// Validate checks the field values on GittarCreateCommitResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCreateCommitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCreateCommitResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCreateCommitResponseMultiError, or nil if none found.
func (m *GittarCreateCommitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCreateCommitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GittarCreateCommitResponseMultiError(errors)
	}

	return nil
}

// GittarCreateCommitResponseMultiError is an error wrapping multiple
// validation errors returned by GittarCreateCommitResponse.ValidateAll() if
// the designated constraints aren't met.
type GittarCreateCommitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCreateCommitResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCreateCommitResponseMultiError) AllErrors() []error { return m }

// GittarCreateCommitResponseValidationError is the validation error returned
// by GittarCreateCommitResponse.Validate if the designated constraints aren't met.
type GittarCreateCommitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCreateCommitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCreateCommitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCreateCommitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCreateCommitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCreateCommitResponseValidationError) ErrorName() string {
	return "GittarCreateCommitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCreateCommitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCreateCommitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCreateCommitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCreateCommitResponseValidationError{}

// Validate checks the field values on GittarCreateMergeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCreateMergeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCreateMergeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCreateMergeRequestMultiError, or nil if none found.
func (m *GittarCreateMergeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCreateMergeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for AssigneeID

	// no validation rules for SourceBranch

	// no validation rules for TargetBranch

	// no validation rules for RemoveSourceBranch

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GittarCreateMergeRequestMultiError(errors)
	}

	return nil
}

// GittarCreateMergeRequestMultiError is an error wrapping multiple validation
// errors returned by GittarCreateMergeRequest.ValidateAll() if the designated
// constraints aren't met.
type GittarCreateMergeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCreateMergeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCreateMergeRequestMultiError) AllErrors() []error { return m }

// GittarCreateMergeRequestValidationError is the validation error returned by
// GittarCreateMergeRequest.Validate if the designated constraints aren't met.
type GittarCreateMergeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCreateMergeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCreateMergeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCreateMergeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCreateMergeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCreateMergeRequestValidationError) ErrorName() string {
	return "GittarCreateMergeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCreateMergeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCreateMergeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCreateMergeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCreateMergeRequestValidationError{}

// Validate checks the field values on GittarCreateMergeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCreateMergeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCreateMergeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCreateMergeResponseMultiError, or nil if none found.
func (m *GittarCreateMergeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCreateMergeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GittarCreateMergeResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GittarCreateMergeResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GittarCreateMergeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GittarCreateMergeResponseMultiError(errors)
	}

	return nil
}

// GittarCreateMergeResponseMultiError is an error wrapping multiple validation
// errors returned by GittarCreateMergeResponse.ValidateAll() if the
// designated constraints aren't met.
type GittarCreateMergeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCreateMergeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCreateMergeResponseMultiError) AllErrors() []error { return m }

// GittarCreateMergeResponseValidationError is the validation error returned by
// GittarCreateMergeResponse.Validate if the designated constraints aren't met.
type GittarCreateMergeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCreateMergeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCreateMergeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCreateMergeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCreateMergeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCreateMergeResponseValidationError) ErrorName() string {
	return "GittarCreateMergeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCreateMergeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCreateMergeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCreateMergeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCreateMergeResponseValidationError{}

// Validate checks the field values on GittarCreateTagRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCreateTagRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCreateTagRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCreateTagRequestMultiError, or nil if none found.
func (m *GittarCreateTagRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCreateTagRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Message

	// no validation rules for Ref

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GittarCreateTagRequestMultiError(errors)
	}

	return nil
}

// GittarCreateTagRequestMultiError is an error wrapping multiple validation
// errors returned by GittarCreateTagRequest.ValidateAll() if the designated
// constraints aren't met.
type GittarCreateTagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCreateTagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCreateTagRequestMultiError) AllErrors() []error { return m }

// GittarCreateTagRequestValidationError is the validation error returned by
// GittarCreateTagRequest.Validate if the designated constraints aren't met.
type GittarCreateTagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCreateTagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCreateTagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCreateTagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCreateTagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCreateTagRequestValidationError) ErrorName() string {
	return "GittarCreateTagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCreateTagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCreateTagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCreateTagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCreateTagRequestValidationError{}

// Validate checks the field values on GittarCreateTagResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarCreateTagResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarCreateTagResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarCreateTagResponseMultiError, or nil if none found.
func (m *GittarCreateTagResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarCreateTagResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GittarCreateTagResponseMultiError(errors)
	}

	return nil
}

// GittarCreateTagResponseMultiError is an error wrapping multiple validation
// errors returned by GittarCreateTagResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarCreateTagResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarCreateTagResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarCreateTagResponseMultiError) AllErrors() []error { return m }

// GittarCreateTagResponseValidationError is the validation error returned by
// GittarCreateTagResponse.Validate if the designated constraints aren't met.
type GittarCreateTagResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarCreateTagResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarCreateTagResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarCreateTagResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarCreateTagResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarCreateTagResponseValidationError) ErrorName() string {
	return "GittarCreateTagResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarCreateTagResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarCreateTagResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarCreateTagResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarCreateTagResponseValidationError{}

// Validate checks the field values on GittarDeleteBranchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarDeleteBranchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarDeleteBranchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarDeleteBranchResponseMultiError, or nil if none found.
func (m *GittarDeleteBranchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarDeleteBranchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GittarDeleteBranchResponseMultiError(errors)
	}

	return nil
}

// GittarDeleteBranchResponseMultiError is an error wrapping multiple
// validation errors returned by GittarDeleteBranchResponse.ValidateAll() if
// the designated constraints aren't met.
type GittarDeleteBranchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarDeleteBranchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarDeleteBranchResponseMultiError) AllErrors() []error { return m }

// GittarDeleteBranchResponseValidationError is the validation error returned
// by GittarDeleteBranchResponse.Validate if the designated constraints aren't met.
type GittarDeleteBranchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarDeleteBranchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarDeleteBranchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarDeleteBranchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarDeleteBranchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarDeleteBranchResponseValidationError) ErrorName() string {
	return "GittarDeleteBranchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarDeleteBranchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarDeleteBranchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarDeleteBranchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarDeleteBranchResponseValidationError{}

// Validate checks the field values on GittarDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarDeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarDeleteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarDeleteResponseMultiError, or nil if none found.
func (m *GittarDeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarDeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarDeleteResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarDeleteResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarDeleteResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarDeleteResponseMultiError(errors)
	}

	return nil
}

// GittarDeleteResponseMultiError is an error wrapping multiple validation
// errors returned by GittarDeleteResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarDeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarDeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarDeleteResponseMultiError) AllErrors() []error { return m }

// GittarDeleteResponseValidationError is the validation error returned by
// GittarDeleteResponse.Validate if the designated constraints aren't met.
type GittarDeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarDeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarDeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarDeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarDeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarDeleteResponseValidationError) ErrorName() string {
	return "GittarDeleteResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarDeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarDeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarDeleteResponseValidationError{}

// Validate checks the field values on GittarDiffData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GittarDiffData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarDiffData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GittarDiffDataMultiError,
// or nil if none found.
func (m *GittarDiffData) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarDiffData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarDiffDataValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarDiffDataValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarDiffDataValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDiff()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarDiffDataValidationError{
					field:  "Diff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarDiffDataValidationError{
					field:  "Diff",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiff()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarDiffDataValidationError{
				field:  "Diff",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarDiffDataMultiError(errors)
	}

	return nil
}

// GittarDiffDataMultiError is an error wrapping multiple validation errors
// returned by GittarDiffData.ValidateAll() if the designated constraints
// aren't met.
type GittarDiffDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarDiffDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarDiffDataMultiError) AllErrors() []error { return m }

// GittarDiffDataValidationError is the validation error returned by
// GittarDiffData.Validate if the designated constraints aren't met.
type GittarDiffDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarDiffDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarDiffDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarDiffDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarDiffDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarDiffDataValidationError) ErrorName() string { return "GittarDiffDataValidationError" }

// Error satisfies the builtin error interface
func (e GittarDiffDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarDiffData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarDiffDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarDiffDataValidationError{}

// Validate checks the field values on GittarMergeStatusData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarMergeStatusData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarMergeStatusData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarMergeStatusDataMultiError, or nil if none found.
func (m *GittarMergeStatusData) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarMergeStatusData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HasConflict

	// no validation rules for IsMerged

	// no validation rules for HasError

	// no validation rules for ErrorMsg

	if len(errors) > 0 {
		return GittarMergeStatusDataMultiError(errors)
	}

	return nil
}

// GittarMergeStatusDataMultiError is an error wrapping multiple validation
// errors returned by GittarMergeStatusData.ValidateAll() if the designated
// constraints aren't met.
type GittarMergeStatusDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarMergeStatusDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarMergeStatusDataMultiError) AllErrors() []error { return m }

// GittarMergeStatusDataValidationError is the validation error returned by
// GittarMergeStatusData.Validate if the designated constraints aren't met.
type GittarMergeStatusDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarMergeStatusDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarMergeStatusDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarMergeStatusDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarMergeStatusDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarMergeStatusDataValidationError) ErrorName() string {
	return "GittarMergeStatusDataValidationError"
}

// Error satisfies the builtin error interface
func (e GittarMergeStatusDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarMergeStatusData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarMergeStatusDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarMergeStatusDataValidationError{}

// Validate checks the field values on GittarMergeStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarMergeStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarMergeStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarMergeStatusRequestMultiError, or nil if none found.
func (m *GittarMergeStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarMergeStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceBranch

	// no validation rules for TargetBranch

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GittarMergeStatusRequestMultiError(errors)
	}

	return nil
}

// GittarMergeStatusRequestMultiError is an error wrapping multiple validation
// errors returned by GittarMergeStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type GittarMergeStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarMergeStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarMergeStatusRequestMultiError) AllErrors() []error { return m }

// GittarMergeStatusRequestValidationError is the validation error returned by
// GittarMergeStatusRequest.Validate if the designated constraints aren't met.
type GittarMergeStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarMergeStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarMergeStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarMergeStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarMergeStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarMergeStatusRequestValidationError) ErrorName() string {
	return "GittarMergeStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GittarMergeStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarMergeStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarMergeStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarMergeStatusRequestValidationError{}

// Validate checks the field values on GittarMergeStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarMergeStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarMergeStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarMergeStatusResponseMultiError, or nil if none found.
func (m *GittarMergeStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarMergeStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarMergeStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarMergeStatusResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarMergeStatusResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarMergeStatusResponseMultiError(errors)
	}

	return nil
}

// GittarMergeStatusResponseMultiError is an error wrapping multiple validation
// errors returned by GittarMergeStatusResponse.ValidateAll() if the
// designated constraints aren't met.
type GittarMergeStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarMergeStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarMergeStatusResponseMultiError) AllErrors() []error { return m }

// GittarMergeStatusResponseValidationError is the validation error returned by
// GittarMergeStatusResponse.Validate if the designated constraints aren't met.
type GittarMergeStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarMergeStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarMergeStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarMergeStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarMergeStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarMergeStatusResponseValidationError) ErrorName() string {
	return "GittarMergeStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarMergeStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarMergeStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarMergeStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarMergeStatusResponseValidationError{}

// Validate checks the field values on GittarMergeTemplatesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarMergeTemplatesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarMergeTemplatesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarMergeTemplatesResponseMultiError, or nil if none found.
func (m *GittarMergeTemplatesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarMergeTemplatesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarMergeTemplatesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarMergeTemplatesResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarMergeTemplatesResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarMergeTemplatesResponseMultiError(errors)
	}

	return nil
}

// GittarMergeTemplatesResponseMultiError is an error wrapping multiple
// validation errors returned by GittarMergeTemplatesResponse.ValidateAll() if
// the designated constraints aren't met.
type GittarMergeTemplatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarMergeTemplatesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarMergeTemplatesResponseMultiError) AllErrors() []error { return m }

// GittarMergeTemplatesResponseValidationError is the validation error returned
// by GittarMergeTemplatesResponse.Validate if the designated constraints
// aren't met.
type GittarMergeTemplatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarMergeTemplatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarMergeTemplatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarMergeTemplatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarMergeTemplatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarMergeTemplatesResponseValidationError) ErrorName() string {
	return "GittarMergeTemplatesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarMergeTemplatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarMergeTemplatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarMergeTemplatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarMergeTemplatesResponseValidationError{}

// Validate checks the field values on GittarQueryMrDetailResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarQueryMrDetailResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarQueryMrDetailResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarQueryMrDetailResponseMultiError, or nil if none found.
func (m *GittarQueryMrDetailResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarQueryMrDetailResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarQueryMrDetailResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarQueryMrDetailResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarQueryMrDetailResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarQueryMrDetailResponseMultiError(errors)
	}

	return nil
}

// GittarQueryMrDetailResponseMultiError is an error wrapping multiple
// validation errors returned by GittarQueryMrDetailResponse.ValidateAll() if
// the designated constraints aren't met.
type GittarQueryMrDetailResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarQueryMrDetailResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarQueryMrDetailResponseMultiError) AllErrors() []error { return m }

// GittarQueryMrDetailResponseValidationError is the validation error returned
// by GittarQueryMrDetailResponse.Validate if the designated constraints
// aren't met.
type GittarQueryMrDetailResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarQueryMrDetailResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarQueryMrDetailResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarQueryMrDetailResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarQueryMrDetailResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarQueryMrDetailResponseValidationError) ErrorName() string {
	return "GittarQueryMrDetailResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarQueryMrDetailResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarQueryMrDetailResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarQueryMrDetailResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarQueryMrDetailResponseValidationError{}

// Validate checks the field values on GittarQueryMrRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarQueryMrRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarQueryMrRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarQueryMrRequestMultiError, or nil if none found.
func (m *GittarQueryMrRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarQueryMrRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for State

	// no validation rules for Query

	// no validation rules for AuthorId

	// no validation rules for AssigneeId

	// no validation rules for Score

	// no validation rules for Page

	// no validation rules for Size

	// no validation rules for TargetBranch

	// no validation rules for SourceBranch

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GittarQueryMrRequestMultiError(errors)
	}

	return nil
}

// GittarQueryMrRequestMultiError is an error wrapping multiple validation
// errors returned by GittarQueryMrRequest.ValidateAll() if the designated
// constraints aren't met.
type GittarQueryMrRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarQueryMrRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarQueryMrRequestMultiError) AllErrors() []error { return m }

// GittarQueryMrRequestValidationError is the validation error returned by
// GittarQueryMrRequest.Validate if the designated constraints aren't met.
type GittarQueryMrRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarQueryMrRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarQueryMrRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarQueryMrRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarQueryMrRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarQueryMrRequestValidationError) ErrorName() string {
	return "GittarQueryMrRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GittarQueryMrRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarQueryMrRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarQueryMrRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarQueryMrRequestValidationError{}

// Validate checks the field values on GittarQueryMrResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarQueryMrResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarQueryMrResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarQueryMrResponseMultiError, or nil if none found.
func (m *GittarQueryMrResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarQueryMrResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarQueryMrResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarQueryMrResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarQueryMrResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarQueryMrResponseMultiError(errors)
	}

	return nil
}

// GittarQueryMrResponseMultiError is an error wrapping multiple validation
// errors returned by GittarQueryMrResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarQueryMrResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarQueryMrResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarQueryMrResponseMultiError) AllErrors() []error { return m }

// GittarQueryMrResponseValidationError is the validation error returned by
// GittarQueryMrResponse.Validate if the designated constraints aren't met.
type GittarQueryMrResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarQueryMrResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarQueryMrResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarQueryMrResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarQueryMrResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarQueryMrResponseValidationError) ErrorName() string {
	return "GittarQueryMrResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarQueryMrResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarQueryMrResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarQueryMrResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarQueryMrResponseValidationError{}

// Validate checks the field values on GittarStatsData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GittarStatsData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarStatsData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarStatsDataMultiError, or nil if none found.
func (m *GittarStatsData) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarStatsData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CommitsCount

	// no validation rules for ContributorCount

	// no validation rules for DefaultBranch

	// no validation rules for Empty

	// no validation rules for CommitID

	// no validation rules for MergeRequestCount

	// no validation rules for Size

	// no validation rules for ReadmeFile

	// no validation rules for ApplicationID

	// no validation rules for ProjectID

	if len(errors) > 0 {
		return GittarStatsDataMultiError(errors)
	}

	return nil
}

// GittarStatsDataMultiError is an error wrapping multiple validation errors
// returned by GittarStatsData.ValidateAll() if the designated constraints
// aren't met.
type GittarStatsDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarStatsDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarStatsDataMultiError) AllErrors() []error { return m }

// GittarStatsDataValidationError is the validation error returned by
// GittarStatsData.Validate if the designated constraints aren't met.
type GittarStatsDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarStatsDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarStatsDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarStatsDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarStatsDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarStatsDataValidationError) ErrorName() string { return "GittarStatsDataValidationError" }

// Error satisfies the builtin error interface
func (e GittarStatsDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarStatsData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarStatsDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarStatsDataValidationError{}

// Validate checks the field values on GittarStatsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarStatsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarStatsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarStatsResponseMultiError, or nil if none found.
func (m *GittarStatsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarStatsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GittarStatsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GittarStatsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GittarStatsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GittarStatsResponseMultiError(errors)
	}

	return nil
}

// GittarStatsResponseMultiError is an error wrapping multiple validation
// errors returned by GittarStatsResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarStatsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarStatsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarStatsResponseMultiError) AllErrors() []error { return m }

// GittarStatsResponseValidationError is the validation error returned by
// GittarStatsResponse.Validate if the designated constraints aren't met.
type GittarStatsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarStatsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarStatsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarStatsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarStatsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarStatsResponseValidationError) ErrorName() string {
	return "GittarStatsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarStatsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarStatsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarStatsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarStatsResponseValidationError{}

// Validate checks the field values on GittarTagsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarTagsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarTagsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarTagsResponseMultiError, or nil if none found.
func (m *GittarTagsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarTagsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GittarTagsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GittarTagsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GittarTagsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GittarTagsResponseMultiError(errors)
	}

	return nil
}

// GittarTagsResponseMultiError is an error wrapping multiple validation errors
// returned by GittarTagsResponse.ValidateAll() if the designated constraints
// aren't met.
type GittarTagsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarTagsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarTagsResponseMultiError) AllErrors() []error { return m }

// GittarTagsResponseValidationError is the validation error returned by
// GittarTagsResponse.Validate if the designated constraints aren't met.
type GittarTagsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarTagsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarTagsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarTagsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarTagsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarTagsResponseValidationError) ErrorName() string {
	return "GittarTagsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarTagsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarTagsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarTagsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarTagsResponseValidationError{}

// Validate checks the field values on GittarTreeSearchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarTreeSearchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarTreeSearchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarTreeSearchRequestMultiError, or nil if none found.
func (m *GittarTreeSearchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarTreeSearchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ref

	// no validation rules for Pattern

	// no validation rules for Org

	// no validation rules for Repo

	if len(errors) > 0 {
		return GittarTreeSearchRequestMultiError(errors)
	}

	return nil
}

// GittarTreeSearchRequestMultiError is an error wrapping multiple validation
// errors returned by GittarTreeSearchRequest.ValidateAll() if the designated
// constraints aren't met.
type GittarTreeSearchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarTreeSearchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarTreeSearchRequestMultiError) AllErrors() []error { return m }

// GittarTreeSearchRequestValidationError is the validation error returned by
// GittarTreeSearchRequest.Validate if the designated constraints aren't met.
type GittarTreeSearchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarTreeSearchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarTreeSearchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarTreeSearchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarTreeSearchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarTreeSearchRequestValidationError) ErrorName() string {
	return "GittarTreeSearchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GittarTreeSearchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarTreeSearchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarTreeSearchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarTreeSearchRequestValidationError{}

// Validate checks the field values on GittarTreeSearchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GittarTreeSearchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GittarTreeSearchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GittarTreeSearchResponseMultiError, or nil if none found.
func (m *GittarTreeSearchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GittarTreeSearchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GittarTreeSearchResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GittarTreeSearchResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GittarTreeSearchResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GittarTreeSearchResponseMultiError(errors)
	}

	return nil
}

// GittarTreeSearchResponseMultiError is an error wrapping multiple validation
// errors returned by GittarTreeSearchResponse.ValidateAll() if the designated
// constraints aren't met.
type GittarTreeSearchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GittarTreeSearchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GittarTreeSearchResponseMultiError) AllErrors() []error { return m }

// GittarTreeSearchResponseValidationError is the validation error returned by
// GittarTreeSearchResponse.Validate if the designated constraints aren't met.
type GittarTreeSearchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GittarTreeSearchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GittarTreeSearchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GittarTreeSearchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GittarTreeSearchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GittarTreeSearchResponseValidationError) ErrorName() string {
	return "GittarTreeSearchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GittarTreeSearchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGittarTreeSearchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GittarTreeSearchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GittarTreeSearchResponseValidationError{}

// Validate checks the field values on MergeRequestInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MergeRequestInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeRequestInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MergeRequestInfoMultiError, or nil if none found.
func (m *MergeRequestInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeRequestInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RepoMergeId

	// no validation rules for AppID

	// no validation rules for RepoID

	// no validation rules for Title

	// no validation rules for AuthorId

	// no validation rules for Description

	// no validation rules for AssigneeId

	// no validation rules for MergeUserId

	// no validation rules for CloseUserId

	// no validation rules for SourceBranch

	// no validation rules for TargetBranch

	// no validation rules for SourceSha

	// no validation rules for TargetSha

	// no validation rules for RemoveSourceBranch

	// no validation rules for State

	// no validation rules for IsCheckRunValid

	// no validation rules for DefaultCommitMessage

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeRequestInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeRequestInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeRequestInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Link

	// no validation rules for Score

	// no validation rules for ScoreNum

	// no validation rules for RebaseBranch

	// no validation rules for EventName

	if all {
		switch v := interface{}(m.GetCheckRuns()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MergeRequestInfoValidationError{
					field:  "CheckRuns",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MergeRequestInfoValidationError{
					field:  "CheckRuns",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheckRuns()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MergeRequestInfoValidationError{
				field:  "CheckRuns",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for JoinTempBranchStatus

	// no validation rules for IsJoinTempBranch

	if m.AuthorUser != nil {

		if all {
			switch v := interface{}(m.GetAuthorUser()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "AuthorUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "AuthorUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorUser()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeRequestInfoValidationError{
					field:  "AuthorUser",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.AssigneeUser != nil {

		if all {
			switch v := interface{}(m.GetAssigneeUser()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "AssigneeUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "AssigneeUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAssigneeUser()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeRequestInfoValidationError{
					field:  "AssigneeUser",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.MergeUser != nil {

		if all {
			switch v := interface{}(m.GetMergeUser()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "MergeUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "MergeUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMergeUser()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeRequestInfoValidationError{
					field:  "MergeUser",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CloseUser != nil {

		if all {
			switch v := interface{}(m.GetCloseUser()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "CloseUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "CloseUser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCloseUser()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeRequestInfoValidationError{
					field:  "CloseUser",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TargetBranchRule != nil {

		if all {
			switch v := interface{}(m.GetTargetBranchRule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "TargetBranchRule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "TargetBranchRule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTargetBranchRule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeRequestInfoValidationError{
					field:  "TargetBranchRule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeRequestInfoValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CloseAt != nil {

		if all {
			switch v := interface{}(m.GetCloseAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "CloseAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "CloseAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCloseAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeRequestInfoValidationError{
					field:  "CloseAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.MergeAt != nil {

		if all {
			switch v := interface{}(m.GetMergeAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "MergeAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MergeRequestInfoValidationError{
						field:  "MergeAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMergeAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MergeRequestInfoValidationError{
					field:  "MergeAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MergeRequestInfoMultiError(errors)
	}

	return nil
}

// MergeRequestInfoMultiError is an error wrapping multiple validation errors
// returned by MergeRequestInfo.ValidateAll() if the designated constraints
// aren't met.
type MergeRequestInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeRequestInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeRequestInfoMultiError) AllErrors() []error { return m }

// MergeRequestInfoValidationError is the validation error returned by
// MergeRequestInfo.Validate if the designated constraints aren't met.
type MergeRequestInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeRequestInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeRequestInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeRequestInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeRequestInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeRequestInfoValidationError) ErrorName() string { return "MergeRequestInfoValidationError" }

// Error satisfies the builtin error interface
func (e MergeRequestInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeRequestInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeRequestInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeRequestInfoValidationError{}

// Validate checks the field values on MergeTemplatesResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MergeTemplatesResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MergeTemplatesResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MergeTemplatesResponseDataMultiError, or nil if none found.
func (m *MergeTemplatesResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *MergeTemplatesResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Branch

	// no validation rules for Path

	if len(errors) > 0 {
		return MergeTemplatesResponseDataMultiError(errors)
	}

	return nil
}

// MergeTemplatesResponseDataMultiError is an error wrapping multiple
// validation errors returned by MergeTemplatesResponseData.ValidateAll() if
// the designated constraints aren't met.
type MergeTemplatesResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MergeTemplatesResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MergeTemplatesResponseDataMultiError) AllErrors() []error { return m }

// MergeTemplatesResponseDataValidationError is the validation error returned
// by MergeTemplatesResponseData.Validate if the designated constraints aren't met.
type MergeTemplatesResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MergeTemplatesResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MergeTemplatesResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MergeTemplatesResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MergeTemplatesResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MergeTemplatesResponseDataValidationError) ErrorName() string {
	return "MergeTemplatesResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e MergeTemplatesResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMergeTemplatesResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MergeTemplatesResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MergeTemplatesResponseDataValidationError{}

// Validate checks the field values on QueryMergeRequestsData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryMergeRequestsData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryMergeRequestsData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryMergeRequestsDataMultiError, or nil if none found.
func (m *QueryMergeRequestsData) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryMergeRequestsData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryMergeRequestsDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryMergeRequestsDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryMergeRequestsDataValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return QueryMergeRequestsDataMultiError(errors)
	}

	return nil
}

// QueryMergeRequestsDataMultiError is an error wrapping multiple validation
// errors returned by QueryMergeRequestsData.ValidateAll() if the designated
// constraints aren't met.
type QueryMergeRequestsDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMergeRequestsDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMergeRequestsDataMultiError) AllErrors() []error { return m }

// QueryMergeRequestsDataValidationError is the validation error returned by
// QueryMergeRequestsData.Validate if the designated constraints aren't met.
type QueryMergeRequestsDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryMergeRequestsDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryMergeRequestsDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryMergeRequestsDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryMergeRequestsDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryMergeRequestsDataValidationError) ErrorName() string {
	return "QueryMergeRequestsDataValidationError"
}

// Error satisfies the builtin error interface
func (e QueryMergeRequestsDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryMergeRequestsData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryMergeRequestsDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryMergeRequestsDataValidationError{}

// Validate checks the field values on REPO_DELETE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *REPO_DELETE_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on REPO_DELETE_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// REPO_DELETE_RequestMultiError, or nil if none found.
func (m *REPO_DELETE_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *REPO_DELETE_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return REPO_DELETE_RequestMultiError(errors)
	}

	return nil
}

// REPO_DELETE_RequestMultiError is an error wrapping multiple validation
// errors returned by REPO_DELETE_Request.ValidateAll() if the designated
// constraints aren't met.
type REPO_DELETE_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m REPO_DELETE_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m REPO_DELETE_RequestMultiError) AllErrors() []error { return m }

// REPO_DELETE_RequestValidationError is the validation error returned by
// REPO_DELETE_Request.Validate if the designated constraints aren't met.
type REPO_DELETE_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e REPO_DELETE_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e REPO_DELETE_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e REPO_DELETE_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e REPO_DELETE_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e REPO_DELETE_RequestValidationError) ErrorName() string {
	return "REPO_DELETE_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e REPO_DELETE_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sREPO_DELETE_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = REPO_DELETE_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = REPO_DELETE_RequestValidationError{}

// Validate checks the field values on REPO_GET_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *REPO_GET_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on REPO_GET_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// REPO_GET_RequestMultiError, or nil if none found.
func (m *REPO_GET_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *REPO_GET_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return REPO_GET_RequestMultiError(errors)
	}

	return nil
}

// REPO_GET_RequestMultiError is an error wrapping multiple validation errors
// returned by REPO_GET_Request.ValidateAll() if the designated constraints
// aren't met.
type REPO_GET_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m REPO_GET_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m REPO_GET_RequestMultiError) AllErrors() []error { return m }

// REPO_GET_RequestValidationError is the validation error returned by
// REPO_GET_Request.Validate if the designated constraints aren't met.
type REPO_GET_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e REPO_GET_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e REPO_GET_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e REPO_GET_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e REPO_GET_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e REPO_GET_RequestValidationError) ErrorName() string { return "REPO_GET_RequestValidationError" }

// Error satisfies the builtin error interface
func (e REPO_GET_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sREPO_GET_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = REPO_GET_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = REPO_GET_RequestValidationError{}

// Validate checks the field values on REPO_POST_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *REPO_POST_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on REPO_POST_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// REPO_POST_RequestMultiError, or nil if none found.
func (m *REPO_POST_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *REPO_POST_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return REPO_POST_RequestMultiError(errors)
	}

	return nil
}

// REPO_POST_RequestMultiError is an error wrapping multiple validation errors
// returned by REPO_POST_Request.ValidateAll() if the designated constraints
// aren't met.
type REPO_POST_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m REPO_POST_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m REPO_POST_RequestMultiError) AllErrors() []error { return m }

// REPO_POST_RequestValidationError is the validation error returned by
// REPO_POST_Request.Validate if the designated constraints aren't met.
type REPO_POST_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e REPO_POST_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e REPO_POST_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e REPO_POST_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e REPO_POST_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e REPO_POST_RequestValidationError) ErrorName() string {
	return "REPO_POST_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e REPO_POST_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sREPO_POST_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = REPO_POST_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = REPO_POST_RequestValidationError{}

// Validate checks the field values on REPO_PUT_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *REPO_PUT_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on REPO_PUT_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// REPO_PUT_RequestMultiError, or nil if none found.
func (m *REPO_PUT_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *REPO_PUT_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return REPO_PUT_RequestMultiError(errors)
	}

	return nil
}

// REPO_PUT_RequestMultiError is an error wrapping multiple validation errors
// returned by REPO_PUT_Request.ValidateAll() if the designated constraints
// aren't met.
type REPO_PUT_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m REPO_PUT_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m REPO_PUT_RequestMultiError) AllErrors() []error { return m }

// REPO_PUT_RequestValidationError is the validation error returned by
// REPO_PUT_Request.Validate if the designated constraints aren't met.
type REPO_PUT_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e REPO_PUT_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e REPO_PUT_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e REPO_PUT_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e REPO_PUT_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e REPO_PUT_RequestValidationError) ErrorName() string { return "REPO_PUT_RequestValidationError" }

// Error satisfies the builtin error interface
func (e REPO_PUT_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sREPO_PUT_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = REPO_PUT_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = REPO_PUT_RequestValidationError{}

// Validate checks the field values on Tag with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Tag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tag with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TagMultiError, or nil if none found.
func (m *Tag) ValidateAll() error {
	return m.validate(true)
}

func (m *Tag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for ID

	// no validation rules for Object

	// no validation rules for Message

	if m.Tagger != nil {

		if all {
			switch v := interface{}(m.GetTagger()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TagValidationError{
						field:  "Tagger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TagValidationError{
						field:  "Tagger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTagger()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TagValidationError{
					field:  "Tagger",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TagMultiError(errors)
	}

	return nil
}

// TagMultiError is an error wrapping multiple validation errors returned by
// Tag.ValidateAll() if the designated constraints aren't met.
type TagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagMultiError) AllErrors() []error { return m }

// TagValidationError is the validation error returned by Tag.Validate if the
// designated constraints aren't met.
type TagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagValidationError) ErrorName() string { return "TagValidationError" }

// Error satisfies the builtin error interface
func (e TagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagValidationError{}
