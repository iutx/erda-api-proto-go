// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: testplatform_autotest.proto

package pb

import (
	context "context"
	http1 "net/http"
	strconv "strconv"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// TestplatformAutotestHandler is the server API for TestplatformAutotest service.
type TestplatformAutotestHandler interface {
	// GET /api/autotests/filetree/{inode}/actions/download-action-log
	ACTION_LOG_DOWNLOAD(context.Context, *ACTION_LOG_DOWNLOAD_Request) (*emptypb.Empty, error)
	// GET /api/autotests/filetree/{inode}/actions/get-action-log
	ACTION_LOG_GET(context.Context, *ACTION_LOG_GET_Request) (*emptypb.Empty, error)
	// POST /api/autotests/scenes/{sceneID}/actions/cancel
	AUTOTESTS_SCENES_CANCEL(context.Context, *AUTOTESTS_SCENES_CANCEL_Request) (*emptypb.Empty, error)
	// POST /api/autotests/scenes/{sceneID}/actions/execute
	AUTOTESTS_SCENES_EXECUTE(context.Context, *AUTOTESTS_SCENES_EXECUTE_Request) (*emptypb.Empty, error)
	// POST /api/autotests/pipeline-snippets/actions/batch-query-snippet-yml
	BATCH_QUERY_PIPELINE_SNIPPET_YAML(context.Context, *AutoTestCaseSavePipelineRequest) (*emptypb.Empty, error)
	// POST /api/autotests/filetree/{inode}/actions/copy
	FILETREE_NODE_COPY(context.Context, *UnifiedFileTreeNodeCopyRequest) (*UnifiedFileTreeNodeCopyResponse, error)
	// POST /api/autotests/filetree
	FILETREE_NODE_CREATE(context.Context, *UnifiedFileTreeNodeCreateRequest) (*UnifiedFileTreeNodeCreateResponse, error)
	// DELETE /api/autotests/filetree/{inode}
	FILETREE_NODE_DELETE(context.Context, *UnifiedFileTreeNodeDeleteRequest) (*UnifiedFileTreeNodeDeleteResponse, error)
	// GET /api/autotests/filetree/{inode}/actions/find-ancestors
	FILETREE_NODE_FIND_ANCESTORS(context.Context, *UnifiedFileTreeNodeFindAncestorsRequest) (*UnifiedFileTreeNodeFindAncestorsResponse, error)
	// GET /api/autotests/filetree/actions/fuzzy-search
	FILETREE_NODE_FUZZY_SEARCH(context.Context, *UnifiedFileTreeNodeFuzzySearchRequest) (*UnifiedFileTreeNodeFuzzySearchResponse, error)
	// GET /api/autotests/filetree/{inode}
	FILETREE_NODE_GET(context.Context, *UnifiedFileTreeNodeGetRequest) (*UnifiedFileTreeNodeGetResponse, error)
	// GET /api/autotests/filetree/{inode}/actions/get-histories
	FILETREE_NODE_HISTORY_LIST(context.Context, *UnifiedFileTreeNodeHistorySearchRequest) (*emptypb.Empty, error)
	// GET /api/autotests/filetree
	FILETREE_NODE_LIST(context.Context, *UnifiedFileTreeNodeListRequest) (*UnifiedFileTreeNodeListResponse, error)
	// POST /api/autotests/filetree/{inode}/actions/move
	FILETREE_NODE_MOVE(context.Context, *UnifiedFileTreeNodeMoveRequest) (*UnifiedFileTreeNodeMoveResponse, error)
	// POST /api/autotests/filetree/{inode}/actions/save-pipeline
	FILETREE_NODE_SAVE_PIPELINE(context.Context, *AutoTestCaseSavePipelineRequest) (*AutoTestCaseSavePipelineResponse, error)
	// PUT /api/autotests/filetree/{inode}
	FILETREE_NODE_UPDATE_BASIC_INFO(context.Context, *UnifiedFileTreeNodeUpdateBasicInfoRequest) (*UnifiedFileTreeNodeUpdateBasicInfoResponse, error)
	// POST /api/autotests/global-configs
	GLOBAL_CONFIG_CREATE(context.Context, *AutoTestGlobalConfigCreateRequest) (*AutoTestGlobalConfigCreateResponse, error)
	// DELETE /api/autotests/global-configs/{ns}
	GLOBAL_CONFIG_DELETE(context.Context, *AutoTestGlobalConfigDeleteRequest) (*AutoTestGlobalConfigDeleteResponse, error)
	// GET /api/autotests/global-configs
	GLOBAL_CONFIG_LIST(context.Context, *AutoTestGlobalConfigListRequest) (*AutoTestGlobalConfigListResponse, error)
	// PUT /api/autotests/global-configs/{ns}
	GLOBAL_CONFIG_UPDATE(context.Context, *AutoTestGlobalConfigUpdateRequest) (*AutoTestGlobalConfigUpdateResponse, error)
	// GET /api/reportsets/{pipelineID}
	QA_REPORTSETS_LIST(context.Context, *QA_REPORTSETS_LIST_Request) (*emptypb.Empty, error)
	// POST /api/autotests/pipeline-snippets/actions/query-snippet-yml
	QUERY_PIPELINE_SNIPPET_YAML(context.Context, *AutoTestCaseSavePipelineRequest) (*emptypb.Empty, error)
	// POST /api/projects/{projectID}/test-reports
	REPORT_CREATE(context.Context, *TestReportRecord) (*CreateTestReportRecordResponse, error)
	// GET /api/projects/{projectID}/test-reports/{ID}
	REPORT_GET(context.Context, *TestReportRecord) (*GetTestReportRecordResponse, error)
	// POST /api/autotests/scenesets/actions/import
	SCENE_SET_IMPORT(context.Context, *AutoTestSceneSetImportRequest) (*AutoTestSceneSetImportResponse, error)
	// GET /api/autotests/spaces/actions/export
	SPACE_EXPORT(context.Context, *AutoTestSpaceExportRequest) (*AutoTestSpaceExportResponse, error)
	// POST /api/autotests/spaces/actions/import
	SPACE_IMPORT(context.Context, *AutoTestSpaceImportRequest) (*AutoTestSpaceImportResponse, error)
}

// RegisterTestplatformAutotestHandler register TestplatformAutotestHandler to http.Router.
func RegisterTestplatformAutotestHandler(r http.Router, srv TestplatformAutotestHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_ACTION_LOG_DOWNLOAD := func(method, path string, fn func(context.Context, *ACTION_LOG_DOWNLOAD_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ACTION_LOG_DOWNLOAD_Request))
		}
		var ACTION_LOG_DOWNLOAD_info transport.ServiceInfo
		if h.Interceptor != nil {
			ACTION_LOG_DOWNLOAD_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "ACTION_LOG_DOWNLOAD", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ACTION_LOG_DOWNLOAD_info)
				}
				r = r.WithContext(ctx)
				var in ACTION_LOG_DOWNLOAD_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ACTION_LOG_GET := func(method, path string, fn func(context.Context, *ACTION_LOG_GET_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ACTION_LOG_GET_Request))
		}
		var ACTION_LOG_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			ACTION_LOG_GET_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "ACTION_LOG_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ACTION_LOG_GET_info)
				}
				r = r.WithContext(ctx)
				var in ACTION_LOG_GET_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_AUTOTESTS_SCENES_CANCEL := func(method, path string, fn func(context.Context, *AUTOTESTS_SCENES_CANCEL_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AUTOTESTS_SCENES_CANCEL_Request))
		}
		var AUTOTESTS_SCENES_CANCEL_info transport.ServiceInfo
		if h.Interceptor != nil {
			AUTOTESTS_SCENES_CANCEL_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "AUTOTESTS_SCENES_CANCEL", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, AUTOTESTS_SCENES_CANCEL_info)
				}
				r = r.WithContext(ctx)
				var in AUTOTESTS_SCENES_CANCEL_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "sceneID":
							in.SceneID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_AUTOTESTS_SCENES_EXECUTE := func(method, path string, fn func(context.Context, *AUTOTESTS_SCENES_EXECUTE_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AUTOTESTS_SCENES_EXECUTE_Request))
		}
		var AUTOTESTS_SCENES_EXECUTE_info transport.ServiceInfo
		if h.Interceptor != nil {
			AUTOTESTS_SCENES_EXECUTE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "AUTOTESTS_SCENES_EXECUTE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, AUTOTESTS_SCENES_EXECUTE_info)
				}
				r = r.WithContext(ctx)
				var in AUTOTESTS_SCENES_EXECUTE_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "sceneID":
							in.SceneID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_BATCH_QUERY_PIPELINE_SNIPPET_YAML := func(method, path string, fn func(context.Context, *AutoTestCaseSavePipelineRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestCaseSavePipelineRequest))
		}
		var BATCH_QUERY_PIPELINE_SNIPPET_YAML_info transport.ServiceInfo
		if h.Interceptor != nil {
			BATCH_QUERY_PIPELINE_SNIPPET_YAML_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "BATCH_QUERY_PIPELINE_SNIPPET_YAML", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, BATCH_QUERY_PIPELINE_SNIPPET_YAML_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestCaseSavePipelineRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_COPY := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeCopyRequest) (*UnifiedFileTreeNodeCopyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeCopyRequest))
		}
		var FILETREE_NODE_COPY_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_COPY_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_COPY", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_COPY_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeCopyRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_CREATE := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeCreateRequest) (*UnifiedFileTreeNodeCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeCreateRequest))
		}
		var FILETREE_NODE_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_CREATE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_DELETE := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeDeleteRequest) (*UnifiedFileTreeNodeDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeDeleteRequest))
		}
		var FILETREE_NODE_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_DELETE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeDeleteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_FIND_ANCESTORS := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeFindAncestorsRequest) (*UnifiedFileTreeNodeFindAncestorsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeFindAncestorsRequest))
		}
		var FILETREE_NODE_FIND_ANCESTORS_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_FIND_ANCESTORS_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_FIND_ANCESTORS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_FIND_ANCESTORS_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeFindAncestorsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_FUZZY_SEARCH := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeFuzzySearchRequest) (*UnifiedFileTreeNodeFuzzySearchResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeFuzzySearchRequest))
		}
		var FILETREE_NODE_FUZZY_SEARCH_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_FUZZY_SEARCH_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_FUZZY_SEARCH", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_FUZZY_SEARCH_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeFuzzySearchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_GET := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeGetRequest) (*UnifiedFileTreeNodeGetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeGetRequest))
		}
		var FILETREE_NODE_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_GET_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_GET_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeGetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_HISTORY_LIST := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeHistorySearchRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeHistorySearchRequest))
		}
		var FILETREE_NODE_HISTORY_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_HISTORY_LIST_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_HISTORY_LIST", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_HISTORY_LIST_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeHistorySearchRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_LIST := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeListRequest) (*UnifiedFileTreeNodeListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeListRequest))
		}
		var FILETREE_NODE_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_LIST_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_LIST_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_MOVE := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeMoveRequest) (*UnifiedFileTreeNodeMoveResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeMoveRequest))
		}
		var FILETREE_NODE_MOVE_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_MOVE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_MOVE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_MOVE_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeMoveRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_SAVE_PIPELINE := func(method, path string, fn func(context.Context, *AutoTestCaseSavePipelineRequest) (*AutoTestCaseSavePipelineResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestCaseSavePipelineRequest))
		}
		var FILETREE_NODE_SAVE_PIPELINE_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_SAVE_PIPELINE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_SAVE_PIPELINE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_SAVE_PIPELINE_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestCaseSavePipelineRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_FILETREE_NODE_UPDATE_BASIC_INFO := func(method, path string, fn func(context.Context, *UnifiedFileTreeNodeUpdateBasicInfoRequest) (*UnifiedFileTreeNodeUpdateBasicInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnifiedFileTreeNodeUpdateBasicInfoRequest))
		}
		var FILETREE_NODE_UPDATE_BASIC_INFO_info transport.ServiceInfo
		if h.Interceptor != nil {
			FILETREE_NODE_UPDATE_BASIC_INFO_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "FILETREE_NODE_UPDATE_BASIC_INFO", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, FILETREE_NODE_UPDATE_BASIC_INFO_info)
				}
				r = r.WithContext(ctx)
				var in UnifiedFileTreeNodeUpdateBasicInfoRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "inode":
							in.Inode = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GLOBAL_CONFIG_CREATE := func(method, path string, fn func(context.Context, *AutoTestGlobalConfigCreateRequest) (*AutoTestGlobalConfigCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestGlobalConfigCreateRequest))
		}
		var GLOBAL_CONFIG_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GLOBAL_CONFIG_CREATE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "GLOBAL_CONFIG_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GLOBAL_CONFIG_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestGlobalConfigCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GLOBAL_CONFIG_DELETE := func(method, path string, fn func(context.Context, *AutoTestGlobalConfigDeleteRequest) (*AutoTestGlobalConfigDeleteResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestGlobalConfigDeleteRequest))
		}
		var GLOBAL_CONFIG_DELETE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GLOBAL_CONFIG_DELETE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "GLOBAL_CONFIG_DELETE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GLOBAL_CONFIG_DELETE_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestGlobalConfigDeleteRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ns":
							in.Ns = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GLOBAL_CONFIG_LIST := func(method, path string, fn func(context.Context, *AutoTestGlobalConfigListRequest) (*AutoTestGlobalConfigListResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestGlobalConfigListRequest))
		}
		var GLOBAL_CONFIG_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			GLOBAL_CONFIG_LIST_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "GLOBAL_CONFIG_LIST", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GLOBAL_CONFIG_LIST_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestGlobalConfigListRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GLOBAL_CONFIG_UPDATE := func(method, path string, fn func(context.Context, *AutoTestGlobalConfigUpdateRequest) (*AutoTestGlobalConfigUpdateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestGlobalConfigUpdateRequest))
		}
		var GLOBAL_CONFIG_UPDATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			GLOBAL_CONFIG_UPDATE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "GLOBAL_CONFIG_UPDATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GLOBAL_CONFIG_UPDATE_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestGlobalConfigUpdateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "ns":
							in.Ns = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QA_REPORTSETS_LIST := func(method, path string, fn func(context.Context, *QA_REPORTSETS_LIST_Request) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QA_REPORTSETS_LIST_Request))
		}
		var QA_REPORTSETS_LIST_info transport.ServiceInfo
		if h.Interceptor != nil {
			QA_REPORTSETS_LIST_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "QA_REPORTSETS_LIST", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QA_REPORTSETS_LIST_info)
				}
				r = r.WithContext(ctx)
				var in QA_REPORTSETS_LIST_Request
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "pipelineID":
							in.PipelineID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QUERY_PIPELINE_SNIPPET_YAML := func(method, path string, fn func(context.Context, *AutoTestCaseSavePipelineRequest) (*emptypb.Empty, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestCaseSavePipelineRequest))
		}
		var QUERY_PIPELINE_SNIPPET_YAML_info transport.ServiceInfo
		if h.Interceptor != nil {
			QUERY_PIPELINE_SNIPPET_YAML_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "QUERY_PIPELINE_SNIPPET_YAML", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QUERY_PIPELINE_SNIPPET_YAML_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestCaseSavePipelineRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_REPORT_CREATE := func(method, path string, fn func(context.Context, *TestReportRecord) (*CreateTestReportRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TestReportRecord))
		}
		var REPORT_CREATE_info transport.ServiceInfo
		if h.Interceptor != nil {
			REPORT_CREATE_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "REPORT_CREATE", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, REPORT_CREATE_info)
				}
				r = r.WithContext(ctx)
				var in TestReportRecord
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ProjectID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_REPORT_GET := func(method, path string, fn func(context.Context, *TestReportRecord) (*GetTestReportRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*TestReportRecord))
		}
		var REPORT_GET_info transport.ServiceInfo
		if h.Interceptor != nil {
			REPORT_GET_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "REPORT_GET", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, REPORT_GET_info)
				}
				r = r.WithContext(ctx)
				var in TestReportRecord
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ProjectID = val
						case "ID":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.ID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SCENE_SET_IMPORT := func(method, path string, fn func(context.Context, *AutoTestSceneSetImportRequest) (*AutoTestSceneSetImportResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestSceneSetImportRequest))
		}
		var SCENE_SET_IMPORT_info transport.ServiceInfo
		if h.Interceptor != nil {
			SCENE_SET_IMPORT_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "SCENE_SET_IMPORT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SCENE_SET_IMPORT_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestSceneSetImportRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SPACE_EXPORT := func(method, path string, fn func(context.Context, *AutoTestSpaceExportRequest) (*AutoTestSpaceExportResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestSpaceExportRequest))
		}
		var SPACE_EXPORT_info transport.ServiceInfo
		if h.Interceptor != nil {
			SPACE_EXPORT_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "SPACE_EXPORT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SPACE_EXPORT_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestSpaceExportRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SPACE_IMPORT := func(method, path string, fn func(context.Context, *AutoTestSpaceImportRequest) (*AutoTestSpaceImportResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AutoTestSpaceImportRequest))
		}
		var SPACE_IMPORT_info transport.ServiceInfo
		if h.Interceptor != nil {
			SPACE_IMPORT_info = transport.NewServiceInfo("erda.openapiv1.testplatform.testplatform_autotest", "SPACE_IMPORT", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SPACE_IMPORT_info)
				}
				r = r.WithContext(ctx)
				var in AutoTestSpaceImportRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ACTION_LOG_DOWNLOAD("GET", "/api/autotests/filetree/{inode}/actions/download-action-log", srv.ACTION_LOG_DOWNLOAD)
	add_ACTION_LOG_GET("GET", "/api/autotests/filetree/{inode}/actions/get-action-log", srv.ACTION_LOG_GET)
	add_AUTOTESTS_SCENES_CANCEL("POST", "/api/autotests/scenes/{sceneID}/actions/cancel", srv.AUTOTESTS_SCENES_CANCEL)
	add_AUTOTESTS_SCENES_EXECUTE("POST", "/api/autotests/scenes/{sceneID}/actions/execute", srv.AUTOTESTS_SCENES_EXECUTE)
	add_BATCH_QUERY_PIPELINE_SNIPPET_YAML("POST", "/api/autotests/pipeline-snippets/actions/batch-query-snippet-yml", srv.BATCH_QUERY_PIPELINE_SNIPPET_YAML)
	add_FILETREE_NODE_COPY("POST", "/api/autotests/filetree/{inode}/actions/copy", srv.FILETREE_NODE_COPY)
	add_FILETREE_NODE_CREATE("POST", "/api/autotests/filetree", srv.FILETREE_NODE_CREATE)
	add_FILETREE_NODE_DELETE("DELETE", "/api/autotests/filetree/{inode}", srv.FILETREE_NODE_DELETE)
	add_FILETREE_NODE_FIND_ANCESTORS("GET", "/api/autotests/filetree/{inode}/actions/find-ancestors", srv.FILETREE_NODE_FIND_ANCESTORS)
	add_FILETREE_NODE_FUZZY_SEARCH("GET", "/api/autotests/filetree/actions/fuzzy-search", srv.FILETREE_NODE_FUZZY_SEARCH)
	add_FILETREE_NODE_GET("GET", "/api/autotests/filetree/{inode}", srv.FILETREE_NODE_GET)
	add_FILETREE_NODE_HISTORY_LIST("GET", "/api/autotests/filetree/{inode}/actions/get-histories", srv.FILETREE_NODE_HISTORY_LIST)
	add_FILETREE_NODE_LIST("GET", "/api/autotests/filetree", srv.FILETREE_NODE_LIST)
	add_FILETREE_NODE_MOVE("POST", "/api/autotests/filetree/{inode}/actions/move", srv.FILETREE_NODE_MOVE)
	add_FILETREE_NODE_SAVE_PIPELINE("POST", "/api/autotests/filetree/{inode}/actions/save-pipeline", srv.FILETREE_NODE_SAVE_PIPELINE)
	add_FILETREE_NODE_UPDATE_BASIC_INFO("PUT", "/api/autotests/filetree/{inode}", srv.FILETREE_NODE_UPDATE_BASIC_INFO)
	add_GLOBAL_CONFIG_CREATE("POST", "/api/autotests/global-configs", srv.GLOBAL_CONFIG_CREATE)
	add_GLOBAL_CONFIG_DELETE("DELETE", "/api/autotests/global-configs/{ns}", srv.GLOBAL_CONFIG_DELETE)
	add_GLOBAL_CONFIG_LIST("GET", "/api/autotests/global-configs", srv.GLOBAL_CONFIG_LIST)
	add_GLOBAL_CONFIG_UPDATE("PUT", "/api/autotests/global-configs/{ns}", srv.GLOBAL_CONFIG_UPDATE)
	add_QA_REPORTSETS_LIST("GET", "/api/reportsets/{pipelineID}", srv.QA_REPORTSETS_LIST)
	add_QUERY_PIPELINE_SNIPPET_YAML("POST", "/api/autotests/pipeline-snippets/actions/query-snippet-yml", srv.QUERY_PIPELINE_SNIPPET_YAML)
	add_REPORT_CREATE("POST", "/api/projects/{projectID}/test-reports", srv.REPORT_CREATE)
	add_REPORT_GET("GET", "/api/projects/{projectID}/test-reports/{ID}", srv.REPORT_GET)
	add_SCENE_SET_IMPORT("POST", "/api/autotests/scenesets/actions/import", srv.SCENE_SET_IMPORT)
	add_SPACE_EXPORT("GET", "/api/autotests/spaces/actions/export", srv.SPACE_EXPORT)
	add_SPACE_IMPORT("POST", "/api/autotests/spaces/actions/import", srv.SPACE_IMPORT)
}
