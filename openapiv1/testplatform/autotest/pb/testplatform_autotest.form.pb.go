// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: testplatform_autotest.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*ACTION_LOG_DOWNLOAD_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ACTION_LOG_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AUTOTESTS_SCENES_CANCEL_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AUTOTESTS_SCENES_EXECUTE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestCaseSavePipelineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestCaseSavePipelineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfig)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfigCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfigCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfigDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfigDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfigListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfigListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfigUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestGlobalConfigUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestSceneSetImportRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestSceneSetImportResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestSpaceExportRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestSpaceExportResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestSpaceImportRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AutoTestSpaceImportResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateTestReportRecordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetTestReportRecordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineRunParam)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QA_REPORTSETS_LIST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestReportData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestReportRecord)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNode)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeCopyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeCopyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeFindAncestorsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeFindAncestorsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeFuzzySearchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeFuzzySearchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeGetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeHistorySearchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeMoveRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeMoveResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeUpdateBasicInfoRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnifiedFileTreeNodeUpdateBasicInfoResponse)(nil)

// ACTION_LOG_DOWNLOAD_Request implement urlenc.URLValuesUnmarshaler.
func (m *ACTION_LOG_DOWNLOAD_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			}
		}
	}
	return nil
}

// ACTION_LOG_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *ACTION_LOG_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			}
		}
	}
	return nil
}

// AUTOTESTS_SCENES_CANCEL_Request implement urlenc.URLValuesUnmarshaler.
func (m *AUTOTESTS_SCENES_CANCEL_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "sceneID":
				m.SceneID = vals[0]
			}
		}
	}
	return nil
}

// AUTOTESTS_SCENES_EXECUTE_Request implement urlenc.URLValuesUnmarshaler.
func (m *AUTOTESTS_SCENES_EXECUTE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "sceneID":
				m.SceneID = vals[0]
			}
		}
	}
	return nil
}

// AutoTestCaseSavePipelineRequest implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestCaseSavePipelineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "pipelineYml":
				m.PipelineYml = vals[0]
			}
		}
	}
	return nil
}

// AutoTestCaseSavePipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestCaseSavePipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AutoTestGlobalConfig implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfig) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "ns":
				m.Ns = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "creatorID":
				m.CreatorID = vals[0]
			case "updaterID":
				m.UpdaterID = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "aPIConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.APIConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.APIConfig = val
					} else {
						m.APIConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "uIConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.UIConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.UIConfig = val
					} else {
						m.UIConfig = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AutoTestGlobalConfigCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfigCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "aPIConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.APIConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.APIConfig = val
					} else {
						m.APIConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "uIConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.UIConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.UIConfig = val
					} else {
						m.UIConfig = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AutoTestGlobalConfigCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfigCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AutoTestGlobalConfigDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfigDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineCmsNs":
				m.PipelineCmsNs = vals[0]
			case "ns":
				m.Ns = vals[0]
			}
		}
	}
	return nil
}

// AutoTestGlobalConfigDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfigDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AutoTestGlobalConfigListRequest implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfigListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// AutoTestGlobalConfigListResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfigListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// AutoTestGlobalConfigUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfigUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineCmsNs":
				m.PipelineCmsNs = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "aPIConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.APIConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.APIConfig = val
					} else {
						m.APIConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "uIConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.UIConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.UIConfig = val
					} else {
						m.UIConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "ns":
				m.Ns = vals[0]
			}
		}
	}
	return nil
}

// AutoTestGlobalConfigUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestGlobalConfigUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AutoTestSceneSetImportRequest implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestSceneSetImportRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "spaceID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SpaceID = val
			case "fileType":
				m.FileType = vals[0]
			}
		}
	}
	return nil
}

// AutoTestSceneSetImportResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestSceneSetImportResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// AutoTestSpaceExportRequest implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestSpaceExportRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "locale":
				m.Locale = vals[0]
			case "isCopy":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsCopy = val
			case "fileType":
				m.FileType = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "spaceName":
				m.SpaceName = vals[0]
			}
		}
	}
	return nil
}

// AutoTestSpaceExportResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestSpaceExportResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// AutoTestSpaceImportRequest implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestSpaceImportRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "fileType":
				m.FileType = vals[0]
			}
		}
	}
	return nil
}

// AutoTestSpaceImportResponse implement urlenc.URLValuesUnmarshaler.
func (m *AutoTestSpaceImportResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// CreateTestReportRecordResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateTestReportRecordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetTestReportRecordResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetTestReportRecordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// PipelineRunParam implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRunParam) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "value":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Value = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Value = val
					} else {
						m.Value = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QA_REPORTSETS_LIST_Request implement urlenc.URLValuesUnmarshaler.
func (m *QA_REPORTSETS_LIST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineID":
				m.PipelineID = vals[0]
			}
		}
	}
	return nil
}

// TestReportData implement urlenc.URLValuesUnmarshaler.
func (m *TestReportData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueDashboard":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.IssueDashboard = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.IssueDashboard = val
					} else {
						m.IssueDashboard = structpb.NewStringValue(vals[0])
					}
				}
			case "testDashboard":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.TestDashboard = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.TestDashboard = val
					} else {
						m.TestDashboard = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// TestReportRecord implement urlenc.URLValuesUnmarshaler.
func (m *TestReportRecord) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "creatorID":
				m.CreatorID = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "name":
				m.Name = vals[0]
			case "summary":
				m.Summary = vals[0]
			case "qualityScore":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.QualityScore = val
			case "reportData":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ReportData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ReportData = val
					} else {
						m.ReportData = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UnifiedFileTreeNode implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNode) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "inode":
				m.Inode = vals[0]
			case "pinode":
				m.Pinode = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "creatorID":
				m.CreatorID = vals[0]
			case "updaterID":
				m.UpdaterID = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeCopyRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeCopyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "pinode":
				m.Pinode = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeCopyResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeCopyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "pinode":
				m.Pinode = vals[0]
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeFindAncestorsRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeFindAncestorsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeFindAncestorsResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeFindAncestorsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UnifiedFileTreeNodeFuzzySearchRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeFuzzySearchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "fromPinode":
				m.FromPinode = vals[0]
			case "recursive":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Recursive = val
			case "prefixFuzzy":
				m.PrefixFuzzy = vals[0]
			case "suffixFuzzy":
				m.SuffixFuzzy = vals[0]
			case "fuzzy":
				m.Fuzzy = vals[0]
			case "creatorID":
				m.CreatorID = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeFuzzySearchResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeFuzzySearchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UnifiedFileTreeNodeGetRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeGetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeHistorySearchRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeHistorySearchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeListRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "pinode":
				m.Pinode = vals[0]
			case "pipelineCategoryKey":
				m.PipelineCategoryKey = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeListResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UnifiedFileTreeNodeMoveRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeMoveRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "pinode":
				m.Pinode = vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeMoveResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeMoveResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeUpdateBasicInfoRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeUpdateBasicInfoRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "inode":
				m.Inode = vals[0]
			case "name":
				m.Name = &vals[0]
			case "desc":
				m.Desc = &vals[0]
			}
		}
	}
	return nil
}

// UnifiedFileTreeNodeUpdateBasicInfoResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnifiedFileTreeNodeUpdateBasicInfoResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}
