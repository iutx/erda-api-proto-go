// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: testplatform_testplan.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*AUTOTESTS_TESTPLAN_EXECUTE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AUTOTESTS_TESTPLAN_PAGING_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CANCEL_APITEST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*EXECUTE_APITEST_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GENERATE_REPORT_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlan)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanPagingRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanPagingResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanPagingResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanRelsCount)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanReportGenerateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanTestSetListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanTestSetsListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestSet)(nil)

// AUTOTESTS_TESTPLAN_EXECUTE_Request implement urlenc.URLValuesUnmarshaler.
func (m *AUTOTESTS_TESTPLAN_EXECUTE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "testPlanID":
				m.TestPlanID = vals[0]
			}
		}
	}
	return nil
}

// AUTOTESTS_TESTPLAN_PAGING_Request implement urlenc.URLValuesUnmarshaler.
func (m *AUTOTESTS_TESTPLAN_PAGING_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CANCEL_APITEST_Request implement urlenc.URLValuesUnmarshaler.
func (m *CANCEL_APITEST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "testPlanID":
				m.TestPlanID = vals[0]
			case "pipelineID":
				m.PipelineID = vals[0]
			}
		}
	}
	return nil
}

// DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// EXECUTE_APITEST_Request implement urlenc.URLValuesUnmarshaler.
func (m *EXECUTE_APITEST_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "testPlanID":
				m.TestPlanID = vals[0]
			}
		}
	}
	return nil
}

// GENERATE_REPORT_Request implement urlenc.URLValuesUnmarshaler.
func (m *GENERATE_REPORT_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "testPlanID":
				m.TestPlanID = vals[0]
			}
		}
	}
	return nil
}

// GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// TestPlan implement urlenc.URLValuesUnmarshaler.
func (m *TestPlan) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "ownerID":
				m.OwnerID = vals[0]
			case "partnerIDs":
				m.PartnerIDs = vals
			case "status":
				m.Status = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "creatorID":
				m.CreatorID = vals[0]
			case "updaterID":
				m.UpdaterID = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "summary":
				m.Summary = vals[0]
			case "startedAt":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
			case "startedAt.seconds":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartedAt.Seconds = val
			case "startedAt.nanos":
				if m.StartedAt == nil {
					m.StartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.StartedAt.Nanos = int32(val)
			case "endedAt":
				if m.EndedAt == nil {
					m.EndedAt = &timestamppb.Timestamp{}
				}
			case "endedAt.seconds":
				if m.EndedAt == nil {
					m.EndedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndedAt.Seconds = val
			case "endedAt.nanos":
				if m.EndedAt == nil {
					m.EndedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.EndedAt.Nanos = int32(val)
			case "relsCount":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.RelsCount = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.RelsCount = val
					} else {
						m.RelsCount = structpb.NewStringValue(vals[0])
					}
				}
			case "type":
				m.Type = vals[0]
			case "inode":
				m.Inode = vals[0]
			case "isArchived":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsArchived = val
			case "iterationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "iterationName":
				m.IterationName = vals[0]
			}
		}
	}
	return nil
}

// TestPlanCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "ownerID":
				m.OwnerID = vals[0]
			case "partnerIDs":
				m.PartnerIDs = vals
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "isAutoTest":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsAutoTest = val
			}
		}
	}
	return nil
}

// TestPlanCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// TestPlanGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// TestPlanPagingRequest implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanPagingRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "statuses":
				m.Statuses = vals
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IterationIDs = list
			case "type":
				m.Type = vals[0]
			case "isArchived":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsArchived = &val
			case "ownerIDs":
				m.OwnerIDs = vals
			case "partnerIDs":
				m.PartnerIDs = vals
			case "userIDs":
				m.UserIDs = vals
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// TestPlanPagingResponse implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanPagingResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// TestPlanPagingResponseData implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanPagingResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// TestPlanRelsCount implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanRelsCount) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			case "init":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Init = val
			case "succ":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Succ = val
			case "fail":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Fail = val
			case "block":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Block = val
			}
		}
	}
	return nil
}

// TestPlanReportGenerateResponse implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanReportGenerateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// TestPlanTestSetListResponse implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanTestSetListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// TestPlanTestSetsListRequest implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanTestSetsListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "testPlanID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TestPlanID = val
			case "parentTestSetID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ParentTestSetID = val
			}
		}
	}
	return nil
}

// TestPlanUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "ownerID":
				m.OwnerID = vals[0]
			case "partnerIDs":
				m.PartnerIDs = vals
			case "status":
				m.Status = vals[0]
			case "summary":
				m.Summary = vals[0]
			case "timestampSecStartedAt":
				if m.TimestampSecStartedAt == nil {
					m.TimestampSecStartedAt = &durationpb.Duration{}
				}
			case "timestampSecStartedAt.seconds":
				if m.TimestampSecStartedAt == nil {
					m.TimestampSecStartedAt = &durationpb.Duration{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimestampSecStartedAt.Seconds = val
			case "timestampSecStartedAt.nanos":
				if m.TimestampSecStartedAt == nil {
					m.TimestampSecStartedAt = &durationpb.Duration{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimestampSecStartedAt.Nanos = int32(val)
			case "timestampSecEndedAt":
				if m.TimestampSecEndedAt == nil {
					m.TimestampSecEndedAt = &durationpb.Duration{}
				}
			case "timestampSecEndedAt.seconds":
				if m.TimestampSecEndedAt == nil {
					m.TimestampSecEndedAt = &durationpb.Duration{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimestampSecEndedAt.Seconds = val
			case "timestampSecEndedAt.nanos":
				if m.TimestampSecEndedAt == nil {
					m.TimestampSecEndedAt = &durationpb.Duration{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimestampSecEndedAt.Nanos = int32(val)
			case "testPlanID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TestPlanID = val
			case "isArchived":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsArchived = &val
			case "iterationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			}
		}
	}
	return nil
}

// TestSet implement urlenc.URLValuesUnmarshaler.
func (m *TestSet) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "parentID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ParentID = val
			case "recycled":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Recycled = val
			case "directory":
				m.Directory = vals[0]
			case "order":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Order = val
			case "creatorID":
				m.CreatorID = vals[0]
			case "updaterID":
				m.UpdaterID = vals[0]
			}
		}
	}
	return nil
}
