// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: testplatform_testcase.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GET_Request with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GET_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GET_Request with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GET_RequestMultiError, or
// nil if none found.
func (m *GET_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *GET_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TestCaseID

	if len(errors) > 0 {
		return GET_RequestMultiError(errors)
	}

	return nil
}

// GET_RequestMultiError is an error wrapping multiple validation errors
// returned by GET_Request.ValidateAll() if the designated constraints aren't met.
type GET_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GET_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GET_RequestMultiError) AllErrors() []error { return m }

// GET_RequestValidationError is the validation error returned by
// GET_Request.Validate if the designated constraints aren't met.
type GET_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GET_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GET_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GET_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GET_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GET_RequestValidationError) ErrorName() string { return "GET_RequestValidationError" }

// Error satisfies the builtin error interface
func (e GET_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGET_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GET_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GET_RequestValidationError{}

// Validate checks the field values on TestCaseBatchCleanFromRecycleBinRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *TestCaseBatchCleanFromRecycleBinRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TestCaseBatchCleanFromRecycleBinRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// TestCaseBatchCleanFromRecycleBinRequestMultiError, or nil if none found.
func (m *TestCaseBatchCleanFromRecycleBinRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseBatchCleanFromRecycleBinRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestCaseBatchCleanFromRecycleBinRequestMultiError(errors)
	}

	return nil
}

// TestCaseBatchCleanFromRecycleBinRequestMultiError is an error wrapping
// multiple validation errors returned by
// TestCaseBatchCleanFromRecycleBinRequest.ValidateAll() if the designated
// constraints aren't met.
type TestCaseBatchCleanFromRecycleBinRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseBatchCleanFromRecycleBinRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseBatchCleanFromRecycleBinRequestMultiError) AllErrors() []error { return m }

// TestCaseBatchCleanFromRecycleBinRequestValidationError is the validation
// error returned by TestCaseBatchCleanFromRecycleBinRequest.Validate if the
// designated constraints aren't met.
type TestCaseBatchCleanFromRecycleBinRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseBatchCleanFromRecycleBinRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseBatchCleanFromRecycleBinRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseBatchCleanFromRecycleBinRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseBatchCleanFromRecycleBinRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseBatchCleanFromRecycleBinRequestValidationError) ErrorName() string {
	return "TestCaseBatchCleanFromRecycleBinRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseBatchCleanFromRecycleBinRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseBatchCleanFromRecycleBinRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseBatchCleanFromRecycleBinRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseBatchCleanFromRecycleBinRequestValidationError{}

// Validate checks the field values on TestCaseBatchCleanFromRecycleBinResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *TestCaseBatchCleanFromRecycleBinResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TestCaseBatchCleanFromRecycleBinResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// TestCaseBatchCleanFromRecycleBinResponseMultiError, or nil if none found.
func (m *TestCaseBatchCleanFromRecycleBinResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseBatchCleanFromRecycleBinResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestCaseBatchCleanFromRecycleBinResponseMultiError(errors)
	}

	return nil
}

// TestCaseBatchCleanFromRecycleBinResponseMultiError is an error wrapping
// multiple validation errors returned by
// TestCaseBatchCleanFromRecycleBinResponse.ValidateAll() if the designated
// constraints aren't met.
type TestCaseBatchCleanFromRecycleBinResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseBatchCleanFromRecycleBinResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseBatchCleanFromRecycleBinResponseMultiError) AllErrors() []error { return m }

// TestCaseBatchCleanFromRecycleBinResponseValidationError is the validation
// error returned by TestCaseBatchCleanFromRecycleBinResponse.Validate if the
// designated constraints aren't met.
type TestCaseBatchCleanFromRecycleBinResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseBatchCleanFromRecycleBinResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseBatchCleanFromRecycleBinResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseBatchCleanFromRecycleBinResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseBatchCleanFromRecycleBinResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseBatchCleanFromRecycleBinResponseValidationError) ErrorName() string {
	return "TestCaseBatchCleanFromRecycleBinResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseBatchCleanFromRecycleBinResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseBatchCleanFromRecycleBinResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseBatchCleanFromRecycleBinResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseBatchCleanFromRecycleBinResponseValidationError{}

// Validate checks the field values on TestCaseBatchCopyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseBatchCopyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseBatchCopyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseBatchCopyRequestMultiError, or nil if none found.
func (m *TestCaseBatchCopyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseBatchCopyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CopyToTestSetID

	// no validation rules for ProjectID

	if len(errors) > 0 {
		return TestCaseBatchCopyRequestMultiError(errors)
	}

	return nil
}

// TestCaseBatchCopyRequestMultiError is an error wrapping multiple validation
// errors returned by TestCaseBatchCopyRequest.ValidateAll() if the designated
// constraints aren't met.
type TestCaseBatchCopyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseBatchCopyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseBatchCopyRequestMultiError) AllErrors() []error { return m }

// TestCaseBatchCopyRequestValidationError is the validation error returned by
// TestCaseBatchCopyRequest.Validate if the designated constraints aren't met.
type TestCaseBatchCopyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseBatchCopyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseBatchCopyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseBatchCopyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseBatchCopyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseBatchCopyRequestValidationError) ErrorName() string {
	return "TestCaseBatchCopyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseBatchCopyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseBatchCopyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseBatchCopyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseBatchCopyRequestValidationError{}

// Validate checks the field values on TestCaseBatchCopyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseBatchCopyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseBatchCopyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseBatchCopyResponseMultiError, or nil if none found.
func (m *TestCaseBatchCopyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseBatchCopyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestCaseBatchCopyResponseMultiError(errors)
	}

	return nil
}

// TestCaseBatchCopyResponseMultiError is an error wrapping multiple validation
// errors returned by TestCaseBatchCopyResponse.ValidateAll() if the
// designated constraints aren't met.
type TestCaseBatchCopyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseBatchCopyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseBatchCopyResponseMultiError) AllErrors() []error { return m }

// TestCaseBatchCopyResponseValidationError is the validation error returned by
// TestCaseBatchCopyResponse.Validate if the designated constraints aren't met.
type TestCaseBatchCopyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseBatchCopyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseBatchCopyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseBatchCopyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseBatchCopyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseBatchCopyResponseValidationError) ErrorName() string {
	return "TestCaseBatchCopyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseBatchCopyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseBatchCopyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseBatchCopyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseBatchCopyResponseValidationError{}

// Validate checks the field values on TestCaseBatchUpdateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseBatchUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseBatchUpdateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseBatchUpdateRequestMultiError, or nil if none found.
func (m *TestCaseBatchUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseBatchUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Priority

	if m.Recycled != nil {
		// no validation rules for Recycled
	}

	if m.MoveToTestSetID != nil {
		// no validation rules for MoveToTestSetID
	}

	if len(errors) > 0 {
		return TestCaseBatchUpdateRequestMultiError(errors)
	}

	return nil
}

// TestCaseBatchUpdateRequestMultiError is an error wrapping multiple
// validation errors returned by TestCaseBatchUpdateRequest.ValidateAll() if
// the designated constraints aren't met.
type TestCaseBatchUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseBatchUpdateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseBatchUpdateRequestMultiError) AllErrors() []error { return m }

// TestCaseBatchUpdateRequestValidationError is the validation error returned
// by TestCaseBatchUpdateRequest.Validate if the designated constraints aren't met.
type TestCaseBatchUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseBatchUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseBatchUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseBatchUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseBatchUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseBatchUpdateRequestValidationError) ErrorName() string {
	return "TestCaseBatchUpdateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseBatchUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseBatchUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseBatchUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseBatchUpdateRequestValidationError{}

// Validate checks the field values on TestCaseBatchUpdateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseBatchUpdateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseBatchUpdateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseBatchUpdateResponseMultiError, or nil if none found.
func (m *TestCaseBatchUpdateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseBatchUpdateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return TestCaseBatchUpdateResponseMultiError(errors)
	}

	return nil
}

// TestCaseBatchUpdateResponseMultiError is an error wrapping multiple
// validation errors returned by TestCaseBatchUpdateResponse.ValidateAll() if
// the designated constraints aren't met.
type TestCaseBatchUpdateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseBatchUpdateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseBatchUpdateResponseMultiError) AllErrors() []error { return m }

// TestCaseBatchUpdateResponseValidationError is the validation error returned
// by TestCaseBatchUpdateResponse.Validate if the designated constraints
// aren't met.
type TestCaseBatchUpdateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseBatchUpdateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseBatchUpdateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseBatchUpdateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseBatchUpdateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseBatchUpdateResponseValidationError) ErrorName() string {
	return "TestCaseBatchUpdateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseBatchUpdateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseBatchUpdateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseBatchUpdateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseBatchUpdateResponseValidationError{}

// Validate checks the field values on TestCaseCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseCreateRequestMultiError, or nil if none found.
func (m *TestCaseCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for TestSetID

	// no validation rules for Name

	// no validation rules for PreCondition

	for idx, item := range m.GetStepAndResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCaseCreateRequestValidationError{
						field:  fmt.Sprintf("StepAndResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCaseCreateRequestValidationError{
						field:  fmt.Sprintf("StepAndResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCaseCreateRequestValidationError{
					field:  fmt.Sprintf("StepAndResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAPIs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCaseCreateRequestValidationError{
						field:  fmt.Sprintf("APIs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCaseCreateRequestValidationError{
						field:  fmt.Sprintf("APIs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCaseCreateRequestValidationError{
					field:  fmt.Sprintf("APIs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Desc

	// no validation rules for Priority

	if len(errors) > 0 {
		return TestCaseCreateRequestMultiError(errors)
	}

	return nil
}

// TestCaseCreateRequestMultiError is an error wrapping multiple validation
// errors returned by TestCaseCreateRequest.ValidateAll() if the designated
// constraints aren't met.
type TestCaseCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseCreateRequestMultiError) AllErrors() []error { return m }

// TestCaseCreateRequestValidationError is the validation error returned by
// TestCaseCreateRequest.Validate if the designated constraints aren't met.
type TestCaseCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseCreateRequestValidationError) ErrorName() string {
	return "TestCaseCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseCreateRequestValidationError{}

// Validate checks the field values on TestCaseCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseCreateResponseMultiError, or nil if none found.
func (m *TestCaseCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return TestCaseCreateResponseMultiError(errors)
	}

	return nil
}

// TestCaseCreateResponseMultiError is an error wrapping multiple validation
// errors returned by TestCaseCreateResponse.ValidateAll() if the designated
// constraints aren't met.
type TestCaseCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseCreateResponseMultiError) AllErrors() []error { return m }

// TestCaseCreateResponseValidationError is the validation error returned by
// TestCaseCreateResponse.Validate if the designated constraints aren't met.
type TestCaseCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseCreateResponseValidationError) ErrorName() string {
	return "TestCaseCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseCreateResponseValidationError{}

// Validate checks the field values on TestCaseExportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseExportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseExportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseExportRequestMultiError, or nil if none found.
func (m *TestCaseExportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseExportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTestCasePagingRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestCaseExportRequestValidationError{
					field:  "TestCasePagingRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestCaseExportRequestValidationError{
					field:  "TestCasePagingRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTestCasePagingRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestCaseExportRequestValidationError{
				field:  "TestCasePagingRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FileType

	// no validation rules for Locale

	if len(errors) > 0 {
		return TestCaseExportRequestMultiError(errors)
	}

	return nil
}

// TestCaseExportRequestMultiError is an error wrapping multiple validation
// errors returned by TestCaseExportRequest.ValidateAll() if the designated
// constraints aren't met.
type TestCaseExportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseExportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseExportRequestMultiError) AllErrors() []error { return m }

// TestCaseExportRequestValidationError is the validation error returned by
// TestCaseExportRequest.Validate if the designated constraints aren't met.
type TestCaseExportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseExportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseExportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseExportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseExportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseExportRequestValidationError) ErrorName() string {
	return "TestCaseExportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseExportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseExportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseExportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseExportRequestValidationError{}

// Validate checks the field values on TestCaseExportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseExportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseExportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseExportResponseMultiError, or nil if none found.
func (m *TestCaseExportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseExportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return TestCaseExportResponseMultiError(errors)
	}

	return nil
}

// TestCaseExportResponseMultiError is an error wrapping multiple validation
// errors returned by TestCaseExportResponse.ValidateAll() if the designated
// constraints aren't met.
type TestCaseExportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseExportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseExportResponseMultiError) AllErrors() []error { return m }

// TestCaseExportResponseValidationError is the validation error returned by
// TestCaseExportResponse.Validate if the designated constraints aren't met.
type TestCaseExportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseExportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseExportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseExportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseExportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseExportResponseValidationError) ErrorName() string {
	return "TestCaseExportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseExportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseExportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseExportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseExportResponseValidationError{}

// Validate checks the field values on TestCaseGetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseGetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseGetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseGetResponseMultiError, or nil if none found.
func (m *TestCaseGetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseGetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCaseGetResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCaseGetResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCaseGetResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestCaseGetResponseMultiError(errors)
	}

	return nil
}

// TestCaseGetResponseMultiError is an error wrapping multiple validation
// errors returned by TestCaseGetResponse.ValidateAll() if the designated
// constraints aren't met.
type TestCaseGetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseGetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseGetResponseMultiError) AllErrors() []error { return m }

// TestCaseGetResponseValidationError is the validation error returned by
// TestCaseGetResponse.Validate if the designated constraints aren't met.
type TestCaseGetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseGetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseGetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseGetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseGetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseGetResponseValidationError) ErrorName() string {
	return "TestCaseGetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseGetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseGetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseGetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseGetResponseValidationError{}

// Validate checks the field values on TestCaseImportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseImportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseImportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseImportRequestMultiError, or nil if none found.
func (m *TestCaseImportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseImportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TestSetID

	// no validation rules for ProjectID

	// no validation rules for FileType

	if len(errors) > 0 {
		return TestCaseImportRequestMultiError(errors)
	}

	return nil
}

// TestCaseImportRequestMultiError is an error wrapping multiple validation
// errors returned by TestCaseImportRequest.ValidateAll() if the designated
// constraints aren't met.
type TestCaseImportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseImportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseImportRequestMultiError) AllErrors() []error { return m }

// TestCaseImportRequestValidationError is the validation error returned by
// TestCaseImportRequest.Validate if the designated constraints aren't met.
type TestCaseImportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseImportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseImportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseImportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseImportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseImportRequestValidationError) ErrorName() string {
	return "TestCaseImportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseImportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseImportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseImportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseImportRequestValidationError{}

// Validate checks the field values on TestCaseImportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseImportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseImportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseImportResponseMultiError, or nil if none found.
func (m *TestCaseImportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseImportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCaseImportResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCaseImportResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCaseImportResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestCaseImportResponseMultiError(errors)
	}

	return nil
}

// TestCaseImportResponseMultiError is an error wrapping multiple validation
// errors returned by TestCaseImportResponse.ValidateAll() if the designated
// constraints aren't met.
type TestCaseImportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseImportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseImportResponseMultiError) AllErrors() []error { return m }

// TestCaseImportResponseValidationError is the validation error returned by
// TestCaseImportResponse.Validate if the designated constraints aren't met.
type TestCaseImportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseImportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseImportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseImportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseImportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseImportResponseValidationError) ErrorName() string {
	return "TestCaseImportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseImportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseImportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseImportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseImportResponseValidationError{}

// Validate checks the field values on TestCasePagingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCasePagingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCasePagingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCasePagingRequestMultiError, or nil if none found.
func (m *TestCasePagingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCasePagingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNo

	// no validation rules for PageSize

	// no validation rules for ProjectID

	// no validation rules for TestSetID

	// no validation rules for NoSubTestSet

	{
		sorted_keys := make([]uint64, len(m.GetTestSetCaseMap()))
		i := 0
		for key := range m.GetTestSetCaseMap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTestSetCaseMap()[key]
			_ = val

			// no validation rules for TestSetCaseMap[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TestCasePagingRequestValidationError{
							field:  fmt.Sprintf("TestSetCaseMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TestCasePagingRequestValidationError{
							field:  fmt.Sprintf("TestSetCaseMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TestCasePagingRequestValidationError{
						field:  fmt.Sprintf("TestSetCaseMap[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Query

	// no validation rules for Recycled

	if m.TimestampSecUpdatedAtBegin != nil {

		if all {
			switch v := interface{}(m.GetTimestampSecUpdatedAtBegin()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCasePagingRequestValidationError{
						field:  "TimestampSecUpdatedAtBegin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCasePagingRequestValidationError{
						field:  "TimestampSecUpdatedAtBegin",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimestampSecUpdatedAtBegin()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCasePagingRequestValidationError{
					field:  "TimestampSecUpdatedAtBegin",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TimestampSecUpdatedAtEnd != nil {

		if all {
			switch v := interface{}(m.GetTimestampSecUpdatedAtEnd()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCasePagingRequestValidationError{
						field:  "TimestampSecUpdatedAtEnd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCasePagingRequestValidationError{
						field:  "TimestampSecUpdatedAtEnd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimestampSecUpdatedAtEnd()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCasePagingRequestValidationError{
					field:  "TimestampSecUpdatedAtEnd",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAtBeginInclude != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAtBeginInclude()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCasePagingRequestValidationError{
						field:  "UpdatedAtBeginInclude",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCasePagingRequestValidationError{
						field:  "UpdatedAtBeginInclude",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAtBeginInclude()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCasePagingRequestValidationError{
					field:  "UpdatedAtBeginInclude",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAtEndInclude != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAtEndInclude()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCasePagingRequestValidationError{
						field:  "UpdatedAtEndInclude",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCasePagingRequestValidationError{
						field:  "UpdatedAtEndInclude",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAtEndInclude()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCasePagingRequestValidationError{
					field:  "UpdatedAtEndInclude",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.OrderByPriorityAsc != nil {
		// no validation rules for OrderByPriorityAsc
	}

	if m.OrderByPriorityDesc != nil {
		// no validation rules for OrderByPriorityDesc
	}

	if m.OrderByUpdaterIDAsc != nil {
		// no validation rules for OrderByUpdaterIDAsc
	}

	if m.OrderByUpdaterIDDesc != nil {
		// no validation rules for OrderByUpdaterIDDesc
	}

	if m.OrderByUpdatedAtAsc != nil {
		// no validation rules for OrderByUpdatedAtAsc
	}

	if m.OrderByUpdatedAtDesc != nil {
		// no validation rules for OrderByUpdatedAtDesc
	}

	if m.OrderByIDAsc != nil {
		// no validation rules for OrderByIDAsc
	}

	if m.OrderByIDDesc != nil {
		// no validation rules for OrderByIDDesc
	}

	if m.OrderByTestSetIDAsc != nil {
		// no validation rules for OrderByTestSetIDAsc
	}

	if m.OrderByTestSetIDDesc != nil {
		// no validation rules for OrderByTestSetIDDesc
	}

	if m.OrderByTestSetNameAsc != nil {
		// no validation rules for OrderByTestSetNameAsc
	}

	if m.OrderByTestSetNameDesc != nil {
		// no validation rules for OrderByTestSetNameDesc
	}

	if len(errors) > 0 {
		return TestCasePagingRequestMultiError(errors)
	}

	return nil
}

// TestCasePagingRequestMultiError is an error wrapping multiple validation
// errors returned by TestCasePagingRequest.ValidateAll() if the designated
// constraints aren't met.
type TestCasePagingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCasePagingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCasePagingRequestMultiError) AllErrors() []error { return m }

// TestCasePagingRequestValidationError is the validation error returned by
// TestCasePagingRequest.Validate if the designated constraints aren't met.
type TestCasePagingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCasePagingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCasePagingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCasePagingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCasePagingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCasePagingRequestValidationError) ErrorName() string {
	return "TestCasePagingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCasePagingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCasePagingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCasePagingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCasePagingRequestValidationError{}

// Validate checks the field values on TestCasePagingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCasePagingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCasePagingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCasePagingResponseMultiError, or nil if none found.
func (m *TestCasePagingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCasePagingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCasePagingResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCasePagingResponseValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCasePagingResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestCasePagingResponseMultiError(errors)
	}

	return nil
}

// TestCasePagingResponseMultiError is an error wrapping multiple validation
// errors returned by TestCasePagingResponse.ValidateAll() if the designated
// constraints aren't met.
type TestCasePagingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCasePagingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCasePagingResponseMultiError) AllErrors() []error { return m }

// TestCasePagingResponseValidationError is the validation error returned by
// TestCasePagingResponse.Validate if the designated constraints aren't met.
type TestCasePagingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCasePagingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCasePagingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCasePagingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCasePagingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCasePagingResponseValidationError) ErrorName() string {
	return "TestCasePagingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCasePagingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCasePagingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCasePagingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCasePagingResponseValidationError{}

// Validate checks the field values on TestCaseStepAndResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseStepAndResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseStepAndResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseStepAndResultMultiError, or nil if none found.
func (m *TestCaseStepAndResult) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseStepAndResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Step

	// no validation rules for Result

	if len(errors) > 0 {
		return TestCaseStepAndResultMultiError(errors)
	}

	return nil
}

// TestCaseStepAndResultMultiError is an error wrapping multiple validation
// errors returned by TestCaseStepAndResult.ValidateAll() if the designated
// constraints aren't met.
type TestCaseStepAndResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseStepAndResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseStepAndResultMultiError) AllErrors() []error { return m }

// TestCaseStepAndResultValidationError is the validation error returned by
// TestCaseStepAndResult.Validate if the designated constraints aren't met.
type TestCaseStepAndResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseStepAndResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseStepAndResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseStepAndResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseStepAndResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseStepAndResultValidationError) ErrorName() string {
	return "TestCaseStepAndResultValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseStepAndResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseStepAndResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseStepAndResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseStepAndResultValidationError{}

// Validate checks the field values on TestCaseUpdateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseUpdateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseUpdateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseUpdateRequestMultiError, or nil if none found.
func (m *TestCaseUpdateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseUpdateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for Name

	// no validation rules for Priority

	// no validation rules for PreCondition

	for idx, item := range m.GetStepAndResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCaseUpdateRequestValidationError{
						field:  fmt.Sprintf("StepAndResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCaseUpdateRequestValidationError{
						field:  fmt.Sprintf("StepAndResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCaseUpdateRequestValidationError{
					field:  fmt.Sprintf("StepAndResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAPIs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCaseUpdateRequestValidationError{
						field:  fmt.Sprintf("APIs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCaseUpdateRequestValidationError{
						field:  fmt.Sprintf("APIs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCaseUpdateRequestValidationError{
					field:  fmt.Sprintf("APIs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Desc

	// no validation rules for TestCaseID

	if len(errors) > 0 {
		return TestCaseUpdateRequestMultiError(errors)
	}

	return nil
}

// TestCaseUpdateRequestMultiError is an error wrapping multiple validation
// errors returned by TestCaseUpdateRequest.ValidateAll() if the designated
// constraints aren't met.
type TestCaseUpdateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseUpdateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseUpdateRequestMultiError) AllErrors() []error { return m }

// TestCaseUpdateRequestValidationError is the validation error returned by
// TestCaseUpdateRequest.Validate if the designated constraints aren't met.
type TestCaseUpdateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseUpdateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseUpdateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseUpdateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseUpdateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseUpdateRequestValidationError) ErrorName() string {
	return "TestCaseUpdateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseUpdateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseUpdateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseUpdateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseUpdateRequestValidationError{}

// Validate checks the field values on TestCaseUpdateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCaseUpdateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseUpdateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseUpdateResponseMultiError, or nil if none found.
func (m *TestCaseUpdateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseUpdateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestCaseUpdateResponseMultiError(errors)
	}

	return nil
}

// TestCaseUpdateResponseMultiError is an error wrapping multiple validation
// errors returned by TestCaseUpdateResponse.ValidateAll() if the designated
// constraints aren't met.
type TestCaseUpdateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseUpdateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseUpdateResponseMultiError) AllErrors() []error { return m }

// TestCaseUpdateResponseValidationError is the validation error returned by
// TestCaseUpdateResponse.Validate if the designated constraints aren't met.
type TestCaseUpdateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseUpdateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseUpdateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseUpdateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseUpdateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseUpdateResponseValidationError) ErrorName() string {
	return "TestCaseUpdateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCaseUpdateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseUpdateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseUpdateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseUpdateResponseValidationError{}
