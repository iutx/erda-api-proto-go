// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: elf.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DependencyPackageList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DependencyPackageList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependencyPackageList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DependencyPackageListMultiError, or nil if none found.
func (m *DependencyPackageList) ValidateAll() error {
	return m.validate(true)
}

func (m *DependencyPackageList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetListMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependencyPackageListValidationError{
					field:  "ListMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependencyPackageListValidationError{
					field:  "ListMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetListMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependencyPackageListValidationError{
				field:  "ListMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDependencyPackageSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependencyPackageListValidationError{
					field:  "DependencyPackageSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependencyPackageListValidationError{
					field:  "DependencyPackageSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDependencyPackageSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependencyPackageListValidationError{
				field:  "DependencyPackageSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DependencyPackageListMultiError(errors)
	}

	return nil
}

// DependencyPackageListMultiError is an error wrapping multiple validation
// errors returned by DependencyPackageList.ValidateAll() if the designated
// constraints aren't met.
type DependencyPackageListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependencyPackageListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependencyPackageListMultiError) AllErrors() []error { return m }

// DependencyPackageListValidationError is the validation error returned by
// DependencyPackageList.Validate if the designated constraints aren't met.
type DependencyPackageListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependencyPackageListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependencyPackageListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependencyPackageListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependencyPackageListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependencyPackageListValidationError) ErrorName() string {
	return "DependencyPackageListValidationError"
}

// Error satisfies the builtin error interface
func (e DependencyPackageListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependencyPackageList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependencyPackageListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependencyPackageListValidationError{}

// Validate checks the field values on DependencyPackageListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DependencyPackageListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependencyPackageListResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DependencyPackageListResponseMultiError, or nil if none found.
func (m *DependencyPackageListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DependencyPackageListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DependencyPackageListResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DependencyPackageListResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DependencyPackageListResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DependencyPackageListResponseMultiError(errors)
	}

	return nil
}

// DependencyPackageListResponseMultiError is an error wrapping multiple
// validation errors returned by DependencyPackageListResponse.ValidateAll()
// if the designated constraints aren't met.
type DependencyPackageListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependencyPackageListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependencyPackageListResponseMultiError) AllErrors() []error { return m }

// DependencyPackageListResponseValidationError is the validation error
// returned by DependencyPackageListResponse.Validate if the designated
// constraints aren't met.
type DependencyPackageListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependencyPackageListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependencyPackageListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependencyPackageListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependencyPackageListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependencyPackageListResponseValidationError) ErrorName() string {
	return "DependencyPackageListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DependencyPackageListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependencyPackageListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependencyPackageListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependencyPackageListResponseValidationError{}

// Validate checks the field values on DependencyPackageSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DependencyPackageSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependencyPackageSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DependencyPackageSpecMultiError, or nil if none found.
func (m *DependencyPackageSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *DependencyPackageSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DependencyPackageSpecValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DependencyPackageSpecValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DependencyPackageSpecValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DependencyPackageSpecMultiError(errors)
	}

	return nil
}

// DependencyPackageSpecMultiError is an error wrapping multiple validation
// errors returned by DependencyPackageSpec.ValidateAll() if the designated
// constraints aren't met.
type DependencyPackageSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependencyPackageSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependencyPackageSpecMultiError) AllErrors() []error { return m }

// DependencyPackageSpecValidationError is the validation error returned by
// DependencyPackageSpec.Validate if the designated constraints aren't met.
type DependencyPackageSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependencyPackageSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependencyPackageSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependencyPackageSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependencyPackageSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependencyPackageSpecValidationError) ErrorName() string {
	return "DependencyPackageSpecValidationError"
}

// Error satisfies the builtin error interface
func (e DependencyPackageSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependencyPackageSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependencyPackageSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependencyPackageSpecValidationError{}

// Validate checks the field values on DependencyPackageType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DependencyPackageType) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependencyPackageType with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DependencyPackageTypeMultiError, or nil if none found.
func (m *DependencyPackageType) ValidateAll() error {
	return m.validate(true)
}

func (m *DependencyPackageType) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	for idx, item := range m.GetPackages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DependencyPackageTypeValidationError{
						field:  fmt.Sprintf("Packages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DependencyPackageTypeValidationError{
						field:  fmt.Sprintf("Packages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DependencyPackageTypeValidationError{
					field:  fmt.Sprintf("Packages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DependencyPackageTypeMultiError(errors)
	}

	return nil
}

// DependencyPackageTypeMultiError is an error wrapping multiple validation
// errors returned by DependencyPackageType.ValidateAll() if the designated
// constraints aren't met.
type DependencyPackageTypeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependencyPackageTypeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependencyPackageTypeMultiError) AllErrors() []error { return m }

// DependencyPackageTypeValidationError is the validation error returned by
// DependencyPackageType.Validate if the designated constraints aren't met.
type DependencyPackageTypeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependencyPackageTypeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependencyPackageTypeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependencyPackageTypeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependencyPackageTypeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependencyPackageTypeValidationError) ErrorName() string {
	return "DependencyPackageTypeValidationError"
}

// Error satisfies the builtin error interface
func (e DependencyPackageTypeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependencyPackageType.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependencyPackageTypeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependencyPackageTypeValidationError{}

// Validate checks the field values on DependencyPackageTypeItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DependencyPackageTypeItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependencyPackageTypeItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DependencyPackageTypeItemMultiError, or nil if none found.
func (m *DependencyPackageTypeItem) ValidateAll() error {
	return m.validate(true)
}

func (m *DependencyPackageTypeItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return DependencyPackageTypeItemMultiError(errors)
	}

	return nil
}

// DependencyPackageTypeItemMultiError is an error wrapping multiple validation
// errors returned by DependencyPackageTypeItem.ValidateAll() if the
// designated constraints aren't met.
type DependencyPackageTypeItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependencyPackageTypeItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependencyPackageTypeItemMultiError) AllErrors() []error { return m }

// DependencyPackageTypeItemValidationError is the validation error returned by
// DependencyPackageTypeItem.Validate if the designated constraints aren't met.
type DependencyPackageTypeItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependencyPackageTypeItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependencyPackageTypeItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependencyPackageTypeItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependencyPackageTypeItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependencyPackageTypeItemValidationError) ErrorName() string {
	return "DependencyPackageTypeItemValidationError"
}

// Error satisfies the builtin error interface
func (e DependencyPackageTypeItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependencyPackageTypeItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependencyPackageTypeItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependencyPackageTypeItemValidationError{}

// Validate checks the field values on ELF_ENVIROMENT_DELETE_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ELF_ENVIROMENT_DELETE_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ELF_ENVIROMENT_DELETE_Request with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ELF_ENVIROMENT_DELETE_RequestMultiError, or nil if none found.
func (m *ELF_ENVIROMENT_DELETE_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ELF_ENVIROMENT_DELETE_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ELF_ENVIROMENT_DELETE_RequestMultiError(errors)
	}

	return nil
}

// ELF_ENVIROMENT_DELETE_RequestMultiError is an error wrapping multiple
// validation errors returned by ELF_ENVIROMENT_DELETE_Request.ValidateAll()
// if the designated constraints aren't met.
type ELF_ENVIROMENT_DELETE_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ELF_ENVIROMENT_DELETE_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ELF_ENVIROMENT_DELETE_RequestMultiError) AllErrors() []error { return m }

// ELF_ENVIROMENT_DELETE_RequestValidationError is the validation error
// returned by ELF_ENVIROMENT_DELETE_Request.Validate if the designated
// constraints aren't met.
type ELF_ENVIROMENT_DELETE_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ELF_ENVIROMENT_DELETE_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ELF_ENVIROMENT_DELETE_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ELF_ENVIROMENT_DELETE_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ELF_ENVIROMENT_DELETE_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ELF_ENVIROMENT_DELETE_RequestValidationError) ErrorName() string {
	return "ELF_ENVIROMENT_DELETE_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ELF_ENVIROMENT_DELETE_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sELF_ENVIROMENT_DELETE_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ELF_ENVIROMENT_DELETE_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ELF_ENVIROMENT_DELETE_RequestValidationError{}

// Validate checks the field values on ELF_ENVIROMENT_GET_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ELF_ENVIROMENT_GET_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ELF_ENVIROMENT_GET_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ELF_ENVIROMENT_GET_RequestMultiError, or nil if none found.
func (m *ELF_ENVIROMENT_GET_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ELF_ENVIROMENT_GET_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ELF_ENVIROMENT_GET_RequestMultiError(errors)
	}

	return nil
}

// ELF_ENVIROMENT_GET_RequestMultiError is an error wrapping multiple
// validation errors returned by ELF_ENVIROMENT_GET_Request.ValidateAll() if
// the designated constraints aren't met.
type ELF_ENVIROMENT_GET_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ELF_ENVIROMENT_GET_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ELF_ENVIROMENT_GET_RequestMultiError) AllErrors() []error { return m }

// ELF_ENVIROMENT_GET_RequestValidationError is the validation error returned
// by ELF_ENVIROMENT_GET_Request.Validate if the designated constraints aren't met.
type ELF_ENVIROMENT_GET_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ELF_ENVIROMENT_GET_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ELF_ENVIROMENT_GET_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ELF_ENVIROMENT_GET_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ELF_ENVIROMENT_GET_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ELF_ENVIROMENT_GET_RequestValidationError) ErrorName() string {
	return "ELF_ENVIROMENT_GET_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ELF_ENVIROMENT_GET_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sELF_ENVIROMENT_GET_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ELF_ENVIROMENT_GET_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ELF_ENVIROMENT_GET_RequestValidationError{}

// Validate checks the field values on ELF_ENVIROMENT_LIST_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ELF_ENVIROMENT_LIST_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ELF_ENVIROMENT_LIST_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ELF_ENVIROMENT_LIST_RequestMultiError, or nil if none found.
func (m *ELF_ENVIROMENT_LIST_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ELF_ENVIROMENT_LIST_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ELF_ENVIROMENT_LIST_RequestMultiError(errors)
	}

	return nil
}

// ELF_ENVIROMENT_LIST_RequestMultiError is an error wrapping multiple
// validation errors returned by ELF_ENVIROMENT_LIST_Request.ValidateAll() if
// the designated constraints aren't met.
type ELF_ENVIROMENT_LIST_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ELF_ENVIROMENT_LIST_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ELF_ENVIROMENT_LIST_RequestMultiError) AllErrors() []error { return m }

// ELF_ENVIROMENT_LIST_RequestValidationError is the validation error returned
// by ELF_ENVIROMENT_LIST_Request.Validate if the designated constraints
// aren't met.
type ELF_ENVIROMENT_LIST_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ELF_ENVIROMENT_LIST_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ELF_ENVIROMENT_LIST_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ELF_ENVIROMENT_LIST_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ELF_ENVIROMENT_LIST_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ELF_ENVIROMENT_LIST_RequestValidationError) ErrorName() string {
	return "ELF_ENVIROMENT_LIST_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ELF_ENVIROMENT_LIST_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sELF_ENVIROMENT_LIST_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ELF_ENVIROMENT_LIST_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ELF_ENVIROMENT_LIST_RequestValidationError{}

// Validate checks the field values on ELF_NOTEBOOK_DELETE_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ELF_NOTEBOOK_DELETE_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ELF_NOTEBOOK_DELETE_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ELF_NOTEBOOK_DELETE_RequestMultiError, or nil if none found.
func (m *ELF_NOTEBOOK_DELETE_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ELF_NOTEBOOK_DELETE_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ELF_NOTEBOOK_DELETE_RequestMultiError(errors)
	}

	return nil
}

// ELF_NOTEBOOK_DELETE_RequestMultiError is an error wrapping multiple
// validation errors returned by ELF_NOTEBOOK_DELETE_Request.ValidateAll() if
// the designated constraints aren't met.
type ELF_NOTEBOOK_DELETE_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ELF_NOTEBOOK_DELETE_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ELF_NOTEBOOK_DELETE_RequestMultiError) AllErrors() []error { return m }

// ELF_NOTEBOOK_DELETE_RequestValidationError is the validation error returned
// by ELF_NOTEBOOK_DELETE_Request.Validate if the designated constraints
// aren't met.
type ELF_NOTEBOOK_DELETE_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ELF_NOTEBOOK_DELETE_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ELF_NOTEBOOK_DELETE_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ELF_NOTEBOOK_DELETE_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ELF_NOTEBOOK_DELETE_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ELF_NOTEBOOK_DELETE_RequestValidationError) ErrorName() string {
	return "ELF_NOTEBOOK_DELETE_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ELF_NOTEBOOK_DELETE_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sELF_NOTEBOOK_DELETE_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ELF_NOTEBOOK_DELETE_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ELF_NOTEBOOK_DELETE_RequestValidationError{}

// Validate checks the field values on ELF_NOTEBOOK_GET_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ELF_NOTEBOOK_GET_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ELF_NOTEBOOK_GET_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ELF_NOTEBOOK_GET_RequestMultiError, or nil if none found.
func (m *ELF_NOTEBOOK_GET_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ELF_NOTEBOOK_GET_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ELF_NOTEBOOK_GET_RequestMultiError(errors)
	}

	return nil
}

// ELF_NOTEBOOK_GET_RequestMultiError is an error wrapping multiple validation
// errors returned by ELF_NOTEBOOK_GET_Request.ValidateAll() if the designated
// constraints aren't met.
type ELF_NOTEBOOK_GET_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ELF_NOTEBOOK_GET_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ELF_NOTEBOOK_GET_RequestMultiError) AllErrors() []error { return m }

// ELF_NOTEBOOK_GET_RequestValidationError is the validation error returned by
// ELF_NOTEBOOK_GET_Request.Validate if the designated constraints aren't met.
type ELF_NOTEBOOK_GET_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ELF_NOTEBOOK_GET_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ELF_NOTEBOOK_GET_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ELF_NOTEBOOK_GET_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ELF_NOTEBOOK_GET_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ELF_NOTEBOOK_GET_RequestValidationError) ErrorName() string {
	return "ELF_NOTEBOOK_GET_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ELF_NOTEBOOK_GET_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sELF_NOTEBOOK_GET_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ELF_NOTEBOOK_GET_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ELF_NOTEBOOK_GET_RequestValidationError{}

// Validate checks the field values on ELF_NOTEBOOK_LIST_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ELF_NOTEBOOK_LIST_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ELF_NOTEBOOK_LIST_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ELF_NOTEBOOK_LIST_RequestMultiError, or nil if none found.
func (m *ELF_NOTEBOOK_LIST_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ELF_NOTEBOOK_LIST_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ELF_NOTEBOOK_LIST_RequestMultiError(errors)
	}

	return nil
}

// ELF_NOTEBOOK_LIST_RequestMultiError is an error wrapping multiple validation
// errors returned by ELF_NOTEBOOK_LIST_Request.ValidateAll() if the
// designated constraints aren't met.
type ELF_NOTEBOOK_LIST_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ELF_NOTEBOOK_LIST_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ELF_NOTEBOOK_LIST_RequestMultiError) AllErrors() []error { return m }

// ELF_NOTEBOOK_LIST_RequestValidationError is the validation error returned by
// ELF_NOTEBOOK_LIST_Request.Validate if the designated constraints aren't met.
type ELF_NOTEBOOK_LIST_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ELF_NOTEBOOK_LIST_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ELF_NOTEBOOK_LIST_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ELF_NOTEBOOK_LIST_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ELF_NOTEBOOK_LIST_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ELF_NOTEBOOK_LIST_RequestValidationError) ErrorName() string {
	return "ELF_NOTEBOOK_LIST_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ELF_NOTEBOOK_LIST_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sELF_NOTEBOOK_LIST_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ELF_NOTEBOOK_LIST_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ELF_NOTEBOOK_LIST_RequestValidationError{}

// Validate checks the field values on ELF_PACKAGE_LIST_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ELF_PACKAGE_LIST_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ELF_PACKAGE_LIST_Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ELF_PACKAGE_LIST_RequestMultiError, or nil if none found.
func (m *ELF_PACKAGE_LIST_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *ELF_PACKAGE_LIST_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ELF_PACKAGE_LIST_RequestMultiError(errors)
	}

	return nil
}

// ELF_PACKAGE_LIST_RequestMultiError is an error wrapping multiple validation
// errors returned by ELF_PACKAGE_LIST_Request.ValidateAll() if the designated
// constraints aren't met.
type ELF_PACKAGE_LIST_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ELF_PACKAGE_LIST_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ELF_PACKAGE_LIST_RequestMultiError) AllErrors() []error { return m }

// ELF_PACKAGE_LIST_RequestValidationError is the validation error returned by
// ELF_PACKAGE_LIST_Request.Validate if the designated constraints aren't met.
type ELF_PACKAGE_LIST_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ELF_PACKAGE_LIST_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ELF_PACKAGE_LIST_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ELF_PACKAGE_LIST_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ELF_PACKAGE_LIST_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ELF_PACKAGE_LIST_RequestValidationError) ErrorName() string {
	return "ELF_PACKAGE_LIST_RequestValidationError"
}

// Error satisfies the builtin error interface
func (e ELF_PACKAGE_LIST_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sELF_PACKAGE_LIST_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ELF_PACKAGE_LIST_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ELF_PACKAGE_LIST_RequestValidationError{}

// Validate checks the field values on ElfMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ElfMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ElfMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ElfMetadataMultiError, or
// nil if none found.
func (m *ElfMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ElfMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ID

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Workspace

	// no validation rules for OwnerName

	// no validation rules for OwnerID

	// no validation rules for OrganizationID

	// no validation rules for OrganizationName

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ElfMetadataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ElfMetadataValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ElfMetadataValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ElfMetadataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ElfMetadataValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ElfMetadataValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ElfMetadataMultiError(errors)
	}

	return nil
}

// ElfMetadataMultiError is an error wrapping multiple validation errors
// returned by ElfMetadata.ValidateAll() if the designated constraints aren't met.
type ElfMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ElfMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ElfMetadataMultiError) AllErrors() []error { return m }

// ElfMetadataValidationError is the validation error returned by
// ElfMetadata.Validate if the designated constraints aren't met.
type ElfMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ElfMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ElfMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ElfMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ElfMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ElfMetadataValidationError) ErrorName() string { return "ElfMetadataValidationError" }

// Error satisfies the builtin error interface
func (e ElfMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sElfMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ElfMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ElfMetadataValidationError{}

// Validate checks the field values on ElfResource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ElfResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ElfResource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ElfResourceMultiError, or
// nil if none found.
func (m *ElfResource) ValidateAll() error {
	return m.validate(true)
}

func (m *ElfResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CPU

	// no validation rules for Memory

	if len(errors) > 0 {
		return ElfResourceMultiError(errors)
	}

	return nil
}

// ElfResourceMultiError is an error wrapping multiple validation errors
// returned by ElfResource.ValidateAll() if the designated constraints aren't met.
type ElfResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ElfResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ElfResourceMultiError) AllErrors() []error { return m }

// ElfResourceValidationError is the validation error returned by
// ElfResource.Validate if the designated constraints aren't met.
type ElfResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ElfResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ElfResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ElfResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ElfResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ElfResourceValidationError) ErrorName() string { return "ElfResourceValidationError" }

// Error satisfies the builtin error interface
func (e ElfResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sElfResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ElfResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ElfResourceValidationError{}

// Validate checks the field values on Environment with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Environment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Environment with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnvironmentMultiError, or
// nil if none found.
func (m *Environment) ValidateAll() error {
	return m.validate(true)
}

func (m *Environment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetElfMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnvironmentValidationError{
					field:  "ElfMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnvironmentValidationError{
					field:  "ElfMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetElfMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnvironmentValidationError{
				field:  "ElfMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnvironmentSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnvironmentValidationError{
					field:  "EnvironmentSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnvironmentValidationError{
					field:  "EnvironmentSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnvironmentSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnvironmentValidationError{
				field:  "EnvironmentSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnvironmentMultiError(errors)
	}

	return nil
}

// EnvironmentMultiError is an error wrapping multiple validation errors
// returned by Environment.ValidateAll() if the designated constraints aren't met.
type EnvironmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvironmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvironmentMultiError) AllErrors() []error { return m }

// EnvironmentValidationError is the validation error returned by
// Environment.Validate if the designated constraints aren't met.
type EnvironmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvironmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvironmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvironmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvironmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvironmentValidationError) ErrorName() string { return "EnvironmentValidationError" }

// Error satisfies the builtin error interface
func (e EnvironmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvironment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvironmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvironmentValidationError{}

// Validate checks the field values on EnvironmentList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnvironmentList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnvironmentList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnvironmentListMultiError, or nil if none found.
func (m *EnvironmentList) ValidateAll() error {
	return m.validate(true)
}

func (m *EnvironmentList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetListMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnvironmentListValidationError{
					field:  "ListMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnvironmentListValidationError{
					field:  "ListMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetListMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnvironmentListValidationError{
				field:  "ListMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnvironmentListSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnvironmentListValidationError{
					field:  "EnvironmentListSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnvironmentListValidationError{
					field:  "EnvironmentListSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnvironmentListSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnvironmentListValidationError{
				field:  "EnvironmentListSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnvironmentListMultiError(errors)
	}

	return nil
}

// EnvironmentListMultiError is an error wrapping multiple validation errors
// returned by EnvironmentList.ValidateAll() if the designated constraints
// aren't met.
type EnvironmentListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvironmentListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvironmentListMultiError) AllErrors() []error { return m }

// EnvironmentListValidationError is the validation error returned by
// EnvironmentList.Validate if the designated constraints aren't met.
type EnvironmentListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvironmentListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvironmentListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvironmentListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvironmentListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvironmentListValidationError) ErrorName() string { return "EnvironmentListValidationError" }

// Error satisfies the builtin error interface
func (e EnvironmentListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvironmentList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvironmentListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvironmentListValidationError{}

// Validate checks the field values on EnvironmentListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnvironmentListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnvironmentListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnvironmentListResponseMultiError, or nil if none found.
func (m *EnvironmentListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EnvironmentListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnvironmentListResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnvironmentListResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnvironmentListResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnvironmentListResponseMultiError(errors)
	}

	return nil
}

// EnvironmentListResponseMultiError is an error wrapping multiple validation
// errors returned by EnvironmentListResponse.ValidateAll() if the designated
// constraints aren't met.
type EnvironmentListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvironmentListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvironmentListResponseMultiError) AllErrors() []error { return m }

// EnvironmentListResponseValidationError is the validation error returned by
// EnvironmentListResponse.Validate if the designated constraints aren't met.
type EnvironmentListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvironmentListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvironmentListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvironmentListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvironmentListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvironmentListResponseValidationError) ErrorName() string {
	return "EnvironmentListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EnvironmentListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvironmentListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvironmentListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvironmentListResponseValidationError{}

// Validate checks the field values on EnvironmentListSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnvironmentListSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnvironmentListSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnvironmentListSpecMultiError, or nil if none found.
func (m *EnvironmentListSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *EnvironmentListSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnvironmentListSpecValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnvironmentListSpecValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnvironmentListSpecValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnvironmentListSpecMultiError(errors)
	}

	return nil
}

// EnvironmentListSpecMultiError is an error wrapping multiple validation
// errors returned by EnvironmentListSpec.ValidateAll() if the designated
// constraints aren't met.
type EnvironmentListSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvironmentListSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvironmentListSpecMultiError) AllErrors() []error { return m }

// EnvironmentListSpecValidationError is the validation error returned by
// EnvironmentListSpec.Validate if the designated constraints aren't met.
type EnvironmentListSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvironmentListSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvironmentListSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvironmentListSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvironmentListSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvironmentListSpecValidationError) ErrorName() string {
	return "EnvironmentListSpecValidationError"
}

// Error satisfies the builtin error interface
func (e EnvironmentListSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvironmentListSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvironmentListSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvironmentListSpecValidationError{}

// Validate checks the field values on EnvironmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnvironmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnvironmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnvironmentResponseMultiError, or nil if none found.
func (m *EnvironmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EnvironmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnvironmentResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnvironmentResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnvironmentResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EnvironmentResponseMultiError(errors)
	}

	return nil
}

// EnvironmentResponseMultiError is an error wrapping multiple validation
// errors returned by EnvironmentResponse.ValidateAll() if the designated
// constraints aren't met.
type EnvironmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvironmentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvironmentResponseMultiError) AllErrors() []error { return m }

// EnvironmentResponseValidationError is the validation error returned by
// EnvironmentResponse.Validate if the designated constraints aren't met.
type EnvironmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvironmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvironmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvironmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvironmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvironmentResponseValidationError) ErrorName() string {
	return "EnvironmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EnvironmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvironmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvironmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvironmentResponseValidationError{}

// Validate checks the field values on EnvironmentSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnvironmentSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnvironmentSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnvironmentSpecMultiError, or nil if none found.
func (m *EnvironmentSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *EnvironmentSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRequires() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnvironmentSpecValidationError{
						field:  fmt.Sprintf("Requires[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnvironmentSpecValidationError{
						field:  fmt.Sprintf("Requires[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnvironmentSpecValidationError{
					field:  fmt.Sprintf("Requires[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DBRequires

	// no validation rules for Labels

	// no validation rules for DBLabels

	// no validation rules for NotebookCount

	if len(errors) > 0 {
		return EnvironmentSpecMultiError(errors)
	}

	return nil
}

// EnvironmentSpecMultiError is an error wrapping multiple validation errors
// returned by EnvironmentSpec.ValidateAll() if the designated constraints
// aren't met.
type EnvironmentSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvironmentSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvironmentSpecMultiError) AllErrors() []error { return m }

// EnvironmentSpecValidationError is the validation error returned by
// EnvironmentSpec.Validate if the designated constraints aren't met.
type EnvironmentSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvironmentSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvironmentSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvironmentSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvironmentSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvironmentSpecValidationError) ErrorName() string { return "EnvironmentSpecValidationError" }

// Error satisfies the builtin error interface
func (e EnvironmentSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvironmentSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvironmentSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvironmentSpecValidationError{}

// Validate checks the field values on ListMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListMetadataMultiError, or
// nil if none found.
func (m *ListMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	if len(errors) > 0 {
		return ListMetadataMultiError(errors)
	}

	return nil
}

// ListMetadataMultiError is an error wrapping multiple validation errors
// returned by ListMetadata.ValidateAll() if the designated constraints aren't met.
type ListMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMetadataMultiError) AllErrors() []error { return m }

// ListMetadataValidationError is the validation error returned by
// ListMetadata.Validate if the designated constraints aren't met.
type ListMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMetadataValidationError) ErrorName() string { return "ListMetadataValidationError" }

// Error satisfies the builtin error interface
func (e ListMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMetadataValidationError{}

// Validate checks the field values on MetadataField with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetadataField) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetadataField with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataFieldMultiError, or
// nil if none found.
func (m *MetadataField) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataField) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Value

	// no validation rules for Type

	// no validation rules for Optional

	// no validation rules for Labels

	// no validation rules for Level

	if len(errors) > 0 {
		return MetadataFieldMultiError(errors)
	}

	return nil
}

// MetadataFieldMultiError is an error wrapping multiple validation errors
// returned by MetadataField.ValidateAll() if the designated constraints
// aren't met.
type MetadataFieldMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataFieldMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataFieldMultiError) AllErrors() []error { return m }

// MetadataFieldValidationError is the validation error returned by
// MetadataField.Validate if the designated constraints aren't met.
type MetadataFieldValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataFieldValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataFieldValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataFieldValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataFieldValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataFieldValidationError) ErrorName() string { return "MetadataFieldValidationError" }

// Error satisfies the builtin error interface
func (e MetadataFieldValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataField.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataFieldValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataFieldValidationError{}

// Validate checks the field values on NoteBookList with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NoteBookList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoteBookList with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NoteBookListMultiError, or
// nil if none found.
func (m *NoteBookList) ValidateAll() error {
	return m.validate(true)
}

func (m *NoteBookList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetListMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoteBookListValidationError{
					field:  "ListMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoteBookListValidationError{
					field:  "ListMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetListMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoteBookListValidationError{
				field:  "ListMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNoteBookListSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NoteBookListValidationError{
					field:  "NoteBookListSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NoteBookListValidationError{
					field:  "NoteBookListSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNoteBookListSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NoteBookListValidationError{
				field:  "NoteBookListSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NoteBookListMultiError(errors)
	}

	return nil
}

// NoteBookListMultiError is an error wrapping multiple validation errors
// returned by NoteBookList.ValidateAll() if the designated constraints aren't met.
type NoteBookListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoteBookListMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoteBookListMultiError) AllErrors() []error { return m }

// NoteBookListValidationError is the validation error returned by
// NoteBookList.Validate if the designated constraints aren't met.
type NoteBookListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoteBookListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoteBookListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoteBookListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoteBookListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoteBookListValidationError) ErrorName() string { return "NoteBookListValidationError" }

// Error satisfies the builtin error interface
func (e NoteBookListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoteBookList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoteBookListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoteBookListValidationError{}

// Validate checks the field values on NoteBookListSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NoteBookListSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NoteBookListSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NoteBookListSpecMultiError, or nil if none found.
func (m *NoteBookListSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *NoteBookListSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NoteBookListSpecValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NoteBookListSpecValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NoteBookListSpecValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NoteBookListSpecMultiError(errors)
	}

	return nil
}

// NoteBookListSpecMultiError is an error wrapping multiple validation errors
// returned by NoteBookListSpec.ValidateAll() if the designated constraints
// aren't met.
type NoteBookListSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NoteBookListSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NoteBookListSpecMultiError) AllErrors() []error { return m }

// NoteBookListSpecValidationError is the validation error returned by
// NoteBookListSpec.Validate if the designated constraints aren't met.
type NoteBookListSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NoteBookListSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NoteBookListSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NoteBookListSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NoteBookListSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NoteBookListSpecValidationError) ErrorName() string { return "NoteBookListSpecValidationError" }

// Error satisfies the builtin error interface
func (e NoteBookListSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNoteBookListSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NoteBookListSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NoteBookListSpecValidationError{}

// Validate checks the field values on Notebook with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Notebook) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Notebook with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotebookMultiError, or nil
// if none found.
func (m *Notebook) ValidateAll() error {
	return m.validate(true)
}

func (m *Notebook) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMetadata() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotebookValidationError{
						field:  fmt.Sprintf("Metadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotebookValidationError{
						field:  fmt.Sprintf("Metadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotebookValidationError{
					field:  fmt.Sprintf("Metadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetNotebookSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotebookValidationError{
					field:  "NotebookSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotebookValidationError{
					field:  "NotebookSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotebookSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotebookValidationError{
				field:  "NotebookSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNotebookStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotebookValidationError{
					field:  "NotebookStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotebookValidationError{
					field:  "NotebookStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNotebookStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotebookValidationError{
				field:  "NotebookStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NotebookMultiError(errors)
	}

	return nil
}

// NotebookMultiError is an error wrapping multiple validation errors returned
// by Notebook.ValidateAll() if the designated constraints aren't met.
type NotebookMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotebookMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotebookMultiError) AllErrors() []error { return m }

// NotebookValidationError is the validation error returned by
// Notebook.Validate if the designated constraints aren't met.
type NotebookValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotebookValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotebookValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotebookValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotebookValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotebookValidationError) ErrorName() string { return "NotebookValidationError" }

// Error satisfies the builtin error interface
func (e NotebookValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotebook.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotebookValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotebookValidationError{}

// Validate checks the field values on NotebookListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NotebookListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotebookListResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NotebookListResponseMultiError, or nil if none found.
func (m *NotebookListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NotebookListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotebookListResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotebookListResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotebookListResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NotebookListResponseMultiError(errors)
	}

	return nil
}

// NotebookListResponseMultiError is an error wrapping multiple validation
// errors returned by NotebookListResponse.ValidateAll() if the designated
// constraints aren't met.
type NotebookListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotebookListResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotebookListResponseMultiError) AllErrors() []error { return m }

// NotebookListResponseValidationError is the validation error returned by
// NotebookListResponse.Validate if the designated constraints aren't met.
type NotebookListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotebookListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotebookListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotebookListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotebookListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotebookListResponseValidationError) ErrorName() string {
	return "NotebookListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e NotebookListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotebookListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotebookListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotebookListResponseValidationError{}

// Validate checks the field values on NotebookResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NotebookResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotebookResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NotebookResponseMultiError, or nil if none found.
func (m *NotebookResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *NotebookResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotebookResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotebookResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotebookResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NotebookResponseMultiError(errors)
	}

	return nil
}

// NotebookResponseMultiError is an error wrapping multiple validation errors
// returned by NotebookResponse.ValidateAll() if the designated constraints
// aren't met.
type NotebookResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotebookResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotebookResponseMultiError) AllErrors() []error { return m }

// NotebookResponseValidationError is the validation error returned by
// NotebookResponse.Validate if the designated constraints aren't met.
type NotebookResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotebookResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotebookResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotebookResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotebookResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotebookResponseValidationError) ErrorName() string { return "NotebookResponseValidationError" }

// Error satisfies the builtin error interface
func (e NotebookResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotebookResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotebookResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotebookResponseValidationError{}

// Validate checks the field values on NotebookSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotebookSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotebookSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotebookSpecMultiError, or
// nil if none found.
func (m *NotebookSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *NotebookSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEnvs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotebookSpecValidationError{
						field:  fmt.Sprintf("Envs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotebookSpecValidationError{
						field:  fmt.Sprintf("Envs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotebookSpecValidationError{
					field:  fmt.Sprintf("Envs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ClusterName

	// no validation rules for ProjectName

	// no validation rules for ApplicationName

	// no validation rules for DBEnvs

	// no validation rules for Image

	// no validation rules for RequirementEnvID

	// no validation rules for DataSourceID

	// no validation rules for GenericDomain

	// no validation rules for ClusterDomain

	if all {
		switch v := interface{}(m.GetElfResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotebookSpecValidationError{
					field:  "ElfResource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotebookSpecValidationError{
					field:  "ElfResource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetElfResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotebookSpecValidationError{
				field:  "ElfResource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NotebookSpecMultiError(errors)
	}

	return nil
}

// NotebookSpecMultiError is an error wrapping multiple validation errors
// returned by NotebookSpec.ValidateAll() if the designated constraints aren't met.
type NotebookSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotebookSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotebookSpecMultiError) AllErrors() []error { return m }

// NotebookSpecValidationError is the validation error returned by
// NotebookSpec.Validate if the designated constraints aren't met.
type NotebookSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotebookSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotebookSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotebookSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotebookSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotebookSpecValidationError) ErrorName() string { return "NotebookSpecValidationError" }

// Error satisfies the builtin error interface
func (e NotebookSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotebookSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotebookSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotebookSpecValidationError{}

// Validate checks the field values on NotebookStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotebookStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotebookStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotebookStatusMultiError,
// or nil if none found.
func (m *NotebookStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *NotebookStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStartedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotebookStatusValidationError{
					field:  "StartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotebookStatusValidationError{
					field:  "StartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotebookStatusValidationError{
				field:  "StartedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	if len(errors) > 0 {
		return NotebookStatusMultiError(errors)
	}

	return nil
}

// NotebookStatusMultiError is an error wrapping multiple validation errors
// returned by NotebookStatus.ValidateAll() if the designated constraints
// aren't met.
type NotebookStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotebookStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotebookStatusMultiError) AllErrors() []error { return m }

// NotebookStatusValidationError is the validation error returned by
// NotebookStatus.Validate if the designated constraints aren't met.
type NotebookStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotebookStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotebookStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotebookStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotebookStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotebookStatusValidationError) ErrorName() string { return "NotebookStatusValidationError" }

// Error satisfies the builtin error interface
func (e NotebookStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotebookStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotebookStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotebookStatusValidationError{}

// Validate checks the field values on Package with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Package) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Package with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PackageMultiError, or nil if none found.
func (m *Package) ValidateAll() error {
	return m.validate(true)
}

func (m *Package) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Version

	if len(errors) > 0 {
		return PackageMultiError(errors)
	}

	return nil
}

// PackageMultiError is an error wrapping multiple validation errors returned
// by Package.ValidateAll() if the designated constraints aren't met.
type PackageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PackageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PackageMultiError) AllErrors() []error { return m }

// PackageValidationError is the validation error returned by Package.Validate
// if the designated constraints aren't met.
type PackageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PackageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PackageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PackageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PackageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PackageValidationError) ErrorName() string { return "PackageValidationError" }

// Error satisfies the builtin error interface
func (e PackageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPackage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PackageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PackageValidationError{}

// Validate checks the field values on Require with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Require) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Require with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RequireMultiError, or nil if none found.
func (m *Require) ValidateAll() error {
	return m.validate(true)
}

func (m *Require) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	for idx, item := range m.GetPackages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequireValidationError{
						field:  fmt.Sprintf("Packages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequireValidationError{
						field:  fmt.Sprintf("Packages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequireValidationError{
					field:  fmt.Sprintf("Packages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RequireMultiError(errors)
	}

	return nil
}

// RequireMultiError is an error wrapping multiple validation errors returned
// by Require.ValidateAll() if the designated constraints aren't met.
type RequireMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequireMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequireMultiError) AllErrors() []error { return m }

// RequireValidationError is the validation error returned by Require.Validate
// if the designated constraints aren't met.
type RequireValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequireValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequireValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequireValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequireValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequireValidationError) ErrorName() string { return "RequireValidationError" }

// Error satisfies the builtin error interface
func (e RequireValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequire.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequireValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequireValidationError{}
