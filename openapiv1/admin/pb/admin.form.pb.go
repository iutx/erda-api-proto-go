// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: admin.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*ADMIN_APPROVE_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADMIN_CLUSTER_GET_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADMIN_NOTICE_DELETE_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADMIN_NOTICE_PUBLISH_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ADMIN_NOTICE_UNPUBLISH_Request)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApproveDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApproveDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApproveListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApproveUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApproveUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AuditsListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AuditsListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ClusterInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ClusterListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ClusterListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Notice)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticeCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticeCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticeDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticeListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticeListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticeListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticePublishResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticeUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NoticeUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingApproveDTO)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UserInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UserListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UserListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UserListResponseData)(nil)

// ADMIN_APPROVE_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADMIN_APPROVE_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "approveId":
				m.ApproveId = vals[0]
			}
		}
	}
	return nil
}

// ADMIN_CLUSTER_GET_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADMIN_CLUSTER_GET_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			}
		}
	}
	return nil
}

// ADMIN_NOTICE_DELETE_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADMIN_NOTICE_DELETE_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// ADMIN_NOTICE_PUBLISH_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADMIN_NOTICE_PUBLISH_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// ADMIN_NOTICE_UNPUBLISH_Request implement urlenc.URLValuesUnmarshaler.
func (m *ADMIN_NOTICE_UNPUBLISH_Request) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// ApproveDTO implement urlenc.URLValuesUnmarshaler.
func (m *ApproveDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "entityID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EntityID = val
			case "targetID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TargetID = val
			case "targetName":
				m.TargetName = vals[0]
			case "type":
				m.Type = vals[0]
			case "title":
				m.Title = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "status":
				m.Status = vals[0]
			case "submitter":
				m.Submitter = vals[0]
			case "approver":
				m.Approver = vals[0]
			case "approvalTime":
				if m.ApprovalTime == nil {
					m.ApprovalTime = &timestamppb.Timestamp{}
				}
			case "approvalTime.seconds":
				if m.ApprovalTime == nil {
					m.ApprovalTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApprovalTime.Seconds = val
			case "approvalTime.nanos":
				if m.ApprovalTime == nil {
					m.ApprovalTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ApprovalTime.Nanos = int32(val)
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// ApproveDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApproveDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ApproveListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApproveListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "status":
				m.Status = vals
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = &val
			}
		}
	}
	return nil
}

// ApproveUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ApproveUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "priority":
				m.Priority = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "status":
				m.Status = vals[0]
			case "approver":
				m.Approver = vals[0]
			case "approveId":
				m.ApproveId = vals[0]
			}
		}
	}
	return nil
}

// ApproveUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ApproveUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AuditsListRequest implement urlenc.URLValuesUnmarshaler.
func (m *AuditsListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "sys":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Sys = val
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "startAt":
				m.StartAt = vals[0]
			case "endAt":
				m.EndAt = vals[0]
			case "fDPProjectID":
				m.FDPProjectID = vals[0]
			case "userID":
				m.UserID = vals
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// AuditsListResponse implement urlenc.URLValuesUnmarshaler.
func (m *AuditsListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// ClusterInfo implement urlenc.URLValuesUnmarshaler.
func (m *ClusterInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "type":
				m.Type = vals[0]
			case "cloudVendor":
				m.CloudVendor = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "description":
				m.Description = vals[0]
			case "wildcardDomain":
				m.WildcardDomain = vals[0]
			case "schedConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.SchedConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.SchedConfig = val
					} else {
						m.SchedConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "opsConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.OpsConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.OpsConfig = val
					} else {
						m.OpsConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "system":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.System = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.System = val
					} else {
						m.System = structpb.NewStringValue(vals[0])
					}
				}
			case "manageConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ManageConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ManageConfig = val
					} else {
						m.ManageConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "isRelation":
				m.IsRelation = vals[0]
			}
		}
	}
	return nil
}

// ClusterListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ClusterListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// ClusterListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ClusterListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// Notice implement urlenc.URLValuesUnmarshaler.
func (m *Notice) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "content":
				m.Content = vals[0]
			case "status":
				m.Status = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updateAt":
				if m.UpdateAt == nil {
					m.UpdateAt = &timestamppb.Timestamp{}
				}
			case "updateAt.seconds":
				if m.UpdateAt == nil {
					m.UpdateAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateAt.Seconds = val
			case "updateAt.nanos":
				if m.UpdateAt == nil {
					m.UpdateAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdateAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// NoticeCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *NoticeCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "content":
				m.Content = vals[0]
			}
		}
	}
	return nil
}

// NoticeCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *NoticeCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// NoticeDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *NoticeDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// NoticeListRequest implement urlenc.URLValuesUnmarshaler.
func (m *NoticeListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "content":
				m.Content = vals[0]
			case "status":
				m.Status = vals[0]
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// NoticeListResponse implement urlenc.URLValuesUnmarshaler.
func (m *NoticeListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// NoticeListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *NoticeListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// NoticePublishResponse implement urlenc.URLValuesUnmarshaler.
func (m *NoticePublishResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// NoticeUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *NoticeUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "content":
				m.Content = vals[0]
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			}
		}
	}
	return nil
}

// NoticeUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *NoticeUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// PagingApproveDTO implement urlenc.URLValuesUnmarshaler.
func (m *PagingApproveDTO) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// UserInfo implement urlenc.URLValuesUnmarshaler.
func (m *UserInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "name":
				m.Name = vals[0]
			case "nick":
				m.Nick = vals[0]
			case "avatar":
				m.Avatar = vals[0]
			case "phone":
				m.Phone = vals[0]
			case "email":
				m.Email = vals[0]
			case "token":
				m.Token = vals[0]
			case "lastLoginAt":
				m.LastLoginAt = vals[0]
			case "pwdExpireAt":
				m.PwdExpireAt = vals[0]
			case "source":
				m.Source = vals[0]
			}
		}
	}
	return nil
}

// UserListRequest implement urlenc.URLValuesUnmarshaler.
func (m *UserListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "query":
				m.Query = vals[0]
			case "plaintext":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Plaintext = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// UserListResponse implement urlenc.URLValuesUnmarshaler.
func (m *UserListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// UserListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *UserListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}
