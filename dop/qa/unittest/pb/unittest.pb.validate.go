// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: unittest.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on TestRecordPagingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestRecordPagingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRecordPagingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestRecordPagingRequestMultiError, or nil if none found.
func (m *TestRecordPagingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRecordPagingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageNo

	// no validation rules for PageSize

	// no validation rules for ApplicationId

	if len(errors) > 0 {
		return TestRecordPagingRequestMultiError(errors)
	}

	return nil
}

// TestRecordPagingRequestMultiError is an error wrapping multiple validation
// errors returned by TestRecordPagingRequest.ValidateAll() if the designated
// constraints aren't met.
type TestRecordPagingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRecordPagingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRecordPagingRequestMultiError) AllErrors() []error { return m }

// TestRecordPagingRequestValidationError is the validation error returned by
// TestRecordPagingRequest.Validate if the designated constraints aren't met.
type TestRecordPagingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRecordPagingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRecordPagingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRecordPagingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRecordPagingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRecordPagingRequestValidationError) ErrorName() string {
	return "TestRecordPagingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestRecordPagingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRecordPagingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRecordPagingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRecordPagingRequestValidationError{}

// Validate checks the field values on TestRecordPagingResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestRecordPagingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRecordPagingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestRecordPagingResponseMultiError, or nil if none found.
func (m *TestRecordPagingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRecordPagingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRecordPagingResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRecordPagingResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRecordPagingResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TestRecordPagingResponseMultiError(errors)
	}

	return nil
}

// TestRecordPagingResponseMultiError is an error wrapping multiple validation
// errors returned by TestRecordPagingResponse.ValidateAll() if the designated
// constraints aren't met.
type TestRecordPagingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRecordPagingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRecordPagingResponseMultiError) AllErrors() []error { return m }

// TestRecordPagingResponseValidationError is the validation error returned by
// TestRecordPagingResponse.Validate if the designated constraints aren't met.
type TestRecordPagingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRecordPagingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRecordPagingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRecordPagingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRecordPagingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRecordPagingResponseValidationError) ErrorName() string {
	return "TestRecordPagingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestRecordPagingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRecordPagingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRecordPagingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRecordPagingResponseValidationError{}

// Validate checks the field values on TestRecordPagingResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestRecordPagingResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRecordPagingResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestRecordPagingResultMultiError, or nil if none found.
func (m *TestRecordPagingResult) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRecordPagingResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestRecordPagingResultValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestRecordPagingResultValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestRecordPagingResultValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestRecordPagingResultMultiError(errors)
	}

	return nil
}

// TestRecordPagingResultMultiError is an error wrapping multiple validation
// errors returned by TestRecordPagingResult.ValidateAll() if the designated
// constraints aren't met.
type TestRecordPagingResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRecordPagingResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRecordPagingResultMultiError) AllErrors() []error { return m }

// TestRecordPagingResultValidationError is the validation error returned by
// TestRecordPagingResult.Validate if the designated constraints aren't met.
type TestRecordPagingResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRecordPagingResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRecordPagingResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRecordPagingResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRecordPagingResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRecordPagingResultValidationError) ErrorName() string {
	return "TestRecordPagingResultValidationError"
}

// Error satisfies the builtin error interface
func (e TestRecordPagingResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRecordPagingResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRecordPagingResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRecordPagingResultValidationError{}

// Validate checks the field values on TestRecordGetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestRecordGetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRecordGetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestRecordGetRequestMultiError, or nil if none found.
func (m *TestRecordGetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRecordGetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return TestRecordGetRequestMultiError(errors)
	}

	return nil
}

// TestRecordGetRequestMultiError is an error wrapping multiple validation
// errors returned by TestRecordGetRequest.ValidateAll() if the designated
// constraints aren't met.
type TestRecordGetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRecordGetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRecordGetRequestMultiError) AllErrors() []error { return m }

// TestRecordGetRequestValidationError is the validation error returned by
// TestRecordGetRequest.Validate if the designated constraints aren't met.
type TestRecordGetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRecordGetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRecordGetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRecordGetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRecordGetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRecordGetRequestValidationError) ErrorName() string {
	return "TestRecordGetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestRecordGetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRecordGetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRecordGetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRecordGetRequestValidationError{}

// Validate checks the field values on TestRecordGetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestRecordGetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRecordGetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestRecordGetResponseMultiError, or nil if none found.
func (m *TestRecordGetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRecordGetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRecordGetResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRecordGetResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRecordGetResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TestRecordGetResponseMultiError(errors)
	}

	return nil
}

// TestRecordGetResponseMultiError is an error wrapping multiple validation
// errors returned by TestRecordGetResponse.ValidateAll() if the designated
// constraints aren't met.
type TestRecordGetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRecordGetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRecordGetResponseMultiError) AllErrors() []error { return m }

// TestRecordGetResponseValidationError is the validation error returned by
// TestRecordGetResponse.Validate if the designated constraints aren't met.
type TestRecordGetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRecordGetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRecordGetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRecordGetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRecordGetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRecordGetResponseValidationError) ErrorName() string {
	return "TestRecordGetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestRecordGetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRecordGetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRecordGetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRecordGetResponseValidationError{}

// Validate checks the field values on TestRecord with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRecord with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestRecordMultiError, or
// nil if none found.
func (m *TestRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRecordValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRecordValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRecordValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRecordValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRecordValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRecordValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApplicationId

	// no validation rules for ProjectId

	// no validation rules for BuildId

	// no validation rules for Name

	// no validation rules for Uuid

	// no validation rules for ApplicationName

	// no validation rules for Output

	// no validation rules for Desc

	// no validation rules for OperatorId

	// no validation rules for OperatorName

	// no validation rules for CommitId

	// no validation rules for Branch

	// no validation rules for GitRepo

	// no validation rules for CaseDir

	// no validation rules for Application

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetTotals()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRecordValidationError{
					field:  "Totals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRecordValidationError{
					field:  "Totals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotals()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRecordValidationError{
				field:  "Totals",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ParserType

	// no validation rules for Extra

	// no validation rules for Envs

	// no validation rules for Workspace

	for idx, item := range m.GetSuites() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestRecordValidationError{
						field:  fmt.Sprintf("Suites[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestRecordValidationError{
						field:  fmt.Sprintf("Suites[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestRecordValidationError{
					field:  fmt.Sprintf("Suites[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCoverageReport() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestRecordValidationError{
						field:  fmt.Sprintf("CoverageReport[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestRecordValidationError{
						field:  fmt.Sprintf("CoverageReport[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestRecordValidationError{
					field:  fmt.Sprintf("CoverageReport[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestRecordMultiError(errors)
	}

	return nil
}

// TestRecordMultiError is an error wrapping multiple validation errors
// returned by TestRecord.ValidateAll() if the designated constraints aren't met.
type TestRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRecordMultiError) AllErrors() []error { return m }

// TestRecordValidationError is the validation error returned by
// TestRecord.Validate if the designated constraints aren't met.
type TestRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRecordValidationError) ErrorName() string { return "TestRecordValidationError" }

// Error satisfies the builtin error interface
func (e TestRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRecordValidationError{}

// Validate checks the field values on TestTypeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TestTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestTypeRequestMultiError, or nil if none found.
func (m *TestTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestTypeRequestMultiError(errors)
	}

	return nil
}

// TestTypeRequestMultiError is an error wrapping multiple validation errors
// returned by TestTypeRequest.ValidateAll() if the designated constraints
// aren't met.
type TestTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestTypeRequestMultiError) AllErrors() []error { return m }

// TestTypeRequestValidationError is the validation error returned by
// TestTypeRequest.Validate if the designated constraints aren't met.
type TestTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestTypeRequestValidationError) ErrorName() string { return "TestTypeRequestValidationError" }

// Error satisfies the builtin error interface
func (e TestTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestTypeRequestValidationError{}

// Validate checks the field values on TestTypeResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TestTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestTypeResponseMultiError, or nil if none found.
func (m *TestTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestTypeResponseMultiError(errors)
	}

	return nil
}

// TestTypeResponseMultiError is an error wrapping multiple validation errors
// returned by TestTypeResponse.ValidateAll() if the designated constraints
// aren't met.
type TestTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestTypeResponseMultiError) AllErrors() []error { return m }

// TestTypeResponseValidationError is the validation error returned by
// TestTypeResponse.Validate if the designated constraints aren't met.
type TestTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestTypeResponseValidationError) ErrorName() string { return "TestTypeResponseValidationError" }

// Error satisfies the builtin error interface
func (e TestTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestTypeResponseValidationError{}

// Validate checks the field values on TestCallBackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCallBackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCallBackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCallBackRequestMultiError, or nil if none found.
func (m *TestCallBackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCallBackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResults()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestCallBackRequestValidationError{
					field:  "Results",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestCallBackRequestValidationError{
					field:  "Results",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResults()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestCallBackRequestValidationError{
				field:  "Results",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotals()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestCallBackRequestValidationError{
					field:  "Totals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestCallBackRequestValidationError{
					field:  "Totals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotals()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestCallBackRequestValidationError{
				field:  "Totals",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSuites() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCallBackRequestValidationError{
						field:  fmt.Sprintf("Suites[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCallBackRequestValidationError{
						field:  fmt.Sprintf("Suites[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCallBackRequestValidationError{
					field:  fmt.Sprintf("Suites[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCoverageReport() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestCallBackRequestValidationError{
						field:  fmt.Sprintf("CoverageReport[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestCallBackRequestValidationError{
						field:  fmt.Sprintf("CoverageReport[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestCallBackRequestValidationError{
					field:  fmt.Sprintf("CoverageReport[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestCallBackRequestMultiError(errors)
	}

	return nil
}

// TestCallBackRequestMultiError is an error wrapping multiple validation
// errors returned by TestCallBackRequest.ValidateAll() if the designated
// constraints aren't met.
type TestCallBackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCallBackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCallBackRequestMultiError) AllErrors() []error { return m }

// TestCallBackRequestValidationError is the validation error returned by
// TestCallBackRequest.Validate if the designated constraints aren't met.
type TestCallBackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCallBackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCallBackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCallBackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCallBackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCallBackRequestValidationError) ErrorName() string {
	return "TestCallBackRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TestCallBackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCallBackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCallBackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCallBackRequestValidationError{}

// Validate checks the field values on TestResult with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestResultMultiError, or
// nil if none found.
func (m *TestResult) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApplicationId

	// no validation rules for BuildId

	// no validation rules for ProjectId

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for ApplicationName

	// no validation rules for Branch

	// no validation rules for GitRepo

	// no validation rules for CommitId

	// no validation rules for OperatorName

	// no validation rules for OperatorId

	// no validation rules for Status

	// no validation rules for Workspace

	// no validation rules for ParserType

	// no validation rules for Uuid

	// no validation rules for Extra

	if len(errors) > 0 {
		return TestResultMultiError(errors)
	}

	return nil
}

// TestResultMultiError is an error wrapping multiple validation errors
// returned by TestResult.ValidateAll() if the designated constraints aren't met.
type TestResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResultMultiError) AllErrors() []error { return m }

// TestResultValidationError is the validation error returned by
// TestResult.Validate if the designated constraints aren't met.
type TestResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResultValidationError) ErrorName() string { return "TestResultValidationError" }

// Error satisfies the builtin error interface
func (e TestResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResultValidationError{}

// Validate checks the field values on TestError with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestError with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestErrorMultiError, or nil
// if none found.
func (m *TestError) ValidateAll() error {
	return m.validate(true)
}

func (m *TestError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for Type

	// no validation rules for Body

	if len(errors) > 0 {
		return TestErrorMultiError(errors)
	}

	return nil
}

// TestErrorMultiError is an error wrapping multiple validation errors returned
// by TestError.ValidateAll() if the designated constraints aren't met.
type TestErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestErrorMultiError) AllErrors() []error { return m }

// TestErrorValidationError is the validation error returned by
// TestError.Validate if the designated constraints aren't met.
type TestErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestErrorValidationError) ErrorName() string { return "TestErrorValidationError" }

// Error satisfies the builtin error interface
func (e TestErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestErrorValidationError{}

// Validate checks the field values on Test with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Test) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Test with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TestMultiError, or nil if none found.
func (m *Test) ValidateAll() error {
	return m.validate(true)
}

func (m *Test) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Classname

	// no validation rules for Duration

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Stdout

	// no validation rules for Stderr

	if len(errors) > 0 {
		return TestMultiError(errors)
	}

	return nil
}

// TestMultiError is an error wrapping multiple validation errors returned by
// Test.ValidateAll() if the designated constraints aren't met.
type TestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestMultiError) AllErrors() []error { return m }

// TestValidationError is the validation error returned by Test.Validate if the
// designated constraints aren't met.
type TestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestValidationError) ErrorName() string { return "TestValidationError" }

// Error satisfies the builtin error interface
func (e TestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestValidationError{}

// Validate checks the field values on TestTotal with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestTotal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestTotal with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestTotalMultiError, or nil
// if none found.
func (m *TestTotal) ValidateAll() error {
	return m.validate(true)
}

func (m *TestTotal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Tests

	// no validation rules for Duration

	// no validation rules for Statuses

	if len(errors) > 0 {
		return TestTotalMultiError(errors)
	}

	return nil
}

// TestTotalMultiError is an error wrapping multiple validation errors returned
// by TestTotal.ValidateAll() if the designated constraints aren't met.
type TestTotalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestTotalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestTotalMultiError) AllErrors() []error { return m }

// TestTotalValidationError is the validation error returned by
// TestTotal.Validate if the designated constraints aren't met.
type TestTotalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestTotalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestTotalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestTotalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestTotalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestTotalValidationError) ErrorName() string { return "TestTotalValidationError" }

// Error satisfies the builtin error interface
func (e TestTotalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestTotal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestTotalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestTotalValidationError{}

// Validate checks the field values on TestSuite with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestSuite) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestSuite with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestSuiteMultiError, or nil
// if none found.
func (m *TestSuite) ValidateAll() error {
	return m.validate(true)
}

func (m *TestSuite) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Package

	// no validation rules for Properties

	for idx, item := range m.GetTests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestSuiteValidationError{
						field:  fmt.Sprintf("Tests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestSuiteValidationError{
						field:  fmt.Sprintf("Tests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestSuiteValidationError{
					field:  fmt.Sprintf("Tests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Stdout

	// no validation rules for Stderr

	if all {
		switch v := interface{}(m.GetTotals()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestSuiteValidationError{
					field:  "Totals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestSuiteValidationError{
					field:  "Totals",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotals()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestSuiteValidationError{
				field:  "Totals",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Extra

	if len(errors) > 0 {
		return TestSuiteMultiError(errors)
	}

	return nil
}

// TestSuiteMultiError is an error wrapping multiple validation errors returned
// by TestSuite.ValidateAll() if the designated constraints aren't met.
type TestSuiteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestSuiteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestSuiteMultiError) AllErrors() []error { return m }

// TestSuiteValidationError is the validation error returned by
// TestSuite.Validate if the designated constraints aren't met.
type TestSuiteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestSuiteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestSuiteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestSuiteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestSuiteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestSuiteValidationError) ErrorName() string { return "TestSuiteValidationError" }

// Error satisfies the builtin error interface
func (e TestSuiteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestSuite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestSuiteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestSuiteValidationError{}

// Validate checks the field values on ToolTip with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ToolTip) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ToolTip with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ToolTipMultiError, or nil if none found.
func (m *ToolTip) ValidateAll() error {
	return m.validate(true)
}

func (m *ToolTip) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Formatter

	if len(errors) > 0 {
		return ToolTipMultiError(errors)
	}

	return nil
}

// ToolTipMultiError is an error wrapping multiple validation errors returned
// by ToolTip.ValidateAll() if the designated constraints aren't met.
type ToolTipMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ToolTipMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ToolTipMultiError) AllErrors() []error { return m }

// ToolTipValidationError is the validation error returned by ToolTip.Validate
// if the designated constraints aren't met.
type ToolTipValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ToolTipValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ToolTipValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ToolTipValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ToolTipValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ToolTipValidationError) ErrorName() string { return "ToolTipValidationError" }

// Error satisfies the builtin error interface
func (e ToolTipValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sToolTip.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ToolTipValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ToolTipValidationError{}

// Validate checks the field values on CodeCoverageNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CodeCoverageNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CodeCoverageNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CodeCoverageNodeMultiError, or nil if none found.
func (m *CodeCoverageNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CodeCoverageNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	if all {
		switch v := interface{}(m.GetTooltip()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CodeCoverageNodeValidationError{
					field:  "Tooltip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CodeCoverageNodeValidationError{
					field:  "Tooltip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTooltip()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CodeCoverageNodeValidationError{
				field:  "Tooltip",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CodeCoverageNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CodeCoverageNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CodeCoverageNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCounter() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CodeCoverageNodeValidationError{
						field:  fmt.Sprintf("Counter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CodeCoverageNodeValidationError{
						field:  fmt.Sprintf("Counter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CodeCoverageNodeValidationError{
					field:  fmt.Sprintf("Counter[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CodeCoverageNodeMultiError(errors)
	}

	return nil
}

// CodeCoverageNodeMultiError is an error wrapping multiple validation errors
// returned by CodeCoverageNode.ValidateAll() if the designated constraints
// aren't met.
type CodeCoverageNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CodeCoverageNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CodeCoverageNodeMultiError) AllErrors() []error { return m }

// CodeCoverageNodeValidationError is the validation error returned by
// CodeCoverageNode.Validate if the designated constraints aren't met.
type CodeCoverageNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CodeCoverageNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CodeCoverageNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CodeCoverageNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CodeCoverageNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CodeCoverageNodeValidationError) ErrorName() string { return "CodeCoverageNodeValidationError" }

// Error satisfies the builtin error interface
func (e CodeCoverageNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCodeCoverageNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CodeCoverageNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CodeCoverageNodeValidationError{}

// Validate checks the field values on ReportCounter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportCounter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportCounter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportCounterMultiError, or
// nil if none found.
func (m *ReportCounter) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportCounter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Covered

	// no validation rules for Missed

	// no validation rules for Type

	if len(errors) > 0 {
		return ReportCounterMultiError(errors)
	}

	return nil
}

// ReportCounterMultiError is an error wrapping multiple validation errors
// returned by ReportCounter.ValidateAll() if the designated constraints
// aren't met.
type ReportCounterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportCounterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportCounterMultiError) AllErrors() []error { return m }

// ReportCounterValidationError is the validation error returned by
// ReportCounter.Validate if the designated constraints aren't met.
type ReportCounterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportCounterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportCounterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportCounterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportCounterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportCounterValidationError) ErrorName() string { return "ReportCounterValidationError" }

// Error satisfies the builtin error interface
func (e ReportCounterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportCounter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportCounterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportCounterValidationError{}

// Validate checks the field values on ReportPackage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportPackage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportPackage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportPackageMultiError, or
// nil if none found.
func (m *ReportPackage) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportPackage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetClass() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportPackageValidationError{
						field:  fmt.Sprintf("Class[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportPackageValidationError{
						field:  fmt.Sprintf("Class[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportPackageValidationError{
					field:  fmt.Sprintf("Class[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCounter() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportPackageValidationError{
						field:  fmt.Sprintf("Counter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportPackageValidationError{
						field:  fmt.Sprintf("Counter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportPackageValidationError{
					field:  fmt.Sprintf("Counter[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReportPackageMultiError(errors)
	}

	return nil
}

// ReportPackageMultiError is an error wrapping multiple validation errors
// returned by ReportPackage.ValidateAll() if the designated constraints
// aren't met.
type ReportPackageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportPackageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportPackageMultiError) AllErrors() []error { return m }

// ReportPackageValidationError is the validation error returned by
// ReportPackage.Validate if the designated constraints aren't met.
type ReportPackageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportPackageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportPackageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportPackageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportPackageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportPackageValidationError) ErrorName() string { return "ReportPackageValidationError" }

// Error satisfies the builtin error interface
func (e ReportPackageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportPackage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportPackageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportPackageValidationError{}

// Validate checks the field values on ReportClass with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportClass) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportClass with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportClassMultiError, or
// nil if none found.
func (m *ReportClass) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportClass) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Sourcefilename

	for idx, item := range m.GetMethod() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportClassValidationError{
						field:  fmt.Sprintf("Method[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportClassValidationError{
						field:  fmt.Sprintf("Method[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportClassValidationError{
					field:  fmt.Sprintf("Method[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCounter() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportClassValidationError{
						field:  fmt.Sprintf("Counter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportClassValidationError{
						field:  fmt.Sprintf("Counter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportClassValidationError{
					field:  fmt.Sprintf("Counter[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReportClassMultiError(errors)
	}

	return nil
}

// ReportClassMultiError is an error wrapping multiple validation errors
// returned by ReportClass.ValidateAll() if the designated constraints aren't met.
type ReportClassMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportClassMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportClassMultiError) AllErrors() []error { return m }

// ReportClassValidationError is the validation error returned by
// ReportClass.Validate if the designated constraints aren't met.
type ReportClassValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportClassValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportClassValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportClassValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportClassValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportClassValidationError) ErrorName() string { return "ReportClassValidationError" }

// Error satisfies the builtin error interface
func (e ReportClassValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportClass.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportClassValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportClassValidationError{}

// Validate checks the field values on ReportMethod with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportMethod) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportMethod with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportMethodMultiError, or
// nil if none found.
func (m *ReportMethod) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportMethod) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Desc

	// no validation rules for Line

	for idx, item := range m.GetCounter() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportMethodValidationError{
						field:  fmt.Sprintf("Counter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportMethodValidationError{
						field:  fmt.Sprintf("Counter[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportMethodValidationError{
					field:  fmt.Sprintf("Counter[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReportMethodMultiError(errors)
	}

	return nil
}

// ReportMethodMultiError is an error wrapping multiple validation errors
// returned by ReportMethod.ValidateAll() if the designated constraints aren't met.
type ReportMethodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportMethodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportMethodMultiError) AllErrors() []error { return m }

// ReportMethodValidationError is the validation error returned by
// ReportMethod.Validate if the designated constraints aren't met.
type ReportMethodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportMethodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportMethodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportMethodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportMethodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportMethodValidationError) ErrorName() string { return "ReportMethodValidationError" }

// Error satisfies the builtin error interface
func (e ReportMethodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportMethod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportMethodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportMethodValidationError{}

// Validate checks the field values on TestCallBackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCallBackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCallBackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCallBackResponseMultiError, or nil if none found.
func (m *TestCallBackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCallBackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return TestCallBackResponseMultiError(errors)
	}

	return nil
}

// TestCallBackResponseMultiError is an error wrapping multiple validation
// errors returned by TestCallBackResponse.ValidateAll() if the designated
// constraints aren't met.
type TestCallBackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCallBackResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCallBackResponseMultiError) AllErrors() []error { return m }

// TestCallBackResponseValidationError is the validation error returned by
// TestCallBackResponse.Validate if the designated constraints aren't met.
type TestCallBackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCallBackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCallBackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCallBackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCallBackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCallBackResponseValidationError) ErrorName() string {
	return "TestCallBackResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TestCallBackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCallBackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCallBackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCallBackResponseValidationError{}
