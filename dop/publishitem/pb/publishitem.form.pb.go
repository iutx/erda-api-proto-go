// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: publishitem.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*CreateBranchRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreatePublishItemRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreatePublishItemResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreatePublishItemVersionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreatePublishItemVersionResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreatePublishItemVersionData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateUpdateDeleteReleaseRuleRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeletePublishItemBlackListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemBlackListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreatePublishItemEraseRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemEraseRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListPublishItemMonitorKeysRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListPublishItemMonitorKeysResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MonitorKeys)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeletePublishItemResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemLatestVersionData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemLatestVersionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemLatestVersionResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*H5VersionInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreatePublishItemOfflineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreatePublishItemOfflineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeletePublishItemRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DistributePublishItemRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemH5PackageNameRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemH5PackageNameResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublishItemResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetPublicPublishItemVersionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SetPublishItemVersionStatusRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublicItemAddEraseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublicItemAddEraseResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItem)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemAddBlacklistResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemDeleteBlacklistResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemDistributionData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemDistributionResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemUserListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemUserlistRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemUserListDataResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemUserListData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PublishItemVersion)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryPublishItemData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryPublishItemRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryPublishItemResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryPublishItemVersionData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryPublishItemVersionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryPublishItemVersionResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdatePublishItemRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdatePublishItemResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdatePublishItemVersionStatesRequset)(nil)
var _ urlenc.URLValuesUnmarshaler = (*VersionInfo)(nil)

// CreateBranchRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateBranchRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CreatePublishItemRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreatePublishItemRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "publisherID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublisherID = val
			case "type":
				m.Type = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "desc":
				m.Desc = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "creator":
				m.Creator = vals[0]
			case "noJailbreak":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NoJailbreak = val
			case "geofenceLon":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceLon = val
			case "geofenceLat":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceLat = val
			case "geofenceRadius":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceRadius = val
			case "grayLevelPercent":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GrayLevelPercent = val
			case "previewImages":
				m.PreviewImages = vals
			case "backgroundImage":
				m.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// CreatePublishItemResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreatePublishItemResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Name = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DisplayName = vals[0]
			case "data.logo":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Logo = vals[0]
			case "data.publisherID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublisherID = val
			case "data.aK":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AK = vals[0]
			case "data.aI":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AI = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Type = vals[0]
			case "data.public":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.desc":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Desc = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Creator = vals[0]
			case "data.downloadUrl":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DownloadUrl = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.noJailbreak":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.NoJailbreak = val
			case "data.geofenceLon":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLon = val
			case "data.geofenceLat":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLat = val
			case "data.geofenceRadius":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceRadius = val
			case "data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.GrayLevelPercent = val
			case "data.latestVersion":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.LatestVersion = vals[0]
			case "data.refCount":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RefCount = val
			case "data.previewImages":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.PreviewImages = vals
			case "data.backgroundImage":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// CreatePublishItemVersionRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreatePublishItemVersionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "version":
				m.Version = vals[0]
			case "buildID":
				m.BuildID = vals[0]
			case "packageName":
				m.PackageName = vals[0]
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "isDefault":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsDefault = val
			case "logo":
				m.Logo = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "readme":
				m.Readme = vals[0]
			case "spec":
				m.Spec = vals[0]
			case "swagger":
				m.Swagger = vals[0]
			case "releaseID":
				m.ReleaseID = vals[0]
			case "mobileType":
				m.MobileType = vals[0]
			case "h5VersionInfo":
				if m.H5VersionInfo == nil {
					m.H5VersionInfo = &H5VersionInfo{}
				}
			case "h5VersionInfo.versionInfo":
				if m.H5VersionInfo == nil {
					m.H5VersionInfo = &H5VersionInfo{}
				}
				if m.H5VersionInfo.VersionInfo == nil {
					m.H5VersionInfo.VersionInfo = &VersionInfo{}
				}
			case "h5VersionInfo.versionInfo.packageName":
				if m.H5VersionInfo == nil {
					m.H5VersionInfo = &H5VersionInfo{}
				}
				if m.H5VersionInfo.VersionInfo == nil {
					m.H5VersionInfo.VersionInfo = &VersionInfo{}
				}
				m.H5VersionInfo.VersionInfo.PackageName = vals[0]
			case "h5VersionInfo.versionInfo.version":
				if m.H5VersionInfo == nil {
					m.H5VersionInfo = &H5VersionInfo{}
				}
				if m.H5VersionInfo.VersionInfo == nil {
					m.H5VersionInfo.VersionInfo = &VersionInfo{}
				}
				m.H5VersionInfo.VersionInfo.Version = vals[0]
			case "h5VersionInfo.versionInfo.buildID":
				if m.H5VersionInfo == nil {
					m.H5VersionInfo = &H5VersionInfo{}
				}
				if m.H5VersionInfo.VersionInfo == nil {
					m.H5VersionInfo.VersionInfo = &VersionInfo{}
				}
				m.H5VersionInfo.VersionInfo.BuildID = vals[0]
			case "publishItemID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemID = val
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "creator":
				m.Creator = vals[0]
			}
		}
	}
	return nil
}

// CreatePublishItemVersionResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreatePublishItemVersionResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
			case "data.data":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
			case "data.data.ID":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.ID = val
			case "data.data.version":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.Version = vals[0]
			case "data.data.buildID":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.BuildID = vals[0]
			case "data.data.packageName":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.PackageName = vals[0]
			case "data.data.public":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Data.Public = val
			case "data.data.isDefault":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Data.IsDefault = val
			case "data.data.desc":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.Desc = vals[0]
			case "data.data.logo":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.Logo = vals[0]
			case "data.data.resources":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Resources = val
					} else {
						m.Data.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.resources.null_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Resources = val
					} else {
						m.Data.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.resources.number_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Resources = val
					} else {
						m.Data.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.resources.string_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Resources = val
					} else {
						m.Data.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.resources.bool_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Resources = val
					} else {
						m.Data.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.resources.struct_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Resources = val
					} else {
						m.Data.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.resources.list_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Resources = val
					} else {
						m.Data.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.meta":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Meta = val
					} else {
						m.Data.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.meta.null_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Meta = val
					} else {
						m.Data.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.meta.number_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Meta = val
					} else {
						m.Data.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.meta.string_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Meta = val
					} else {
						m.Data.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.meta.bool_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Meta = val
					} else {
						m.Data.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.meta.struct_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Meta = val
					} else {
						m.Data.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.meta.list_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Meta = val
					} else {
						m.Data.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.swagger":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Swagger = val
					} else {
						m.Data.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.swagger.null_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Swagger = val
					} else {
						m.Data.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.swagger.number_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Swagger = val
					} else {
						m.Data.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.swagger.string_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Swagger = val
					} else {
						m.Data.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.swagger.bool_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Swagger = val
					} else {
						m.Data.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.swagger.struct_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Swagger = val
					} else {
						m.Data.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.swagger.list_value":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Data.Swagger = val
					} else {
						m.Data.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.data.orgID":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.OrgID = val
			case "data.data.createdAt":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if m.Data.Data.CreatedAt == nil {
					m.Data.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if m.Data.Data.CreatedAt == nil {
					m.Data.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.CreatedAt.Seconds = val
			case "data.data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if m.Data.Data.CreatedAt == nil {
					m.Data.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Data.CreatedAt.Nanos = int32(val)
			case "data.data.updatedAt":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if m.Data.Data.UpdatedAt == nil {
					m.Data.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if m.Data.Data.UpdatedAt == nil {
					m.Data.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.UpdatedAt.Seconds = val
			case "data.data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				if m.Data.Data.UpdatedAt == nil {
					m.Data.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Data.UpdatedAt.Nanos = int32(val)
			case "data.data.spec":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.Spec = vals[0]
			case "data.data.readme":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.Readme = vals[0]
			case "data.data.mobileType":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.MobileType = vals[0]
			case "data.data.versionStates":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				m.Data.Data.VersionStates = vals[0]
			case "data.data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.GrayLevelPercent = val
			case "data.publishItem":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
			case "data.publishItem.ID":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.ID = val
			case "data.publishItem.name":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.Name = vals[0]
			case "data.publishItem.displayName":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.DisplayName = vals[0]
			case "data.publishItem.logo":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.Logo = vals[0]
			case "data.publishItem.publisherID":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.PublisherID = val
			case "data.publishItem.aK":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.AK = vals[0]
			case "data.publishItem.aI":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.AI = vals[0]
			case "data.publishItem.type":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.Type = vals[0]
			case "data.publishItem.public":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PublishItem.Public = val
			case "data.publishItem.orgID":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.OrgID = val
			case "data.publishItem.desc":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.Desc = vals[0]
			case "data.publishItem.creator":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.Creator = vals[0]
			case "data.publishItem.downloadUrl":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.DownloadUrl = vals[0]
			case "data.publishItem.createdAt":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				if m.Data.PublishItem.CreatedAt == nil {
					m.Data.PublishItem.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.publishItem.createdAt.seconds":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				if m.Data.PublishItem.CreatedAt == nil {
					m.Data.PublishItem.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.CreatedAt.Seconds = val
			case "data.publishItem.createdAt.nanos":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				if m.Data.PublishItem.CreatedAt == nil {
					m.Data.PublishItem.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PublishItem.CreatedAt.Nanos = int32(val)
			case "data.publishItem.updatedAt":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				if m.Data.PublishItem.UpdatedAt == nil {
					m.Data.PublishItem.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.publishItem.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				if m.Data.PublishItem.UpdatedAt == nil {
					m.Data.PublishItem.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.UpdatedAt.Seconds = val
			case "data.publishItem.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				if m.Data.PublishItem.UpdatedAt == nil {
					m.Data.PublishItem.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PublishItem.UpdatedAt.Nanos = int32(val)
			case "data.publishItem.noJailbreak":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.PublishItem.NoJailbreak = val
			case "data.publishItem.geofenceLon":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.GeofenceLon = val
			case "data.publishItem.geofenceLat":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.GeofenceLat = val
			case "data.publishItem.geofenceRadius":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.GeofenceRadius = val
			case "data.publishItem.grayLevelPercent":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.GrayLevelPercent = val
			case "data.publishItem.latestVersion":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.LatestVersion = vals[0]
			case "data.publishItem.refCount":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublishItem.RefCount = val
			case "data.publishItem.previewImages":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.PreviewImages = vals
			case "data.publishItem.backgroundImage":
				if m.Data == nil {
					m.Data = &CreatePublishItemVersionData{}
				}
				if m.Data.PublishItem == nil {
					m.Data.PublishItem = &PublishItem{}
				}
				m.Data.PublishItem.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// CreatePublishItemVersionData implement urlenc.URLValuesUnmarshaler.
func (m *CreatePublishItemVersionData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.version":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.Version = vals[0]
			case "data.buildID":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.BuildID = vals[0]
			case "data.packageName":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.PackageName = vals[0]
			case "data.public":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			case "data.isDefault":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.IsDefault = val
			case "data.desc":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.Desc = vals[0]
			case "data.logo":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.Logo = vals[0]
			case "data.resources":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Resources = val
					} else {
						m.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.resources.null_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Resources = val
					} else {
						m.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.resources.number_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Resources = val
					} else {
						m.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.resources.string_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Resources = val
					} else {
						m.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.resources.bool_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Resources = val
					} else {
						m.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.resources.struct_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Resources = val
					} else {
						m.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.resources.list_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Resources = val
					} else {
						m.Data.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.meta":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Meta = val
					} else {
						m.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.meta.null_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Meta = val
					} else {
						m.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.meta.number_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Meta = val
					} else {
						m.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.meta.string_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Meta = val
					} else {
						m.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.meta.bool_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Meta = val
					} else {
						m.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.meta.struct_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Meta = val
					} else {
						m.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.meta.list_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Meta = val
					} else {
						m.Data.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.null_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.number_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.string_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.bool_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.struct_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.list_value":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.spec":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.Spec = vals[0]
			case "data.readme":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.Readme = vals[0]
			case "data.mobileType":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.MobileType = vals[0]
			case "data.versionStates":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				m.Data.VersionStates = vals[0]
			case "data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.GrayLevelPercent = val
			case "publishItem":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
			case "publishItem.ID":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItem.ID = val
			case "publishItem.name":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.Name = vals[0]
			case "publishItem.displayName":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.DisplayName = vals[0]
			case "publishItem.logo":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.Logo = vals[0]
			case "publishItem.publisherID":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItem.PublisherID = val
			case "publishItem.aK":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.AK = vals[0]
			case "publishItem.aI":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.AI = vals[0]
			case "publishItem.type":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.Type = vals[0]
			case "publishItem.public":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PublishItem.Public = val
			case "publishItem.orgID":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItem.OrgID = val
			case "publishItem.desc":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.Desc = vals[0]
			case "publishItem.creator":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.Creator = vals[0]
			case "publishItem.downloadUrl":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.DownloadUrl = vals[0]
			case "publishItem.createdAt":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				if m.PublishItem.CreatedAt == nil {
					m.PublishItem.CreatedAt = &timestamppb.Timestamp{}
				}
			case "publishItem.createdAt.seconds":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				if m.PublishItem.CreatedAt == nil {
					m.PublishItem.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItem.CreatedAt.Seconds = val
			case "publishItem.createdAt.nanos":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				if m.PublishItem.CreatedAt == nil {
					m.PublishItem.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PublishItem.CreatedAt.Nanos = int32(val)
			case "publishItem.updatedAt":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				if m.PublishItem.UpdatedAt == nil {
					m.PublishItem.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "publishItem.updatedAt.seconds":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				if m.PublishItem.UpdatedAt == nil {
					m.PublishItem.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItem.UpdatedAt.Seconds = val
			case "publishItem.updatedAt.nanos":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				if m.PublishItem.UpdatedAt == nil {
					m.PublishItem.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PublishItem.UpdatedAt.Nanos = int32(val)
			case "publishItem.noJailbreak":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.PublishItem.NoJailbreak = val
			case "publishItem.geofenceLon":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.PublishItem.GeofenceLon = val
			case "publishItem.geofenceLat":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.PublishItem.GeofenceLat = val
			case "publishItem.geofenceRadius":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.PublishItem.GeofenceRadius = val
			case "publishItem.grayLevelPercent":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItem.GrayLevelPercent = val
			case "publishItem.latestVersion":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.LatestVersion = vals[0]
			case "publishItem.refCount":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItem.RefCount = val
			case "publishItem.previewImages":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.PreviewImages = vals
			case "publishItem.backgroundImage":
				if m.PublishItem == nil {
					m.PublishItem = &PublishItem{}
				}
				m.PublishItem.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// CreateUpdateDeleteReleaseRuleRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateUpdateDeleteReleaseRuleRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "userID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UserID = val
			case "ruleID":
				m.RuleID = vals[0]
			case "body":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Body = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Body = val
					} else {
						m.Body = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// DeletePublishItemBlackListRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeletePublishItemBlackListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			case "blacklistId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.BlacklistId = val
			}
		}
	}
	return nil
}

// GetPublishItemBlackListRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemBlackListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// CreatePublishItemEraseRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreatePublishItemEraseRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "userID":
				m.UserID = vals[0]
			case "userName":
				m.UserName = vals[0]
			case "deviceNo":
				m.DeviceNo = vals[0]
			case "publishItemId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			case "operator":
				m.Operator = vals[0]
			}
		}
	}
	return nil
}

// GetPublishItemEraseRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemEraseRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "publishItemId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			}
		}
	}
	return nil
}

// ListPublishItemMonitorKeysRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListPublishItemMonitorKeysRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			}
		}
	}
	return nil
}

// ListPublishItemMonitorKeysResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListPublishItemMonitorKeysResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// MonitorKeys implement urlenc.URLValuesUnmarshaler.
func (m *MonitorKeys) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "aK":
				m.AK = vals[0]
			case "aI":
				m.AI = vals[0]
			case "env":
				m.Env = vals[0]
			case "appID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			}
		}
	}
	return nil
}

// DeletePublishItemResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeletePublishItemResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Name = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DisplayName = vals[0]
			case "data.logo":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Logo = vals[0]
			case "data.publisherID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublisherID = val
			case "data.aK":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AK = vals[0]
			case "data.aI":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AI = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Type = vals[0]
			case "data.public":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.desc":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Desc = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Creator = vals[0]
			case "data.downloadUrl":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DownloadUrl = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.noJailbreak":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.NoJailbreak = val
			case "data.geofenceLon":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLon = val
			case "data.geofenceLat":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLat = val
			case "data.geofenceRadius":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceRadius = val
			case "data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.GrayLevelPercent = val
			case "data.latestVersion":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.LatestVersion = vals[0]
			case "data.refCount":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RefCount = val
			case "data.previewImages":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.PreviewImages = vals
			case "data.backgroundImage":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// GetPublishItemLatestVersionData implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemLatestVersionData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appVersion":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
			case "appVersion.ID":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppVersion.ID = val
			case "appVersion.version":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.Version = vals[0]
			case "appVersion.buildID":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.BuildID = vals[0]
			case "appVersion.packageName":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.PackageName = vals[0]
			case "appVersion.public":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AppVersion.Public = val
			case "appVersion.isDefault":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AppVersion.IsDefault = val
			case "appVersion.desc":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.Desc = vals[0]
			case "appVersion.logo":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.Logo = vals[0]
			case "appVersion.resources":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Resources = val
					} else {
						m.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.resources.null_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Resources = val
					} else {
						m.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.resources.number_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Resources = val
					} else {
						m.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.resources.string_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Resources = val
					} else {
						m.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.resources.bool_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Resources = val
					} else {
						m.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.resources.struct_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Resources = val
					} else {
						m.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.resources.list_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Resources = val
					} else {
						m.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.meta":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Meta = val
					} else {
						m.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.meta.null_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Meta = val
					} else {
						m.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.meta.number_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Meta = val
					} else {
						m.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.meta.string_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Meta = val
					} else {
						m.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.meta.bool_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Meta = val
					} else {
						m.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.meta.struct_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Meta = val
					} else {
						m.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.meta.list_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Meta = val
					} else {
						m.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.swagger":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Swagger = val
					} else {
						m.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.swagger.null_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Swagger = val
					} else {
						m.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.swagger.number_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Swagger = val
					} else {
						m.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.swagger.string_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Swagger = val
					} else {
						m.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.swagger.bool_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Swagger = val
					} else {
						m.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.swagger.struct_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Swagger = val
					} else {
						m.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.swagger.list_value":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.AppVersion.Swagger = val
					} else {
						m.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "appVersion.orgID":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppVersion.OrgID = val
			case "appVersion.createdAt":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if m.AppVersion.CreatedAt == nil {
					m.AppVersion.CreatedAt = &timestamppb.Timestamp{}
				}
			case "appVersion.createdAt.seconds":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if m.AppVersion.CreatedAt == nil {
					m.AppVersion.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppVersion.CreatedAt.Seconds = val
			case "appVersion.createdAt.nanos":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if m.AppVersion.CreatedAt == nil {
					m.AppVersion.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.AppVersion.CreatedAt.Nanos = int32(val)
			case "appVersion.updatedAt":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if m.AppVersion.UpdatedAt == nil {
					m.AppVersion.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "appVersion.updatedAt.seconds":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if m.AppVersion.UpdatedAt == nil {
					m.AppVersion.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppVersion.UpdatedAt.Seconds = val
			case "appVersion.updatedAt.nanos":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				if m.AppVersion.UpdatedAt == nil {
					m.AppVersion.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.AppVersion.UpdatedAt.Nanos = int32(val)
			case "appVersion.spec":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.Spec = vals[0]
			case "appVersion.readme":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.Readme = vals[0]
			case "appVersion.mobileType":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.MobileType = vals[0]
			case "appVersion.versionStates":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				m.AppVersion.VersionStates = vals[0]
			case "appVersion.grayLevelPercent":
				if m.AppVersion == nil {
					m.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppVersion.GrayLevelPercent = val
			}
		}
	}
	return nil
}

// GetPublishItemLatestVersionRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemLatestVersionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ak":
				m.Ak = vals[0]
			case "ai":
				m.Ai = vals[0]
			case "currentAppInfo":
				if m.CurrentAppInfo == nil {
					m.CurrentAppInfo = &VersionInfo{}
				}
			case "currentAppInfo.packageName":
				if m.CurrentAppInfo == nil {
					m.CurrentAppInfo = &VersionInfo{}
				}
				m.CurrentAppInfo.PackageName = vals[0]
			case "currentAppInfo.version":
				if m.CurrentAppInfo == nil {
					m.CurrentAppInfo = &VersionInfo{}
				}
				m.CurrentAppInfo.Version = vals[0]
			case "currentAppInfo.buildID":
				if m.CurrentAppInfo == nil {
					m.CurrentAppInfo = &VersionInfo{}
				}
				m.CurrentAppInfo.BuildID = vals[0]
			case "mobileType":
				m.MobileType = vals[0]
			case "forceBetaH5":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.ForceBetaH5 = val
			case "check":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Check = val
			}
		}
	}
	return nil
}

// GetPublishItemLatestVersionResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemLatestVersionResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
			case "data.appVersion":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
			case "data.appVersion.ID":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AppVersion.ID = val
			case "data.appVersion.version":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.Version = vals[0]
			case "data.appVersion.buildID":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.BuildID = vals[0]
			case "data.appVersion.packageName":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.PackageName = vals[0]
			case "data.appVersion.public":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.AppVersion.Public = val
			case "data.appVersion.isDefault":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.AppVersion.IsDefault = val
			case "data.appVersion.desc":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.Desc = vals[0]
			case "data.appVersion.logo":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.Logo = vals[0]
			case "data.appVersion.resources":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Resources = val
					} else {
						m.Data.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.resources.null_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Resources = val
					} else {
						m.Data.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.resources.number_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Resources = val
					} else {
						m.Data.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.resources.string_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Resources = val
					} else {
						m.Data.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.resources.bool_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Resources = val
					} else {
						m.Data.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.resources.struct_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Resources = val
					} else {
						m.Data.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.resources.list_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Resources = val
					} else {
						m.Data.AppVersion.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.meta":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Meta = val
					} else {
						m.Data.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.meta.null_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Meta = val
					} else {
						m.Data.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.meta.number_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Meta = val
					} else {
						m.Data.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.meta.string_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Meta = val
					} else {
						m.Data.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.meta.bool_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Meta = val
					} else {
						m.Data.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.meta.struct_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Meta = val
					} else {
						m.Data.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.meta.list_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Meta = val
					} else {
						m.Data.AppVersion.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.swagger":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Swagger = val
					} else {
						m.Data.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.swagger.null_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Swagger = val
					} else {
						m.Data.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.swagger.number_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Swagger = val
					} else {
						m.Data.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.swagger.string_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Swagger = val
					} else {
						m.Data.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.swagger.bool_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Swagger = val
					} else {
						m.Data.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.swagger.struct_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Swagger = val
					} else {
						m.Data.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.swagger.list_value":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.AppVersion.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.AppVersion.Swagger = val
					} else {
						m.Data.AppVersion.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.appVersion.orgID":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AppVersion.OrgID = val
			case "data.appVersion.createdAt":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if m.Data.AppVersion.CreatedAt == nil {
					m.Data.AppVersion.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.appVersion.createdAt.seconds":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if m.Data.AppVersion.CreatedAt == nil {
					m.Data.AppVersion.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AppVersion.CreatedAt.Seconds = val
			case "data.appVersion.createdAt.nanos":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if m.Data.AppVersion.CreatedAt == nil {
					m.Data.AppVersion.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.AppVersion.CreatedAt.Nanos = int32(val)
			case "data.appVersion.updatedAt":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if m.Data.AppVersion.UpdatedAt == nil {
					m.Data.AppVersion.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.appVersion.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if m.Data.AppVersion.UpdatedAt == nil {
					m.Data.AppVersion.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AppVersion.UpdatedAt.Seconds = val
			case "data.appVersion.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				if m.Data.AppVersion.UpdatedAt == nil {
					m.Data.AppVersion.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.AppVersion.UpdatedAt.Nanos = int32(val)
			case "data.appVersion.spec":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.Spec = vals[0]
			case "data.appVersion.readme":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.Readme = vals[0]
			case "data.appVersion.mobileType":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.MobileType = vals[0]
			case "data.appVersion.versionStates":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				m.Data.AppVersion.VersionStates = vals[0]
			case "data.appVersion.grayLevelPercent":
				if m.Data == nil {
					m.Data = &GetPublishItemLatestVersionData{}
				}
				if m.Data.AppVersion == nil {
					m.Data.AppVersion = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AppVersion.GrayLevelPercent = val
			}
		}
	}
	return nil
}

// H5VersionInfo implement urlenc.URLValuesUnmarshaler.
func (m *H5VersionInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "versionInfo":
				if m.VersionInfo == nil {
					m.VersionInfo = &VersionInfo{}
				}
			case "versionInfo.packageName":
				if m.VersionInfo == nil {
					m.VersionInfo = &VersionInfo{}
				}
				m.VersionInfo.PackageName = vals[0]
			case "versionInfo.version":
				if m.VersionInfo == nil {
					m.VersionInfo = &VersionInfo{}
				}
				m.VersionInfo.Version = vals[0]
			case "versionInfo.buildID":
				if m.VersionInfo == nil {
					m.VersionInfo = &VersionInfo{}
				}
				m.VersionInfo.BuildID = vals[0]
			}
		}
	}
	return nil
}

// CreatePublishItemOfflineRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreatePublishItemOfflineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			}
		}
	}
	return nil
}

// CreatePublishItemOfflineResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreatePublishItemOfflineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// DeletePublishItemRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeletePublishItemRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			}
		}
	}
	return nil
}

// DistributePublishItemRequest implement urlenc.URLValuesUnmarshaler.
func (m *DistributePublishItemRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			case "mobileType":
				m.MobileType = vals[0]
			case "packageName":
				m.PackageName = vals[0]
			}
		}
	}
	return nil
}

// GetPublishItemH5PackageNameRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemH5PackageNameRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			}
		}
	}
	return nil
}

// GetPublishItemH5PackageNameResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemH5PackageNameResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals
			}
		}
	}
	return nil
}

// GetPublishItemRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetPublishItemResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetPublishItemResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Name = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DisplayName = vals[0]
			case "data.logo":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Logo = vals[0]
			case "data.publisherID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublisherID = val
			case "data.aK":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AK = vals[0]
			case "data.aI":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AI = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Type = vals[0]
			case "data.public":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.desc":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Desc = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Creator = vals[0]
			case "data.downloadUrl":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DownloadUrl = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.noJailbreak":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.NoJailbreak = val
			case "data.geofenceLon":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLon = val
			case "data.geofenceLat":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLat = val
			case "data.geofenceRadius":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceRadius = val
			case "data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.GrayLevelPercent = val
			case "data.latestVersion":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.LatestVersion = vals[0]
			case "data.refCount":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RefCount = val
			case "data.previewImages":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.PreviewImages = vals
			case "data.backgroundImage":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// GetPublicPublishItemVersionRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetPublicPublishItemVersionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			case "mobileType":
				m.MobileType = vals[0]
			case "packageName":
				m.PackageName = vals[0]
			}
		}
	}
	return nil
}

// SetPublishItemVersionStatusRequest implement urlenc.URLValuesUnmarshaler.
func (m *SetPublishItemVersionStatusRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			case "versionID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.VersionID = val
			case "action":
				m.Action = vals[0]
			}
		}
	}
	return nil
}

// PublicItemAddEraseData implement urlenc.URLValuesUnmarshaler.
func (m *PublicItemAddEraseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Name = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DisplayName = vals[0]
			case "data.logo":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Logo = vals[0]
			case "data.publisherID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublisherID = val
			case "data.aK":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AK = vals[0]
			case "data.aI":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AI = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Type = vals[0]
			case "data.public":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.desc":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Desc = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Creator = vals[0]
			case "data.downloadUrl":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DownloadUrl = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.noJailbreak":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.NoJailbreak = val
			case "data.geofenceLon":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLon = val
			case "data.geofenceLat":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLat = val
			case "data.geofenceRadius":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceRadius = val
			case "data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.GrayLevelPercent = val
			case "data.latestVersion":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.LatestVersion = vals[0]
			case "data.refCount":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RefCount = val
			case "data.previewImages":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.PreviewImages = vals
			case "data.backgroundImage":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.BackgroundImage = vals[0]
			case "deviceNo":
				m.DeviceNo = vals[0]
			}
		}
	}
	return nil
}

// PublicItemAddEraseResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublicItemAddEraseResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
			case "data.data":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
			case "data.data.ID":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.ID = val
			case "data.data.name":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.Name = vals[0]
			case "data.data.displayName":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.DisplayName = vals[0]
			case "data.data.logo":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.Logo = vals[0]
			case "data.data.publisherID":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.PublisherID = val
			case "data.data.aK":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.AK = vals[0]
			case "data.data.aI":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.AI = vals[0]
			case "data.data.type":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.Type = vals[0]
			case "data.data.public":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Data.Public = val
			case "data.data.orgID":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.OrgID = val
			case "data.data.desc":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.Desc = vals[0]
			case "data.data.creator":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.Creator = vals[0]
			case "data.data.downloadUrl":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.DownloadUrl = vals[0]
			case "data.data.createdAt":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				if m.Data.Data.CreatedAt == nil {
					m.Data.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				if m.Data.Data.CreatedAt == nil {
					m.Data.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.CreatedAt.Seconds = val
			case "data.data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				if m.Data.Data.CreatedAt == nil {
					m.Data.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Data.CreatedAt.Nanos = int32(val)
			case "data.data.updatedAt":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				if m.Data.Data.UpdatedAt == nil {
					m.Data.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				if m.Data.Data.UpdatedAt == nil {
					m.Data.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.UpdatedAt.Seconds = val
			case "data.data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				if m.Data.Data.UpdatedAt == nil {
					m.Data.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Data.UpdatedAt.Nanos = int32(val)
			case "data.data.noJailbreak":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Data.NoJailbreak = val
			case "data.data.geofenceLon":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.Data.GeofenceLon = val
			case "data.data.geofenceLat":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.Data.GeofenceLat = val
			case "data.data.geofenceRadius":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.Data.GeofenceRadius = val
			case "data.data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.GrayLevelPercent = val
			case "data.data.latestVersion":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.LatestVersion = vals[0]
			case "data.data.refCount":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Data.RefCount = val
			case "data.data.previewImages":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.PreviewImages = vals
			case "data.data.backgroundImage":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				if m.Data.Data == nil {
					m.Data.Data = &PublishItem{}
				}
				m.Data.Data.BackgroundImage = vals[0]
			case "data.deviceNo":
				if m.Data == nil {
					m.Data = &PublicItemAddEraseData{}
				}
				m.Data.DeviceNo = vals[0]
			}
		}
	}
	return nil
}

// PublishItem implement urlenc.URLValuesUnmarshaler.
func (m *PublishItem) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "publisherID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublisherID = val
			case "aK":
				m.AK = vals[0]
			case "aI":
				m.AI = vals[0]
			case "type":
				m.Type = vals[0]
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "desc":
				m.Desc = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "downloadUrl":
				m.DownloadUrl = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "noJailbreak":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NoJailbreak = val
			case "geofenceLon":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceLon = val
			case "geofenceLat":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceLat = val
			case "geofenceRadius":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceRadius = val
			case "grayLevelPercent":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GrayLevelPercent = val
			case "latestVersion":
				m.LatestVersion = vals[0]
			case "refCount":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RefCount = val
			case "previewImages":
				m.PreviewImages = vals
			case "backgroundImage":
				m.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// PublishItemAddBlacklistResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemAddBlacklistResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Name = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DisplayName = vals[0]
			case "data.logo":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Logo = vals[0]
			case "data.publisherID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublisherID = val
			case "data.aK":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AK = vals[0]
			case "data.aI":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AI = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Type = vals[0]
			case "data.public":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.desc":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Desc = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Creator = vals[0]
			case "data.downloadUrl":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DownloadUrl = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.noJailbreak":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.NoJailbreak = val
			case "data.geofenceLon":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLon = val
			case "data.geofenceLat":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLat = val
			case "data.geofenceRadius":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceRadius = val
			case "data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.GrayLevelPercent = val
			case "data.latestVersion":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.LatestVersion = vals[0]
			case "data.refCount":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RefCount = val
			case "data.previewImages":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.PreviewImages = vals
			case "data.backgroundImage":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// PublishItemDeleteBlacklistResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemDeleteBlacklistResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.userID":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				m.Data.UserID = vals[0]
			case "data.userName":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				m.Data.UserName = vals[0]
			case "data.eraseStatus":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				m.Data.EraseStatus = vals[0]
			case "data.deviceNo":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				m.Data.DeviceNo = vals[0]
			case "data.publishItemID":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublishItemID = val
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.publishItemName":
				if m.Data == nil {
					m.Data = &PublishItemUserListResponse{}
				}
				m.Data.PublishItemName = vals[0]
			}
		}
	}
	return nil
}

// PublishItemDistributionData implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemDistributionData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "default":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
			case "default.ID":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Default.ID = val
			case "default.version":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.Version = vals[0]
			case "default.buildID":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.BuildID = vals[0]
			case "default.packageName":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.PackageName = vals[0]
			case "default.public":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Default.Public = val
			case "default.isDefault":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Default.IsDefault = val
			case "default.desc":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.Desc = vals[0]
			case "default.logo":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.Logo = vals[0]
			case "default.resources":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Resources = val
					} else {
						m.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "default.resources.null_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Resources = val
					} else {
						m.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "default.resources.number_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Resources = val
					} else {
						m.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "default.resources.string_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Resources = val
					} else {
						m.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "default.resources.bool_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Resources = val
					} else {
						m.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "default.resources.struct_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Resources = val
					} else {
						m.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "default.resources.list_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Resources = val
					} else {
						m.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "default.meta":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Meta = val
					} else {
						m.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "default.meta.null_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Meta = val
					} else {
						m.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "default.meta.number_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Meta = val
					} else {
						m.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "default.meta.string_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Meta = val
					} else {
						m.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "default.meta.bool_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Meta = val
					} else {
						m.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "default.meta.struct_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Meta = val
					} else {
						m.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "default.meta.list_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Meta = val
					} else {
						m.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "default.swagger":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Swagger = val
					} else {
						m.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "default.swagger.null_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Swagger = val
					} else {
						m.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "default.swagger.number_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Swagger = val
					} else {
						m.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "default.swagger.string_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Swagger = val
					} else {
						m.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "default.swagger.bool_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Swagger = val
					} else {
						m.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "default.swagger.struct_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Swagger = val
					} else {
						m.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "default.swagger.list_value":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default.Swagger = val
					} else {
						m.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "default.orgID":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Default.OrgID = val
			case "default.createdAt":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if m.Default.CreatedAt == nil {
					m.Default.CreatedAt = &timestamppb.Timestamp{}
				}
			case "default.createdAt.seconds":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if m.Default.CreatedAt == nil {
					m.Default.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Default.CreatedAt.Seconds = val
			case "default.createdAt.nanos":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if m.Default.CreatedAt == nil {
					m.Default.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Default.CreatedAt.Nanos = int32(val)
			case "default.updatedAt":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if m.Default.UpdatedAt == nil {
					m.Default.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "default.updatedAt.seconds":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if m.Default.UpdatedAt == nil {
					m.Default.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Default.UpdatedAt.Seconds = val
			case "default.updatedAt.nanos":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				if m.Default.UpdatedAt == nil {
					m.Default.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Default.UpdatedAt.Nanos = int32(val)
			case "default.spec":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.Spec = vals[0]
			case "default.readme":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.Readme = vals[0]
			case "default.mobileType":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.MobileType = vals[0]
			case "default.versionStates":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				m.Default.VersionStates = vals[0]
			case "default.grayLevelPercent":
				if m.Default == nil {
					m.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Default.GrayLevelPercent = val
			case "versions":
				if m.Versions == nil {
					m.Versions = &QueryPublishItemVersionData{}
				}
			case "versions.total":
				if m.Versions == nil {
					m.Versions = &QueryPublishItemVersionData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Versions.Total = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "previewImages":
				m.PreviewImages = vals
			case "backgroundImage":
				m.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// PublishItemDistributionResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemDistributionResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
			case "data.default":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
			case "data.default.ID":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Default.ID = val
			case "data.default.version":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.Version = vals[0]
			case "data.default.buildID":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.BuildID = vals[0]
			case "data.default.packageName":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.PackageName = vals[0]
			case "data.default.public":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Default.Public = val
			case "data.default.isDefault":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Default.IsDefault = val
			case "data.default.desc":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.Desc = vals[0]
			case "data.default.logo":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.Logo = vals[0]
			case "data.default.resources":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Resources = val
					} else {
						m.Data.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.resources.null_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Resources = val
					} else {
						m.Data.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.resources.number_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Resources = val
					} else {
						m.Data.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.resources.string_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Resources = val
					} else {
						m.Data.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.resources.bool_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Resources = val
					} else {
						m.Data.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.resources.struct_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Resources = val
					} else {
						m.Data.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.resources.list_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Resources = val
					} else {
						m.Data.Default.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.meta":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Meta = val
					} else {
						m.Data.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.meta.null_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Meta = val
					} else {
						m.Data.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.meta.number_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Meta = val
					} else {
						m.Data.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.meta.string_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Meta = val
					} else {
						m.Data.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.meta.bool_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Meta = val
					} else {
						m.Data.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.meta.struct_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Meta = val
					} else {
						m.Data.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.meta.list_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Meta = val
					} else {
						m.Data.Default.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.swagger":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Swagger = val
					} else {
						m.Data.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.swagger.null_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Swagger = val
					} else {
						m.Data.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.swagger.number_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Swagger = val
					} else {
						m.Data.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.swagger.string_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Swagger = val
					} else {
						m.Data.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.swagger.bool_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Swagger = val
					} else {
						m.Data.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.swagger.struct_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Swagger = val
					} else {
						m.Data.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.swagger.list_value":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Default.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Default.Swagger = val
					} else {
						m.Data.Default.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.default.orgID":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Default.OrgID = val
			case "data.default.createdAt":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if m.Data.Default.CreatedAt == nil {
					m.Data.Default.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.default.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if m.Data.Default.CreatedAt == nil {
					m.Data.Default.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Default.CreatedAt.Seconds = val
			case "data.default.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if m.Data.Default.CreatedAt == nil {
					m.Data.Default.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Default.CreatedAt.Nanos = int32(val)
			case "data.default.updatedAt":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if m.Data.Default.UpdatedAt == nil {
					m.Data.Default.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.default.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if m.Data.Default.UpdatedAt == nil {
					m.Data.Default.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Default.UpdatedAt.Seconds = val
			case "data.default.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				if m.Data.Default.UpdatedAt == nil {
					m.Data.Default.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Default.UpdatedAt.Nanos = int32(val)
			case "data.default.spec":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.Spec = vals[0]
			case "data.default.readme":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.Readme = vals[0]
			case "data.default.mobileType":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.MobileType = vals[0]
			case "data.default.versionStates":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				m.Data.Default.VersionStates = vals[0]
			case "data.default.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Default == nil {
					m.Data.Default = &PublishItemVersion{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Default.GrayLevelPercent = val
			case "data.versions":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Versions == nil {
					m.Data.Versions = &QueryPublishItemVersionData{}
				}
			case "data.versions.total":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.Versions == nil {
					m.Data.Versions = &QueryPublishItemVersionData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Versions.Total = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				m.Data.Name = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				m.Data.DisplayName = vals[0]
			case "data.desc":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				m.Data.Desc = vals[0]
			case "data.logo":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				m.Data.Logo = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.previewImages":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				m.Data.PreviewImages = vals
			case "data.backgroundImage":
				if m.Data == nil {
					m.Data = &PublishItemDistributionData{}
				}
				m.Data.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// PublishItemUserListResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemUserListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "userID":
				m.UserID = vals[0]
			case "userName":
				m.UserName = vals[0]
			case "eraseStatus":
				m.EraseStatus = vals[0]
			case "deviceNo":
				m.DeviceNo = vals[0]
			case "publishItemID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemID = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "publishItemName":
				m.PublishItemName = vals[0]
			}
		}
	}
	return nil
}

// PublishItemUserlistRequest implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemUserlistRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "userID":
				m.UserID = vals[0]
			case "userName":
				m.UserName = vals[0]
			case "deviceNo":
				m.DeviceNo = vals[0]
			case "publishItemID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemID = val
			case "operator":
				m.Operator = vals[0]
			}
		}
	}
	return nil
}

// PublishItemUserListDataResponse implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemUserListDataResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItemUserListData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &PublishItemUserListData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// PublishItemUserListData implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemUserListData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// PublishItemVersion implement urlenc.URLValuesUnmarshaler.
func (m *PublishItemVersion) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "version":
				m.Version = vals[0]
			case "buildID":
				m.BuildID = vals[0]
			case "packageName":
				m.PackageName = vals[0]
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "isDefault":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsDefault = val
			case "desc":
				m.Desc = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "resources":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Resources = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Resources = val
					} else {
						m.Resources = structpb.NewStringValue(vals[0])
					}
				}
			case "meta":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Meta = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Meta = val
					} else {
						m.Meta = structpb.NewStringValue(vals[0])
					}
				}
			case "swagger":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Swagger = val
					} else {
						m.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "spec":
				m.Spec = vals[0]
			case "readme":
				m.Readme = vals[0]
			case "mobileType":
				m.MobileType = vals[0]
			case "versionStates":
				m.VersionStates = vals[0]
			case "grayLevelPercent":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GrayLevelPercent = val
			}
		}
	}
	return nil
}

// QueryPublishItemData implement urlenc.URLValuesUnmarshaler.
func (m *QueryPublishItemData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// QueryPublishItemRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryPublishItemRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "publisherId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublisherId = val
			case "name":
				m.Name = vals[0]
			case "type":
				m.Type = vals[0]
			case "public":
				m.Public = vals[0]
			case "q":
				m.Q = vals[0]
			case "ids":
				m.Ids = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// QueryPublishItemResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryPublishItemResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryPublishItemData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &QueryPublishItemData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// QueryPublishItemVersionData implement urlenc.URLValuesUnmarshaler.
func (m *QueryPublishItemVersionData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// QueryPublishItemVersionRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryPublishItemVersionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "public":
				m.Public = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "mobileType":
				m.MobileType = vals[0]
			case "packageName":
				m.PackageName = vals[0]
			case "itemID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ItemID = val
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "isDefault":
				m.IsDefault = vals[0]
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			}
		}
	}
	return nil
}

// QueryPublishItemVersionResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryPublishItemVersionResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryPublishItemVersionData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &QueryPublishItemVersionData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// UpdatePublishItemRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdatePublishItemRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "displayName":
				m.DisplayName = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "desc":
				m.Desc = vals[0]
			case "noJailbreak":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NoJailbreak = val
			case "geofenceLon":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceLon = val
			case "geofenceLat":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceLat = val
			case "geofenceRadius":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.GeofenceRadius = val
			case "grayLevelPercent":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GrayLevelPercent = val
			case "previewImages":
				m.PreviewImages = vals
			case "backgroundImage":
				m.BackgroundImage = vals[0]
			case "publishItemId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemId = val
			}
		}
	}
	return nil
}

// UpdatePublishItemResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdatePublishItemResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
			case "data.ID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ID = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Name = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DisplayName = vals[0]
			case "data.logo":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Logo = vals[0]
			case "data.publisherID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PublisherID = val
			case "data.aK":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AK = vals[0]
			case "data.aI":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.AI = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Type = vals[0]
			case "data.public":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			case "data.orgID":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.desc":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Desc = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.Creator = vals[0]
			case "data.downloadUrl":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.DownloadUrl = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.noJailbreak":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.NoJailbreak = val
			case "data.geofenceLon":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLon = val
			case "data.geofenceLat":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceLat = val
			case "data.geofenceRadius":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.GeofenceRadius = val
			case "data.grayLevelPercent":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.GrayLevelPercent = val
			case "data.latestVersion":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.LatestVersion = vals[0]
			case "data.refCount":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RefCount = val
			case "data.previewImages":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.PreviewImages = vals
			case "data.backgroundImage":
				if m.Data == nil {
					m.Data = &PublishItem{}
				}
				m.Data.BackgroundImage = vals[0]
			}
		}
	}
	return nil
}

// UpdatePublishItemVersionStatesRequset implement urlenc.URLValuesUnmarshaler.
func (m *UpdatePublishItemVersionStatesRequset) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "publishItemID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemID = val
			case "publishItemVersionID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PublishItemVersionID = val
			case "packageName":
				m.PackageName = vals[0]
			case "versionStates":
				m.VersionStates = vals[0]
			case "grayLevelPercent":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GrayLevelPercent = val
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "action":
				m.Action = vals[0]
			}
		}
	}
	return nil
}

// VersionInfo implement urlenc.URLValuesUnmarshaler.
func (m *VersionInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageName":
				m.PackageName = vals[0]
			case "version":
				m.Version = vals[0]
			case "buildID":
				m.BuildID = vals[0]
			}
		}
	}
	return nil
}
