// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: core.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	pb "github.com/erda-project/erda-proto-go/common/pb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*IssueCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BatchUpdateIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BatchUpdateIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssueTypeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssueTypeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueStageRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueStageResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssueStageResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateIssuePropertyInstanceRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateIssuePropertyInstanceResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssuePropertyInstanceRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssuePropertyInstanceResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateIssuePropertyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateIssuePropertyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteIssuePropertyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteIssuePropertyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssuePropertyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssuePropertyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssuePropertyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssuePropertyResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssuePropertiesIndexRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssuePropertiesIndexResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssuePropertyUpdateTimeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssuePropertyUpdateTimeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SubscribeIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SubscribeIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnsubscribeIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UnsubscribeIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BatchUpdateIssueSubscriberRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BatchUpdateIssueSubscriberResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Issue)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueStage)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssuePropertyInstance)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssuePropertyIndex)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PropertyEnumerate)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ScopeTypeEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueTypeEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssuePriorityEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueComplexityEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueSeverityEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueStateBelongEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectLabelTypeEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueManHour)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueStateButton)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueSummary)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectLabel)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanCaseRel)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestCaseAPICount)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestPlanCaseRelIssueBug)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TestCasePriorityEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PropertyTypeEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PropertyIssueTypeEnum)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Enumerate)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueAndPropertyAndValue)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssuePropertyExtraProperty)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssuePropertyUpdateTimes)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagingIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssuePagingResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExportExcelIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExportExcelIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ImportExcelIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ImportExcelIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AddIssueRelationRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AddIssueRelationResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteIssueRelationRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteIssueRelationResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueRelationsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueRelationsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueRelations)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateIssueStateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateIssueStateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteIssueStateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteIssueStateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueStatus)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueStateRelation)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssueStateRelationRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateIssueStateRelationResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueStatesRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueStatesResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueTypeState)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueStateRelationRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIssueStateRelationResponse)(nil)

// IssueCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *IssueCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "planStartedAt":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
			case "planStartedAt.seconds":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Seconds = val
			case "planStartedAt.nanos":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Nanos = int32(val)
			case "planFinishedAt":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
			case "planFinishedAt.seconds":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Seconds = val
			case "planFinishedAt.nanos":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Nanos = int32(val)
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = &val
			case "testPlanCaseRelIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.TestPlanCaseRelIDs = list
			case "type":
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "priority":
			case "complexity":
			case "severity":
			case "assignee":
				m.Assignee = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "labels":
				m.Labels = vals
			case "source":
				m.Source = vals[0]
			case "issueManHour":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
			case "issueManHour.estimateTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.EstimateTime = val
			case "issueManHour.thisElapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ThisElapsedTime = val
			case "issueManHour.elapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ElapsedTime = val
			case "issueManHour.remainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.RemainingTime = val
			case "issueManHour.startTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.StartTime = vals[0]
			case "issueManHour.workContent":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.WorkContent = vals[0]
			case "issueManHour.isModifiedRemainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IssueManHour.IsModifiedRemainingTime = val
			case "taskType":
				m.TaskType = vals[0]
			case "bugStage":
				m.BugStage = vals[0]
			case "subscribers":
				m.Subscribers = vals
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			case "external":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.External = val
			case "owner":
				m.Owner = vals[0]
			}
		}
	}
	return nil
}

// IssueCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *IssueCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// GetIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// GetIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.planStartedAt":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanStartedAt == nil {
					m.Data.PlanStartedAt = &timestamppb.Timestamp{}
				}
			case "data.planStartedAt.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanStartedAt == nil {
					m.Data.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PlanStartedAt.Seconds = val
			case "data.planStartedAt.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanStartedAt == nil {
					m.Data.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PlanStartedAt.Nanos = int32(val)
			case "data.planFinishedAt":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanFinishedAt == nil {
					m.Data.PlanFinishedAt = &timestamppb.Timestamp{}
				}
			case "data.planFinishedAt.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanFinishedAt == nil {
					m.Data.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PlanFinishedAt.Seconds = val
			case "data.planFinishedAt.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanFinishedAt == nil {
					m.Data.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PlanFinishedAt.Nanos = int32(val)
			case "data.projectID":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.iterationID":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IterationID = val
			case "data.appID":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AppID = val
			case "data.requirementID":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RequirementID = val
			case "data.requirementTitle":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.RequirementTitle = vals[0]
			case "data.title":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Title = vals[0]
			case "data.content":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Content = vals[0]
			case "data.state":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.State = val
			case "data.priority":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "data.complexity":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "data.severity":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "data.assignee":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Assignee = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Creator = vals[0]
			case "data.issueSummary":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueSummary == nil {
					m.Data.IssueSummary = &IssueSummary{}
				}
			case "data.issueSummary.processingCount":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueSummary == nil {
					m.Data.IssueSummary = &IssueSummary{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.IssueSummary.ProcessingCount = int32(val)
			case "data.issueSummary.doneCount":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueSummary == nil {
					m.Data.IssueSummary = &IssueSummary{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.IssueSummary.DoneCount = int32(val)
			case "data.labels":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Labels = vals
			case "data.issueManHour":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
			case "data.issueManHour.estimateTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueManHour.EstimateTime = val
			case "data.issueManHour.thisElapsedTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueManHour.ThisElapsedTime = val
			case "data.issueManHour.elapsedTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueManHour.ElapsedTime = val
			case "data.issueManHour.remainingTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueManHour.RemainingTime = val
			case "data.issueManHour.startTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				m.Data.IssueManHour.StartTime = vals[0]
			case "data.issueManHour.workContent":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				m.Data.IssueManHour.WorkContent = vals[0]
			case "data.issueManHour.isModifiedRemainingTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.IssueManHour.IsModifiedRemainingTime = val
			case "data.source":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Source = vals[0]
			case "data.taskType":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.TaskType = vals[0]
			case "data.bugStage":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.BugStage = vals[0]
			case "data.owner":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Owner = vals[0]
			case "data.subscribers":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Subscribers = vals
			case "data.finishTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.FinishTime == nil {
					m.Data.FinishTime = &timestamppb.Timestamp{}
				}
			case "data.finishTime.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.FinishTime == nil {
					m.Data.FinishTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.FinishTime.Seconds = val
			case "data.finishTime.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.FinishTime == nil {
					m.Data.FinishTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.FinishTime.Nanos = int32(val)
			case "data.relatedIssueIDs":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.RelatedIssueIDs = list
			case "data.reopenCount":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.ReopenCount = int32(val)
			case "data.type":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// UpdateIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "title":
				m.Title = &vals[0]
			case "content":
				m.Content = &vals[0]
			case "priority":
				m.Priority = &vals[0]
			case "complexity":
				m.Complexity = &vals[0]
			case "severity":
				m.Severity = &vals[0]
			case "planStartedAt":
				m.PlanStartedAt = &vals[0]
			case "planFinishedAt":
				m.PlanFinishedAt = &vals[0]
			case "assignee":
				m.Assignee = &vals[0]
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = &val
			case "source":
				m.Source = &vals[0]
			case "labels":
				m.Labels = vals
			case "relatedIssues":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.RelatedIssues = list
			case "taskType":
				m.TaskType = &vals[0]
			case "bugStage":
				m.BugStage = &vals[0]
			case "owner":
				m.Owner = &vals[0]
			case "withChildrenIteration":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.WithChildrenIteration = val
			case "issueManHour":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
			case "issueManHour.estimateTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.EstimateTime = val
			case "issueManHour.thisElapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ThisElapsedTime = val
			case "issueManHour.elapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ElapsedTime = val
			case "issueManHour.remainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.RemainingTime = val
			case "issueManHour.startTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.StartTime = vals[0]
			case "issueManHour.workContent":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.WorkContent = vals[0]
			case "issueManHour.isModifiedRemainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IssueManHour.IsModifiedRemainingTime = val
			case "testPlanCaseRelIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.TestPlanCaseRelIDs = list
			case "removeTestPlanCaseRelIDs":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.RemoveTestPlanCaseRelIDs = val
			case "state":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.State = &val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// UpdateIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// DeleteIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// DeleteIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.planStartedAt":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanStartedAt == nil {
					m.Data.PlanStartedAt = &timestamppb.Timestamp{}
				}
			case "data.planStartedAt.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanStartedAt == nil {
					m.Data.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PlanStartedAt.Seconds = val
			case "data.planStartedAt.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanStartedAt == nil {
					m.Data.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PlanStartedAt.Nanos = int32(val)
			case "data.planFinishedAt":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanFinishedAt == nil {
					m.Data.PlanFinishedAt = &timestamppb.Timestamp{}
				}
			case "data.planFinishedAt.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanFinishedAt == nil {
					m.Data.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PlanFinishedAt.Seconds = val
			case "data.planFinishedAt.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.PlanFinishedAt == nil {
					m.Data.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.PlanFinishedAt.Nanos = int32(val)
			case "data.projectID":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.iterationID":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IterationID = val
			case "data.appID":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AppID = val
			case "data.requirementID":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RequirementID = val
			case "data.requirementTitle":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.RequirementTitle = vals[0]
			case "data.title":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Title = vals[0]
			case "data.content":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Content = vals[0]
			case "data.state":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.State = val
			case "data.priority":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "data.complexity":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "data.severity":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			case "data.assignee":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Assignee = vals[0]
			case "data.creator":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Creator = vals[0]
			case "data.issueSummary":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueSummary == nil {
					m.Data.IssueSummary = &IssueSummary{}
				}
			case "data.issueSummary.processingCount":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueSummary == nil {
					m.Data.IssueSummary = &IssueSummary{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.IssueSummary.ProcessingCount = int32(val)
			case "data.issueSummary.doneCount":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueSummary == nil {
					m.Data.IssueSummary = &IssueSummary{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.IssueSummary.DoneCount = int32(val)
			case "data.labels":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Labels = vals
			case "data.issueManHour":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
			case "data.issueManHour.estimateTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueManHour.EstimateTime = val
			case "data.issueManHour.thisElapsedTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueManHour.ThisElapsedTime = val
			case "data.issueManHour.elapsedTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueManHour.ElapsedTime = val
			case "data.issueManHour.remainingTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueManHour.RemainingTime = val
			case "data.issueManHour.startTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				m.Data.IssueManHour.StartTime = vals[0]
			case "data.issueManHour.workContent":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				m.Data.IssueManHour.WorkContent = vals[0]
			case "data.issueManHour.isModifiedRemainingTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.IssueManHour == nil {
					m.Data.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.IssueManHour.IsModifiedRemainingTime = val
			case "data.source":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Source = vals[0]
			case "data.taskType":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.TaskType = vals[0]
			case "data.bugStage":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.BugStage = vals[0]
			case "data.owner":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Owner = vals[0]
			case "data.subscribers":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				m.Data.Subscribers = vals
			case "data.finishTime":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.FinishTime == nil {
					m.Data.FinishTime = &timestamppb.Timestamp{}
				}
			case "data.finishTime.seconds":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.FinishTime == nil {
					m.Data.FinishTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.FinishTime.Seconds = val
			case "data.finishTime.nanos":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				if m.Data.FinishTime == nil {
					m.Data.FinishTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.FinishTime.Nanos = int32(val)
			case "data.relatedIssueIDs":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.RelatedIssueIDs = list
			case "data.reopenCount":
				if m.Data == nil {
					m.Data = &Issue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.ReopenCount = int32(val)
			case "data.type":
				if m.Data == nil {
					m.Data = &Issue{}
				}
			}
		}
	}
	return nil
}

// BatchUpdateIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *BatchUpdateIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "all":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.All = val
			case "mine":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Mine = val
			case "ids":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Ids = list
			case "assignee":
				m.Assignee = vals[0]
			case "state":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.State = val
			case "newIterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NewIterationID = val
			case "taskType":
				m.TaskType = vals[0]
			case "bugStage":
				m.BugStage = vals[0]
			case "owner":
				m.Owner = vals[0]
			case "currentIterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CurrentIterationID = val
			case "currentIterationIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.CurrentIterationIDs = list
			case "type":
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// BatchUpdateIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *BatchUpdateIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateIssueTypeRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssueTypeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "type":
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// UpdateIssueTypeResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssueTypeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// IssueStageRequest implement urlenc.URLValuesUnmarshaler.
func (m *IssueStageRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "issueType":
				m.IssueType = vals[0]
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// GetIssueStageResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueStageResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateIssueStageResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssueStageResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CreateIssuePropertyInstanceRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateIssuePropertyInstanceRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "issueID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// CreateIssuePropertyInstanceResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateIssuePropertyInstanceResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// GetIssuePropertyInstanceRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetIssuePropertyInstanceRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "issueID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "propertyIssueType":
				m.PropertyIssueType = vals[0]
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// GetIssuePropertyInstanceResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIssuePropertyInstanceResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &IssueAndPropertyAndValue{}
				}
			case "data.issueID":
				if m.Data == nil {
					m.Data = &IssueAndPropertyAndValue{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueID = val
			}
		}
	}
	return nil
}

// CreateIssuePropertyRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateIssuePropertyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScopeID = val
			case "scopeType":
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "propertyName":
				m.PropertyName = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "propertyType":
			case "required":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Required = val
			case "propertyIssueType":
			case "relation":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Relation = val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// CreateIssuePropertyResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateIssuePropertyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.propertyID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PropertyID = val
			case "data.scopeID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ScopeID = val
			case "data.scopeType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.propertyName":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.PropertyName = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.DisplayName = vals[0]
			case "data.propertyType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.required":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Required = val
			case "data.propertyIssueType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.relation":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Relation = val
			case "data.index":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Index = val
			case "data.values":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.Values = list
			case "data.relatedIssue":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.RelatedIssue = vals
			}
		}
	}
	return nil
}

// DeleteIssuePropertyRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteIssuePropertyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "propertyID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PropertyID = val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// DeleteIssuePropertyResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteIssuePropertyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.propertyID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PropertyID = val
			case "data.scopeID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ScopeID = val
			case "data.scopeType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.propertyName":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.PropertyName = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.DisplayName = vals[0]
			case "data.propertyType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.required":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Required = val
			case "data.propertyIssueType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.relation":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Relation = val
			case "data.index":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Index = val
			case "data.values":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.Values = list
			case "data.relatedIssue":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.RelatedIssue = vals
			}
		}
	}
	return nil
}

// UpdateIssuePropertyRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssuePropertyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "propertyID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PropertyID = val
			case "scopeID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScopeID = val
			case "scopeType":
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "propertyName":
				m.PropertyName = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "propertyType":
			case "required":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Required = val
			case "propertyIssueType":
			case "relation":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Relation = val
			case "index":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Index = val
			case "values":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Values = list
			case "relatedIssue":
				m.RelatedIssue = vals
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// UpdateIssuePropertyResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssuePropertyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.propertyID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.PropertyID = val
			case "data.scopeID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ScopeID = val
			case "data.scopeType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.orgID":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.propertyName":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.PropertyName = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.DisplayName = vals[0]
			case "data.propertyType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.required":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Required = val
			case "data.propertyIssueType":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
			case "data.relation":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Relation = val
			case "data.index":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Index = val
			case "data.values":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.Values = list
			case "data.relatedIssue":
				if m.Data == nil {
					m.Data = &IssuePropertyIndex{}
				}
				m.Data.RelatedIssue = vals
			}
		}
	}
	return nil
}

// GetIssuePropertyRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetIssuePropertyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "propertyIssueType":
				m.PropertyIssueType = vals[0]
			case "propertyName":
				m.PropertyName = vals[0]
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// GetIssuePropertyResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIssuePropertyResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateIssuePropertiesIndexRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssuePropertiesIndexRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// UpdateIssuePropertiesIndexResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssuePropertiesIndexResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetIssuePropertyUpdateTimeRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetIssuePropertyUpdateTimeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			}
		}
	}
	return nil
}

// GetIssuePropertyUpdateTimeResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIssuePropertyUpdateTimeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &IssuePropertyUpdateTimes{}
				}
			case "data.task":
				if m.Data == nil {
					m.Data = &IssuePropertyUpdateTimes{}
				}
				m.Data.Task = vals[0]
			case "data.bug":
				if m.Data == nil {
					m.Data = &IssuePropertyUpdateTimes{}
				}
				m.Data.Bug = vals[0]
			case "data.epic":
				if m.Data == nil {
					m.Data = &IssuePropertyUpdateTimes{}
				}
				m.Data.Epic = vals[0]
			case "data.requirement":
				if m.Data == nil {
					m.Data = &IssuePropertyUpdateTimes{}
				}
				m.Data.Requirement = vals[0]
			}
		}
	}
	return nil
}

// SubscribeIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *SubscribeIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// SubscribeIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *SubscribeIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UnsubscribeIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *UnsubscribeIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// UnsubscribeIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *UnsubscribeIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// BatchUpdateIssueSubscriberRequest implement urlenc.URLValuesUnmarshaler.
func (m *BatchUpdateIssueSubscriberRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "subscribers":
				m.Subscribers = vals
			case "issueID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			case "id":
				m.Id = vals[0]
			case "isIncrementalUpdate":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsIncrementalUpdate = val
			}
		}
	}
	return nil
}

// BatchUpdateIssueSubscriberResponse implement urlenc.URLValuesUnmarshaler.
func (m *BatchUpdateIssueSubscriberResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// Issue implement urlenc.URLValuesUnmarshaler.
func (m *Issue) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "planStartedAt":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
			case "planStartedAt.seconds":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Seconds = val
			case "planStartedAt.nanos":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Nanos = int32(val)
			case "planFinishedAt":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
			case "planFinishedAt.seconds":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Seconds = val
			case "planFinishedAt.nanos":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Nanos = int32(val)
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "requirementID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RequirementID = val
			case "requirementTitle":
				m.RequirementTitle = vals[0]
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "state":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.State = val
			case "priority":
			case "complexity":
			case "severity":
			case "assignee":
				m.Assignee = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "issueSummary":
				if m.IssueSummary == nil {
					m.IssueSummary = &IssueSummary{}
				}
			case "issueSummary.processingCount":
				if m.IssueSummary == nil {
					m.IssueSummary = &IssueSummary{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.IssueSummary.ProcessingCount = int32(val)
			case "issueSummary.doneCount":
				if m.IssueSummary == nil {
					m.IssueSummary = &IssueSummary{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.IssueSummary.DoneCount = int32(val)
			case "labels":
				m.Labels = vals
			case "issueManHour":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
			case "issueManHour.estimateTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.EstimateTime = val
			case "issueManHour.thisElapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ThisElapsedTime = val
			case "issueManHour.elapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ElapsedTime = val
			case "issueManHour.remainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.RemainingTime = val
			case "issueManHour.startTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.StartTime = vals[0]
			case "issueManHour.workContent":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.WorkContent = vals[0]
			case "issueManHour.isModifiedRemainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IssueManHour.IsModifiedRemainingTime = val
			case "source":
				m.Source = vals[0]
			case "taskType":
				m.TaskType = vals[0]
			case "bugStage":
				m.BugStage = vals[0]
			case "owner":
				m.Owner = vals[0]
			case "subscribers":
				m.Subscribers = vals
			case "finishTime":
				if m.FinishTime == nil {
					m.FinishTime = &timestamppb.Timestamp{}
				}
			case "finishTime.seconds":
				if m.FinishTime == nil {
					m.FinishTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FinishTime.Seconds = val
			case "finishTime.nanos":
				if m.FinishTime == nil {
					m.FinishTime = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.FinishTime.Nanos = int32(val)
			case "relatedIssueIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.RelatedIssueIDs = list
			case "reopenCount":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ReopenCount = int32(val)
			case "type":
			}
		}
	}
	return nil
}

// IssueStage implement urlenc.URLValuesUnmarshaler.
func (m *IssueStage) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "value":
				m.Value = vals[0]
			}
		}
	}
	return nil
}

// IssuePropertyInstance implement urlenc.URLValuesUnmarshaler.
func (m *IssuePropertyInstance) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "propertyID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PropertyID = val
			case "scopeID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScopeID = val
			case "scopeType":
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "propertyName":
				m.PropertyName = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "propertyType":
			case "required":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Required = val
			case "propertyIssueType":
			case "relation":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Relation = val
			case "index":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Index = val
			case "values":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Values = list
			case "relatedIssue":
				m.RelatedIssue = vals
			case "arbitraryValue":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ArbitraryValue = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ArbitraryValue = val
					} else {
						m.ArbitraryValue = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// IssuePropertyIndex implement urlenc.URLValuesUnmarshaler.
func (m *IssuePropertyIndex) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "propertyID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PropertyID = val
			case "scopeID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ScopeID = val
			case "scopeType":
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "propertyName":
				m.PropertyName = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "propertyType":
			case "required":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Required = val
			case "propertyIssueType":
			case "relation":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Relation = val
			case "index":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Index = val
			case "values":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Values = list
			case "relatedIssue":
				m.RelatedIssue = vals
			}
		}
	}
	return nil
}

// PropertyEnumerate implement urlenc.URLValuesUnmarshaler.
func (m *PropertyEnumerate) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// ScopeTypeEnum implement urlenc.URLValuesUnmarshaler.
func (m *ScopeTypeEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// IssueTypeEnum implement urlenc.URLValuesUnmarshaler.
func (m *IssueTypeEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// IssuePriorityEnum implement urlenc.URLValuesUnmarshaler.
func (m *IssuePriorityEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// IssueComplexityEnum implement urlenc.URLValuesUnmarshaler.
func (m *IssueComplexityEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// IssueSeverityEnum implement urlenc.URLValuesUnmarshaler.
func (m *IssueSeverityEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// IssueStateBelongEnum implement urlenc.URLValuesUnmarshaler.
func (m *IssueStateBelongEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ProjectLabelTypeEnum implement urlenc.URLValuesUnmarshaler.
func (m *ProjectLabelTypeEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// IssueManHour implement urlenc.URLValuesUnmarshaler.
func (m *IssueManHour) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "estimateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EstimateTime = val
			case "thisElapsedTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ThisElapsedTime = val
			case "elapsedTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ElapsedTime = val
			case "remainingTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RemainingTime = val
			case "startTime":
				m.StartTime = vals[0]
			case "workContent":
				m.WorkContent = vals[0]
			case "isModifiedRemainingTime":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsModifiedRemainingTime = val
			}
		}
	}
	return nil
}

// IssueStateButton implement urlenc.URLValuesUnmarshaler.
func (m *IssueStateButton) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "stateID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StateID = val
			case "stateName":
				m.StateName = vals[0]
			case "stateBelong":
			case "permission":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Permission = val
			}
		}
	}
	return nil
}

// IssueSummary implement urlenc.URLValuesUnmarshaler.
func (m *IssueSummary) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "processingCount":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ProcessingCount = int32(val)
			case "doneCount":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.DoneCount = int32(val)
			}
		}
	}
	return nil
}

// ProjectLabel implement urlenc.URLValuesUnmarshaler.
func (m *ProjectLabel) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "type":
			case "color":
				m.Color = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "creator":
				m.Creator = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// TestPlanCaseRel implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanCaseRel) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "testPlanID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TestPlanID = val
			case "testSetID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TestSetID = val
			case "testCaseID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TestCaseID = val
			case "execStatus":
				m.ExecStatus = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "updaterID":
				m.UpdaterID = vals[0]
			case "executorID":
				m.ExecutorID = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "APICount":
				if m.APICount == nil {
					m.APICount = &TestCaseAPICount{}
				}
			case "APICount.total":
				if m.APICount == nil {
					m.APICount = &TestCaseAPICount{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.APICount.Total = val
			case "APICount.created":
				if m.APICount == nil {
					m.APICount = &TestCaseAPICount{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.APICount.Created = val
			case "APICount.running":
				if m.APICount == nil {
					m.APICount = &TestCaseAPICount{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.APICount.Running = val
			case "APICount.passed":
				if m.APICount == nil {
					m.APICount = &TestCaseAPICount{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.APICount.Passed = val
			case "APICount.failed":
				if m.APICount == nil {
					m.APICount = &TestCaseAPICount{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.APICount.Failed = val
			}
		}
	}
	return nil
}

// TestCaseAPICount implement urlenc.URLValuesUnmarshaler.
func (m *TestCaseAPICount) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			case "created":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Created = val
			case "running":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Running = val
			case "passed":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Passed = val
			case "failed":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Failed = val
			}
		}
	}
	return nil
}

// TestPlanCaseRelIssueBug implement urlenc.URLValuesUnmarshaler.
func (m *TestPlanCaseRelIssueBug) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueRelationID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueRelationID = val
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "title":
				m.Title = vals[0]
			case "state":
				m.State = vals[0]
			case "stateBelong":
				m.StateBelong = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// TestCasePriorityEnum implement urlenc.URLValuesUnmarshaler.
func (m *TestCasePriorityEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PropertyTypeEnum implement urlenc.URLValuesUnmarshaler.
func (m *PropertyTypeEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PropertyIssueTypeEnum implement urlenc.URLValuesUnmarshaler.
func (m *PropertyIssueTypeEnum) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// Enumerate implement urlenc.URLValuesUnmarshaler.
func (m *Enumerate) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "index":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Index = val
			}
		}
	}
	return nil
}

// IssueAndPropertyAndValue implement urlenc.URLValuesUnmarshaler.
func (m *IssueAndPropertyAndValue) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			}
		}
	}
	return nil
}

// IssuePropertyExtraProperty implement urlenc.URLValuesUnmarshaler.
func (m *IssuePropertyExtraProperty) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "propertyID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PropertyID = val
			case "propertyType":
			case "propertyName":
				m.PropertyName = vals[0]
			case "required":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Required = val
			case "displayName":
				m.DisplayName = vals[0]
			case "arbitraryValue":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.ArbitraryValue = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.ArbitraryValue = val
					} else {
						m.ArbitraryValue = structpb.NewStringValue(vals[0])
					}
				}
			case "values":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Values = list
			}
		}
	}
	return nil
}

// IssuePropertyUpdateTimes implement urlenc.URLValuesUnmarshaler.
func (m *IssuePropertyUpdateTimes) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "task":
				m.Task = vals[0]
			case "bug":
				m.Bug = vals[0]
			case "epic":
				m.Epic = vals[0]
			case "requirement":
				m.Requirement = vals[0]
			}
		}
	}
	return nil
}

// PagingIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *PagingIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "type":
				m.Type = vals
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "iterationIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IterationIDs = list
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = &val
			case "requirementID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RequirementID = &val
			case "state":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.State = list
			case "stateBelongs":
				m.StateBelongs = vals
			case "creator":
				m.Creator = vals
			case "assignee":
				m.Assignee = vals
			case "label":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Label = list
			case "startCreatedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartCreatedAt = val
			case "endCreatedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndCreatedAt = val
			case "startFinishedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartFinishedAt = val
			case "endFinishedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndFinishedAt = val
			case "isEmptyPlanFinishedAt":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsEmptyPlanFinishedAt = val
			case "startClosedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartClosedAt = val
			case "endClosedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndClosedAt = val
			case "priority":
				m.Priority = vals
			case "complexity":
				m.Complexity = vals
			case "severity":
				m.Severity = vals
			case "relatedIssueId":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.RelatedIssueId = list
			case "source":
				m.Source = vals[0]
			case "orderBy":
				m.OrderBy = vals[0]
			case "taskType":
				m.TaskType = vals
			case "bugStage":
				m.BugStage = vals
			case "owner":
				m.Owner = vals
			case "withProcessSummary":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.WithProcessSummary = val
			case "exceptIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ExceptIDs = list
			case "asc":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Asc = val
			case "IDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IDs = list
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			case "external":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.External = val
			case "customPanelID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CustomPanelID = val
			case "onlyIdResult":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.OnlyIdResult = val
			case "notIncluded":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NotIncluded = val
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ProjectIDs = list
			case "participant":
				m.Participant = vals
			case "withCustomProperties":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.WithCustomProperties = val
			}
		}
	}
	return nil
}

// IssueListRequest implement urlenc.URLValuesUnmarshaler.
func (m *IssueListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "type":
				m.Type = vals
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "iterationIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IterationIDs = list
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = &val
			case "requirementID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RequirementID = &val
			case "state":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.State = list
			case "stateBelongs":
				m.StateBelongs = vals
			case "creator":
				m.Creator = vals
			case "assignee":
				m.Assignee = vals
			case "label":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Label = list
			case "startCreatedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartCreatedAt = val
			case "endCreatedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndCreatedAt = val
			case "startFinishedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartFinishedAt = val
			case "endFinishedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndFinishedAt = val
			case "isEmptyPlanFinishedAt":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsEmptyPlanFinishedAt = val
			case "startClosedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartClosedAt = val
			case "endClosedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndClosedAt = val
			case "priority":
				m.Priority = vals
			case "complexity":
				m.Complexity = vals
			case "severity":
				m.Severity = vals
			case "relatedIssueId":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.RelatedIssueId = list
			case "source":
				m.Source = vals[0]
			case "orderBy":
				m.OrderBy = vals[0]
			case "taskType":
				m.TaskType = vals
			case "bugStage":
				m.BugStage = vals
			case "owner":
				m.Owner = vals
			case "withProcessSummary":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.WithProcessSummary = val
			case "exceptIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ExceptIDs = list
			case "asc":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Asc = val
			case "IDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IDs = list
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			case "external":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.External = val
			case "customPanelID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CustomPanelID = val
			case "onlyIdResult":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.OnlyIdResult = val
			case "notIncluded":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NotIncluded = val
			}
		}
	}
	return nil
}

// PagingIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *PagingIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &IssuePagingResponseData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &IssuePagingResponseData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// IssuePagingResponseData implement urlenc.URLValuesUnmarshaler.
func (m *IssuePagingResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ExportExcelIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExportExcelIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "type":
				m.Type = vals
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "iterationIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IterationIDs = list
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = &val
			case "requirementID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RequirementID = &val
			case "state":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.State = list
			case "stateBelongs":
				m.StateBelongs = vals
			case "creator":
				m.Creator = vals
			case "assignee":
				m.Assignee = vals
			case "label":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Label = list
			case "startCreatedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartCreatedAt = val
			case "endCreatedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndCreatedAt = val
			case "startFinishedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartFinishedAt = val
			case "endFinishedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndFinishedAt = val
			case "isEmptyPlanFinishedAt":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsEmptyPlanFinishedAt = val
			case "startClosedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartClosedAt = val
			case "endClosedAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndClosedAt = val
			case "priority":
				m.Priority = vals
			case "complexity":
				m.Complexity = vals
			case "severity":
				m.Severity = vals
			case "relatedIssueId":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.RelatedIssueId = list
			case "source":
				m.Source = vals[0]
			case "orderBy":
				m.OrderBy = vals[0]
			case "taskType":
				m.TaskType = vals
			case "bugStage":
				m.BugStage = vals
			case "owner":
				m.Owner = vals
			case "withProcessSummary":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.WithProcessSummary = val
			case "exceptIDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ExceptIDs = list
			case "asc":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Asc = val
			case "IDs":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.IDs = list
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			case "external":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.External = val
			case "customPanelID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CustomPanelID = val
			case "onlyIdResult":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.OnlyIdResult = val
			case "notIncluded":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.NotIncluded = val
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.ProjectIDs = list
			case "locale":
				m.Locale = vals[0]
			case "isDownload":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsDownload = val
			}
		}
	}
	return nil
}

// ExportExcelIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *ExportExcelIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// ImportExcelIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *ImportExcelIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "type":
				m.Type = vals[0]
			case "fileID":
				m.FileID = vals[0]
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// ImportExcelIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *ImportExcelIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// AddIssueRelationRequest implement urlenc.URLValuesUnmarshaler.
func (m *AddIssueRelationRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "relatedIssues":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.RelatedIssues = list
			case "comment":
				m.Comment = vals[0]
			case "projectId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			case "type":
				m.Type = vals[0]
			}
		}
	}
	return nil
}

// AddIssueRelationResponse implement urlenc.URLValuesUnmarshaler.
func (m *AddIssueRelationResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DeleteIssueRelationRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteIssueRelationRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			case "relatedIssueID":
				m.RelatedIssueID = vals[0]
			case "relationTypes":
				m.RelationTypes = vals
			}
		}
	}
	return nil
}

// DeleteIssueRelationResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteIssueRelationResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetIssueRelationsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueRelationsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			case "relationTypes":
				m.RelationTypes = vals
			}
		}
	}
	return nil
}

// GetIssueRelationsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueRelationsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &IssueRelations{}
				}
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// IssueRelations implement urlenc.URLValuesUnmarshaler.
func (m *IssueRelations) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CreateIssueStateRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateIssueStateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "issueType":
				m.IssueType = vals[0]
			case "stateName":
				m.StateName = vals[0]
			case "stateBelong":
				m.StateBelong = vals[0]
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// CreateIssueStateResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateIssueStateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// DeleteIssueStateRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteIssueStateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// DeleteIssueStateResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteIssueStateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &IssueStatus{}
				}
			case "data.projectID":
				if m.Data == nil {
					m.Data = &IssueStatus{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.issueType":
				if m.Data == nil {
					m.Data = &IssueStatus{}
				}
				m.Data.IssueType = vals[0]
			case "data.stateName":
				if m.Data == nil {
					m.Data = &IssueStatus{}
				}
				m.Data.StateName = vals[0]
			case "data.stateBelong":
				if m.Data == nil {
					m.Data = &IssueStatus{}
				}
				m.Data.StateBelong = vals[0]
			case "data.stateID":
				if m.Data == nil {
					m.Data = &IssueStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.StateID = val
			case "data.index":
				if m.Data == nil {
					m.Data = &IssueStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Index = val
			}
		}
	}
	return nil
}

// IssueStatus implement urlenc.URLValuesUnmarshaler.
func (m *IssueStatus) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "issueType":
				m.IssueType = vals[0]
			case "stateName":
				m.StateName = vals[0]
			case "stateBelong":
				m.StateBelong = vals[0]
			case "stateID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StateID = val
			case "index":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Index = val
			}
		}
	}
	return nil
}

// IssueStateRelation implement urlenc.URLValuesUnmarshaler.
func (m *IssueStateRelation) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "issueType":
				m.IssueType = vals[0]
			case "stateName":
				m.StateName = vals[0]
			case "stateBelong":
				m.StateBelong = vals[0]
			case "stateID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StateID = val
			case "index":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Index = val
			case "stateRelation":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.StateRelation = list
			}
		}
	}
	return nil
}

// UpdateIssueStateRelationRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssueStateRelationRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// UpdateIssueStateRelationResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateIssueStateRelationResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetIssueStatesRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueStatesRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "issueType":
				m.IssueType = vals[0]
			case "stateBelongs":
				m.StateBelongs = vals
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// GetIssueStatesResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueStatesResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// IssueTypeState implement urlenc.URLValuesUnmarshaler.
func (m *IssueTypeState) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueType":
				m.IssueType = vals[0]
			case "state":
				m.State = vals
			}
		}
	}
	return nil
}

// GetIssueStateRelationRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueStateRelationRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "issueType":
				m.IssueType = vals[0]
			case "identityInfo":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
			case "identityInfo.userID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.UserID = vals[0]
			case "identityInfo.internalClient":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.InternalClient = vals[0]
			case "identityInfo.orgID":
				if m.IdentityInfo == nil {
					m.IdentityInfo = &pb.IdentityInfo{}
				}
				m.IdentityInfo.OrgID = vals[0]
			}
		}
	}
	return nil
}

// GetIssueStateRelationResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIssueStateRelationResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}
