// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: core.proto

package pb

import (
	context "context"
	http1 "net/http"
	strconv "strconv"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// IssueCoreServiceHandler is the server API for IssueCoreService service.
type IssueCoreServiceHandler interface {
	// POST /api/issues
	CreateIssue(context.Context, *IssueCreateRequest) (*IssueCreateResponse, error)
	// GET /api/issues
	PagingIssue(context.Context, *PagingIssueRequest) (*PagingIssueResponse, error)
	// GET /api/issues/{id}
	GetIssue(context.Context, *GetIssueRequest) (*GetIssueResponse, error)
	// PUT /api/issues/{id}
	UpdateIssue(context.Context, *UpdateIssueRequest) (*UpdateIssueResponse, error)
	// DELETE /api/issues/{id}
	DeleteIssue(context.Context, *DeleteIssueRequest) (*DeleteIssueResponse, error)
	// PUT /api/issues/actions/batch-update
	BatchUpdateIssue(context.Context, *BatchUpdateIssueRequest) (*BatchUpdateIssueResponse, error)
	// PUT /api/issues/actions/update-issue-type
	UpdateIssueType(context.Context, *UpdateIssueTypeRequest) (*UpdateIssueTypeResponse, error)
	// POST /api/issues/{id}/actions/subscribe
	SubscribeIssue(context.Context, *SubscribeIssueRequest) (*SubscribeIssueResponse, error)
	// POST /api/issues/{id}/actions/unsubscribe
	UnsubscribeIssue(context.Context, *UnsubscribeIssueRequest) (*UnsubscribeIssueResponse, error)
	// PUT /api/issues/{id}/actions/batch-update-subscriber
	BatchUpdateIssueSubscriber(context.Context, *BatchUpdateIssueSubscriberRequest) (*BatchUpdateIssueSubscriberResponse, error)
	// POST /api/issues/actions/create-property
	CreateIssueProperty(context.Context, *CreateIssuePropertyRequest) (*CreateIssuePropertyResponse, error)
	// DELETE /api/issues/actions/delete-property
	DeleteIssueProperty(context.Context, *DeleteIssuePropertyRequest) (*DeleteIssuePropertyResponse, error)
	// PUT /api/issues/actions/update-property
	UpdateIssueProperty(context.Context, *UpdateIssuePropertyRequest) (*UpdateIssuePropertyResponse, error)
	// GET /api/issues/actions/get-properties
	GetIssueProperty(context.Context, *GetIssuePropertyRequest) (*GetIssuePropertyResponse, error)
	// PUT /api/issues/actions/update-properties-index
	UpdateIssuePropertiesIndex(context.Context, *UpdateIssuePropertiesIndexRequest) (*UpdateIssuePropertiesIndexResponse, error)
	// GET /api/issues/actions/get-properties-time
	GetIssuePropertyUpdateTime(context.Context, *GetIssuePropertyUpdateTimeRequest) (*GetIssuePropertyUpdateTimeResponse, error)
	// POST /api/issues/actions/create-property-instance
	CreateIssuePropertyInstance(context.Context, *CreateIssuePropertyInstanceRequest) (*CreateIssuePropertyInstanceResponse, error)
	// GET /api/issues/actions/get-property-instance
	GetIssuePropertyInstance(context.Context, *GetIssuePropertyInstanceRequest) (*GetIssuePropertyInstanceResponse, error)
	// GET /api/issues/action/get-stage
	GetIssueStage(context.Context, *IssueStageRequest) (*GetIssueStageResponse, error)
	// PUT /api/issues/action/update-stage
	UpdateIssueStage(context.Context, *IssueStageRequest) (*UpdateIssueStageResponse, error)
	// POST /api/issues/{id}/relations
	AddIssueRelation(context.Context, *AddIssueRelationRequest) (*AddIssueRelationResponse, error)
	// DELETE /api/issues/{id}/relations/{relatedIssueID}
	DeleteIssueRelation(context.Context, *DeleteIssueRelationRequest) (*DeleteIssueRelationResponse, error)
	// GET /api/issues/{id}/relations
	GetIssueRelations(context.Context, *GetIssueRelationsRequest) (*GetIssueRelationsResponse, error)
	// POST /api/issues/actions/create-state
	CreateIssueState(context.Context, *CreateIssueStateRequest) (*CreateIssueStateResponse, error)
	// DELETE /api/issues/actions/delete-state
	DeleteIssueState(context.Context, *DeleteIssueStateRequest) (*DeleteIssueStateResponse, error)
	// PUT /api/issues/actions/update-state-relation
	UpdateIssueStateRelation(context.Context, *UpdateIssueStateRelationRequest) (*UpdateIssueStateRelationResponse, error)
	// GET /api/issues/actions/get-states
	GetIssueStates(context.Context, *GetIssueStatesRequest) (*GetIssueStatesResponse, error)
	// GET /api/issues/actions/get-state-relations
	GetIssueStateRelation(context.Context, *GetIssueStateRelationRequest) (*GetIssueStateRelationResponse, error)
	// GET /api/issues/actions/export-excel
	ExportExcelIssue(context.Context, *ExportExcelIssueRequest) (*ExportExcelIssueResponse, error)
	// POST /api/issues/actions/import-excel
	ImportExcelIssue(context.Context, *ImportExcelIssueRequest) (*ImportExcelIssueResponse, error)
}

// RegisterIssueCoreServiceHandler register IssueCoreServiceHandler to http.Router.
func RegisterIssueCoreServiceHandler(r http.Router, srv IssueCoreServiceHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_CreateIssue := func(method, path string, fn func(context.Context, *IssueCreateRequest) (*IssueCreateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*IssueCreateRequest))
		}
		var CreateIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "CreateIssue", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateIssue_info)
				}
				r = r.WithContext(ctx)
				var in IssueCreateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_PagingIssue := func(method, path string, fn func(context.Context, *PagingIssueRequest) (*PagingIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*PagingIssueRequest))
		}
		var PagingIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			PagingIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "PagingIssue", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, PagingIssue_info)
				}
				r = r.WithContext(ctx)
				var in PagingIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetIssue := func(method, path string, fn func(context.Context, *GetIssueRequest) (*GetIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetIssueRequest))
		}
		var GetIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "GetIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetIssue_info)
				}
				r = r.WithContext(ctx)
				var in GetIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateIssue := func(method, path string, fn func(context.Context, *UpdateIssueRequest) (*UpdateIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateIssueRequest))
		}
		var UpdateIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "UpdateIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateIssue_info)
				}
				r = r.WithContext(ctx)
				var in UpdateIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteIssue := func(method, path string, fn func(context.Context, *DeleteIssueRequest) (*DeleteIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteIssueRequest))
		}
		var DeleteIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "DeleteIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteIssue_info)
				}
				r = r.WithContext(ctx)
				var in DeleteIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_BatchUpdateIssue := func(method, path string, fn func(context.Context, *BatchUpdateIssueRequest) (*BatchUpdateIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*BatchUpdateIssueRequest))
		}
		var BatchUpdateIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			BatchUpdateIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "BatchUpdateIssue", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, BatchUpdateIssue_info)
				}
				r = r.WithContext(ctx)
				var in BatchUpdateIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateIssueType := func(method, path string, fn func(context.Context, *UpdateIssueTypeRequest) (*UpdateIssueTypeResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateIssueTypeRequest))
		}
		var UpdateIssueType_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateIssueType_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "UpdateIssueType", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateIssueType_info)
				}
				r = r.WithContext(ctx)
				var in UpdateIssueTypeRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SubscribeIssue := func(method, path string, fn func(context.Context, *SubscribeIssueRequest) (*SubscribeIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SubscribeIssueRequest))
		}
		var SubscribeIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			SubscribeIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "SubscribeIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SubscribeIssue_info)
				}
				r = r.WithContext(ctx)
				var in SubscribeIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UnsubscribeIssue := func(method, path string, fn func(context.Context, *UnsubscribeIssueRequest) (*UnsubscribeIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UnsubscribeIssueRequest))
		}
		var UnsubscribeIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			UnsubscribeIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "UnsubscribeIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UnsubscribeIssue_info)
				}
				r = r.WithContext(ctx)
				var in UnsubscribeIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_BatchUpdateIssueSubscriber := func(method, path string, fn func(context.Context, *BatchUpdateIssueSubscriberRequest) (*BatchUpdateIssueSubscriberResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*BatchUpdateIssueSubscriberRequest))
		}
		var BatchUpdateIssueSubscriber_info transport.ServiceInfo
		if h.Interceptor != nil {
			BatchUpdateIssueSubscriber_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "BatchUpdateIssueSubscriber", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, BatchUpdateIssueSubscriber_info)
				}
				r = r.WithContext(ctx)
				var in BatchUpdateIssueSubscriberRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateIssueProperty := func(method, path string, fn func(context.Context, *CreateIssuePropertyRequest) (*CreateIssuePropertyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateIssuePropertyRequest))
		}
		var CreateIssueProperty_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateIssueProperty_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "CreateIssueProperty", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateIssueProperty_info)
				}
				r = r.WithContext(ctx)
				var in CreateIssuePropertyRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteIssueProperty := func(method, path string, fn func(context.Context, *DeleteIssuePropertyRequest) (*DeleteIssuePropertyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteIssuePropertyRequest))
		}
		var DeleteIssueProperty_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteIssueProperty_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "DeleteIssueProperty", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteIssueProperty_info)
				}
				r = r.WithContext(ctx)
				var in DeleteIssuePropertyRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateIssueProperty := func(method, path string, fn func(context.Context, *UpdateIssuePropertyRequest) (*UpdateIssuePropertyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateIssuePropertyRequest))
		}
		var UpdateIssueProperty_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateIssueProperty_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "UpdateIssueProperty", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateIssueProperty_info)
				}
				r = r.WithContext(ctx)
				var in UpdateIssuePropertyRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetIssueProperty := func(method, path string, fn func(context.Context, *GetIssuePropertyRequest) (*GetIssuePropertyResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetIssuePropertyRequest))
		}
		var GetIssueProperty_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetIssueProperty_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "GetIssueProperty", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetIssueProperty_info)
				}
				r = r.WithContext(ctx)
				var in GetIssuePropertyRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateIssuePropertiesIndex := func(method, path string, fn func(context.Context, *UpdateIssuePropertiesIndexRequest) (*UpdateIssuePropertiesIndexResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateIssuePropertiesIndexRequest))
		}
		var UpdateIssuePropertiesIndex_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateIssuePropertiesIndex_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "UpdateIssuePropertiesIndex", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateIssuePropertiesIndex_info)
				}
				r = r.WithContext(ctx)
				var in UpdateIssuePropertiesIndexRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetIssuePropertyUpdateTime := func(method, path string, fn func(context.Context, *GetIssuePropertyUpdateTimeRequest) (*GetIssuePropertyUpdateTimeResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetIssuePropertyUpdateTimeRequest))
		}
		var GetIssuePropertyUpdateTime_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetIssuePropertyUpdateTime_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "GetIssuePropertyUpdateTime", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetIssuePropertyUpdateTime_info)
				}
				r = r.WithContext(ctx)
				var in GetIssuePropertyUpdateTimeRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateIssuePropertyInstance := func(method, path string, fn func(context.Context, *CreateIssuePropertyInstanceRequest) (*CreateIssuePropertyInstanceResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateIssuePropertyInstanceRequest))
		}
		var CreateIssuePropertyInstance_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateIssuePropertyInstance_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "CreateIssuePropertyInstance", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateIssuePropertyInstance_info)
				}
				r = r.WithContext(ctx)
				var in CreateIssuePropertyInstanceRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetIssuePropertyInstance := func(method, path string, fn func(context.Context, *GetIssuePropertyInstanceRequest) (*GetIssuePropertyInstanceResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetIssuePropertyInstanceRequest))
		}
		var GetIssuePropertyInstance_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetIssuePropertyInstance_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "GetIssuePropertyInstance", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetIssuePropertyInstance_info)
				}
				r = r.WithContext(ctx)
				var in GetIssuePropertyInstanceRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetIssueStage := func(method, path string, fn func(context.Context, *IssueStageRequest) (*GetIssueStageResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*IssueStageRequest))
		}
		var GetIssueStage_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetIssueStage_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "GetIssueStage", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetIssueStage_info)
				}
				r = r.WithContext(ctx)
				var in IssueStageRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateIssueStage := func(method, path string, fn func(context.Context, *IssueStageRequest) (*UpdateIssueStageResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*IssueStageRequest))
		}
		var UpdateIssueStage_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateIssueStage_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "UpdateIssueStage", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateIssueStage_info)
				}
				r = r.WithContext(ctx)
				var in IssueStageRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_AddIssueRelation := func(method, path string, fn func(context.Context, *AddIssueRelationRequest) (*AddIssueRelationResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*AddIssueRelationRequest))
		}
		var AddIssueRelation_info transport.ServiceInfo
		if h.Interceptor != nil {
			AddIssueRelation_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "AddIssueRelation", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, AddIssueRelation_info)
				}
				r = r.WithContext(ctx)
				var in AddIssueRelationRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteIssueRelation := func(method, path string, fn func(context.Context, *DeleteIssueRelationRequest) (*DeleteIssueRelationResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteIssueRelationRequest))
		}
		var DeleteIssueRelation_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteIssueRelation_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "DeleteIssueRelation", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteIssueRelation_info)
				}
				r = r.WithContext(ctx)
				var in DeleteIssueRelationRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						case "relatedIssueID":
							in.RelatedIssueID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetIssueRelations := func(method, path string, fn func(context.Context, *GetIssueRelationsRequest) (*GetIssueRelationsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetIssueRelationsRequest))
		}
		var GetIssueRelations_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetIssueRelations_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "GetIssueRelations", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetIssueRelations_info)
				}
				r = r.WithContext(ctx)
				var in GetIssueRelationsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateIssueState := func(method, path string, fn func(context.Context, *CreateIssueStateRequest) (*CreateIssueStateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateIssueStateRequest))
		}
		var CreateIssueState_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateIssueState_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "CreateIssueState", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateIssueState_info)
				}
				r = r.WithContext(ctx)
				var in CreateIssueStateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteIssueState := func(method, path string, fn func(context.Context, *DeleteIssueStateRequest) (*DeleteIssueStateResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteIssueStateRequest))
		}
		var DeleteIssueState_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteIssueState_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "DeleteIssueState", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteIssueState_info)
				}
				r = r.WithContext(ctx)
				var in DeleteIssueStateRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateIssueStateRelation := func(method, path string, fn func(context.Context, *UpdateIssueStateRelationRequest) (*UpdateIssueStateRelationResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateIssueStateRelationRequest))
		}
		var UpdateIssueStateRelation_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateIssueStateRelation_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "UpdateIssueStateRelation", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateIssueStateRelation_info)
				}
				r = r.WithContext(ctx)
				var in UpdateIssueStateRelationRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetIssueStates := func(method, path string, fn func(context.Context, *GetIssueStatesRequest) (*GetIssueStatesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetIssueStatesRequest))
		}
		var GetIssueStates_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetIssueStates_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "GetIssueStates", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetIssueStates_info)
				}
				r = r.WithContext(ctx)
				var in GetIssueStatesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetIssueStateRelation := func(method, path string, fn func(context.Context, *GetIssueStateRelationRequest) (*GetIssueStateRelationResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetIssueStateRelationRequest))
		}
		var GetIssueStateRelation_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetIssueStateRelation_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "GetIssueStateRelation", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetIssueStateRelation_info)
				}
				r = r.WithContext(ctx)
				var in GetIssueStateRelationRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ExportExcelIssue := func(method, path string, fn func(context.Context, *ExportExcelIssueRequest) (*ExportExcelIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ExportExcelIssueRequest))
		}
		var ExportExcelIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			ExportExcelIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "ExportExcelIssue", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ExportExcelIssue_info)
				}
				r = r.WithContext(ctx)
				var in ExportExcelIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ImportExcelIssue := func(method, path string, fn func(context.Context, *ImportExcelIssueRequest) (*ImportExcelIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ImportExcelIssueRequest))
		}
		var ImportExcelIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			ImportExcelIssue_info = transport.NewServiceInfo("erda.dop.issue.core.IssueCoreService", "ImportExcelIssue", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ImportExcelIssue_info)
				}
				r = r.WithContext(ctx)
				var in ImportExcelIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateIssue("POST", "/api/issues", srv.CreateIssue)
	add_PagingIssue("GET", "/api/issues", srv.PagingIssue)
	add_GetIssue("GET", "/api/issues/{id}", srv.GetIssue)
	add_UpdateIssue("PUT", "/api/issues/{id}", srv.UpdateIssue)
	add_DeleteIssue("DELETE", "/api/issues/{id}", srv.DeleteIssue)
	add_BatchUpdateIssue("PUT", "/api/issues/actions/batch-update", srv.BatchUpdateIssue)
	add_UpdateIssueType("PUT", "/api/issues/actions/update-issue-type", srv.UpdateIssueType)
	add_SubscribeIssue("POST", "/api/issues/{id}/actions/subscribe", srv.SubscribeIssue)
	add_UnsubscribeIssue("POST", "/api/issues/{id}/actions/unsubscribe", srv.UnsubscribeIssue)
	add_BatchUpdateIssueSubscriber("PUT", "/api/issues/{id}/actions/batch-update-subscriber", srv.BatchUpdateIssueSubscriber)
	add_CreateIssueProperty("POST", "/api/issues/actions/create-property", srv.CreateIssueProperty)
	add_DeleteIssueProperty("DELETE", "/api/issues/actions/delete-property", srv.DeleteIssueProperty)
	add_UpdateIssueProperty("PUT", "/api/issues/actions/update-property", srv.UpdateIssueProperty)
	add_GetIssueProperty("GET", "/api/issues/actions/get-properties", srv.GetIssueProperty)
	add_UpdateIssuePropertiesIndex("PUT", "/api/issues/actions/update-properties-index", srv.UpdateIssuePropertiesIndex)
	add_GetIssuePropertyUpdateTime("GET", "/api/issues/actions/get-properties-time", srv.GetIssuePropertyUpdateTime)
	add_CreateIssuePropertyInstance("POST", "/api/issues/actions/create-property-instance", srv.CreateIssuePropertyInstance)
	add_GetIssuePropertyInstance("GET", "/api/issues/actions/get-property-instance", srv.GetIssuePropertyInstance)
	add_GetIssueStage("GET", "/api/issues/action/get-stage", srv.GetIssueStage)
	add_UpdateIssueStage("PUT", "/api/issues/action/update-stage", srv.UpdateIssueStage)
	add_AddIssueRelation("POST", "/api/issues/{id}/relations", srv.AddIssueRelation)
	add_DeleteIssueRelation("DELETE", "/api/issues/{id}/relations/{relatedIssueID}", srv.DeleteIssueRelation)
	add_GetIssueRelations("GET", "/api/issues/{id}/relations", srv.GetIssueRelations)
	add_CreateIssueState("POST", "/api/issues/actions/create-state", srv.CreateIssueState)
	add_DeleteIssueState("DELETE", "/api/issues/actions/delete-state", srv.DeleteIssueState)
	add_UpdateIssueStateRelation("PUT", "/api/issues/actions/update-state-relation", srv.UpdateIssueStateRelation)
	add_GetIssueStates("GET", "/api/issues/actions/get-states", srv.GetIssueStates)
	add_GetIssueStateRelation("GET", "/api/issues/actions/get-state-relations", srv.GetIssueStateRelation)
	add_ExportExcelIssue("GET", "/api/issues/actions/export-excel", srv.ExportExcelIssue)
	add_ImportExcelIssue("POST", "/api/issues/actions/import-excel", srv.ImportExcelIssue)
}
