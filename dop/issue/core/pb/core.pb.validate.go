// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: core.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on IssueCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueCreateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueCreateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueCreateRequestMultiError, or nil if none found.
func (m *IssueCreateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueCreateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlanStartedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueCreateRequestValidationError{
					field:  "PlanStartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueCreateRequestValidationError{
					field:  "PlanStartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanStartedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueCreateRequestValidationError{
				field:  "PlanStartedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlanFinishedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueCreateRequestValidationError{
					field:  "PlanFinishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueCreateRequestValidationError{
					field:  "PlanFinishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanFinishedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueCreateRequestValidationError{
				field:  "PlanFinishedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProjectID

	// no validation rules for IterationID

	// no validation rules for Type

	// no validation rules for Title

	// no validation rules for Content

	// no validation rules for Priority

	// no validation rules for Complexity

	// no validation rules for Severity

	// no validation rules for Assignee

	// no validation rules for Creator

	// no validation rules for Source

	if all {
		switch v := interface{}(m.GetIssueManHour()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueCreateRequestValidationError{
					field:  "IssueManHour",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueCreateRequestValidationError{
					field:  "IssueManHour",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueManHour()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueCreateRequestValidationError{
				field:  "IssueManHour",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TaskType

	// no validation rules for BugStage

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueCreateRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueCreateRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueCreateRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for External

	// no validation rules for Owner

	if m.AppID != nil {
		// no validation rules for AppID
	}

	if len(errors) > 0 {
		return IssueCreateRequestMultiError(errors)
	}

	return nil
}

// IssueCreateRequestMultiError is an error wrapping multiple validation errors
// returned by IssueCreateRequest.ValidateAll() if the designated constraints
// aren't met.
type IssueCreateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueCreateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueCreateRequestMultiError) AllErrors() []error { return m }

// IssueCreateRequestValidationError is the validation error returned by
// IssueCreateRequest.Validate if the designated constraints aren't met.
type IssueCreateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueCreateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueCreateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueCreateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueCreateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueCreateRequestValidationError) ErrorName() string {
	return "IssueCreateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IssueCreateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueCreateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueCreateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueCreateRequestValidationError{}

// Validate checks the field values on IssueCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueCreateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueCreateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueCreateResponseMultiError, or nil if none found.
func (m *IssueCreateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueCreateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return IssueCreateResponseMultiError(errors)
	}

	return nil
}

// IssueCreateResponseMultiError is an error wrapping multiple validation
// errors returned by IssueCreateResponse.ValidateAll() if the designated
// constraints aren't met.
type IssueCreateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueCreateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueCreateResponseMultiError) AllErrors() []error { return m }

// IssueCreateResponseValidationError is the validation error returned by
// IssueCreateResponse.Validate if the designated constraints aren't met.
type IssueCreateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueCreateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueCreateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueCreateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueCreateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueCreateResponseValidationError) ErrorName() string {
	return "IssueCreateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IssueCreateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueCreateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueCreateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueCreateResponseValidationError{}

// Validate checks the field values on GetIssueRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssueRequestMultiError, or nil if none found.
func (m *GetIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetIssueRequestMultiError(errors)
	}

	return nil
}

// GetIssueRequestMultiError is an error wrapping multiple validation errors
// returned by GetIssueRequest.ValidateAll() if the designated constraints
// aren't met.
type GetIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueRequestMultiError) AllErrors() []error { return m }

// GetIssueRequestValidationError is the validation error returned by
// GetIssueRequest.Validate if the designated constraints aren't met.
type GetIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueRequestValidationError) ErrorName() string { return "GetIssueRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueRequestValidationError{}

// Validate checks the field values on GetIssueResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssueResponseMultiError, or nil if none found.
func (m *GetIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIssueResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIssueResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIssueResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIssueResponseMultiError(errors)
	}

	return nil
}

// GetIssueResponseMultiError is an error wrapping multiple validation errors
// returned by GetIssueResponse.ValidateAll() if the designated constraints
// aren't met.
type GetIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueResponseMultiError) AllErrors() []error { return m }

// GetIssueResponseValidationError is the validation error returned by
// GetIssueResponse.Validate if the designated constraints aren't met.
type GetIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueResponseValidationError) ErrorName() string { return "GetIssueResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueResponseValidationError{}

// Validate checks the field values on UpdateIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIssueRequestMultiError, or nil if none found.
func (m *UpdateIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for WithChildrenIteration

	if all {
		switch v := interface{}(m.GetIssueManHour()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIssueRequestValidationError{
					field:  "IssueManHour",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIssueRequestValidationError{
					field:  "IssueManHour",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueManHour()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIssueRequestValidationError{
				field:  "IssueManHour",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RemoveTestPlanCaseRelIDs

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIssueRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Title != nil {
		// no validation rules for Title
	}

	if m.Content != nil {
		// no validation rules for Content
	}

	if m.Priority != nil {
		// no validation rules for Priority
	}

	if m.Complexity != nil {
		// no validation rules for Complexity
	}

	if m.Severity != nil {
		// no validation rules for Severity
	}

	if m.PlanStartedAt != nil {
		// no validation rules for PlanStartedAt
	}

	if m.PlanFinishedAt != nil {
		// no validation rules for PlanFinishedAt
	}

	if m.Assignee != nil {
		// no validation rules for Assignee
	}

	if m.IterationID != nil {
		// no validation rules for IterationID
	}

	if m.Source != nil {
		// no validation rules for Source
	}

	if m.TaskType != nil {
		// no validation rules for TaskType
	}

	if m.BugStage != nil {
		// no validation rules for BugStage
	}

	if m.Owner != nil {
		// no validation rules for Owner
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return UpdateIssueRequestMultiError(errors)
	}

	return nil
}

// UpdateIssueRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateIssueRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssueRequestMultiError) AllErrors() []error { return m }

// UpdateIssueRequestValidationError is the validation error returned by
// UpdateIssueRequest.Validate if the designated constraints aren't met.
type UpdateIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssueRequestValidationError) ErrorName() string {
	return "UpdateIssueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssueRequestValidationError{}

// Validate checks the field values on UpdateIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIssueResponseMultiError, or nil if none found.
func (m *UpdateIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return UpdateIssueResponseMultiError(errors)
	}

	return nil
}

// UpdateIssueResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateIssueResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssueResponseMultiError) AllErrors() []error { return m }

// UpdateIssueResponseValidationError is the validation error returned by
// UpdateIssueResponse.Validate if the designated constraints aren't met.
type UpdateIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssueResponseValidationError) ErrorName() string {
	return "UpdateIssueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssueResponseValidationError{}

// Validate checks the field values on DeleteIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIssueRequestMultiError, or nil if none found.
func (m *DeleteIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteIssueRequestMultiError(errors)
	}

	return nil
}

// DeleteIssueRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteIssueRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIssueRequestMultiError) AllErrors() []error { return m }

// DeleteIssueRequestValidationError is the validation error returned by
// DeleteIssueRequest.Validate if the designated constraints aren't met.
type DeleteIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIssueRequestValidationError) ErrorName() string {
	return "DeleteIssueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIssueRequestValidationError{}

// Validate checks the field values on DeleteIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIssueResponseMultiError, or nil if none found.
func (m *DeleteIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteIssueResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteIssueResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteIssueResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteIssueResponseMultiError(errors)
	}

	return nil
}

// DeleteIssueResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteIssueResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIssueResponseMultiError) AllErrors() []error { return m }

// DeleteIssueResponseValidationError is the validation error returned by
// DeleteIssueResponse.Validate if the designated constraints aren't met.
type DeleteIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIssueResponseValidationError) ErrorName() string {
	return "DeleteIssueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIssueResponseValidationError{}

// Validate checks the field values on BatchUpdateIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchUpdateIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchUpdateIssueRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchUpdateIssueRequestMultiError, or nil if none found.
func (m *BatchUpdateIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchUpdateIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for All

	// no validation rules for Mine

	// no validation rules for Assignee

	// no validation rules for State

	// no validation rules for NewIterationID

	// no validation rules for TaskType

	// no validation rules for BugStage

	// no validation rules for Owner

	// no validation rules for CurrentIterationID

	// no validation rules for Type

	// no validation rules for ProjectID

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchUpdateIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchUpdateIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchUpdateIssueRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BatchUpdateIssueRequestMultiError(errors)
	}

	return nil
}

// BatchUpdateIssueRequestMultiError is an error wrapping multiple validation
// errors returned by BatchUpdateIssueRequest.ValidateAll() if the designated
// constraints aren't met.
type BatchUpdateIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchUpdateIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchUpdateIssueRequestMultiError) AllErrors() []error { return m }

// BatchUpdateIssueRequestValidationError is the validation error returned by
// BatchUpdateIssueRequest.Validate if the designated constraints aren't met.
type BatchUpdateIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchUpdateIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchUpdateIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchUpdateIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchUpdateIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchUpdateIssueRequestValidationError) ErrorName() string {
	return "BatchUpdateIssueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchUpdateIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchUpdateIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchUpdateIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchUpdateIssueRequestValidationError{}

// Validate checks the field values on BatchUpdateIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchUpdateIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchUpdateIssueResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchUpdateIssueResponseMultiError, or nil if none found.
func (m *BatchUpdateIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchUpdateIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BatchUpdateIssueResponseMultiError(errors)
	}

	return nil
}

// BatchUpdateIssueResponseMultiError is an error wrapping multiple validation
// errors returned by BatchUpdateIssueResponse.ValidateAll() if the designated
// constraints aren't met.
type BatchUpdateIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchUpdateIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchUpdateIssueResponseMultiError) AllErrors() []error { return m }

// BatchUpdateIssueResponseValidationError is the validation error returned by
// BatchUpdateIssueResponse.Validate if the designated constraints aren't met.
type BatchUpdateIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchUpdateIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchUpdateIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchUpdateIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchUpdateIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchUpdateIssueResponseValidationError) ErrorName() string {
	return "BatchUpdateIssueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatchUpdateIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchUpdateIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchUpdateIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchUpdateIssueResponseValidationError{}

// Validate checks the field values on UpdateIssueTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIssueTypeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssueTypeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIssueTypeRequestMultiError, or nil if none found.
func (m *UpdateIssueTypeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssueTypeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for Id

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIssueTypeRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIssueTypeRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIssueTypeRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateIssueTypeRequestMultiError(errors)
	}

	return nil
}

// UpdateIssueTypeRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateIssueTypeRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateIssueTypeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssueTypeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssueTypeRequestMultiError) AllErrors() []error { return m }

// UpdateIssueTypeRequestValidationError is the validation error returned by
// UpdateIssueTypeRequest.Validate if the designated constraints aren't met.
type UpdateIssueTypeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssueTypeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssueTypeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssueTypeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssueTypeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssueTypeRequestValidationError) ErrorName() string {
	return "UpdateIssueTypeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssueTypeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssueTypeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssueTypeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssueTypeRequestValidationError{}

// Validate checks the field values on UpdateIssueTypeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIssueTypeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssueTypeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIssueTypeResponseMultiError, or nil if none found.
func (m *UpdateIssueTypeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssueTypeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return UpdateIssueTypeResponseMultiError(errors)
	}

	return nil
}

// UpdateIssueTypeResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateIssueTypeResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateIssueTypeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssueTypeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssueTypeResponseMultiError) AllErrors() []error { return m }

// UpdateIssueTypeResponseValidationError is the validation error returned by
// UpdateIssueTypeResponse.Validate if the designated constraints aren't met.
type UpdateIssueTypeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssueTypeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssueTypeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssueTypeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssueTypeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssueTypeResponseValidationError) ErrorName() string {
	return "UpdateIssueTypeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssueTypeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssueTypeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssueTypeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssueTypeResponseValidationError{}

// Validate checks the field values on IssueStageRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IssueStageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueStageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueStageRequestMultiError, or nil if none found.
func (m *IssueStageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueStageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for IssueType

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueStageRequestValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueStageRequestValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueStageRequestValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueStageRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueStageRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueStageRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IssueStageRequestMultiError(errors)
	}

	return nil
}

// IssueStageRequestMultiError is an error wrapping multiple validation errors
// returned by IssueStageRequest.ValidateAll() if the designated constraints
// aren't met.
type IssueStageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueStageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueStageRequestMultiError) AllErrors() []error { return m }

// IssueStageRequestValidationError is the validation error returned by
// IssueStageRequest.Validate if the designated constraints aren't met.
type IssueStageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueStageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueStageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueStageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueStageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueStageRequestValidationError) ErrorName() string {
	return "IssueStageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IssueStageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueStageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueStageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueStageRequestValidationError{}

// Validate checks the field values on GetIssueStageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssueStageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueStageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssueStageResponseMultiError, or nil if none found.
func (m *GetIssueStageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueStageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIssueStageResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIssueStageResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIssueStageResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetIssueStageResponseMultiError(errors)
	}

	return nil
}

// GetIssueStageResponseMultiError is an error wrapping multiple validation
// errors returned by GetIssueStageResponse.ValidateAll() if the designated
// constraints aren't met.
type GetIssueStageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueStageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueStageResponseMultiError) AllErrors() []error { return m }

// GetIssueStageResponseValidationError is the validation error returned by
// GetIssueStageResponse.Validate if the designated constraints aren't met.
type GetIssueStageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueStageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueStageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueStageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueStageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueStageResponseValidationError) ErrorName() string {
	return "GetIssueStageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssueStageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueStageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueStageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueStageResponseValidationError{}

// Validate checks the field values on UpdateIssueStageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIssueStageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssueStageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIssueStageResponseMultiError, or nil if none found.
func (m *UpdateIssueStageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssueStageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateIssueStageResponseMultiError(errors)
	}

	return nil
}

// UpdateIssueStageResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateIssueStageResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateIssueStageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssueStageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssueStageResponseMultiError) AllErrors() []error { return m }

// UpdateIssueStageResponseValidationError is the validation error returned by
// UpdateIssueStageResponse.Validate if the designated constraints aren't met.
type UpdateIssueStageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssueStageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssueStageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssueStageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssueStageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssueStageResponseValidationError) ErrorName() string {
	return "UpdateIssueStageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssueStageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssueStageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssueStageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssueStageResponseValidationError{}

// Validate checks the field values on CreateIssuePropertyInstanceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateIssuePropertyInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIssuePropertyInstanceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateIssuePropertyInstanceRequestMultiError, or nil if none found.
func (m *CreateIssuePropertyInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIssuePropertyInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for ProjectID

	// no validation rules for IssueID

	for idx, item := range m.GetProperty() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateIssuePropertyInstanceRequestValidationError{
						field:  fmt.Sprintf("Property[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateIssuePropertyInstanceRequestValidationError{
						field:  fmt.Sprintf("Property[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateIssuePropertyInstanceRequestValidationError{
					field:  fmt.Sprintf("Property[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateIssuePropertyInstanceRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateIssuePropertyInstanceRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateIssuePropertyInstanceRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateIssuePropertyInstanceRequestMultiError(errors)
	}

	return nil
}

// CreateIssuePropertyInstanceRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateIssuePropertyInstanceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateIssuePropertyInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIssuePropertyInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIssuePropertyInstanceRequestMultiError) AllErrors() []error { return m }

// CreateIssuePropertyInstanceRequestValidationError is the validation error
// returned by CreateIssuePropertyInstanceRequest.Validate if the designated
// constraints aren't met.
type CreateIssuePropertyInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIssuePropertyInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIssuePropertyInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIssuePropertyInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIssuePropertyInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIssuePropertyInstanceRequestValidationError) ErrorName() string {
	return "CreateIssuePropertyInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIssuePropertyInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIssuePropertyInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIssuePropertyInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIssuePropertyInstanceRequestValidationError{}

// Validate checks the field values on CreateIssuePropertyInstanceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateIssuePropertyInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIssuePropertyInstanceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateIssuePropertyInstanceResponseMultiError, or nil if none found.
func (m *CreateIssuePropertyInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIssuePropertyInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return CreateIssuePropertyInstanceResponseMultiError(errors)
	}

	return nil
}

// CreateIssuePropertyInstanceResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateIssuePropertyInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateIssuePropertyInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIssuePropertyInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIssuePropertyInstanceResponseMultiError) AllErrors() []error { return m }

// CreateIssuePropertyInstanceResponseValidationError is the validation error
// returned by CreateIssuePropertyInstanceResponse.Validate if the designated
// constraints aren't met.
type CreateIssuePropertyInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIssuePropertyInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIssuePropertyInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIssuePropertyInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIssuePropertyInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIssuePropertyInstanceResponseValidationError) ErrorName() string {
	return "CreateIssuePropertyInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIssuePropertyInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIssuePropertyInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIssuePropertyInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIssuePropertyInstanceResponseValidationError{}

// Validate checks the field values on GetIssuePropertyInstanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssuePropertyInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssuePropertyInstanceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetIssuePropertyInstanceRequestMultiError, or nil if none found.
func (m *GetIssuePropertyInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssuePropertyInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for IssueID

	// no validation rules for PropertyIssueType

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIssuePropertyInstanceRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIssuePropertyInstanceRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIssuePropertyInstanceRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIssuePropertyInstanceRequestMultiError(errors)
	}

	return nil
}

// GetIssuePropertyInstanceRequestMultiError is an error wrapping multiple
// validation errors returned by GetIssuePropertyInstanceRequest.ValidateAll()
// if the designated constraints aren't met.
type GetIssuePropertyInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssuePropertyInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssuePropertyInstanceRequestMultiError) AllErrors() []error { return m }

// GetIssuePropertyInstanceRequestValidationError is the validation error
// returned by GetIssuePropertyInstanceRequest.Validate if the designated
// constraints aren't met.
type GetIssuePropertyInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssuePropertyInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssuePropertyInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssuePropertyInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssuePropertyInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssuePropertyInstanceRequestValidationError) ErrorName() string {
	return "GetIssuePropertyInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssuePropertyInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssuePropertyInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssuePropertyInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssuePropertyInstanceRequestValidationError{}

// Validate checks the field values on GetIssuePropertyInstanceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetIssuePropertyInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssuePropertyInstanceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetIssuePropertyInstanceResponseMultiError, or nil if none found.
func (m *GetIssuePropertyInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssuePropertyInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIssuePropertyInstanceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIssuePropertyInstanceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIssuePropertyInstanceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIssuePropertyInstanceResponseMultiError(errors)
	}

	return nil
}

// GetIssuePropertyInstanceResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetIssuePropertyInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetIssuePropertyInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssuePropertyInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssuePropertyInstanceResponseMultiError) AllErrors() []error { return m }

// GetIssuePropertyInstanceResponseValidationError is the validation error
// returned by GetIssuePropertyInstanceResponse.Validate if the designated
// constraints aren't met.
type GetIssuePropertyInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssuePropertyInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssuePropertyInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssuePropertyInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssuePropertyInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssuePropertyInstanceResponseValidationError) ErrorName() string {
	return "GetIssuePropertyInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssuePropertyInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssuePropertyInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssuePropertyInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssuePropertyInstanceResponseValidationError{}

// Validate checks the field values on CreateIssuePropertyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateIssuePropertyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIssuePropertyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateIssuePropertyRequestMultiError, or nil if none found.
func (m *CreateIssuePropertyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIssuePropertyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ScopeID

	// no validation rules for ScopeType

	// no validation rules for OrgID

	// no validation rules for PropertyName

	// no validation rules for DisplayName

	// no validation rules for PropertyType

	// no validation rules for Required

	// no validation rules for PropertyIssueType

	for idx, item := range m.GetEnumeratedValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateIssuePropertyRequestValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateIssuePropertyRequestValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateIssuePropertyRequestValidationError{
					field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Relation

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateIssuePropertyRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateIssuePropertyRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateIssuePropertyRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateIssuePropertyRequestMultiError(errors)
	}

	return nil
}

// CreateIssuePropertyRequestMultiError is an error wrapping multiple
// validation errors returned by CreateIssuePropertyRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateIssuePropertyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIssuePropertyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIssuePropertyRequestMultiError) AllErrors() []error { return m }

// CreateIssuePropertyRequestValidationError is the validation error returned
// by CreateIssuePropertyRequest.Validate if the designated constraints aren't met.
type CreateIssuePropertyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIssuePropertyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIssuePropertyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIssuePropertyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIssuePropertyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIssuePropertyRequestValidationError) ErrorName() string {
	return "CreateIssuePropertyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIssuePropertyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIssuePropertyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIssuePropertyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIssuePropertyRequestValidationError{}

// Validate checks the field values on CreateIssuePropertyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateIssuePropertyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIssuePropertyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateIssuePropertyResponseMultiError, or nil if none found.
func (m *CreateIssuePropertyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIssuePropertyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateIssuePropertyResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateIssuePropertyResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateIssuePropertyResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateIssuePropertyResponseMultiError(errors)
	}

	return nil
}

// CreateIssuePropertyResponseMultiError is an error wrapping multiple
// validation errors returned by CreateIssuePropertyResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateIssuePropertyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIssuePropertyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIssuePropertyResponseMultiError) AllErrors() []error { return m }

// CreateIssuePropertyResponseValidationError is the validation error returned
// by CreateIssuePropertyResponse.Validate if the designated constraints
// aren't met.
type CreateIssuePropertyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIssuePropertyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIssuePropertyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIssuePropertyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIssuePropertyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIssuePropertyResponseValidationError) ErrorName() string {
	return "CreateIssuePropertyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIssuePropertyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIssuePropertyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIssuePropertyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIssuePropertyResponseValidationError{}

// Validate checks the field values on DeleteIssuePropertyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIssuePropertyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIssuePropertyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIssuePropertyRequestMultiError, or nil if none found.
func (m *DeleteIssuePropertyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIssuePropertyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for PropertyID

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteIssuePropertyRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteIssuePropertyRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteIssuePropertyRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteIssuePropertyRequestMultiError(errors)
	}

	return nil
}

// DeleteIssuePropertyRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteIssuePropertyRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteIssuePropertyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIssuePropertyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIssuePropertyRequestMultiError) AllErrors() []error { return m }

// DeleteIssuePropertyRequestValidationError is the validation error returned
// by DeleteIssuePropertyRequest.Validate if the designated constraints aren't met.
type DeleteIssuePropertyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIssuePropertyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIssuePropertyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIssuePropertyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIssuePropertyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIssuePropertyRequestValidationError) ErrorName() string {
	return "DeleteIssuePropertyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIssuePropertyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIssuePropertyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIssuePropertyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIssuePropertyRequestValidationError{}

// Validate checks the field values on DeleteIssuePropertyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIssuePropertyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIssuePropertyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIssuePropertyResponseMultiError, or nil if none found.
func (m *DeleteIssuePropertyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIssuePropertyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteIssuePropertyResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteIssuePropertyResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteIssuePropertyResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteIssuePropertyResponseMultiError(errors)
	}

	return nil
}

// DeleteIssuePropertyResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteIssuePropertyResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteIssuePropertyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIssuePropertyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIssuePropertyResponseMultiError) AllErrors() []error { return m }

// DeleteIssuePropertyResponseValidationError is the validation error returned
// by DeleteIssuePropertyResponse.Validate if the designated constraints
// aren't met.
type DeleteIssuePropertyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIssuePropertyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIssuePropertyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIssuePropertyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIssuePropertyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIssuePropertyResponseValidationError) ErrorName() string {
	return "DeleteIssuePropertyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIssuePropertyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIssuePropertyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIssuePropertyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIssuePropertyResponseValidationError{}

// Validate checks the field values on UpdateIssuePropertyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIssuePropertyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssuePropertyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIssuePropertyRequestMultiError, or nil if none found.
func (m *UpdateIssuePropertyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssuePropertyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PropertyID

	// no validation rules for ScopeID

	// no validation rules for ScopeType

	// no validation rules for OrgID

	// no validation rules for PropertyName

	// no validation rules for DisplayName

	// no validation rules for PropertyType

	// no validation rules for Required

	// no validation rules for PropertyIssueType

	// no validation rules for Relation

	// no validation rules for Index

	for idx, item := range m.GetEnumeratedValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateIssuePropertyRequestValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateIssuePropertyRequestValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateIssuePropertyRequestValidationError{
					field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIssuePropertyRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIssuePropertyRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIssuePropertyRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateIssuePropertyRequestMultiError(errors)
	}

	return nil
}

// UpdateIssuePropertyRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateIssuePropertyRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateIssuePropertyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssuePropertyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssuePropertyRequestMultiError) AllErrors() []error { return m }

// UpdateIssuePropertyRequestValidationError is the validation error returned
// by UpdateIssuePropertyRequest.Validate if the designated constraints aren't met.
type UpdateIssuePropertyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssuePropertyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssuePropertyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssuePropertyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssuePropertyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssuePropertyRequestValidationError) ErrorName() string {
	return "UpdateIssuePropertyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssuePropertyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssuePropertyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssuePropertyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssuePropertyRequestValidationError{}

// Validate checks the field values on UpdateIssuePropertyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIssuePropertyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssuePropertyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateIssuePropertyResponseMultiError, or nil if none found.
func (m *UpdateIssuePropertyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssuePropertyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIssuePropertyResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIssuePropertyResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIssuePropertyResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateIssuePropertyResponseMultiError(errors)
	}

	return nil
}

// UpdateIssuePropertyResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateIssuePropertyResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateIssuePropertyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssuePropertyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssuePropertyResponseMultiError) AllErrors() []error { return m }

// UpdateIssuePropertyResponseValidationError is the validation error returned
// by UpdateIssuePropertyResponse.Validate if the designated constraints
// aren't met.
type UpdateIssuePropertyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssuePropertyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssuePropertyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssuePropertyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssuePropertyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssuePropertyResponseValidationError) ErrorName() string {
	return "UpdateIssuePropertyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssuePropertyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssuePropertyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssuePropertyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssuePropertyResponseValidationError{}

// Validate checks the field values on GetIssuePropertyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssuePropertyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssuePropertyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssuePropertyRequestMultiError, or nil if none found.
func (m *GetIssuePropertyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssuePropertyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	// no validation rules for PropertyIssueType

	// no validation rules for PropertyName

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIssuePropertyRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIssuePropertyRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIssuePropertyRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIssuePropertyRequestMultiError(errors)
	}

	return nil
}

// GetIssuePropertyRequestMultiError is an error wrapping multiple validation
// errors returned by GetIssuePropertyRequest.ValidateAll() if the designated
// constraints aren't met.
type GetIssuePropertyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssuePropertyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssuePropertyRequestMultiError) AllErrors() []error { return m }

// GetIssuePropertyRequestValidationError is the validation error returned by
// GetIssuePropertyRequest.Validate if the designated constraints aren't met.
type GetIssuePropertyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssuePropertyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssuePropertyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssuePropertyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssuePropertyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssuePropertyRequestValidationError) ErrorName() string {
	return "GetIssuePropertyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssuePropertyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssuePropertyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssuePropertyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssuePropertyRequestValidationError{}

// Validate checks the field values on GetIssuePropertyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssuePropertyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssuePropertyResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssuePropertyResponseMultiError, or nil if none found.
func (m *GetIssuePropertyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssuePropertyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIssuePropertyResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIssuePropertyResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIssuePropertyResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetIssuePropertyResponseMultiError(errors)
	}

	return nil
}

// GetIssuePropertyResponseMultiError is an error wrapping multiple validation
// errors returned by GetIssuePropertyResponse.ValidateAll() if the designated
// constraints aren't met.
type GetIssuePropertyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssuePropertyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssuePropertyResponseMultiError) AllErrors() []error { return m }

// GetIssuePropertyResponseValidationError is the validation error returned by
// GetIssuePropertyResponse.Validate if the designated constraints aren't met.
type GetIssuePropertyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssuePropertyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssuePropertyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssuePropertyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssuePropertyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssuePropertyResponseValidationError) ErrorName() string {
	return "GetIssuePropertyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssuePropertyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssuePropertyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssuePropertyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssuePropertyResponseValidationError{}

// Validate checks the field values on UpdateIssuePropertiesIndexRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateIssuePropertiesIndexRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssuePropertiesIndexRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateIssuePropertiesIndexRequestMultiError, or nil if none found.
func (m *UpdateIssuePropertiesIndexRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssuePropertiesIndexRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateIssuePropertiesIndexRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateIssuePropertiesIndexRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateIssuePropertiesIndexRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIssuePropertiesIndexRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIssuePropertiesIndexRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIssuePropertiesIndexRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateIssuePropertiesIndexRequestMultiError(errors)
	}

	return nil
}

// UpdateIssuePropertiesIndexRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateIssuePropertiesIndexRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateIssuePropertiesIndexRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssuePropertiesIndexRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssuePropertiesIndexRequestMultiError) AllErrors() []error { return m }

// UpdateIssuePropertiesIndexRequestValidationError is the validation error
// returned by UpdateIssuePropertiesIndexRequest.Validate if the designated
// constraints aren't met.
type UpdateIssuePropertiesIndexRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssuePropertiesIndexRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssuePropertiesIndexRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssuePropertiesIndexRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssuePropertiesIndexRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssuePropertiesIndexRequestValidationError) ErrorName() string {
	return "UpdateIssuePropertiesIndexRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssuePropertiesIndexRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssuePropertiesIndexRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssuePropertiesIndexRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssuePropertiesIndexRequestValidationError{}

// Validate checks the field values on UpdateIssuePropertiesIndexResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateIssuePropertiesIndexResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssuePropertiesIndexResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateIssuePropertiesIndexResponseMultiError, or nil if none found.
func (m *UpdateIssuePropertiesIndexResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssuePropertiesIndexResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateIssuePropertiesIndexResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateIssuePropertiesIndexResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateIssuePropertiesIndexResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateIssuePropertiesIndexResponseMultiError(errors)
	}

	return nil
}

// UpdateIssuePropertiesIndexResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateIssuePropertiesIndexResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateIssuePropertiesIndexResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssuePropertiesIndexResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssuePropertiesIndexResponseMultiError) AllErrors() []error { return m }

// UpdateIssuePropertiesIndexResponseValidationError is the validation error
// returned by UpdateIssuePropertiesIndexResponse.Validate if the designated
// constraints aren't met.
type UpdateIssuePropertiesIndexResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssuePropertiesIndexResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssuePropertiesIndexResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssuePropertiesIndexResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssuePropertiesIndexResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssuePropertiesIndexResponseValidationError) ErrorName() string {
	return "UpdateIssuePropertiesIndexResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssuePropertiesIndexResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssuePropertiesIndexResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssuePropertiesIndexResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssuePropertiesIndexResponseValidationError{}

// Validate checks the field values on GetIssuePropertyUpdateTimeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetIssuePropertyUpdateTimeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssuePropertyUpdateTimeRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetIssuePropertyUpdateTimeRequestMultiError, or nil if none found.
func (m *GetIssuePropertyUpdateTimeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssuePropertyUpdateTimeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrgID

	if len(errors) > 0 {
		return GetIssuePropertyUpdateTimeRequestMultiError(errors)
	}

	return nil
}

// GetIssuePropertyUpdateTimeRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetIssuePropertyUpdateTimeRequest.ValidateAll() if the designated
// constraints aren't met.
type GetIssuePropertyUpdateTimeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssuePropertyUpdateTimeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssuePropertyUpdateTimeRequestMultiError) AllErrors() []error { return m }

// GetIssuePropertyUpdateTimeRequestValidationError is the validation error
// returned by GetIssuePropertyUpdateTimeRequest.Validate if the designated
// constraints aren't met.
type GetIssuePropertyUpdateTimeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssuePropertyUpdateTimeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssuePropertyUpdateTimeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssuePropertyUpdateTimeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssuePropertyUpdateTimeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssuePropertyUpdateTimeRequestValidationError) ErrorName() string {
	return "GetIssuePropertyUpdateTimeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssuePropertyUpdateTimeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssuePropertyUpdateTimeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssuePropertyUpdateTimeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssuePropertyUpdateTimeRequestValidationError{}

// Validate checks the field values on GetIssuePropertyUpdateTimeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetIssuePropertyUpdateTimeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssuePropertyUpdateTimeResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetIssuePropertyUpdateTimeResponseMultiError, or nil if none found.
func (m *GetIssuePropertyUpdateTimeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssuePropertyUpdateTimeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIssuePropertyUpdateTimeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIssuePropertyUpdateTimeResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIssuePropertyUpdateTimeResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIssuePropertyUpdateTimeResponseMultiError(errors)
	}

	return nil
}

// GetIssuePropertyUpdateTimeResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetIssuePropertyUpdateTimeResponse.ValidateAll() if the designated
// constraints aren't met.
type GetIssuePropertyUpdateTimeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssuePropertyUpdateTimeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssuePropertyUpdateTimeResponseMultiError) AllErrors() []error { return m }

// GetIssuePropertyUpdateTimeResponseValidationError is the validation error
// returned by GetIssuePropertyUpdateTimeResponse.Validate if the designated
// constraints aren't met.
type GetIssuePropertyUpdateTimeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssuePropertyUpdateTimeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssuePropertyUpdateTimeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssuePropertyUpdateTimeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssuePropertyUpdateTimeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssuePropertyUpdateTimeResponseValidationError) ErrorName() string {
	return "GetIssuePropertyUpdateTimeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssuePropertyUpdateTimeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssuePropertyUpdateTimeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssuePropertyUpdateTimeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssuePropertyUpdateTimeResponseValidationError{}

// Validate checks the field values on SubscribeIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeIssueRequestMultiError, or nil if none found.
func (m *SubscribeIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return SubscribeIssueRequestMultiError(errors)
	}

	return nil
}

// SubscribeIssueRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeIssueRequest.ValidateAll() if the designated
// constraints aren't met.
type SubscribeIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeIssueRequestMultiError) AllErrors() []error { return m }

// SubscribeIssueRequestValidationError is the validation error returned by
// SubscribeIssueRequest.Validate if the designated constraints aren't met.
type SubscribeIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeIssueRequestValidationError) ErrorName() string {
	return "SubscribeIssueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeIssueRequestValidationError{}

// Validate checks the field values on SubscribeIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeIssueResponseMultiError, or nil if none found.
func (m *SubscribeIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return SubscribeIssueResponseMultiError(errors)
	}

	return nil
}

// SubscribeIssueResponseMultiError is an error wrapping multiple validation
// errors returned by SubscribeIssueResponse.ValidateAll() if the designated
// constraints aren't met.
type SubscribeIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeIssueResponseMultiError) AllErrors() []error { return m }

// SubscribeIssueResponseValidationError is the validation error returned by
// SubscribeIssueResponse.Validate if the designated constraints aren't met.
type SubscribeIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeIssueResponseValidationError) ErrorName() string {
	return "SubscribeIssueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeIssueResponseValidationError{}

// Validate checks the field values on UnsubscribeIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnsubscribeIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnsubscribeIssueRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnsubscribeIssueRequestMultiError, or nil if none found.
func (m *UnsubscribeIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnsubscribeIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return UnsubscribeIssueRequestMultiError(errors)
	}

	return nil
}

// UnsubscribeIssueRequestMultiError is an error wrapping multiple validation
// errors returned by UnsubscribeIssueRequest.ValidateAll() if the designated
// constraints aren't met.
type UnsubscribeIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnsubscribeIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnsubscribeIssueRequestMultiError) AllErrors() []error { return m }

// UnsubscribeIssueRequestValidationError is the validation error returned by
// UnsubscribeIssueRequest.Validate if the designated constraints aren't met.
type UnsubscribeIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnsubscribeIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnsubscribeIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnsubscribeIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnsubscribeIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnsubscribeIssueRequestValidationError) ErrorName() string {
	return "UnsubscribeIssueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnsubscribeIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnsubscribeIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnsubscribeIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnsubscribeIssueRequestValidationError{}

// Validate checks the field values on UnsubscribeIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnsubscribeIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnsubscribeIssueResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnsubscribeIssueResponseMultiError, or nil if none found.
func (m *UnsubscribeIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnsubscribeIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return UnsubscribeIssueResponseMultiError(errors)
	}

	return nil
}

// UnsubscribeIssueResponseMultiError is an error wrapping multiple validation
// errors returned by UnsubscribeIssueResponse.ValidateAll() if the designated
// constraints aren't met.
type UnsubscribeIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnsubscribeIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnsubscribeIssueResponseMultiError) AllErrors() []error { return m }

// UnsubscribeIssueResponseValidationError is the validation error returned by
// UnsubscribeIssueResponse.Validate if the designated constraints aren't met.
type UnsubscribeIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnsubscribeIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnsubscribeIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnsubscribeIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnsubscribeIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnsubscribeIssueResponseValidationError) ErrorName() string {
	return "UnsubscribeIssueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnsubscribeIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnsubscribeIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnsubscribeIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnsubscribeIssueResponseValidationError{}

// Validate checks the field values on BatchUpdateIssueSubscriberRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *BatchUpdateIssueSubscriberRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchUpdateIssueSubscriberRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BatchUpdateIssueSubscriberRequestMultiError, or nil if none found.
func (m *BatchUpdateIssueSubscriberRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchUpdateIssueSubscriberRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IssueID

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchUpdateIssueSubscriberRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchUpdateIssueSubscriberRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchUpdateIssueSubscriberRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	// no validation rules for IsIncrementalUpdate

	if len(errors) > 0 {
		return BatchUpdateIssueSubscriberRequestMultiError(errors)
	}

	return nil
}

// BatchUpdateIssueSubscriberRequestMultiError is an error wrapping multiple
// validation errors returned by
// BatchUpdateIssueSubscriberRequest.ValidateAll() if the designated
// constraints aren't met.
type BatchUpdateIssueSubscriberRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchUpdateIssueSubscriberRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchUpdateIssueSubscriberRequestMultiError) AllErrors() []error { return m }

// BatchUpdateIssueSubscriberRequestValidationError is the validation error
// returned by BatchUpdateIssueSubscriberRequest.Validate if the designated
// constraints aren't met.
type BatchUpdateIssueSubscriberRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchUpdateIssueSubscriberRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchUpdateIssueSubscriberRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchUpdateIssueSubscriberRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchUpdateIssueSubscriberRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchUpdateIssueSubscriberRequestValidationError) ErrorName() string {
	return "BatchUpdateIssueSubscriberRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchUpdateIssueSubscriberRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchUpdateIssueSubscriberRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchUpdateIssueSubscriberRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchUpdateIssueSubscriberRequestValidationError{}

// Validate checks the field values on BatchUpdateIssueSubscriberResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *BatchUpdateIssueSubscriberResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchUpdateIssueSubscriberResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BatchUpdateIssueSubscriberResponseMultiError, or nil if none found.
func (m *BatchUpdateIssueSubscriberResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchUpdateIssueSubscriberResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return BatchUpdateIssueSubscriberResponseMultiError(errors)
	}

	return nil
}

// BatchUpdateIssueSubscriberResponseMultiError is an error wrapping multiple
// validation errors returned by
// BatchUpdateIssueSubscriberResponse.ValidateAll() if the designated
// constraints aren't met.
type BatchUpdateIssueSubscriberResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchUpdateIssueSubscriberResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchUpdateIssueSubscriberResponseMultiError) AllErrors() []error { return m }

// BatchUpdateIssueSubscriberResponseValidationError is the validation error
// returned by BatchUpdateIssueSubscriberResponse.Validate if the designated
// constraints aren't met.
type BatchUpdateIssueSubscriberResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchUpdateIssueSubscriberResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchUpdateIssueSubscriberResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchUpdateIssueSubscriberResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchUpdateIssueSubscriberResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchUpdateIssueSubscriberResponseValidationError) ErrorName() string {
	return "BatchUpdateIssueSubscriberResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatchUpdateIssueSubscriberResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchUpdateIssueSubscriberResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchUpdateIssueSubscriberResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchUpdateIssueSubscriberResponseValidationError{}

// Validate checks the field values on Issue with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Issue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Issue with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in IssueMultiError, or nil if none found.
func (m *Issue) ValidateAll() error {
	return m.validate(true)
}

func (m *Issue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlanStartedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "PlanStartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "PlanStartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanStartedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueValidationError{
				field:  "PlanStartedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlanFinishedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "PlanFinishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "PlanFinishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlanFinishedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueValidationError{
				field:  "PlanFinishedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProjectID

	// no validation rules for IterationID

	// no validation rules for AppID

	// no validation rules for RequirementID

	// no validation rules for RequirementTitle

	// no validation rules for Title

	// no validation rules for Content

	// no validation rules for State

	// no validation rules for Priority

	// no validation rules for Complexity

	// no validation rules for Severity

	// no validation rules for Assignee

	// no validation rules for Creator

	for idx, item := range m.GetIssueButton() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueValidationError{
						field:  fmt.Sprintf("IssueButton[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueValidationError{
						field:  fmt.Sprintf("IssueButton[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueValidationError{
					field:  fmt.Sprintf("IssueButton[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetIssueSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "IssueSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "IssueSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueValidationError{
				field:  "IssueSummary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLabelDetails() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueValidationError{
						field:  fmt.Sprintf("LabelDetails[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueValidationError{
						field:  fmt.Sprintf("LabelDetails[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueValidationError{
					field:  fmt.Sprintf("LabelDetails[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetIssueManHour()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "IssueManHour",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "IssueManHour",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueManHour()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueValidationError{
				field:  "IssueManHour",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Source

	// no validation rules for TaskType

	// no validation rules for BugStage

	// no validation rules for Owner

	if all {
		switch v := interface{}(m.GetFinishTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "FinishTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueValidationError{
					field:  "FinishTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinishTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueValidationError{
				field:  "FinishTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTestPlanCaseRels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueValidationError{
						field:  fmt.Sprintf("TestPlanCaseRels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueValidationError{
						field:  fmt.Sprintf("TestPlanCaseRels[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueValidationError{
					field:  fmt.Sprintf("TestPlanCaseRels[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReopenCount

	// no validation rules for Type

	for idx, item := range m.GetPropertyInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueValidationError{
						field:  fmt.Sprintf("PropertyInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueValidationError{
						field:  fmt.Sprintf("PropertyInstances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueValidationError{
					field:  fmt.Sprintf("PropertyInstances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IssueMultiError(errors)
	}

	return nil
}

// IssueMultiError is an error wrapping multiple validation errors returned by
// Issue.ValidateAll() if the designated constraints aren't met.
type IssueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueMultiError) AllErrors() []error { return m }

// IssueValidationError is the validation error returned by Issue.Validate if
// the designated constraints aren't met.
type IssueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueValidationError) ErrorName() string { return "IssueValidationError" }

// Error satisfies the builtin error interface
func (e IssueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueValidationError{}

// Validate checks the field values on IssueStage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IssueStage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueStage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IssueStageMultiError, or
// nil if none found.
func (m *IssueStage) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueStage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Value

	if len(errors) > 0 {
		return IssueStageMultiError(errors)
	}

	return nil
}

// IssueStageMultiError is an error wrapping multiple validation errors
// returned by IssueStage.ValidateAll() if the designated constraints aren't met.
type IssueStageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueStageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueStageMultiError) AllErrors() []error { return m }

// IssueStageValidationError is the validation error returned by
// IssueStage.Validate if the designated constraints aren't met.
type IssueStageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueStageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueStageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueStageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueStageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueStageValidationError) ErrorName() string { return "IssueStageValidationError" }

// Error satisfies the builtin error interface
func (e IssueStageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueStage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueStageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueStageValidationError{}

// Validate checks the field values on IssuePropertyInstance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssuePropertyInstance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssuePropertyInstance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssuePropertyInstanceMultiError, or nil if none found.
func (m *IssuePropertyInstance) ValidateAll() error {
	return m.validate(true)
}

func (m *IssuePropertyInstance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PropertyID

	// no validation rules for ScopeID

	// no validation rules for ScopeType

	// no validation rules for OrgID

	// no validation rules for PropertyName

	// no validation rules for DisplayName

	// no validation rules for PropertyType

	// no validation rules for Required

	// no validation rules for PropertyIssueType

	// no validation rules for Relation

	// no validation rules for Index

	for idx, item := range m.GetEnumeratedValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssuePropertyInstanceValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssuePropertyInstanceValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssuePropertyInstanceValidationError{
					field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetArbitraryValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssuePropertyInstanceValidationError{
					field:  "ArbitraryValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssuePropertyInstanceValidationError{
					field:  "ArbitraryValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArbitraryValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssuePropertyInstanceValidationError{
				field:  "ArbitraryValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPropertyEnumeratedValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssuePropertyInstanceValidationError{
						field:  fmt.Sprintf("PropertyEnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssuePropertyInstanceValidationError{
						field:  fmt.Sprintf("PropertyEnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssuePropertyInstanceValidationError{
					field:  fmt.Sprintf("PropertyEnumeratedValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IssuePropertyInstanceMultiError(errors)
	}

	return nil
}

// IssuePropertyInstanceMultiError is an error wrapping multiple validation
// errors returned by IssuePropertyInstance.ValidateAll() if the designated
// constraints aren't met.
type IssuePropertyInstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssuePropertyInstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssuePropertyInstanceMultiError) AllErrors() []error { return m }

// IssuePropertyInstanceValidationError is the validation error returned by
// IssuePropertyInstance.Validate if the designated constraints aren't met.
type IssuePropertyInstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssuePropertyInstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssuePropertyInstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssuePropertyInstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssuePropertyInstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssuePropertyInstanceValidationError) ErrorName() string {
	return "IssuePropertyInstanceValidationError"
}

// Error satisfies the builtin error interface
func (e IssuePropertyInstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssuePropertyInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssuePropertyInstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssuePropertyInstanceValidationError{}

// Validate checks the field values on IssuePropertyIndex with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssuePropertyIndex) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssuePropertyIndex with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssuePropertyIndexMultiError, or nil if none found.
func (m *IssuePropertyIndex) ValidateAll() error {
	return m.validate(true)
}

func (m *IssuePropertyIndex) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PropertyID

	// no validation rules for ScopeID

	// no validation rules for ScopeType

	// no validation rules for OrgID

	// no validation rules for PropertyName

	// no validation rules for DisplayName

	// no validation rules for PropertyType

	// no validation rules for Required

	// no validation rules for PropertyIssueType

	// no validation rules for Relation

	// no validation rules for Index

	for idx, item := range m.GetEnumeratedValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssuePropertyIndexValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssuePropertyIndexValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssuePropertyIndexValidationError{
					field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IssuePropertyIndexMultiError(errors)
	}

	return nil
}

// IssuePropertyIndexMultiError is an error wrapping multiple validation errors
// returned by IssuePropertyIndex.ValidateAll() if the designated constraints
// aren't met.
type IssuePropertyIndexMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssuePropertyIndexMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssuePropertyIndexMultiError) AllErrors() []error { return m }

// IssuePropertyIndexValidationError is the validation error returned by
// IssuePropertyIndex.Validate if the designated constraints aren't met.
type IssuePropertyIndexValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssuePropertyIndexValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssuePropertyIndexValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssuePropertyIndexValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssuePropertyIndexValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssuePropertyIndexValidationError) ErrorName() string {
	return "IssuePropertyIndexValidationError"
}

// Error satisfies the builtin error interface
func (e IssuePropertyIndexValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssuePropertyIndex.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssuePropertyIndexValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssuePropertyIndexValidationError{}

// Validate checks the field values on PropertyEnumerate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PropertyEnumerate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PropertyEnumerate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PropertyEnumerateMultiError, or nil if none found.
func (m *PropertyEnumerate) ValidateAll() error {
	return m.validate(true)
}

func (m *PropertyEnumerate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return PropertyEnumerateMultiError(errors)
	}

	return nil
}

// PropertyEnumerateMultiError is an error wrapping multiple validation errors
// returned by PropertyEnumerate.ValidateAll() if the designated constraints
// aren't met.
type PropertyEnumerateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PropertyEnumerateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PropertyEnumerateMultiError) AllErrors() []error { return m }

// PropertyEnumerateValidationError is the validation error returned by
// PropertyEnumerate.Validate if the designated constraints aren't met.
type PropertyEnumerateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PropertyEnumerateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PropertyEnumerateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PropertyEnumerateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PropertyEnumerateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PropertyEnumerateValidationError) ErrorName() string {
	return "PropertyEnumerateValidationError"
}

// Error satisfies the builtin error interface
func (e PropertyEnumerateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPropertyEnumerate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PropertyEnumerateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PropertyEnumerateValidationError{}

// Validate checks the field values on ScopeTypeEnum with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScopeTypeEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScopeTypeEnum with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScopeTypeEnumMultiError, or
// nil if none found.
func (m *ScopeTypeEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *ScopeTypeEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ScopeTypeEnumMultiError(errors)
	}

	return nil
}

// ScopeTypeEnumMultiError is an error wrapping multiple validation errors
// returned by ScopeTypeEnum.ValidateAll() if the designated constraints
// aren't met.
type ScopeTypeEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScopeTypeEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScopeTypeEnumMultiError) AllErrors() []error { return m }

// ScopeTypeEnumValidationError is the validation error returned by
// ScopeTypeEnum.Validate if the designated constraints aren't met.
type ScopeTypeEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScopeTypeEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScopeTypeEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScopeTypeEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScopeTypeEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScopeTypeEnumValidationError) ErrorName() string { return "ScopeTypeEnumValidationError" }

// Error satisfies the builtin error interface
func (e ScopeTypeEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScopeTypeEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScopeTypeEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScopeTypeEnumValidationError{}

// Validate checks the field values on IssueTypeEnum with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IssueTypeEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueTypeEnum with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IssueTypeEnumMultiError, or
// nil if none found.
func (m *IssueTypeEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueTypeEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IssueTypeEnumMultiError(errors)
	}

	return nil
}

// IssueTypeEnumMultiError is an error wrapping multiple validation errors
// returned by IssueTypeEnum.ValidateAll() if the designated constraints
// aren't met.
type IssueTypeEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueTypeEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueTypeEnumMultiError) AllErrors() []error { return m }

// IssueTypeEnumValidationError is the validation error returned by
// IssueTypeEnum.Validate if the designated constraints aren't met.
type IssueTypeEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueTypeEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueTypeEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueTypeEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueTypeEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueTypeEnumValidationError) ErrorName() string { return "IssueTypeEnumValidationError" }

// Error satisfies the builtin error interface
func (e IssueTypeEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueTypeEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueTypeEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueTypeEnumValidationError{}

// Validate checks the field values on IssuePriorityEnum with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IssuePriorityEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssuePriorityEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssuePriorityEnumMultiError, or nil if none found.
func (m *IssuePriorityEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *IssuePriorityEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IssuePriorityEnumMultiError(errors)
	}

	return nil
}

// IssuePriorityEnumMultiError is an error wrapping multiple validation errors
// returned by IssuePriorityEnum.ValidateAll() if the designated constraints
// aren't met.
type IssuePriorityEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssuePriorityEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssuePriorityEnumMultiError) AllErrors() []error { return m }

// IssuePriorityEnumValidationError is the validation error returned by
// IssuePriorityEnum.Validate if the designated constraints aren't met.
type IssuePriorityEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssuePriorityEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssuePriorityEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssuePriorityEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssuePriorityEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssuePriorityEnumValidationError) ErrorName() string {
	return "IssuePriorityEnumValidationError"
}

// Error satisfies the builtin error interface
func (e IssuePriorityEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssuePriorityEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssuePriorityEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssuePriorityEnumValidationError{}

// Validate checks the field values on IssueComplexityEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueComplexityEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueComplexityEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueComplexityEnumMultiError, or nil if none found.
func (m *IssueComplexityEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueComplexityEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IssueComplexityEnumMultiError(errors)
	}

	return nil
}

// IssueComplexityEnumMultiError is an error wrapping multiple validation
// errors returned by IssueComplexityEnum.ValidateAll() if the designated
// constraints aren't met.
type IssueComplexityEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueComplexityEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueComplexityEnumMultiError) AllErrors() []error { return m }

// IssueComplexityEnumValidationError is the validation error returned by
// IssueComplexityEnum.Validate if the designated constraints aren't met.
type IssueComplexityEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueComplexityEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueComplexityEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueComplexityEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueComplexityEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueComplexityEnumValidationError) ErrorName() string {
	return "IssueComplexityEnumValidationError"
}

// Error satisfies the builtin error interface
func (e IssueComplexityEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueComplexityEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueComplexityEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueComplexityEnumValidationError{}

// Validate checks the field values on IssueSeverityEnum with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IssueSeverityEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueSeverityEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueSeverityEnumMultiError, or nil if none found.
func (m *IssueSeverityEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueSeverityEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IssueSeverityEnumMultiError(errors)
	}

	return nil
}

// IssueSeverityEnumMultiError is an error wrapping multiple validation errors
// returned by IssueSeverityEnum.ValidateAll() if the designated constraints
// aren't met.
type IssueSeverityEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueSeverityEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueSeverityEnumMultiError) AllErrors() []error { return m }

// IssueSeverityEnumValidationError is the validation error returned by
// IssueSeverityEnum.Validate if the designated constraints aren't met.
type IssueSeverityEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueSeverityEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueSeverityEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueSeverityEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueSeverityEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueSeverityEnumValidationError) ErrorName() string {
	return "IssueSeverityEnumValidationError"
}

// Error satisfies the builtin error interface
func (e IssueSeverityEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueSeverityEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueSeverityEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueSeverityEnumValidationError{}

// Validate checks the field values on IssueStateBelongEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueStateBelongEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueStateBelongEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueStateBelongEnumMultiError, or nil if none found.
func (m *IssueStateBelongEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueStateBelongEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IssueStateBelongEnumMultiError(errors)
	}

	return nil
}

// IssueStateBelongEnumMultiError is an error wrapping multiple validation
// errors returned by IssueStateBelongEnum.ValidateAll() if the designated
// constraints aren't met.
type IssueStateBelongEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueStateBelongEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueStateBelongEnumMultiError) AllErrors() []error { return m }

// IssueStateBelongEnumValidationError is the validation error returned by
// IssueStateBelongEnum.Validate if the designated constraints aren't met.
type IssueStateBelongEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueStateBelongEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueStateBelongEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueStateBelongEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueStateBelongEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueStateBelongEnumValidationError) ErrorName() string {
	return "IssueStateBelongEnumValidationError"
}

// Error satisfies the builtin error interface
func (e IssueStateBelongEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueStateBelongEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueStateBelongEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueStateBelongEnumValidationError{}

// Validate checks the field values on ProjectLabelTypeEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProjectLabelTypeEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectLabelTypeEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectLabelTypeEnumMultiError, or nil if none found.
func (m *ProjectLabelTypeEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectLabelTypeEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ProjectLabelTypeEnumMultiError(errors)
	}

	return nil
}

// ProjectLabelTypeEnumMultiError is an error wrapping multiple validation
// errors returned by ProjectLabelTypeEnum.ValidateAll() if the designated
// constraints aren't met.
type ProjectLabelTypeEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectLabelTypeEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectLabelTypeEnumMultiError) AllErrors() []error { return m }

// ProjectLabelTypeEnumValidationError is the validation error returned by
// ProjectLabelTypeEnum.Validate if the designated constraints aren't met.
type ProjectLabelTypeEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectLabelTypeEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectLabelTypeEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectLabelTypeEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectLabelTypeEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectLabelTypeEnumValidationError) ErrorName() string {
	return "ProjectLabelTypeEnumValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectLabelTypeEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectLabelTypeEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectLabelTypeEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectLabelTypeEnumValidationError{}

// Validate checks the field values on IssueManHour with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IssueManHour) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueManHour with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IssueManHourMultiError, or
// nil if none found.
func (m *IssueManHour) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueManHour) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EstimateTime

	// no validation rules for ThisElapsedTime

	// no validation rules for ElapsedTime

	// no validation rules for RemainingTime

	// no validation rules for StartTime

	// no validation rules for WorkContent

	// no validation rules for IsModifiedRemainingTime

	if len(errors) > 0 {
		return IssueManHourMultiError(errors)
	}

	return nil
}

// IssueManHourMultiError is an error wrapping multiple validation errors
// returned by IssueManHour.ValidateAll() if the designated constraints aren't met.
type IssueManHourMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueManHourMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueManHourMultiError) AllErrors() []error { return m }

// IssueManHourValidationError is the validation error returned by
// IssueManHour.Validate if the designated constraints aren't met.
type IssueManHourValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueManHourValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueManHourValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueManHourValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueManHourValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueManHourValidationError) ErrorName() string { return "IssueManHourValidationError" }

// Error satisfies the builtin error interface
func (e IssueManHourValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueManHour.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueManHourValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueManHourValidationError{}

// Validate checks the field values on IssueStateButton with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IssueStateButton) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueStateButton with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueStateButtonMultiError, or nil if none found.
func (m *IssueStateButton) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueStateButton) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StateID

	// no validation rules for StateName

	// no validation rules for StateBelong

	// no validation rules for Permission

	if len(errors) > 0 {
		return IssueStateButtonMultiError(errors)
	}

	return nil
}

// IssueStateButtonMultiError is an error wrapping multiple validation errors
// returned by IssueStateButton.ValidateAll() if the designated constraints
// aren't met.
type IssueStateButtonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueStateButtonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueStateButtonMultiError) AllErrors() []error { return m }

// IssueStateButtonValidationError is the validation error returned by
// IssueStateButton.Validate if the designated constraints aren't met.
type IssueStateButtonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueStateButtonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueStateButtonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueStateButtonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueStateButtonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueStateButtonValidationError) ErrorName() string { return "IssueStateButtonValidationError" }

// Error satisfies the builtin error interface
func (e IssueStateButtonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueStateButton.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueStateButtonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueStateButtonValidationError{}

// Validate checks the field values on IssueSummary with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IssueSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueSummary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IssueSummaryMultiError, or
// nil if none found.
func (m *IssueSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProcessingCount

	// no validation rules for DoneCount

	if len(errors) > 0 {
		return IssueSummaryMultiError(errors)
	}

	return nil
}

// IssueSummaryMultiError is an error wrapping multiple validation errors
// returned by IssueSummary.ValidateAll() if the designated constraints aren't met.
type IssueSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueSummaryMultiError) AllErrors() []error { return m }

// IssueSummaryValidationError is the validation error returned by
// IssueSummary.Validate if the designated constraints aren't met.
type IssueSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueSummaryValidationError) ErrorName() string { return "IssueSummaryValidationError" }

// Error satisfies the builtin error interface
func (e IssueSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueSummaryValidationError{}

// Validate checks the field values on ProjectLabel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProjectLabel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectLabel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProjectLabelMultiError, or
// nil if none found.
func (m *ProjectLabel) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectLabel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Color

	// no validation rules for ProjectID

	// no validation rules for Creator

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectLabelValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectLabelValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectLabelValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectLabelValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectLabelValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectLabelValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProjectLabelMultiError(errors)
	}

	return nil
}

// ProjectLabelMultiError is an error wrapping multiple validation errors
// returned by ProjectLabel.ValidateAll() if the designated constraints aren't met.
type ProjectLabelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectLabelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectLabelMultiError) AllErrors() []error { return m }

// ProjectLabelValidationError is the validation error returned by
// ProjectLabel.Validate if the designated constraints aren't met.
type ProjectLabelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectLabelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectLabelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectLabelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectLabelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectLabelValidationError) ErrorName() string { return "ProjectLabelValidationError" }

// Error satisfies the builtin error interface
func (e ProjectLabelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectLabel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectLabelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectLabelValidationError{}

// Validate checks the field values on TestPlanCaseRel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TestPlanCaseRel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestPlanCaseRel with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestPlanCaseRelMultiError, or nil if none found.
func (m *TestPlanCaseRel) ValidateAll() error {
	return m.validate(true)
}

func (m *TestPlanCaseRel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Priority

	// no validation rules for TestPlanID

	// no validation rules for TestSetID

	// no validation rules for TestCaseID

	// no validation rules for ExecStatus

	// no validation rules for Creator

	// no validation rules for UpdaterID

	// no validation rules for ExecutorID

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestPlanCaseRelValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestPlanCaseRelValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestPlanCaseRelValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestPlanCaseRelValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestPlanCaseRelValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestPlanCaseRelValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAPICount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestPlanCaseRelValidationError{
					field:  "APICount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestPlanCaseRelValidationError{
					field:  "APICount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAPICount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestPlanCaseRelValidationError{
				field:  "APICount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetIssueBugs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestPlanCaseRelValidationError{
						field:  fmt.Sprintf("IssueBugs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestPlanCaseRelValidationError{
						field:  fmt.Sprintf("IssueBugs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestPlanCaseRelValidationError{
					field:  fmt.Sprintf("IssueBugs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestPlanCaseRelMultiError(errors)
	}

	return nil
}

// TestPlanCaseRelMultiError is an error wrapping multiple validation errors
// returned by TestPlanCaseRel.ValidateAll() if the designated constraints
// aren't met.
type TestPlanCaseRelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestPlanCaseRelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestPlanCaseRelMultiError) AllErrors() []error { return m }

// TestPlanCaseRelValidationError is the validation error returned by
// TestPlanCaseRel.Validate if the designated constraints aren't met.
type TestPlanCaseRelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestPlanCaseRelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestPlanCaseRelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestPlanCaseRelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestPlanCaseRelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestPlanCaseRelValidationError) ErrorName() string { return "TestPlanCaseRelValidationError" }

// Error satisfies the builtin error interface
func (e TestPlanCaseRelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestPlanCaseRel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestPlanCaseRelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestPlanCaseRelValidationError{}

// Validate checks the field values on TestCaseAPICount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TestCaseAPICount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCaseAPICount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCaseAPICountMultiError, or nil if none found.
func (m *TestCaseAPICount) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCaseAPICount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	// no validation rules for Created

	// no validation rules for Running

	// no validation rules for Passed

	// no validation rules for Failed

	if len(errors) > 0 {
		return TestCaseAPICountMultiError(errors)
	}

	return nil
}

// TestCaseAPICountMultiError is an error wrapping multiple validation errors
// returned by TestCaseAPICount.ValidateAll() if the designated constraints
// aren't met.
type TestCaseAPICountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCaseAPICountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCaseAPICountMultiError) AllErrors() []error { return m }

// TestCaseAPICountValidationError is the validation error returned by
// TestCaseAPICount.Validate if the designated constraints aren't met.
type TestCaseAPICountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCaseAPICountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCaseAPICountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCaseAPICountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCaseAPICountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCaseAPICountValidationError) ErrorName() string { return "TestCaseAPICountValidationError" }

// Error satisfies the builtin error interface
func (e TestCaseAPICountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCaseAPICount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCaseAPICountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCaseAPICountValidationError{}

// Validate checks the field values on TestPlanCaseRelIssueBug with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestPlanCaseRelIssueBug) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestPlanCaseRelIssueBug with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestPlanCaseRelIssueBugMultiError, or nil if none found.
func (m *TestPlanCaseRelIssueBug) ValidateAll() error {
	return m.validate(true)
}

func (m *TestPlanCaseRelIssueBug) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IssueRelationID

	// no validation rules for IssueID

	// no validation rules for IterationID

	// no validation rules for Title

	// no validation rules for State

	// no validation rules for StateBelong

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestPlanCaseRelIssueBugValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestPlanCaseRelIssueBugValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestPlanCaseRelIssueBugValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TestPlanCaseRelIssueBugMultiError(errors)
	}

	return nil
}

// TestPlanCaseRelIssueBugMultiError is an error wrapping multiple validation
// errors returned by TestPlanCaseRelIssueBug.ValidateAll() if the designated
// constraints aren't met.
type TestPlanCaseRelIssueBugMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestPlanCaseRelIssueBugMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestPlanCaseRelIssueBugMultiError) AllErrors() []error { return m }

// TestPlanCaseRelIssueBugValidationError is the validation error returned by
// TestPlanCaseRelIssueBug.Validate if the designated constraints aren't met.
type TestPlanCaseRelIssueBugValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestPlanCaseRelIssueBugValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestPlanCaseRelIssueBugValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestPlanCaseRelIssueBugValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestPlanCaseRelIssueBugValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestPlanCaseRelIssueBugValidationError) ErrorName() string {
	return "TestPlanCaseRelIssueBugValidationError"
}

// Error satisfies the builtin error interface
func (e TestPlanCaseRelIssueBugValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestPlanCaseRelIssueBug.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestPlanCaseRelIssueBugValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestPlanCaseRelIssueBugValidationError{}

// Validate checks the field values on TestCasePriorityEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TestCasePriorityEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestCasePriorityEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TestCasePriorityEnumMultiError, or nil if none found.
func (m *TestCasePriorityEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *TestCasePriorityEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestCasePriorityEnumMultiError(errors)
	}

	return nil
}

// TestCasePriorityEnumMultiError is an error wrapping multiple validation
// errors returned by TestCasePriorityEnum.ValidateAll() if the designated
// constraints aren't met.
type TestCasePriorityEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestCasePriorityEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestCasePriorityEnumMultiError) AllErrors() []error { return m }

// TestCasePriorityEnumValidationError is the validation error returned by
// TestCasePriorityEnum.Validate if the designated constraints aren't met.
type TestCasePriorityEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestCasePriorityEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestCasePriorityEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestCasePriorityEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestCasePriorityEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestCasePriorityEnumValidationError) ErrorName() string {
	return "TestCasePriorityEnumValidationError"
}

// Error satisfies the builtin error interface
func (e TestCasePriorityEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestCasePriorityEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestCasePriorityEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestCasePriorityEnumValidationError{}

// Validate checks the field values on PropertyTypeEnum with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PropertyTypeEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PropertyTypeEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PropertyTypeEnumMultiError, or nil if none found.
func (m *PropertyTypeEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *PropertyTypeEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PropertyTypeEnumMultiError(errors)
	}

	return nil
}

// PropertyTypeEnumMultiError is an error wrapping multiple validation errors
// returned by PropertyTypeEnum.ValidateAll() if the designated constraints
// aren't met.
type PropertyTypeEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PropertyTypeEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PropertyTypeEnumMultiError) AllErrors() []error { return m }

// PropertyTypeEnumValidationError is the validation error returned by
// PropertyTypeEnum.Validate if the designated constraints aren't met.
type PropertyTypeEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PropertyTypeEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PropertyTypeEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PropertyTypeEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PropertyTypeEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PropertyTypeEnumValidationError) ErrorName() string { return "PropertyTypeEnumValidationError" }

// Error satisfies the builtin error interface
func (e PropertyTypeEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPropertyTypeEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PropertyTypeEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PropertyTypeEnumValidationError{}

// Validate checks the field values on PropertyIssueTypeEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PropertyIssueTypeEnum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PropertyIssueTypeEnum with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PropertyIssueTypeEnumMultiError, or nil if none found.
func (m *PropertyIssueTypeEnum) ValidateAll() error {
	return m.validate(true)
}

func (m *PropertyIssueTypeEnum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PropertyIssueTypeEnumMultiError(errors)
	}

	return nil
}

// PropertyIssueTypeEnumMultiError is an error wrapping multiple validation
// errors returned by PropertyIssueTypeEnum.ValidateAll() if the designated
// constraints aren't met.
type PropertyIssueTypeEnumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PropertyIssueTypeEnumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PropertyIssueTypeEnumMultiError) AllErrors() []error { return m }

// PropertyIssueTypeEnumValidationError is the validation error returned by
// PropertyIssueTypeEnum.Validate if the designated constraints aren't met.
type PropertyIssueTypeEnumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PropertyIssueTypeEnumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PropertyIssueTypeEnumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PropertyIssueTypeEnumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PropertyIssueTypeEnumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PropertyIssueTypeEnumValidationError) ErrorName() string {
	return "PropertyIssueTypeEnumValidationError"
}

// Error satisfies the builtin error interface
func (e PropertyIssueTypeEnumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPropertyIssueTypeEnum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PropertyIssueTypeEnumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PropertyIssueTypeEnumValidationError{}

// Validate checks the field values on Enumerate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Enumerate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Enumerate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnumerateMultiError, or nil
// if none found.
func (m *Enumerate) ValidateAll() error {
	return m.validate(true)
}

func (m *Enumerate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Index

	if len(errors) > 0 {
		return EnumerateMultiError(errors)
	}

	return nil
}

// EnumerateMultiError is an error wrapping multiple validation errors returned
// by Enumerate.ValidateAll() if the designated constraints aren't met.
type EnumerateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumerateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumerateMultiError) AllErrors() []error { return m }

// EnumerateValidationError is the validation error returned by
// Enumerate.Validate if the designated constraints aren't met.
type EnumerateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumerateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumerateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumerateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumerateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumerateValidationError) ErrorName() string { return "EnumerateValidationError" }

// Error satisfies the builtin error interface
func (e EnumerateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumerate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumerateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumerateValidationError{}

// Validate checks the field values on IssueAndPropertyAndValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueAndPropertyAndValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueAndPropertyAndValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueAndPropertyAndValueMultiError, or nil if none found.
func (m *IssueAndPropertyAndValue) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueAndPropertyAndValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IssueID

	for idx, item := range m.GetProperty() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueAndPropertyAndValueValidationError{
						field:  fmt.Sprintf("Property[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueAndPropertyAndValueValidationError{
						field:  fmt.Sprintf("Property[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueAndPropertyAndValueValidationError{
					field:  fmt.Sprintf("Property[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IssueAndPropertyAndValueMultiError(errors)
	}

	return nil
}

// IssueAndPropertyAndValueMultiError is an error wrapping multiple validation
// errors returned by IssueAndPropertyAndValue.ValidateAll() if the designated
// constraints aren't met.
type IssueAndPropertyAndValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueAndPropertyAndValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueAndPropertyAndValueMultiError) AllErrors() []error { return m }

// IssueAndPropertyAndValueValidationError is the validation error returned by
// IssueAndPropertyAndValue.Validate if the designated constraints aren't met.
type IssueAndPropertyAndValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueAndPropertyAndValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueAndPropertyAndValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueAndPropertyAndValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueAndPropertyAndValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueAndPropertyAndValueValidationError) ErrorName() string {
	return "IssueAndPropertyAndValueValidationError"
}

// Error satisfies the builtin error interface
func (e IssueAndPropertyAndValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueAndPropertyAndValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueAndPropertyAndValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueAndPropertyAndValueValidationError{}

// Validate checks the field values on IssuePropertyExtraProperty with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssuePropertyExtraProperty) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssuePropertyExtraProperty with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssuePropertyExtraPropertyMultiError, or nil if none found.
func (m *IssuePropertyExtraProperty) ValidateAll() error {
	return m.validate(true)
}

func (m *IssuePropertyExtraProperty) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PropertyID

	// no validation rules for PropertyType

	// no validation rules for PropertyName

	// no validation rules for Required

	// no validation rules for DisplayName

	if all {
		switch v := interface{}(m.GetArbitraryValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssuePropertyExtraPropertyValidationError{
					field:  "ArbitraryValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssuePropertyExtraPropertyValidationError{
					field:  "ArbitraryValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArbitraryValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssuePropertyExtraPropertyValidationError{
				field:  "ArbitraryValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetEnumeratedValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssuePropertyExtraPropertyValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssuePropertyExtraPropertyValidationError{
						field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssuePropertyExtraPropertyValidationError{
					field:  fmt.Sprintf("EnumeratedValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IssuePropertyExtraPropertyMultiError(errors)
	}

	return nil
}

// IssuePropertyExtraPropertyMultiError is an error wrapping multiple
// validation errors returned by IssuePropertyExtraProperty.ValidateAll() if
// the designated constraints aren't met.
type IssuePropertyExtraPropertyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssuePropertyExtraPropertyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssuePropertyExtraPropertyMultiError) AllErrors() []error { return m }

// IssuePropertyExtraPropertyValidationError is the validation error returned
// by IssuePropertyExtraProperty.Validate if the designated constraints aren't met.
type IssuePropertyExtraPropertyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssuePropertyExtraPropertyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssuePropertyExtraPropertyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssuePropertyExtraPropertyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssuePropertyExtraPropertyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssuePropertyExtraPropertyValidationError) ErrorName() string {
	return "IssuePropertyExtraPropertyValidationError"
}

// Error satisfies the builtin error interface
func (e IssuePropertyExtraPropertyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssuePropertyExtraProperty.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssuePropertyExtraPropertyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssuePropertyExtraPropertyValidationError{}

// Validate checks the field values on IssuePropertyUpdateTimes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssuePropertyUpdateTimes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssuePropertyUpdateTimes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssuePropertyUpdateTimesMultiError, or nil if none found.
func (m *IssuePropertyUpdateTimes) ValidateAll() error {
	return m.validate(true)
}

func (m *IssuePropertyUpdateTimes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Task

	// no validation rules for Bug

	// no validation rules for Epic

	// no validation rules for Requirement

	if len(errors) > 0 {
		return IssuePropertyUpdateTimesMultiError(errors)
	}

	return nil
}

// IssuePropertyUpdateTimesMultiError is an error wrapping multiple validation
// errors returned by IssuePropertyUpdateTimes.ValidateAll() if the designated
// constraints aren't met.
type IssuePropertyUpdateTimesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssuePropertyUpdateTimesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssuePropertyUpdateTimesMultiError) AllErrors() []error { return m }

// IssuePropertyUpdateTimesValidationError is the validation error returned by
// IssuePropertyUpdateTimes.Validate if the designated constraints aren't met.
type IssuePropertyUpdateTimesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssuePropertyUpdateTimesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssuePropertyUpdateTimesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssuePropertyUpdateTimesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssuePropertyUpdateTimesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssuePropertyUpdateTimesValidationError) ErrorName() string {
	return "IssuePropertyUpdateTimesValidationError"
}

// Error satisfies the builtin error interface
func (e IssuePropertyUpdateTimesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssuePropertyUpdateTimes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssuePropertyUpdateTimesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssuePropertyUpdateTimesValidationError{}

// Validate checks the field values on PagingIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PagingIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PagingIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PagingIssueRequestMultiError, or nil if none found.
func (m *PagingIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PagingIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for ProjectID

	// no validation rules for IterationID

	// no validation rules for StartCreatedAt

	// no validation rules for EndCreatedAt

	// no validation rules for StartFinishedAt

	// no validation rules for EndFinishedAt

	// no validation rules for IsEmptyPlanFinishedAt

	// no validation rules for StartClosedAt

	// no validation rules for EndClosedAt

	// no validation rules for Source

	// no validation rules for OrderBy

	// no validation rules for WithProcessSummary

	// no validation rules for Asc

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PagingIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PagingIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PagingIssueRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for External

	// no validation rules for CustomPanelID

	// no validation rules for OnlyIdResult

	// no validation rules for NotIncluded

	// no validation rules for PageNo

	// no validation rules for PageSize

	// no validation rules for OrgID

	// no validation rules for WithCustomProperties

	if m.AppID != nil {
		// no validation rules for AppID
	}

	if m.RequirementID != nil {
		// no validation rules for RequirementID
	}

	if len(errors) > 0 {
		return PagingIssueRequestMultiError(errors)
	}

	return nil
}

// PagingIssueRequestMultiError is an error wrapping multiple validation errors
// returned by PagingIssueRequest.ValidateAll() if the designated constraints
// aren't met.
type PagingIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PagingIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PagingIssueRequestMultiError) AllErrors() []error { return m }

// PagingIssueRequestValidationError is the validation error returned by
// PagingIssueRequest.Validate if the designated constraints aren't met.
type PagingIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PagingIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PagingIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PagingIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PagingIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PagingIssueRequestValidationError) ErrorName() string {
	return "PagingIssueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PagingIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPagingIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PagingIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PagingIssueRequestValidationError{}

// Validate checks the field values on IssueListRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IssueListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueListRequestMultiError, or nil if none found.
func (m *IssueListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for ProjectID

	// no validation rules for IterationID

	// no validation rules for StartCreatedAt

	// no validation rules for EndCreatedAt

	// no validation rules for StartFinishedAt

	// no validation rules for EndFinishedAt

	// no validation rules for IsEmptyPlanFinishedAt

	// no validation rules for StartClosedAt

	// no validation rules for EndClosedAt

	// no validation rules for Source

	// no validation rules for OrderBy

	// no validation rules for WithProcessSummary

	// no validation rules for Asc

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueListRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueListRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueListRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for External

	// no validation rules for CustomPanelID

	// no validation rules for OnlyIdResult

	// no validation rules for NotIncluded

	if m.AppID != nil {
		// no validation rules for AppID
	}

	if m.RequirementID != nil {
		// no validation rules for RequirementID
	}

	if len(errors) > 0 {
		return IssueListRequestMultiError(errors)
	}

	return nil
}

// IssueListRequestMultiError is an error wrapping multiple validation errors
// returned by IssueListRequest.ValidateAll() if the designated constraints
// aren't met.
type IssueListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueListRequestMultiError) AllErrors() []error { return m }

// IssueListRequestValidationError is the validation error returned by
// IssueListRequest.Validate if the designated constraints aren't met.
type IssueListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueListRequestValidationError) ErrorName() string { return "IssueListRequestValidationError" }

// Error satisfies the builtin error interface
func (e IssueListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueListRequestValidationError{}

// Validate checks the field values on PagingIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PagingIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PagingIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PagingIssueResponseMultiError, or nil if none found.
func (m *PagingIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PagingIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PagingIssueResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PagingIssueResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PagingIssueResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PagingIssueResponseMultiError(errors)
	}

	return nil
}

// PagingIssueResponseMultiError is an error wrapping multiple validation
// errors returned by PagingIssueResponse.ValidateAll() if the designated
// constraints aren't met.
type PagingIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PagingIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PagingIssueResponseMultiError) AllErrors() []error { return m }

// PagingIssueResponseValidationError is the validation error returned by
// PagingIssueResponse.Validate if the designated constraints aren't met.
type PagingIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PagingIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PagingIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PagingIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PagingIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PagingIssueResponseValidationError) ErrorName() string {
	return "PagingIssueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PagingIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPagingIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PagingIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PagingIssueResponseValidationError{}

// Validate checks the field values on IssuePagingResponseData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssuePagingResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssuePagingResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssuePagingResponseDataMultiError, or nil if none found.
func (m *IssuePagingResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *IssuePagingResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssuePagingResponseDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssuePagingResponseDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssuePagingResponseDataValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IssuePagingResponseDataMultiError(errors)
	}

	return nil
}

// IssuePagingResponseDataMultiError is an error wrapping multiple validation
// errors returned by IssuePagingResponseData.ValidateAll() if the designated
// constraints aren't met.
type IssuePagingResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssuePagingResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssuePagingResponseDataMultiError) AllErrors() []error { return m }

// IssuePagingResponseDataValidationError is the validation error returned by
// IssuePagingResponseData.Validate if the designated constraints aren't met.
type IssuePagingResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssuePagingResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssuePagingResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssuePagingResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssuePagingResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssuePagingResponseDataValidationError) ErrorName() string {
	return "IssuePagingResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e IssuePagingResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssuePagingResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssuePagingResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssuePagingResponseDataValidationError{}

// Validate checks the field values on ExportExcelIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportExcelIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportExcelIssueRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportExcelIssueRequestMultiError, or nil if none found.
func (m *ExportExcelIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportExcelIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for ProjectID

	// no validation rules for IterationID

	// no validation rules for StartCreatedAt

	// no validation rules for EndCreatedAt

	// no validation rules for StartFinishedAt

	// no validation rules for EndFinishedAt

	// no validation rules for IsEmptyPlanFinishedAt

	// no validation rules for StartClosedAt

	// no validation rules for EndClosedAt

	// no validation rules for Source

	// no validation rules for OrderBy

	// no validation rules for WithProcessSummary

	// no validation rules for Asc

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExportExcelIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExportExcelIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExportExcelIssueRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for External

	// no validation rules for CustomPanelID

	// no validation rules for OnlyIdResult

	// no validation rules for NotIncluded

	// no validation rules for PageNo

	// no validation rules for PageSize

	// no validation rules for OrgID

	// no validation rules for Locale

	// no validation rules for IsDownload

	if m.AppID != nil {
		// no validation rules for AppID
	}

	if m.RequirementID != nil {
		// no validation rules for RequirementID
	}

	if len(errors) > 0 {
		return ExportExcelIssueRequestMultiError(errors)
	}

	return nil
}

// ExportExcelIssueRequestMultiError is an error wrapping multiple validation
// errors returned by ExportExcelIssueRequest.ValidateAll() if the designated
// constraints aren't met.
type ExportExcelIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportExcelIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportExcelIssueRequestMultiError) AllErrors() []error { return m }

// ExportExcelIssueRequestValidationError is the validation error returned by
// ExportExcelIssueRequest.Validate if the designated constraints aren't met.
type ExportExcelIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportExcelIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportExcelIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportExcelIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportExcelIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportExcelIssueRequestValidationError) ErrorName() string {
	return "ExportExcelIssueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExportExcelIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportExcelIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportExcelIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportExcelIssueRequestValidationError{}

// Validate checks the field values on ExportExcelIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportExcelIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportExcelIssueResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportExcelIssueResponseMultiError, or nil if none found.
func (m *ExportExcelIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportExcelIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return ExportExcelIssueResponseMultiError(errors)
	}

	return nil
}

// ExportExcelIssueResponseMultiError is an error wrapping multiple validation
// errors returned by ExportExcelIssueResponse.ValidateAll() if the designated
// constraints aren't met.
type ExportExcelIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportExcelIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportExcelIssueResponseMultiError) AllErrors() []error { return m }

// ExportExcelIssueResponseValidationError is the validation error returned by
// ExportExcelIssueResponse.Validate if the designated constraints aren't met.
type ExportExcelIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportExcelIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportExcelIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportExcelIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportExcelIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportExcelIssueResponseValidationError) ErrorName() string {
	return "ExportExcelIssueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExportExcelIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportExcelIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportExcelIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportExcelIssueResponseValidationError{}

// Validate checks the field values on ImportExcelIssueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportExcelIssueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportExcelIssueRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportExcelIssueRequestMultiError, or nil if none found.
func (m *ImportExcelIssueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportExcelIssueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for OrgID

	// no validation rules for Type

	// no validation rules for FileID

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportExcelIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportExcelIssueRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportExcelIssueRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ImportExcelIssueRequestMultiError(errors)
	}

	return nil
}

// ImportExcelIssueRequestMultiError is an error wrapping multiple validation
// errors returned by ImportExcelIssueRequest.ValidateAll() if the designated
// constraints aren't met.
type ImportExcelIssueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportExcelIssueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportExcelIssueRequestMultiError) AllErrors() []error { return m }

// ImportExcelIssueRequestValidationError is the validation error returned by
// ImportExcelIssueRequest.Validate if the designated constraints aren't met.
type ImportExcelIssueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportExcelIssueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportExcelIssueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportExcelIssueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportExcelIssueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportExcelIssueRequestValidationError) ErrorName() string {
	return "ImportExcelIssueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportExcelIssueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportExcelIssueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportExcelIssueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportExcelIssueRequestValidationError{}

// Validate checks the field values on ImportExcelIssueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportExcelIssueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportExcelIssueResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportExcelIssueResponseMultiError, or nil if none found.
func (m *ImportExcelIssueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportExcelIssueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return ImportExcelIssueResponseMultiError(errors)
	}

	return nil
}

// ImportExcelIssueResponseMultiError is an error wrapping multiple validation
// errors returned by ImportExcelIssueResponse.ValidateAll() if the designated
// constraints aren't met.
type ImportExcelIssueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportExcelIssueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportExcelIssueResponseMultiError) AllErrors() []error { return m }

// ImportExcelIssueResponseValidationError is the validation error returned by
// ImportExcelIssueResponse.Validate if the designated constraints aren't met.
type ImportExcelIssueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportExcelIssueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportExcelIssueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportExcelIssueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportExcelIssueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportExcelIssueResponseValidationError) ErrorName() string {
	return "ImportExcelIssueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportExcelIssueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportExcelIssueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportExcelIssueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportExcelIssueResponseValidationError{}

// Validate checks the field values on AddIssueRelationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddIssueRelationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddIssueRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddIssueRelationRequestMultiError, or nil if none found.
func (m *AddIssueRelationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddIssueRelationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for IssueID

	// no validation rules for Comment

	// no validation rules for ProjectId

	// no validation rules for Type

	if len(errors) > 0 {
		return AddIssueRelationRequestMultiError(errors)
	}

	return nil
}

// AddIssueRelationRequestMultiError is an error wrapping multiple validation
// errors returned by AddIssueRelationRequest.ValidateAll() if the designated
// constraints aren't met.
type AddIssueRelationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddIssueRelationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddIssueRelationRequestMultiError) AllErrors() []error { return m }

// AddIssueRelationRequestValidationError is the validation error returned by
// AddIssueRelationRequest.Validate if the designated constraints aren't met.
type AddIssueRelationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddIssueRelationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddIssueRelationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddIssueRelationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddIssueRelationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddIssueRelationRequestValidationError) ErrorName() string {
	return "AddIssueRelationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddIssueRelationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddIssueRelationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddIssueRelationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddIssueRelationRequestValidationError{}

// Validate checks the field values on AddIssueRelationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddIssueRelationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddIssueRelationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddIssueRelationResponseMultiError, or nil if none found.
func (m *AddIssueRelationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddIssueRelationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AddIssueRelationResponseMultiError(errors)
	}

	return nil
}

// AddIssueRelationResponseMultiError is an error wrapping multiple validation
// errors returned by AddIssueRelationResponse.ValidateAll() if the designated
// constraints aren't met.
type AddIssueRelationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddIssueRelationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddIssueRelationResponseMultiError) AllErrors() []error { return m }

// AddIssueRelationResponseValidationError is the validation error returned by
// AddIssueRelationResponse.Validate if the designated constraints aren't met.
type AddIssueRelationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddIssueRelationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddIssueRelationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddIssueRelationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddIssueRelationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddIssueRelationResponseValidationError) ErrorName() string {
	return "AddIssueRelationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddIssueRelationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddIssueRelationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddIssueRelationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddIssueRelationResponseValidationError{}

// Validate checks the field values on DeleteIssueRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIssueRelationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIssueRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIssueRelationRequestMultiError, or nil if none found.
func (m *DeleteIssueRelationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIssueRelationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for RelatedIssueID

	if len(errors) > 0 {
		return DeleteIssueRelationRequestMultiError(errors)
	}

	return nil
}

// DeleteIssueRelationRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteIssueRelationRequest.ValidateAll() if
// the designated constraints aren't met.
type DeleteIssueRelationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIssueRelationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIssueRelationRequestMultiError) AllErrors() []error { return m }

// DeleteIssueRelationRequestValidationError is the validation error returned
// by DeleteIssueRelationRequest.Validate if the designated constraints aren't met.
type DeleteIssueRelationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIssueRelationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIssueRelationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIssueRelationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIssueRelationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIssueRelationRequestValidationError) ErrorName() string {
	return "DeleteIssueRelationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIssueRelationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIssueRelationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIssueRelationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIssueRelationRequestValidationError{}

// Validate checks the field values on DeleteIssueRelationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIssueRelationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIssueRelationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIssueRelationResponseMultiError, or nil if none found.
func (m *DeleteIssueRelationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIssueRelationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteIssueRelationResponseMultiError(errors)
	}

	return nil
}

// DeleteIssueRelationResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteIssueRelationResponse.ValidateAll() if
// the designated constraints aren't met.
type DeleteIssueRelationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIssueRelationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIssueRelationResponseMultiError) AllErrors() []error { return m }

// DeleteIssueRelationResponseValidationError is the validation error returned
// by DeleteIssueRelationResponse.Validate if the designated constraints
// aren't met.
type DeleteIssueRelationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIssueRelationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIssueRelationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIssueRelationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIssueRelationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIssueRelationResponseValidationError) ErrorName() string {
	return "DeleteIssueRelationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIssueRelationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIssueRelationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIssueRelationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIssueRelationResponseValidationError{}

// Validate checks the field values on GetIssueRelationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssueRelationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueRelationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssueRelationsRequestMultiError, or nil if none found.
func (m *GetIssueRelationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueRelationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetIssueRelationsRequestMultiError(errors)
	}

	return nil
}

// GetIssueRelationsRequestMultiError is an error wrapping multiple validation
// errors returned by GetIssueRelationsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetIssueRelationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueRelationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueRelationsRequestMultiError) AllErrors() []error { return m }

// GetIssueRelationsRequestValidationError is the validation error returned by
// GetIssueRelationsRequest.Validate if the designated constraints aren't met.
type GetIssueRelationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueRelationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueRelationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueRelationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueRelationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueRelationsRequestValidationError) ErrorName() string {
	return "GetIssueRelationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssueRelationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueRelationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueRelationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueRelationsRequestValidationError{}

// Validate checks the field values on GetIssueRelationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssueRelationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueRelationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssueRelationsResponseMultiError, or nil if none found.
func (m *GetIssueRelationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueRelationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIssueRelationsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIssueRelationsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIssueRelationsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIssueRelationsResponseMultiError(errors)
	}

	return nil
}

// GetIssueRelationsResponseMultiError is an error wrapping multiple validation
// errors returned by GetIssueRelationsResponse.ValidateAll() if the
// designated constraints aren't met.
type GetIssueRelationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueRelationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueRelationsResponseMultiError) AllErrors() []error { return m }

// GetIssueRelationsResponseValidationError is the validation error returned by
// GetIssueRelationsResponse.Validate if the designated constraints aren't met.
type GetIssueRelationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueRelationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueRelationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueRelationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueRelationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueRelationsResponseValidationError) ErrorName() string {
	return "GetIssueRelationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssueRelationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueRelationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueRelationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueRelationsResponseValidationError{}

// Validate checks the field values on IssueRelations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IssueRelations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueRelations with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IssueRelationsMultiError,
// or nil if none found.
func (m *IssueRelations) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueRelations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRelatedTo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueRelationsValidationError{
						field:  fmt.Sprintf("RelatedTo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueRelationsValidationError{
						field:  fmt.Sprintf("RelatedTo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueRelationsValidationError{
					field:  fmt.Sprintf("RelatedTo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRelatedBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueRelationsValidationError{
						field:  fmt.Sprintf("RelatedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueRelationsValidationError{
						field:  fmt.Sprintf("RelatedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueRelationsValidationError{
					field:  fmt.Sprintf("RelatedBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInclude() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueRelationsValidationError{
						field:  fmt.Sprintf("Include[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueRelationsValidationError{
						field:  fmt.Sprintf("Include[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueRelationsValidationError{
					field:  fmt.Sprintf("Include[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBeIncluded() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IssueRelationsValidationError{
						field:  fmt.Sprintf("BeIncluded[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IssueRelationsValidationError{
						field:  fmt.Sprintf("BeIncluded[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IssueRelationsValidationError{
					field:  fmt.Sprintf("BeIncluded[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IssueRelationsMultiError(errors)
	}

	return nil
}

// IssueRelationsMultiError is an error wrapping multiple validation errors
// returned by IssueRelations.ValidateAll() if the designated constraints
// aren't met.
type IssueRelationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueRelationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueRelationsMultiError) AllErrors() []error { return m }

// IssueRelationsValidationError is the validation error returned by
// IssueRelations.Validate if the designated constraints aren't met.
type IssueRelationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueRelationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueRelationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueRelationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueRelationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueRelationsValidationError) ErrorName() string { return "IssueRelationsValidationError" }

// Error satisfies the builtin error interface
func (e IssueRelationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueRelations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueRelationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueRelationsValidationError{}

// Validate checks the field values on CreateIssueStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateIssueStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIssueStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateIssueStateRequestMultiError, or nil if none found.
func (m *CreateIssueStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIssueStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for IssueType

	// no validation rules for StateName

	// no validation rules for StateBelong

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateIssueStateRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateIssueStateRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateIssueStateRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateIssueStateRequestMultiError(errors)
	}

	return nil
}

// CreateIssueStateRequestMultiError is an error wrapping multiple validation
// errors returned by CreateIssueStateRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateIssueStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIssueStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIssueStateRequestMultiError) AllErrors() []error { return m }

// CreateIssueStateRequestValidationError is the validation error returned by
// CreateIssueStateRequest.Validate if the designated constraints aren't met.
type CreateIssueStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIssueStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIssueStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIssueStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIssueStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIssueStateRequestValidationError) ErrorName() string {
	return "CreateIssueStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIssueStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIssueStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIssueStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIssueStateRequestValidationError{}

// Validate checks the field values on CreateIssueStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateIssueStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateIssueStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateIssueStateResponseMultiError, or nil if none found.
func (m *CreateIssueStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateIssueStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return CreateIssueStateResponseMultiError(errors)
	}

	return nil
}

// CreateIssueStateResponseMultiError is an error wrapping multiple validation
// errors returned by CreateIssueStateResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateIssueStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIssueStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIssueStateResponseMultiError) AllErrors() []error { return m }

// CreateIssueStateResponseValidationError is the validation error returned by
// CreateIssueStateResponse.Validate if the designated constraints aren't met.
type CreateIssueStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIssueStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIssueStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIssueStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIssueStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIssueStateResponseValidationError) ErrorName() string {
	return "CreateIssueStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIssueStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIssueStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIssueStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIssueStateResponseValidationError{}

// Validate checks the field values on DeleteIssueStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIssueStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIssueStateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIssueStateRequestMultiError, or nil if none found.
func (m *DeleteIssueStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIssueStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteIssueStateRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteIssueStateRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteIssueStateRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteIssueStateRequestMultiError(errors)
	}

	return nil
}

// DeleteIssueStateRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteIssueStateRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteIssueStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIssueStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIssueStateRequestMultiError) AllErrors() []error { return m }

// DeleteIssueStateRequestValidationError is the validation error returned by
// DeleteIssueStateRequest.Validate if the designated constraints aren't met.
type DeleteIssueStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIssueStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIssueStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIssueStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIssueStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIssueStateRequestValidationError) ErrorName() string {
	return "DeleteIssueStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIssueStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIssueStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIssueStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIssueStateRequestValidationError{}

// Validate checks the field values on DeleteIssueStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteIssueStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteIssueStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteIssueStateResponseMultiError, or nil if none found.
func (m *DeleteIssueStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteIssueStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteIssueStateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteIssueStateResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteIssueStateResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteIssueStateResponseMultiError(errors)
	}

	return nil
}

// DeleteIssueStateResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteIssueStateResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteIssueStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteIssueStateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteIssueStateResponseMultiError) AllErrors() []error { return m }

// DeleteIssueStateResponseValidationError is the validation error returned by
// DeleteIssueStateResponse.Validate if the designated constraints aren't met.
type DeleteIssueStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteIssueStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteIssueStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteIssueStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteIssueStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteIssueStateResponseValidationError) ErrorName() string {
	return "DeleteIssueStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteIssueStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteIssueStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteIssueStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteIssueStateResponseValidationError{}

// Validate checks the field values on IssueStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IssueStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IssueStatusMultiError, or
// nil if none found.
func (m *IssueStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for IssueType

	// no validation rules for StateName

	// no validation rules for StateBelong

	// no validation rules for StateID

	// no validation rules for Index

	if len(errors) > 0 {
		return IssueStatusMultiError(errors)
	}

	return nil
}

// IssueStatusMultiError is an error wrapping multiple validation errors
// returned by IssueStatus.ValidateAll() if the designated constraints aren't met.
type IssueStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueStatusMultiError) AllErrors() []error { return m }

// IssueStatusValidationError is the validation error returned by
// IssueStatus.Validate if the designated constraints aren't met.
type IssueStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueStatusValidationError) ErrorName() string { return "IssueStatusValidationError" }

// Error satisfies the builtin error interface
func (e IssueStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueStatusValidationError{}

// Validate checks the field values on IssueStateRelation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueStateRelation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueStateRelation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueStateRelationMultiError, or nil if none found.
func (m *IssueStateRelation) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueStateRelation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for IssueType

	// no validation rules for StateName

	// no validation rules for StateBelong

	// no validation rules for StateID

	// no validation rules for Index

	if len(errors) > 0 {
		return IssueStateRelationMultiError(errors)
	}

	return nil
}

// IssueStateRelationMultiError is an error wrapping multiple validation errors
// returned by IssueStateRelation.ValidateAll() if the designated constraints
// aren't met.
type IssueStateRelationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueStateRelationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueStateRelationMultiError) AllErrors() []error { return m }

// IssueStateRelationValidationError is the validation error returned by
// IssueStateRelation.Validate if the designated constraints aren't met.
type IssueStateRelationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueStateRelationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueStateRelationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueStateRelationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueStateRelationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueStateRelationValidationError) ErrorName() string {
	return "IssueStateRelationValidationError"
}

// Error satisfies the builtin error interface
func (e IssueStateRelationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueStateRelation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueStateRelationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueStateRelationValidationError{}

// Validate checks the field values on UpdateIssueStateRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateIssueStateRelationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssueStateRelationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateIssueStateRelationRequestMultiError, or nil if none found.
func (m *UpdateIssueStateRelationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssueStateRelationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateIssueStateRelationRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateIssueStateRelationRequestValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateIssueStateRelationRequestValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateIssueStateRelationRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateIssueStateRelationRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateIssueStateRelationRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateIssueStateRelationRequestMultiError(errors)
	}

	return nil
}

// UpdateIssueStateRelationRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateIssueStateRelationRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateIssueStateRelationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssueStateRelationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssueStateRelationRequestMultiError) AllErrors() []error { return m }

// UpdateIssueStateRelationRequestValidationError is the validation error
// returned by UpdateIssueStateRelationRequest.Validate if the designated
// constraints aren't met.
type UpdateIssueStateRelationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssueStateRelationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssueStateRelationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssueStateRelationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssueStateRelationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssueStateRelationRequestValidationError) ErrorName() string {
	return "UpdateIssueStateRelationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssueStateRelationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssueStateRelationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssueStateRelationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssueStateRelationRequestValidationError{}

// Validate checks the field values on UpdateIssueStateRelationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateIssueStateRelationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateIssueStateRelationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateIssueStateRelationResponseMultiError, or nil if none found.
func (m *UpdateIssueStateRelationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateIssueStateRelationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateIssueStateRelationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateIssueStateRelationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateIssueStateRelationResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateIssueStateRelationResponseMultiError(errors)
	}

	return nil
}

// UpdateIssueStateRelationResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateIssueStateRelationResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateIssueStateRelationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateIssueStateRelationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateIssueStateRelationResponseMultiError) AllErrors() []error { return m }

// UpdateIssueStateRelationResponseValidationError is the validation error
// returned by UpdateIssueStateRelationResponse.Validate if the designated
// constraints aren't met.
type UpdateIssueStateRelationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateIssueStateRelationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateIssueStateRelationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateIssueStateRelationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateIssueStateRelationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateIssueStateRelationResponseValidationError) ErrorName() string {
	return "UpdateIssueStateRelationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateIssueStateRelationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateIssueStateRelationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateIssueStateRelationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateIssueStateRelationResponseValidationError{}

// Validate checks the field values on GetIssueStatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssueStatesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueStatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssueStatesRequestMultiError, or nil if none found.
func (m *GetIssueStatesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueStatesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for IssueType

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIssueStatesRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIssueStatesRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIssueStatesRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIssueStatesRequestMultiError(errors)
	}

	return nil
}

// GetIssueStatesRequestMultiError is an error wrapping multiple validation
// errors returned by GetIssueStatesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetIssueStatesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueStatesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueStatesRequestMultiError) AllErrors() []error { return m }

// GetIssueStatesRequestValidationError is the validation error returned by
// GetIssueStatesRequest.Validate if the designated constraints aren't met.
type GetIssueStatesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueStatesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueStatesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueStatesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueStatesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueStatesRequestValidationError) ErrorName() string {
	return "GetIssueStatesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssueStatesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueStatesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueStatesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueStatesRequestValidationError{}

// Validate checks the field values on GetIssueStatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssueStatesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueStatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssueStatesResponseMultiError, or nil if none found.
func (m *GetIssueStatesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueStatesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIssueStatesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIssueStatesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIssueStatesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetIssueStatesResponseMultiError(errors)
	}

	return nil
}

// GetIssueStatesResponseMultiError is an error wrapping multiple validation
// errors returned by GetIssueStatesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetIssueStatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueStatesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueStatesResponseMultiError) AllErrors() []error { return m }

// GetIssueStatesResponseValidationError is the validation error returned by
// GetIssueStatesResponse.Validate if the designated constraints aren't met.
type GetIssueStatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueStatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueStatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueStatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueStatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueStatesResponseValidationError) ErrorName() string {
	return "GetIssueStatesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssueStatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueStatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueStatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueStatesResponseValidationError{}

// Validate checks the field values on IssueTypeState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IssueTypeState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueTypeState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IssueTypeStateMultiError,
// or nil if none found.
func (m *IssueTypeState) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueTypeState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IssueType

	if len(errors) > 0 {
		return IssueTypeStateMultiError(errors)
	}

	return nil
}

// IssueTypeStateMultiError is an error wrapping multiple validation errors
// returned by IssueTypeState.ValidateAll() if the designated constraints
// aren't met.
type IssueTypeStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueTypeStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueTypeStateMultiError) AllErrors() []error { return m }

// IssueTypeStateValidationError is the validation error returned by
// IssueTypeState.Validate if the designated constraints aren't met.
type IssueTypeStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueTypeStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueTypeStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueTypeStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueTypeStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueTypeStateValidationError) ErrorName() string { return "IssueTypeStateValidationError" }

// Error satisfies the builtin error interface
func (e IssueTypeStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueTypeState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueTypeStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueTypeStateValidationError{}

// Validate checks the field values on GetIssueStateRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssueStateRelationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueStateRelationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetIssueStateRelationRequestMultiError, or nil if none found.
func (m *GetIssueStateRelationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueStateRelationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectID

	// no validation rules for IssueType

	if all {
		switch v := interface{}(m.GetIdentityInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetIssueStateRelationRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetIssueStateRelationRequestValidationError{
					field:  "IdentityInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentityInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetIssueStateRelationRequestValidationError{
				field:  "IdentityInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetIssueStateRelationRequestMultiError(errors)
	}

	return nil
}

// GetIssueStateRelationRequestMultiError is an error wrapping multiple
// validation errors returned by GetIssueStateRelationRequest.ValidateAll() if
// the designated constraints aren't met.
type GetIssueStateRelationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueStateRelationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueStateRelationRequestMultiError) AllErrors() []error { return m }

// GetIssueStateRelationRequestValidationError is the validation error returned
// by GetIssueStateRelationRequest.Validate if the designated constraints
// aren't met.
type GetIssueStateRelationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueStateRelationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueStateRelationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueStateRelationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueStateRelationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueStateRelationRequestValidationError) ErrorName() string {
	return "GetIssueStateRelationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssueStateRelationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueStateRelationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueStateRelationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueStateRelationRequestValidationError{}

// Validate checks the field values on GetIssueStateRelationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetIssueStateRelationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetIssueStateRelationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetIssueStateRelationResponseMultiError, or nil if none found.
func (m *GetIssueStateRelationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetIssueStateRelationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetIssueStateRelationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetIssueStateRelationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetIssueStateRelationResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetIssueStateRelationResponseMultiError(errors)
	}

	return nil
}

// GetIssueStateRelationResponseMultiError is an error wrapping multiple
// validation errors returned by GetIssueStateRelationResponse.ValidateAll()
// if the designated constraints aren't met.
type GetIssueStateRelationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIssueStateRelationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIssueStateRelationResponseMultiError) AllErrors() []error { return m }

// GetIssueStateRelationResponseValidationError is the validation error
// returned by GetIssueStateRelationResponse.Validate if the designated
// constraints aren't met.
type GetIssueStateRelationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIssueStateRelationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIssueStateRelationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIssueStateRelationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIssueStateRelationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIssueStateRelationResponseValidationError) ErrorName() string {
	return "GetIssueStateRelationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetIssueStateRelationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIssueStateRelationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIssueStateRelationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIssueStateRelationResponseValidationError{}
